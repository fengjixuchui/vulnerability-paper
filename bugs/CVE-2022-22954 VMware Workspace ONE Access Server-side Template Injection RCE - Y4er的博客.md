> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [y4er.com](https://y4er.com/post/cve-2022-22954-vmware-workspace-one-access-server-side-template-injection-rce/)

freemarker ssti

安装环境[](#安装环境)
=============

r师给的镜像 identity-manager-21.08.0.1-19010796_OVF10.ova，导入ova的时候要设置下fqdn，不然安装时链接数据库会报错。

![1.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/1.png)

分析[](#分析)
=========

[这个老外的推特中](https://twitter.com/rwincey/status/1512241638994853891?s=20&t=LVGfpTwTcqwQ8Teh6LQrfg)有一点点可以参考的信息

![2.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/2.png)

有两个报错信息，我们先找到这个模板所在。

看路由是在catalog-portal app下，cd到`/opt/vmware/horizon/workspace/webapps/catalog-portal`，然后把jar包拖出来解压之后，`grep -irn "console.log"`

发现在`lib/endusercatalog-ui-1.0-SNAPSHOT-classes.jar!/templates/customError.ftl:61`这个地方存在模板注入

![3.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/3.png)

freemarker官网文档中给出了安全问题的提示

[https://freemarker.apache.org/docs/ref_builtins_expert.html#ref_builtin_eval](https://freemarker.apache.org/docs/ref_builtins_expert.html#ref_builtin_eval)

![4.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/4.png)

确认了这个地方就是freemarker ssti的地方。

接着看哪个路由可以渲染这个模板，找到了`com.vmware.endusercatalog.ui.web.UiErrorController#handleGenericError`

![5.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/5.png)

这个函数没有requestMapping，其中errorObj由参数传入，查找函数调用，寻找从requestMapping进来的控制器能调用到这个函数的。

endusercatalog-ui-1.0-SNAPSHOT-classes.jar这个jar包是一个spring项目

![6.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/6.png)

有几个控制器，其中UiErrorController控制器有两个requestMapping

![7.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/7.png)

这两个路由均可以走到getErrorPage

![8.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/8.png)

getErrorPage会根据handleUnauthorizedError和handleGenericError两个函数拿到需要渲染的模板

其中handleUnauthorizedError只有一个分支可以进入handleGenericError

![9.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/9.png)

到这里，想要控制errorObj，则整个数据流向如图

![10.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/10.png)

我们需要让其走到handleGenericError才可以rce。

但是此时有一个问题，如果直接访问这两个requestMapping，我们无法控制`javax.servlet.error.message`，也就无法控制errorObj，所以找一找哪个控制器跳转过来的。

在`com.vmware.endusercatalog.ui.web.UiApplicationExceptionResolver`类中，通过`@ExceptionHandler`注解标明这是一个异常处理类。

![11.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/11.png)

当程序直接抛出Exception类型的异常时会进入handleAnyGenericException，最终都会返回`/ui/view/error`，并且设置了errorObj所需要的Attribute

```
1request.setAttribute("javax.servlet.error.status_code", responseCode);
2request.setAttribute("javax.servlet.error.message", errorJson);
3request.setAttribute("javax.servlet.error.exception_type", ex.getClass()); 
```

java

errorJson来自于LocalizationParamValueException异常的getArgs。

![12.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/12.png)

即自身args属性，通过构造函数的第二个参数传入

![13.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/13.png)

如果我们可以控制抛出异常的参数，就可以把freemarker的payload传入errorObj。

失败的exception[](#失败的exception)
-----------------------------

然后我找到了`com.vmware.endusercatalog.ui.web.WorkspaceOauth2CodeVerificationController#authorizeError`

![14.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/14.png)

尝试构造一下

```
1https://id.test.local/catalog-portal/ui/oauth/verify?error=1&error_description=a 
```

fallback

![15.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/15.png)

直接302了，调试发现errorMessage确实已经有我们的恶意值1了，但是被sendRedirect，而不是handleGenericError。

![16.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/16.png)

上文讲到必须要handleGenericError才能`return customError`。调试发现

isSpecificUnauthError(excpClass)为false，this.isMdmOnlyUnauthorizedAccessError(request, excpClass)也为false。

```
1    private boolean isSpecificUnauthError(String exceptionClass) {
2        return Predicates.or(new Predicate[]{this::isDeviceRecordNotFoundError, this::isUserMismatchError, this::isMdmAuthUnhandledError, this::isDeviceStateInvalidError, this::isExternalUserIdNotFoundError}).apply(exceptionClass);
3    } 
```

java

isSpecificUnauthError过不去，因为`com.vmware.endusercatalog.ui.web.WorkspaceOauth2CodeVerificationController#authorizeError`抛出的异常是AuthorizationCodeFailedRetrievalException，并非DeviceRecordNotFoundException、UserMismatchException、MdmAuthUnhandledException、DeviceStateInvalidException、ExternalUserIdNotFoundException之一，这个死绕不过去。

isMdmOnlyUnauthorizedAccessError中`this.isMdmOnlyMode(request)`永为false

![17.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/17.png)

因为`((TenantAdapters)adapters).isMdmOnlyMode()`一直追溯到`com.vmware.endusercatalog.repositories.TenantAdapters#getAdapterAttributesOptional`

![18.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/18.png)

当程序配置好之后`this.adapters`就有了`AdapterType.WORKSPACE`

```
1    public boolean isWorkspaceConfigured() {
2        return this.getAdapterAttributesOptional(AdapterType.WORKSPACE).isPresent();
3    } 
```

java

而取反之后为false。

```
1    public boolean isMdmOnlyMode() {
2        return !this.isWorkspaceConfigured();
3    } 
```

java

所以isMdmOnlyUnauthorizedAccessError判断永为false，所以这条路走不通了。

真正的exception[](#真正的exception)
-----------------------------

回头看`com.vmware.endusercatalog.ui.UiApplication`，注解声明自动装配`com.vmware.endusercatalog.auth`包

![19.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/19.png)

在`com.vmware.endusercatalog.auth.interceptor.AuthContextPopulationInterceptor`中

![20.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/20.png)

build函数

```
1        public AuthContext build() {
2            return new AuthContext(this);
3        } 
```

java

withDeviceId和withDeviceType分别设置自身的deviceId和deviceType字段。然后build()函数new了一个AuthContext，跟进到`com.vmware.endusercatalog.auth.AuthContext#AuthContext`构造函数

![21.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/21.png)

这里抛出了一个InvalidAuthContextException异常，参数也可控，if判断只需要让this.deviceId、this.deviceType不为空即可。

![22.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/22.png)

payload[](#payload)
===================

![23.png](https://y4er.com/img/uploads/CVE-2022-22954-VMware-Workspace-ONE-Access-Server-side-Template-Injection-RCE/23.png)

有个坑，host可以为localhost，可以为域名，但是不能为ip，因为ip对不上fqdn。

后利用[](#后利用)
===========

写shell在`/opt/vmware/horizon/workspace/webapps/catalog-portal/`tomcat目录下，发现post会校验csrf，导致哥斯拉连不上，打入一个listener的内存马就可以了。

**文笔垃圾，措辞轻浮，内容浅显，操作生疏。不足之处欢迎大师傅们指点和纠正，感激不尽。**