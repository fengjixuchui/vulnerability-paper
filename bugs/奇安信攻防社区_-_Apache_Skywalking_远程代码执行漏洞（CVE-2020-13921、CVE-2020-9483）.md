<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/908)

> 奇安信攻防社区 - Apache Skywalking 远程代码执行漏洞（CVE-2020-13921、CVE-2020-9483）

# 一、环境： 1、https://www.anquanke.com/post/id/231753 (参考文章地址) 2、https://www.apache.org/dyn/closer.cgi/skywalking/8.3.0/apache-skywalking-apm-8.3.0.tar.gz(下载地址) 3、...

1、[https://www.anquanke.com/post/id/231753](https://www.anquanke.com/post/id/231753) (参考文章地址)  
2、[https://www.apache.org/dyn/closer.cgi/skywalking/8.3.0/apache-skywalking-apm-8.3.0.tar.gz(下载地址](https://www.apache.org/dyn/closer.cgi/skywalking/8.3.0/apache-skywalking-apm-8.3.0.tar.gz(%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80))  
3、[https://www.cnblogs.com/goWithHappy/p/build-dev-env-for-skywalking.html#1.%E4%BE%9D%E8%B5%96%E5%B7%A5%E5%85%B7(源码编译教程](https://www.cnblogs.com/goWithHappy/p/build-dev-env-for-skywalking.html#1.%E4%BE%9D%E8%B5%96%E5%B7%A5%E5%85%B7(%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B))  
4、[https://www.apache.org/dyn/closer.cgi/skywalking/8.3.0/apache-skywalking-apm-8.3.0-src.tgz(源码地址](https://www.apache.org/dyn/closer.cgi/skywalking/8.3.0/apache-skywalking-apm-8.3.0-src.tgz(%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80))  
5、[https://www.runoob.com/w3cnote/java-class-forname.html(Class.forName 原理解析](https://www.runoob.com/w3cnote/java-class-forname.html(Class.forName%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90))  
6、远程调试机以及攻击机 (win10)、服务端 (ubuntu)

1、解压该文件 进入 bin 目录，如下  
![](https://img-blog.csdnimg.cn/2021022521500093.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

2、Liunx 启动`startup.sh`,windows 启动`startup.bat`  
3、启动后访问 ip:8080(默认端口是 8080，需要修改，可进入 webapp 目录下，修改 webapp.yml)，如下

![](https://img-blog.csdnimg.cn/20210225215046533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

4、出现下图即成功启动  
![](https://img-blog.csdnimg.cn/20210225215112693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

1、需先了解一下 GraphQL 流程以及查询语法的构造 (这里我用自己的语言总结下，学的不是很深入)  
GraphQL 主要分为 4 部分分别为：  
(1)`root.graphqls`(定义查询)  
(2)`AuthorQuery.java`(`GraphQLQueryResolver`)  
(3)`AuthorService.java`(`Service`)  
(4) 实体类`Author`(实体类)

整体流程: 首先需要根据`root.graphqls`构造符合请求格式的 payload, 然后通过`AuthorQuery.java`传递给`AuthorService.java`，最后`AuthorService.java`会调用实体类 Author 中的方法进行数据处理，然后返回结果。

注：  
`root.graphqls`是定义请求参数类型与格式的文件，例如下面两个句子

```
type Author {
```

定义 Author 中返回数据的类型

```
id: Int!
```

定义 query 查询的格式，其中`findAuthorById`方法要与`AuthorQuery`中定义的方法一致，这样才能定位到`AuthorQuery`中。id:1 是请求参数，id, name，photo 是期望服务器的返回数据，可自行更改。注意上述两者可能在同一文件，也可能不在同一文件定义 (一般是`root.graphqls`文件，如果不是的话，会有 extend 字段，要继承初始化的`root.graphql`，如下图)。  
![](https://img-blog.csdnimg.cn/20210225215142365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)  
`AuthorQuery`相当于是接口开关，里面会有这么一段代码，相当于开启`GraphQL`查询接口`public class AuthorQuery implements GraphQLQueryResolver AuthorService.java`复制对传进数据的处理，类似加减乘除运算一样  
实体类 Author(实体类) 一般是进行赋值作用，即对传进的参数赋值给新变量  
个人理解和都可以对数据进行操作，看代码放在哪里而已。

2、跟进`skywalking`代码  
(1) 开启调试 (这里使用 win10 当调试机)  
文章开头有教程，就是把源码下载解压之后，在`skywalking`目录下，直接使用以下命令  
`./mvnw clean package –DskipTests`

![](https://img-blog.csdnimg.cn/20210225215337859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)然后一直等待就好了，需要完全编译成功才行，过程一般会很久

(2) 编译后的文件夹会多出一个 target 文件夹，如下

![](https://img-blog.csdnimg.cn/20210225215414589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(3) 使用 idea 新建项目，选中该文件夹即可

![](https://img-blog.csdnimg.cn/20210225215457816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(4) 点击 idea 下运行，编辑配置

![](https://img-blog.csdnimg.cn/20210225215511451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20210225215530271.png)

一开始进来是没有远程调试的，直接点击左上角 + 号，添加远程端口

![](https://img-blog.csdnimg.cn/20210225215539647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

配置如下 (其实主要是添加个远程主机地址和端口就可以了)：

![](https://img-blog.csdnimg.cn/20210225215609905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(5) 在服务器端启动`skywalking`服务 (记得，调试源码与你运行的源码版本需要一致，运行 8.3 就要下载 8.3 的源码去编译调试)  
首先要在`apache-skywalking-apm-bin`的 bin 目录下编辑`oapService.sh`，添加远程调试命令，windows 的就是编辑`oapService.bat`，如下  
直接 / CLASSPATH 搜索即可

![](https://img-blog.csdnimg.cn/20210225215659408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

添加的命令就是上面图里的远程 JVM 的命令行参数，如下  
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5006  
(6) 添加好了之后可以先直接运行`startup.sh`启动服务，然后再在需要的位置进行断点调试，不过我这边修改了`oapService.sh`之后，好像需要手动启动`./ oapService.sh`才能启动监听。如下，确定下端口服务都起来了

![](https://img-blog.csdnimg.cn/20210225215827643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(7) 然后回到 win10 的 idea 中，点击主页面右上角图标进行调试，出现下图即成功

![](https://img-blog.csdnimg.cn/2021022521591684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

3、分析`skywalking`漏洞  
根据原文章可知漏洞点在`oap-server\server-storage-plugin\storage-jdbc-hikaricp-plugin\src\main\java\org\apache\skywalking\oap\server\storage\plugin\jdbc\h2\dao\H2LogQueryDAO.java`文件中  
(1) 直接在该处断点

![](https://img-blog.csdnimg.cn/20210225215935167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(2) 开启调试，发送以下 payload(payload 构造下面会进行说明)

```
name: String
```

可以看到`metricName` 原封不动的被带进 sql 参数中

![](https://img-blog.csdnimg.cn/2021022522003638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

继续跟进 sql，发现被带入`buildCountStatement`

![](https://img-blog.csdnimg.cn/20210225220103682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

跟进`buildCountStatement`，看看返回的结果  
直接把我们的注入语句返回，然后使用`executeQuery`函数执行返回。

![](https://img-blog.csdnimg.cn/20210225220120989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)直接把我们的注入语句返回，然后使用 executeQuery 函数执行返回。

(3) 回溯  
回到一开始，我们的注入点是在`queryLogs`函数中

![](https://img-blog.csdnimg.cn/20210225220227854.png)

往上追，看看是谁调用它的，可以看到`\skywalking\oap-server\servercore\src\main\java\org\apache\skywalking\oap\server\core\query\LogQueryService.java中对queryLogs`进行了调用

![](https://img-blog.csdnimg.cn/20210225220307997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)但是还是看不到入口，所以还是需要继续往上追，一直到  
`E:\skywalking\skywalking\oap-server\server-query-plugin\query-graphql-plugin\src\main\java\org\apache\skywalking\oap\query\graphql\resolver\LogQuery.java`  
![](https://img-blog.csdnimg.cn/20210225220335684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)可以看到一个熟悉的句子  
`implements GraphQLQueryResolver`  
实现`GraphQL`查询接口，所以我们可以直接构造`GraphQL`查询，发送至服务器  
![](https://img-blog.csdnimg.cn/20210225220401775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

4、分析构造`payload`  
(1) 前面说过`GraphQL`查询的整体流程, 四个部分我们已经找到 3 个了。如下  
`H2LogQueryDAO`、`LogQueryService`、`LogQuery`  
(2) 现在要找的是`graphqls`文件，看看是怎么构造查询的  
我先找了`root. Graphqls`，发现没有

![](https://img-blog.csdnimg.cn/20210225220639609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

直接搜`graphqls`，也很好猜，log 肯定是，有两个`log.graphqls`，其实都是一样的，随便选一个看看是不是。

![](https://img-blog.csdnimg.cn/20210225220652794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20210225220707585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

看到`queLogs`函数，基本确定了。因为一般跟`LogQuery.java`文件中的函数会一致，过程中也不会存在其他同名函数，不然就找不到路径了

![](https://img-blog.csdnimg.cn/20210225220800190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(3) 分析`log. graphqls`

###### 1、期待返回的参数，logs 和 total，后面是类型，有感叹号，表明为非空，就是必须有

![](https://img-blog.csdnimg.cn/20210225220833969.png)

###### 2、Log 匹配上面 logs 取值，上面的 Log 使用 [] 框柱，网上解析说是对象类型，非空的话，就只需要在 Log 里面随便取一个参数就可以

![](https://img-blog.csdnimg.cn/2021022522090925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

###### 3、LogQueryCondition 看到 input 类型，就知道这里都是要我们提交的参数值，其中 queryDuration 参数可以不提交，可能是服务器那边会自动提交。(尝试提交会出错)

![](https://img-blog.csdnimg.cn/20210225220925681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

###### 4、可以看看 Duration 类型的构造

![](https://img-blog.csdnimg.cn/20210225220942947.png)

###### 5、enum 表示后面的参数取值只能在它定义的值里面进行取值

![](https://img-blog.csdnimg.cn/20210225220956994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

(4) 分析网上的 payload

![](https://img-blog.csdnimg.cn/20210225221035644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)  
自己的理解如下

###### 1、首先使用 query 表明自己的动作是查询

###### 2、后面跟的是自己定义的函数 queryLogs, 这个是可以随便起的

###### 3、($condition: LogQueryCondition) 中的 $condition 是定义的变量，LogQueryCondition 这里是变量类型

###### 4、logs: queryLogs(condition: $condition)，其中 logs: 是 queryLogs(condition: $condition) 的别名，可要可不要，queryLogs(condition: $condition) 才是开始请求的构造，对应 log.graphqls 部分如下

![](https://img-blog.csdnimg.cn/20210225221142537.png)

这里的 $condition 对应我们上面创建的函数变量 ($condition: LogQueryCondition)  
注意：LogQueryCondition 类型已经在 ######  
log.graphqls 写死了，所以这里传进来的变量类型也只能是 LogQueryCondition，而 LogQueryCondition 类型的构造在上面已经看过了。

###### 5、接下来是 data: logs，data: 一样是别名，logs 和下面的 total 都是期待服务器返回的数据，对应 log.graphqls 部分如下

![](https://img-blog.csdnimg.cn/20210225221327811.png)

其中 logs 对应的 Logs 构造如下，因为是非空，所以从里面选中一个就行，或者全部写上。(每个参数使用空格隔开即可)

![](https://img-blog.csdnimg.cn/20210225221340565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

###### 6、variables，构造参数，此处对应的是 LogQueryCondition 类型的构造

![](https://img-blog.csdnimg.cn/20210225221354438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

总的来说：就是 variables 构造请求的类型值，也就是 LogQueryCondition，然后传入 queryLogs 函数中，最后期待返回 logs 与 total  
还不懂就看下面的例子，自己去领悟吧

![](https://img-blog.csdnimg.cn/20210225221405868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

最后 condition 带的参数 metricName 就存在注入点，之前已经调试过了

1、开启服务之前说过了  
2、利用注入点上传 class 文件  
上传前

![](https://img-blog.csdnimg.cn/20210225221418575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

上传后

![](https://img-blog.csdnimg.cn/202102252214478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

3、利用注入点执行 class 文件  
执行前

![](https://img-blog.csdnimg.cn/20210225221545869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

执行后  
![](https://img-blog.csdnimg.cn/20210225221621272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

注：上传的 class 文件利用注入点执行一次之后即失效，需重新开启服务验证。

1、根据漏洞文档：[https://mp.weixin.qq.com/s/hB-r523_4cM0jZMBOt6Vhw](https://mp.weixin.qq.com/s/hB-r523_4cM0jZMBOt6Vhw)  
可知 h2 数据库中存在函数 file_write(blobValue,fileNameString)  
该函数作用将 16 进制数据写入文件中。  
2、搭建本地 H2 数据库 (下载地址: [https://h2database.com/h2-setup-2019-10-14.exe), 直接双击安装即可](https://h2database.com/h2-setup-2019-10-14.exe),%E7%9B%B4%E6%8E%A5%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF)  
启动 h2 数据库，如下图  
![](https://img-blog.csdnimg.cn/20210225221700623.png)

3、使用 file_write 验证可直接创建文件

![](https://img-blog.csdnimg.cn/20210225223028266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

4、根据以上编写简单 class 文件，如下

![](https://img-blog.csdnimg.cn/20210225221725124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

5、直接在 h2 中使用 file_read() 函数转成 16 进制，如图

![](https://img-blog.csdnimg.cn/20210225221734184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

6、使用以下 payload 直接提交

```
photo: String
```

7、服务器生成 class 文件如下

![](https://img-blog.csdnimg.cn/20210225221826126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

8、根据漏洞文档可知 h2 数据库中 LINK_SCHEMA 函数会触发类加载行为，如下

![](https://img-blog.csdnimg.cn/20210225221838585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

其中的 loadUserClass 函数会使用到 Class.forName() 去加载类

9、Class.forName() 解析

![](https://img-blog.csdnimg.cn/20210225221849552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

返回一个给定类或者接口的一个 Class 对象，如果没有给定 classloader， 那么会使用根类加载器。如果 initalize 这个参数传了 true，那么给定的类如果之前没有被初始化过，那么会被初始化。

10、再看看 loadUserClass 怎么使用 Class.forName() 的

![](https://img-blog.csdnimg.cn/20210225221904316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

可以看到 initalize 为 true，也就是说，当第一次使用这个类的时候，会进行初始化

11、初始化的重点在于类当中的静态代码块会被执行，所以我们把代码写进 static 块让它执行

![](https://img-blog.csdnimg.cn/20210225221916121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM4MTY1MA==,size_16,color_FFFFFF,t_70)

代码如下

```
}
```

注：文件名要与 class 名称一致，不然生成类时会报错  
12、生成恶意类  
`javac evil.java -target 1.6 -source 1.6`

![](https://img-blog.csdnimg.cn/20210225221944437.png)

13、最后执行 payload 进行 RCE(漏洞文档已知第二个参数是 class 文件名，此处直接代入即可)

```
query{
```