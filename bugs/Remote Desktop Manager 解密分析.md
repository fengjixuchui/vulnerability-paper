> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/wva3waln9X4ZmeOJHpeubw)

**点击蓝字 ·  关注我们**

**01**

前言

Remote Desktop Manager 是一款远程桌面管理器工具，主要应用场景在，IT部门负责管理和控制对不断增长的现场和异地服务器、计算机和设备库存的访问。然而，依赖多个远程连接工具和密码管理器效率低下、令人沮丧且不安全。IT 专业人员、系统管理员和帮助台技术人员没有得到简化的清晰度处理，而是在持续的混乱中挣扎。解决方案是将远程连接技术、远程机器数据、密码管理和访问控制集中在一个安全、可扩展且易于使用的平台上。

在内网横向中，我们经常会遇到运维的机器，当我们可以解密Remote Desktop Manager 工具的密码时，可以获取更多的凭据，有助于我们在内网渗透中横向移动。

类似于我们常常去解密Xshell 是一个道理的，由于我项目中遇到，在 google 等搜索引擎并没有找到解密办法，尝试自己解密。

**02**

基本信息获取

根据启动时，所加载的DLL 确定大概分析范围

```
`RemoteDesktopManager.Core.dll``RemoteDesktopManager.Business.dll``Devolutions.dll`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgY8ZtPtWWKVwhDleOeIvSuEibVaiaia5xlzxibKVY0P0KR4OoF3vVr3Ky3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对查看密码功能进行点击测试，观察Operation 是否读取本地文件、注册表等信息，发现在 

```
%LOCALAPPDATA%\AppData\Local\Devolutions\RemoteDesktopManagerFree\Connections.log
```

 进行连接记录  

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg4mo6afPqQhYDC0uEC8iaXJicVvyhhJZicHl8azvBb6tS34sTzCiaYYPgVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgFGV8Ca65ZLaOA3TLNeppq1xKkXZ55s7zn3DcPpTicGia0mMtlOicjzvLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
%LOCALAPPDATA%\AppData\Local\Devolutions\RemoteDesktopManagerFree\Connections.db
```

在DB中发现了加密的密码  

*   RDP
    

```
`<RDP>` `<SafePassword>UJbKx4lffJM=</SafePassword>` `<UserName>administrator</UserName>` `</RDP>`
```

*   SSH
    

```
`<Terminal>` `<Host>cc</Host>` `<PrivateKeyPromptForPassPhrase>false</PrivateKeyPromptForPassPhrase>` `<SafePassword>WqYhDbiAsH8=</SafePassword>` `<Username>aa</Username>` `</Terminal>`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgny3iaHQT5GYjfe7IBU4qrur6LZQBkpy7wa9KDmZyQ5v0GzQiacqwErsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

现在我们已经获取了加密后的密码，和基础的连接信息，接下来我们只要分析出加密方式，即可解密、获取明文密码。

**03**

加密方式获取

根据上0x1的基础分析，我们现在对 

```
RemoteDesktopManager.Core.dll
```

 进行反编译，查看代码，尝试找到加密方式。  

在

```
FreRemoteDesktopConnectionSetings
```

发现了连接配置信息。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg5nKCXhjWYgPJE0hSRVQLont2F8lLIIt92LPNfkNZnNdAUftDHtD2Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

根据连接信息进行回溯

找到 DecryptBasic 方法

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg9daSZnIgBfM3M1al0zpMqRpmWnKJvgTG0fTIzj8RwVrVOet66ZdqDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

```
继续跟 UnsafeEncryptionManager.Deobfuscate
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgteU2Jzo6pMJhrm9nNsfuUY6OAadeoKk62icoRLAEQzWAbzs24wktjJQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

```
`Deobfuscate 中发现` `当满足 !UnsafeEncryptionManager.IsEncrypted(cipherText) 条件` `进入 ObfuscationUtils.Deobfuscate`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgLYsTrpZEIvemUd9uClKf9AnhRJCOpzIZKaJsaNsoIdOQ7By3ibr57BQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
`Deobfuscate 方法 接收参数为 string encryptedString, string key` `那么这里 encryptedString 接收的内容` `可能就是我们在sqlite中看到的Safepassword ，key为软件所生成的，`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg6UUhibDuqib2kRpcTM8lMVCstou7kwuQbbq4icgic1kUWVcjiaibnzLBndEg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

回溯上面的调用，下断点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgBIebcD4YruicMQicN0kuvaG8iaQ4Mx2JfCpOznyoxDehQsR0ictwVD6Gaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

通过逐语句，来到了我们刚刚自己找的这块，确认了我们猜测的流程没有问题。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgb1mx4nPaupYiau9dA92bR7Nq9HmvZH8J88grnwZeeHtE5iaB8e4Kex4Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

在到了 Deobfuscate 方法中时，我们所接收的key 已经有了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgGd94Uf3zH7aX1nFvPOtgzicjvq2ibJW2zARPsSHYbNrc8CLMWuzZdX8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

在继续跟上图103 行,GetDecryptorTransform 方法时，我们看到了加密方法。

```
 `public static ICryptoTransform GetDecryptorTransform(string key)` `{` `Dictionary<string, ICryptoTransform> obj = ObfuscationUtils.decryptorTransforms;` `ICryptoTransform cryptoTransform;` `lock (obj)` `{` `if (!ObfuscationUtils.decryptorTransforms.TryGetValue(key, out cryptoTransform))` `{` `TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();` `byte[] key2 = ObfuscationUtils.MD5CryptoServiceProvider.ComputeHash(Encoding.ASCII.GetBytes(key));` `tripleDESCryptoServiceProvider.Key = key2;` `tripleDESCryptoServiceProvider.Mode = CipherMode.ECB;` `cryptoTransform = tripleDESCryptoServiceProvider.CreateDecryptor();` `ObfuscationUtils.decryptorTransforms.Add(key, cryptoTransform);` `}` `}` `return cryptoTransform;`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgtxEkJn3nt9gw3ZE7zyPy7phfTX5A1SiaA0loJrTAPKZRR8pUeboqk9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

当reurn result 的时，我们就已经看到了密码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgqwrO5icibibUWJuIQvC4KibWufuHcyhrOyONp0bBnYRpfFsGSE7QNexysA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Deobfuscate 对应加密的key 和 encryptedString , text 为我们的明文密码，由刚刚的bytes result 转字符串。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgkMicqhzZN8K2S0icq1WwbV4CYhOrwfWf8ibiaJGBfqfBGLarPSCV1iam91A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

那么现在具体的解密流程，我们就已经大概了解了，接下来我们怎么解密目标机器的呢？

1.离线解密

回溯key的生成，找到key生成的方法和存储位置

2.反编译对应的DLL文件

在DLL文件添加记录 encryptedString 、key、 text(password)

**04**

获取明文凭据

这里我们以反编译对应的DLL，演示获取明文凭据，在此处进行反编译DLL，最后保存生成替换即可。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg6WHughapfTLgkRAyLpy2hZiaiax8JGYWjIyztpLe3WqK76ftjWYkCtkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
 `string[] array2 = new string[]` `{` `"encryptedString:" + encryptedString,` `"key:" + key,` `"result:" + text + "\n"` `};` `using (StreamWriter streamWriter = new StreamWriter("C:\\\\Windows\\\\temp\\\\log.txt", true))` `{` `foreach (string text2 in array2)` `{` `if (!text2.Contains("second"))` `{` `streamWriter.WriteLine(text2);` `}` `}` `}`
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgpjSL8mXr0SDvC9EN2QfTQibBdnJ7OuicOwyaBMbhuhZpicdqs836nD02A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

最后实现效果，成功记录了SSH、RDP 的 password ，想详细的记录连接信息，可继续往上层跳。

拿到encryptedString 直接就可以在数据库中比对了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg0Xia2nxGXGxA8hXqbiaH1e04YZp86opMMxzb6TR1FfbD6SrAZdFKdrmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMgwSQH71KTzgfstSwVrAIepcfU1jJicxZ5Q3mmsahMslc5bbQfx9iaGmgQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

  

注：本文由0xdd原创发布，已经获得本人同意在EDI公众号发布该文章  

文章转载来源安全客  

文章出处： https://www.anquanke.com/post/id/264191

**EDI安全**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/rJALXSMzgemPicPfWVk2ibn2BL3RicNHiaMg6icPQjFJl07AtO0liaAsfnCjgQj3U4VJTCaicrckO9MVA1mSw0m98hQwg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**扫二维码｜关注我们**

一个专注渗透实战经验分享的公众号