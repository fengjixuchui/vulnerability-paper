> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/pNDqKKCWfRBS50vxKMg1nA)

0x00 前言
-------

K3 CLOUD 是某蝶在移动互联⽹时代基于最新技术研发的⼀款战略性 ERP 产品，该产品于近⽇曝 出反序列化漏洞，攻击者可构造对应的序列化数据包在⽬标部署服务器上执⾏恶意代码。⽬前已有对应的 POC, 以及⼀些相关的分析资料，本⽂只说明其中⽐较重要的⼏个部分。

0x01 漏洞分析
---------

### 一、调试

K3Cloud 采⽤ ASP.NET 开发，由多个 Web App 组成，安装后可在 IIS ⻅多个⽹站和虚拟⽬录

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzADmf4DOqokDt2y0LIaX2cdpFoibkjMp2b0GIrEB6dGR7ocdWiadfcqxeQ/640?wx_fmt=png)

使⽤ dnSpy 对 Web 程序进⾏调试，需使⽤管理员权限运⾏，根据 Poc 所测试的应⽤程序附加到对应的 w3wp 进程中

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAhtgecwadwHv2CLU19RRicWSe0P4bmlVUkuQBWFMicyzmgZhKXG72yZwA/640?wx_fmt=png)

本⽂选择 MangeSite（管理后台）为调试⽬标，调试过程中可能会存在局部变量部分被优化的情况，因为程序都是 Release 发布的，Release 的使⽤ VS 调试⾃带的程序⼀样代码会被优化，微软官⽅提供了对应的解决⽅案 https://learn.microsoft.com/zh-cn/dotnet/framework/debug-trace-profile/making-an-imageeasier-to-debug 需要在 dll 所在⽬录创建⼀个同名的 ini ⽂件，内容如下:

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAklGTGGqKGw167KpBhlpic78QBiaS5YQ22FQX4gbz09TJ25w2picQA6uaw/640?wx_fmt=png)

然后重启 IIS 即可。

### 二、handler 处理

本次反序列化漏洞影响只限于 K3Cloud(前台) , ManageSite(后台) 两个应⽤程序。漏洞路径出现在 `Kingdee.BOS.ServiceFacade.ServicesStub.DevReportService.GetBusinessObjectData.common.kdsvc`, 由 kdsvc 后缀结尾，根据 web.config ⾥的 handler 配置信息

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzArHx8ww8UpAXibYhsReMxAbFElVjpLupfSfb1lmJOvERsDBfMlnymibMA/640?wx_fmt=png)

任何由 *.kdsvc 结尾的请求路径均会交由 KDServiceHandler 进⾏处理，不懂. NET 可以把它理解成 JAVA 中的 Servlet，KDServiceHandler 在程序 bin ⽬录下的 Kingdee.BOS.ServiceFacade.KDServiceFx.dll 中。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAg6bGHAYlqWCUSEicNsTicqJNvVysbCVjZmRMPkkDAyKic5eofH6rRePuQ/640?wx_fmt=png)

使⽤ DnsPy 进⾏反编译后可以看到，KDServiceHandler ⼜根据开头和结尾字符再次将请求交给不同的 Handler 去处理。 `Kingdee.BOS.ServiceFacade.ServicesStub.DevReportService.GetBusinessObjectData.common.kdsvc`路径并不满⾜上⾯对应的结尾和开头，因此交给 KDSVCHandler 进⾏处理

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAOYQJEZ9zGIHzTrcK17gCuCqVaW3qXLTLWc8PvGDHomvsJR7uCcb2xA/640?wx_fmt=png)

### 三、format 的值

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAg2gnxhq1axHqiaXY1wr6g6Opn4TYHmLU4mp6OIicaWAykgBHkoiadLZNA/640?wx_fmt=png)

KDSVCHandler 中定义了两个⽅法，ProcessRequest 和 ProcessRequestInternal，根据 ASP.NET 处理 HTTP 请求的优先级会顺序执⾏ ProcessRequest > ProcessRequestInternal ⽅法。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAPhVKGRN6JaicK4kdrVHgvkUuODSibL4eYAibwX6B1ctgz41FmLbA64lHg/640?wx_fmt=png)

ProcessRequest 中使⽤ RequestExtractor.Create 对请求传输的内容进⾏格式化

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzARLUDgqDhb1icNDq79MeJiadw6TdoC3mXGHERq6S1uNL8eK4MMmLvL1pA/640?wx_fmt=png)

根据不同的 Content-Type 传输类型，选择不同的处理类，payload 中的是 Content-Type: json 所以这⾥会选择 JQueryRequestExtractor 类进⾏处理

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAgc6Z1wiaNFYoZ51VVz0yntclbYTKWPiaribTiaib7ssqRBhZ5SceGMtX5RQ/640?wx_fmt=png)

JQueryRequestExtractor 类中再次根据 POST 和 GET 选择对应的处理⽅法，GET 则选择第⼀个参数的内容，POST 则是以 request.InputStream 输⼊流进⾏反序列化，POST ⽅法处理期间还会根据 UserAgent 选择对应的取值⽅式，将所有的键值对存储到 nameValueCollection 对象中。

后续传递参数内容均会从 requestExtractor 对象中获取，包括了 format

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAmtv9TWMnsNoSVIHxbXXiap0MqRibID2Ju1Ko6bgYKT3dxgkmPoKv342A/640?wx_fmt=png)

使⽤ ExtractForm 返回对应的值

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAlJXBriaA7gjxvqssqlsROXxhM6uibZpw8Zaydvk1bj9mXcibY5PqcicM3A/640?wx_fmt=png)

这⾥可以看到定义了多个类型，当 format 为 3 时会返回 Binary，并且此处已经声明 “由于安全原因，⼆进制⽂件将被丢弃。

请改⽤某蝶 Xml 格式”。

### 四、序列化代理的选择

期间会根据请求路径加载对应程序集的操作

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAxxPEx1OriccX1TguZhpbLCxklPzXfRNib8XmHEic2Jn9zLwneAn0N1HdA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzANdrl45DOj2fEI3RwwMAN1WOBYxIWZruDP4uK7XsTrY7Q6BKiaEhrrWw/640?wx_fmt=png)

使⽤ ReflectServiceType 构建⼀个 ServiceType 对象，这个对象⾥包含了名称，CLR 类型，对应的⽅法，是否安全，返回类型，版本，和参数等信息。

加载完后，会遍历调⽤⼀些定义好的 Module 类。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzA5hNiav71ySMIWYzuxp50CS97OWwafHbmqiaoiawrEicFcAvgNYV7zXLdiag/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzA5hDWMwp49dpIg2Qu6IyC7npVFtvUQ5oPcq0PialA055ht9aEW79Wohw/640?wx_fmt=png)

顺序遍历调⽤其中的 OnProcess, 调⽤到第 6 个，ExecuteServiceModule 时，漏洞触发点呈现

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzA0ScLxIRUp1gQpOqiaLc6qlObv25C9uvhfVPPOMhzomVYMlCrAbJjLpA/640?wx_fmt=png)

在执⾏过程中会创建⼀个 serializeProxy 序列化代理器，⽽序列化代理器会根据 format 的值创建对应的序列化类

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAQialmBRh3yiacRPmkFzL2QwMuQzuD8GBiaVrKoYhuM6K5LHQs7RdtAXww/640?wx_fmt=png)

这个在上⽂已经说明，此时的 format 为 Binary，会返回⼀个 BinaryFormatterProxy 类

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAY4NsLpK8FBgeZDKMTiaO5Nmo90icTXm7yTaSC2bJmicJ36C2rmGic5sgMA/640?wx_fmt=png)

然后进⼊到 Execute ⽅法。

### 五、反序列化触发

在 Execute ⽅法中，会根据之前创建的 ServiceType 对象进⾏⼀些判断

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAoMNWxib7GyzbpJB3icMLfof8bn7OSWcm7BKrjiaGtasicibGkiamrCV2hEiaQ/640?wx_fmt=png)

如请求⽅法所需要的参数和传递的参数数量必须要⼀致

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAlebciclswcAVyw1KibHCDicCbVRNgMjcTOcLuWMiaQ0icFpia6bEE42zPKRw/640?wx_fmt=png)

以及 MapToCLRType 类的构造函数需要接收⼀个 Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext 类型的对象。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAMfOB254BJVucLk8J97uLWeiaw8ZAB3qGeLNZ2dR8q8UIhEFgSF95t2w/640?wx_fmt=png)

随后进⼊ DeserializeParameters，也就是漏洞触发点对参数进⾏反序列化。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzATQ6seJEavq4IcqBvkMEFsDkzRtVZMqYxIcxOLFp6QJVDcH4fppmb6w/640?wx_fmt=png)

会根据调⽤⽅法所需要的参数数量进⾏单次或者多次循环，并得到对应参数的 Type 类型传递给代理器的 Deserialize 反序列化⽅法。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAVeGaRmzNVmiclXmiajsS2k2n5vsF9ZLibeZoKgR379hW2xO3riafq0XXSg/640?wx_fmt=png)

这⾥⼜做了⼀层限制，当接受参数的类型为 string,int,byte,float,double,long,.... 等等类型时，并不会进⼊ 到代理器的 Deserialize ⽅法 因此需要找到⼀个这些类型之外的，如 Object 类型，GetBusinessObjectData 刚好满⾜这⼀条件。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAicfGlHs0zcmEHyPCZKJGGJytxwh2SXwXJr3bTyjcFlRPICpaLtaxoDQ/640?wx_fmt=png)

最后进⼊到代理器的 BinaryFormatterProxy.Deserialize ⽅法，导致反序列化漏洞触发。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAtRYMKXOJWiaSWexhg3uvgnBCv8xGOBq2pCXRCicKFBTtY4lvHotQthyQ/640?wx_fmt=png)

### Qestion

**参数传递过程中必须要设置成 ap0？** 根据传递⽅式进⾏设置，具体看 ExecuteServiceModule 类中的处理

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAiaictDyejuDRjCtyNvAAPSibQDysxzZHicD5kWgMkFVqVcoZfrXYiagokZg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzApA3MzT8UCB5TSO8g1jwt8yc63XdsUTc5mFwICkHDxcxbMTEju1ibD7Q/640?wx_fmt=png)

这⾥的 form 存储的是上⽂对传递参数进⾏反序列化后的键值对，如果其中包含 parameters 键，如果存在，将该参数解析为⼀个 JSONArray 对象。

如果不存在，则根据⽅法所需参数数量，进⾏ for 循环，以 “ap” 为开头，依次遍历数字。

当然也可以抛弃 json 格式的内容传递⽅式，使⽤传统的 POST

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzA0PZMriaCOJty4UXYTUOaenfeGoQ8JYyvsQkXh8j3UMEf6vs0PmfyB8w/640?wx_fmt=png)

paylod 需要进⾏⼀次 url 编码。

0x02 修复方案
---------

之前某安全公众号有发布对应的临时修复⽅案

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAETp9HFT3FwHK704Wjhk2ffpKT6I7iapiamqeeD5ratxfEicPUhia9Nd2EQ/640?wx_fmt=png)

设置 EnabledKDSVCBinary 为 False，因为在创建序列化代理器时，会取值进⾏判断是否开启⼆进制流反序列化名功能。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzABT3HV894jmZibH579eHP7eBgxAunlwkicsWWVUGeMSenJmTo0KXAVlAA/640?wx_fmt=png)

0x03 绕过风险
---------

上⾯修复的⼿段并不完全，即使关闭了⼆进制流的⽅式传递参数内容，但是该系统提供了不只 Binary ⼀种⽅式传递参数，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzArbE1ibCqZz4vAFNAVAGUBkMTmgHKKkwKM1P1jWM6VGlLN2w3Ld7XTww/640?wx_fmt=png)

在 8.0 及以上版本，官⽅提供了多种⽅式，其中 KingdeeXml 被推荐使⽤，KingdeeXml ⽐ Binary 更安全？

其实不然，KingdeeXml 本质还是 Bianry。

当 format 为 4 时，赋值为 KingdeeXml，创建⼀个 XmlSerializerProxy 代理器

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzA2Xnpic2MDoV9cNY6D70peiaBA7SUXwCasibOFzVAdic3cWzkwFvMicpq7DA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAg3tdzfJtSg3y5ckXg1dwoP8lpNLPE1XRo2IF7F9JKribVfAxUf79RiaQ/640?wx_fmt=png)

⽽ XmlSerializerProxy 代理中的 Deserialize 其中还是⽤的 BinaryFormatterProxy，只是中间需要经过⼀层 NetDataContractSerializer 反序列化成 KingdeeXMLPack 对象。

![](https://mmbiz.qpic.cn/mmbiz_png/SHI5wib3tvAOEyF3yJPt4kCiaHFzft5OzAI2uvam1kLVvPBeVDBnfLIkSvZiawmQj9x3HmXEOM8bTAJfnbvlKtSxg/640?wx_fmt=png)

从⽽绕过 EnabledKDSVCBinary 的设置。

![](https://mmbiz.qpic.cn/mmbiz_jpg/SHI5wib3tvANbZK0EL9zobHJx6DrP5BUnL5Adgj19sQo2QWtnHicuGmFATaf59elJPUwAJehE8woZZxXI4SxmAEg/640?wx_fmt=jpeg)