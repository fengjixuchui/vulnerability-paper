<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/pm4qUL_U2repfwetu0V_gQ)

漏洞环境搭建参考：

*   https://k21academy.com/oracle-accesss-manager/oracle-access-manager-12c-12-2-1-3-0-download-installation-part/
    
*   https://k21academy.com/oracle-accesss-manager/oracle-access-manager-12c-rcu-configure-domain-12-2-1-3-0-part2/
    

在这篇文章中，我将详细介绍 OAM 12c 版本中的漏洞。使用 OAM 11g 版本，将需要更复杂的条件来 RCE。

让我们首先看一下由`oracle.security.am.pbl.transport.http.AMServlet`类处理的 URL 路由`/oam/server/opensso/sessionservice`：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWqOymo73TvFKKNgcSzs37dDBVibvagRPPKZTSotCgZDGKnR38Mpsus5Q/640?wx_fmt=png)

`AMServlet.doPost()`并没有做太多的工作，它只是调用 `handleRequest()` 然后调用 `PBLFlowManager.processRequest()` 来处理传入的请求：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWCbc2nKtlGsTG95Im8VYicamsibcu1DPTvTjiaAvvL9TGyx543ncJQW9sQ/640?wx_fmt=png)

在 `PBLFlowManager.processRequest()` 中，我们传入的 URI `/oam/server/opensso/sessionservice` 映射到一个名为 `OPENSSO_CHECK_VALID_SESSION` 的事件名称 (eventName)：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvW9thickCZwy1WQE2pmtNvWQLJmEqYd98TP3ibxaZeZam6X8GlccfibHmCw/640?wx_fmt=png)

接下来，根据给定的 eventName 创建一个 EventHint，然后使用该 eventHint 从映射中获取 requestHandler：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWuK0tHPS0mR57mSzjXYfvlPYp9mAkjdSXianCfLMc1fESSiaFhrgPdKSw/640?wx_fmt=png)

在这种情况下，`requestHandler` 是 `AgentRequestHandler` 的一个实例，还有一个更大的这些处理程序 URL 映射的列表：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWaibRLWjKlJdAlICibqPkAmhfScJC8KHEslD1ldF0q09bY1PWwW71uEPQ/640?wx_fmt=png)

从 `PBLFlowManager.handleBaseEvent()` 中，请求流分为两部分：  

*   第一部分：调用`requestHandler.process()`解析、验证传入的 XML 数据
    
*   第二部分：调用`PBLFlowManager.delegateToMasterController()`处理当前请求的逻辑特性
    

在第一部分，`AgentRequestHandler.process()` 将调用 `handleXMLRequest()` 将传入的数据解析为 XML 数据：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvW8LFWOjlohnIeTb9qncgCB9hhkP8qF5Eb8OnadnAtsyFlia5fVR8luiaw/640?wx_fmt=png)

成功将数据解析为 XML 请求后，该方法继续跳转到 `AgentRequestHandler.handleRequest()`  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWzUOA8jDbPAVmCbdAKMfGcpboD5j25Vb7En3cr6QRqzjxlVu4eGK6LA/640?wx_fmt=png)

要通过 `isValid()` 方法，传入的请求必须遵循以下形式：  

```
<?xml version=”1.0" encoding=”UTF-8" standalone=”yes”?>
 <RequestSet vers=”vers123" svcid=”session” reqid=”req_1”>
   <Request dtdid=”dtd1" sid=”sid1">
     Data
   </Request>
 </RequestSet>

```

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvW9UvXN29Cm7vtRKiaHJrAyCa9DCkX9c0SViceSs0barCApOUKu8qUwoyA/640?wx_fmt=png)

然后，它将使用参数`serviceId`（可控）调用 `getServiceHandler()`：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvW2oyF3zSRgLcLMRSYBYkfwUFcb1A3xxuwHzqWpovJaQVmjy4ahoVa7Q/640?wx_fmt=png)

`serviceHandler`类型的`svcid` 有 4 种类型：  

*   **NamingService**：**com.iplanet.am.naming**
    
*   **AuthXMLHandler**：**auth**
    
*   **SessionRequestHandler**：**session**
    
*   **PolicyXMLHandler**：**policy**
    

在这里，我们专注于 `SessionRequestHandler`：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWGIaTqBlAVjAYvQm7AFq4jNHAuOPmmBicgcBmKbBkQ92Y4NIlEJZKKtg/640?wx_fmt=png)

确定`SessionRequestHandler`后，`AgentRequestHandler.handleRequest()`会继续调用我们给定的`sessionHandler.process()`，现在是`SessionRequestHandler.process()`。  

在 `SessionRequestHandler.process()` 中，它将从名为`Request`的 xml 标记中获取数据，并将该数据再次解析为 XML 数据：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWaAica2HJpmJC7TsicibegA6tYloBgpAhhN5fOMiaofHN2txrMzKHq0SHrA/640?wx_fmt=png)

只需注意 `SessionRequestParser.parseXML()`，如果传入的 xml 请求包含名为`requester`的属性，则其数据将被 base64 解码并设置为名为`Requester`的属性：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWeiaD4awFShhib5nkFLV6ltN2P5G3bVgYsSNv4PHnW3PcaFcX7nUEvRHQ/640?wx_fmt=png)

此时，我们的请求数据如下所示：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWFDFoCVtLUycCouIBdL3JkVibIFMjcicyu4PD90TuHVdykfxcVQC0Q9JQ/640?wx_fmt=png)

看这个分析文章听起来很直接，但构造完成这些数据并不容易！  

成功解析传入的 XML 数据后，我们继续第二部分分析，`PBLFlowManager.handleBaseEvent()` 将继续调用 `delegateToMasterController()` -> `MasterController.process()` -> `MasterController.processRequest()` -> `OpenssoEngineController.processEvent()`，这是调用栈帧：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWnliaazhM76oibwq21BZH82XLKNM6SW3iabiarqCbdG3wKn7mTD2Jcsg22A/640?wx_fmt=png)

`OpenssoEngineController` 由上面提到的给定 `EventHint` 确定。  

在 `OpenssoEngineController.processEvent()` 中，有一个 switch case 语句来处理每种事件类型，在我们的例子中，它是 `OPENSSO_CHECK_VALID_SESSION`：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWHbibTl0TAZABpfCQUEM8kxn5GsAwwI9HFiafNjkb9tEWIicJsqrqxGKOQ/640?wx_fmt=png)

跟随这个分支，我们将看到对 `OpenssoEngineController.unmarshal()` 方法的调用，并带有给定的 “requester” 变量：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWqvkXB3UgCVuK6ZTvHyKbNaibbeW00SDYEJadibndWKJIj8saKgRqNRBw/640?wx_fmt=png)

这是 `unmarshal()` 方法的内容：  

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvW2iaJY2CmKKNk9TicbdAaldibAu8npKVYIGdicuZQ21sa6MrLHFbRUGeONA/640?wx_fmt=png)

我们可以很快看出，如果 “requester” 变量的形式是`object:<base64 data>`，那么这个数据会直接反序列化，不做任何过滤。  

这就是这个漏洞的来源，长话短说，请求是这样的：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWLq8z6gr1cp3DJxSJiaOECbAbB81HMvVkUo6sxDPdMOdMHUFcHLvec7g/640?wx_fmt=png)

OAM 建立在 weblogic 之上，并且 OAM 的类加载器还包含 weblogic 的库。所以是的，我们可以使用一些 weblogic gadgetchain 来 RCE。  

在尝试了许多旧的 gadgetchain 之后，我们发现`CVE-2020-14644` gadgetchain 仍然没有被全局序列化过滤器阻止。而我们最终的 PoC 也使用了这个 gadgetchain 来获得 RCE！

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUq9iafnzXtojkYngCD8jBvWGe3Ypoclh9lzhnswkKmibBoeVjQCHm5tfvHicC3Tva0BMMVmytlOf6fQ/640?wx_fmt=png)

在为 OAM 12c 打上最新补丁后，该漏洞 poc 失效了。起初，我们认为 Oracle 已经知道这个漏洞并设法修补它。在查看补丁并检查旧版本后，我们知道他们并没有修补该漏洞。  

原因是：在最近的 OAM 12c 补丁中，他们放弃了对 OpenSSO 的支持，因此入口点`/oam/server/opensso/sessionservice`**也被意外删除了**。但在 OAM 11g 中仍然适用，我们发现易受攻击的入口点仍然存在于完全更新的 OAM 11g 中。

在 OAM 11g 中，CVE-2020-14644 的 gadget 不存在，因此需要更多的工作来构建 gadget。

Weblogic 10.3.6 和 OAM 11g 已经停产，2022 年 1 月 1 日之后没有针对它们的补丁。

这意味着：在 OAM 11g 中，此 Pre-Auth RCE 没有补丁。

漏洞分析文章翻译自：

https://testbnull.medium.com/oracle-access-manager-pre-auth-rce-cve-2021-35587-analysis-1302a4542316