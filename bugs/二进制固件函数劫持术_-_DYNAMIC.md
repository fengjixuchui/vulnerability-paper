<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/wKNc8zy8U-946ac1QLiySg)

**背景介绍**

固件系统中的二进制文件依赖于特定的系统环境执行，针对固件的研究在没有足够的资金的支持下需要通过固件的模拟来执行二进制文件程序。依赖于特定硬件环境的固件无法完整模拟，需要 hook 掉其中依赖于硬件的函数。

LD_PRELOAD 的劫持

对于特定函数的劫持技术分为动态注入劫持和静态注入劫持两种。静态注入指的是通过修改静态二进制文件中的内容来实现对特定函数的注入。动态注入则指的是在运行的过程中对特定的函数进行劫持, 动态注入劫持一方面可以通过劫持 PLT 表或者 GOT 表来实现，另一方面可以通过环境变量 LD_PRELOAD 来实现。

在《揭秘家用路由器 0day 漏洞挖掘》中作者针对 D-link DIR-605L(FW_113) 路由器中的 Web 应用程序 boa，通过 hook 技术劫持 apmib_init() 和 apmib_get() 函数修复 boa 对硬件的依赖，使得 qemu-static-mips 可以模拟执行，在文中作者通过 LD_PRELOAD 环境变量实现对函数的劫持。网上针对 LD_PRELOAD 的劫持也有大量的描述。但是 LD_PRELOAD 仍旧不是普适的。

**存在的问题**

LD_PRELOAD 环境变量的开关在编译生成 ulibc 的时候指定，当关闭该选项的时候，无法使用 LD_PRELOAD 来预加载指定的动态链接库文件。

固件的二进制文件中会将二进制文件中的 Section 信息去除掉，只保留下 Segment 的信息，使得无法通过 patchelf 来增加动态链接库实现劫持。patchelf 支持对二进制文件的 patch 修改，或者添加执行过程中的链接 lib。

**本文方案思路**

在 ELF 文件中，存在 DYNAMIC Segment,ld.so 通过该段内容来加载程序运行过程中需要的 lib 文件，图 1 为在 IDA 中反编译后查看的 DYNAMIC 段的内容。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2aUQtjtlFeQlsKiaykExoQTSz1S8Q9CFbDg99U3TsiaPBLr0NPoEDVQxw/640?wx_fmt=png)

图 1 Elf32_Dyn 结构体数组  

**DYNAMIC 段介绍**

dynamic 段开头包含了由 N 个 Elf32_Dyn 组成的结构体, 该结构体的 D_tag 代表了结构体的类型。d_un 为通过 union 联合的指针 d_ptr 或者对应的结构体的值 d_val。

```
typedef struct {
    Elf32_Sword d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
}Elf32_Dyn;
```

d_tag 字段保存了类型的定义参数，详见 ELF(5) 手册。下面列出了动态链接器常用的比较重要的类型值

*   1-DT_NEEDED 该类型的数据结构保存了程序所需要的共享库的名字相对字符串表的偏移量
    
*   2-DT_SYMTAB 动态符号表的地址，对应的节名为. dynsym
    
*   3-DT_HASH 符号散列表的名称，对应的节名为. hash 又称为. gnu.hash
    
*   4-DT_STRTAB 符号字符串表的地址，对应的节名为 .dynstr
    
*   5-DT_PLTGOT 全局偏移表的地址
    

如上各个字段对应到 IDA 中显示如下，d_tag 字段代表了动态段的类型，当该值为 1 的时候。表示程序依赖的共享库的名字，其对应的 d_val 表示了是要加载的 lib 的名称在 string table 中的偏移。

共享库文件名对应的结构体的类型值为 0x01, 如图 2 所示，0x4001C4-0x4001E4 保存有 5 个二进制文件所依赖的共享库名字，其 D_VAL 的值是指向 string table 的偏移量。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ23hum7nsOgd5ev6fGVGcdjKBMBVp1ZvyZ6Uuf2NKyTyCibicVicq7mhpVg/640?wx_fmt=png)

图 2 DT_NEEDED 共享库依赖图  

**DYNAMIC 段的定位**

从二进制文件头起始定位 DYNAMIC 段的流程如下：

ELF_HEADER->Program Header -> DYNAMIC Program

ELF_HEADER 中保存有 Program Header 的偏移

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2QRduUQX6C8eqO11m5GxulMU4WfaXyDMib2ArRica3dr5bFlCdxX68S2A/640?wx_fmt=png)

图 3 ELF Header

Program Header 中保存有 Dynamic Segment 的相关结构体信息

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2RHtytO0ntic5TodSGlHN3vSYY5nSA9AFHskQajTMwWX3EhWxHZeOGrQ/640?wx_fmt=png)

Program Header 结构体

展开该结构体，可以找到 Dynamic 段在文件中的偏移量 0x140h 

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2jS65RNw7l4vXj3fIr7ibRKydKJWoENmy03mKbudL2wjxvbu9icyzibibpw/640?wx_fmt=png)

Program Header 结构体

**DT_NEEDED 伪造**

动态段由 dynamic 的结构体数组组成，dynamic 的结构体定义如下:

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ23Fxzu5rcKqEJBTY1B032W6F9YPjSiaHkd6nryia7yCtRrrxSt3FZZFicQ/640?wx_fmt=png)

在 dynamic 和 elf_hash 之间仍存在一段空余空余可填充空间。本文利用该段空间填充，实现特定 lib 的加载。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ217B1IpvUQtaIHwyeyEe8s8ywX1L940g371m57lddv0zuLqbY9cdeqg/640?wx_fmt=png)

**本文方案实验与测试**

利用 dynamic 和 elf_hash 之间的空余区域，在该区域伪造出新的 dynamic 的一个数组。如下图，不修改二进制文件大小，伪造增添 ibcjson.so, 使得二进制文件加载 ibcjson.so。在 ibcjson.so 中编写对应的劫持函数

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2F4s6AXicgjpdLOKxuN8t8UphVh0hMAYxkwDSa22XbjIZkENDUv8cQicA/640?wx_fmt=png)

思路：将原有的 Elf32_Dyn 数组元素依次后移，并在该数组的首部添加伪造的 ibcjson.so，该 lib 的命名可以选用 string table 中的任一字符串即可。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2yx7S3ojuqjl0K6vrUCFukHR8ibuglkQpyPt4QTgHAbtzjPxuY8KFxIg/640?wx_fmt=png)

核心移动代码，将 Elf32_Dyn 中的元素依次后移一个，dynamic 段 dynamic[0] 元素作为要伪造填充的数据，在本文的实验中，将 dynamic[0] 中的 value 值加 1。由于在 MIPS 下存在大小端两种架构，在小端机器上的代码解决大端架构的填充伪造时要注意大小端的转换问题。

```
void move_dynamic(char* buf){
    int x = 0;
    Elf32_Dyn* dyn = (Elf32_Dyn *)buf;
    while(1){
        if(dyn[x].d_tag == 0 && dyn[x].d_un.d_ptr == 0){
            break;
        }
        x++;
        if(x>100) {
            printf("Error break\n");
            break;
        }
    }
    while(x--){
        //printf("the index x is %x\n",x);
        mem_cpy(&dyn[x],&dyn[x+1],8);
    }
    dyn[x+1].d_un.d_val = b2l(l2b(dyn[x+1].d_un.d_val) + 1);
}
```

**测试环境**

TOTOLink N210RE 中 boa 程序，劫持函数参考 DIR605A，劫持 apmib_init 以及 apmib_get

该固件的 ld，关闭了 LD_PRELOAD 程序选项，未提供 / etc/ld.preload

劫持函数代码，采用了《揭秘家用路由器漏洞挖掘》提供的示例代码如下, 在原有的基础上，增加 printf 来查看显示是否劫持成功。

```
#include<stdio.h>
#define MIB_HW_VER 0x250
#define MIB_IP_ADDR 170
#define MIB_CAPTCHA 0x2C1
int apmib_init(void){
        printf("helllo");
        return 1;
}
int fork(void){
        return 0;
}
void apmib_get(int code,int *value){
        switch(code){
                case MIB_HW_VER:
                        *value = 1;
                        break;
                case MIB_IP_ADDR:
                        *value = 1;
                        break;
                case MIB_CAPTCHA:
                        *value = 1;
                        break;
        }
        return;
}
```

通过 mips-linux-gcc 进行编译，这里注意 mips-linux-gcc 在编译过程中的编译文件的位置要位于参数之后（踩坑了!!!!）

```
mips-linux-gcc -Wall -fPIC -shared apmib.c -o ibcjson.so
```

  
通过如下代码，给原有的 boa 二进制文件添加一个 dynamic

```
#include<stdio.h>
#include <stdio.h>
#include <stdlib.h>

#include "elf.h"
#define PATCH "boa_patch"
int b2l(int be)
{
    return ((be >> 24) &0xff ) 
        | ((be >> 8) & 0xFF00) 
        | ((be << 8) & 0xFF0000) 
        | ((be << 24));    
}
char* buf = NULL;
int l2b(int le) {

    return (le & 0xff) << 24 
            | (le & 0xff00) << 8 
            | (le & 0xff0000) >> 8 
            | (le >> 24) & 0xff;
}
static char *_get_interp(char *buf)
{
   int x;

   // Check for the existence of a dynamic loader
   Elf_Ehdr *hdr = (Elf_Ehdr *)buf;
   Elf_Phdr *phdr = (Elf_Phdr * )(buf + l2b(hdr->e_phoff));   
   printf("the phdr address is: 0x%x 0x%x 0x%x 0x%x\n",phdr,l2b(hdr->e_phoff),buf,sizeof(hdr->e_phoff));
   for(x = 0; x < hdr->e_phnum; x++){
      if(l2b(phdr[x].p_type) == PT_DYNAMIC){
         // There is a dynamic loader present, so load it
         return buf + l2b(phdr[x].p_offset);
      }
   }

   return NULL;
}
int mem_cpy(char* src,char* dst,int len){
    printf("the src addr is %x , %x\n",src-buf,dst-buf);
    for(int x=0;x<len;x++){
        dst[x]=src[x];
    }
    return 0;
}
/*
1 2 3 4

temp = 2
strcpy(1,2)
1 2
strcpy()

*/
void move_dynamic(char* buf){
    int x = 0;
    Elf32_Dyn* dyn = (Elf32_Dyn *)buf;
    //Elf32_Dyn tmp_dyn;
    //mem_cpy()
    while(1){
        if(dyn[x].d_tag == 0 && dyn[x].d_un.d_ptr == 0){
            printf("the x is %d\n",x);
            break;
        }
        x++;
        if(x>100) {
            printf("Error break\n");
            break;
        }
    }
    while(x--){
        //printf("the index x is %x\n",x);
        mem_cpy(&dyn[x],&dyn[x+1],8);
    }
    dyn[x+1].d_un.d_val = b2l(l2b(dyn[x+1].d_un.d_val) + 1);
    //FILE* fw = fopen("")
}
void analyse(char* buf){
    char* phdr_address = NULL;
    phdr_address = _get_interp(buf);
    printf("phdr address:  0x%x\n",phdr_address-buf);
    move_dynamic(phdr_address);

}
void save_binary(char* buf,int size){
    FILE* fw = fopen(PATCH,"wb");
    fwrite(buf,size,1,fw);
    fclose(fw);
}
int main(int argc,char *argv[],char* envp[]){
    if(argc < 2){
        printf("not enough argc\n");
    }
    FILE* fp = fopen(argv[1],"rb");

    fseek(fp,0,SEEK_END);
    int size = ftell(fp);
    fseek(fp, 0L, SEEK_SET);
    buf = malloc(size);
    fread(buf,size,1,fp);
    analyse(buf);
    save_binary(buf,size);
    free(buf);
    return 0;

}
```

Makefile 如下

```
all: elf.h analyse_ph.c
  gcc analyse_ph.c -m32 -g3 -o analyse
  ./analyse boa_real_n210
```

针对 N210RE 的测试截图如下，通过 export LD_LIBRARY_PATH 使得程序加载 ibcjson.so，成功劫持 boa，输出 helllo

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2J7pRfib1CyvGNbXa7sMuo8wiaEN8DXZLGoH0fhJ1iaicfAe7v0yW5jBNcA/640?wx_fmt=png)

**Ubuntu 下 rand 函数劫持测试**

rand 函数的头文件是 stdlib.h

编写 rand.c 

```
#include<stdio.h>
#include<stdlib.h>
int main(){
    int a = 0;
    a = rand()%100;
    printf("the a is %d\n",a);
    return 0;
}
//gcc -m32 rand.c -o rand
```

编写 rand_hook.so

```
#include<stdio.h>
int rand(){
    printf("hook !\n");
    return 100;
}
//gcc -fPIC -Wall -shared -m32 rand_hook.c -o rand_hook.so
```

使用 LD_PRELOAD 测试，成功实现对该函数的劫持

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2WzjKJYNLK5XtOoeDXBg2YZRlbQXiazmfGMy8f9Qkvus93vSTfa2BsMw/640?wx_fmt=png)

使用 patch，针对 dynamic 段元素添加伪造，测试 rand_patch，依赖的库文件增加了 ibc.so.6，ibc.so.6 需要通过 export LD_LIBRARY_PATH 导入 ibc.so.6 的文件路径

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2FNzUGqZr3vxpmjsdvQG9eaXzNibvMurRpQVCeCwyxS0HzBGdee7pSRA/640?wx_fmt=png)

实现对 rand 的劫持

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9Lfsb5hrumNFjJ5kgiazyavZ2Q8JYYCwly0kn39sAYXryowCVNyHjMf0PDH1PVQpZbqmNxBAE1EsW2Q/640?wx_fmt=png)

**总结**

本文通过研究二进制文件中的 dynamic 段, 通过修改二进制文件增加依赖共享库，可以解决在模拟固件的过程时，固件缺少节信息且固件函数无法通过 LD_PRELOAD 劫持的问题。该方案仍有不足之处，对于 ld 加载共享库的依赖顺序、共享库劫持的底层原理尚未深入探究。

**参考**

《揭秘家用路由器 0day 挖掘技术》

《二进制分析实战》

**原创稿件征集**

征集原创技术文章中，欢迎投递

投稿邮箱：edu@antvsion.com

文章类型：黑客极客技术、信息安全热点安全研究分析等安全相关

通过审核并发布能收获 200-800 元不等的稿酬。

[更多详情，点我查看！](http://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652885477&idx=1&sn=39e97a60d7b68d19569284654e74ffa1&chksm=bd59ad288a2e243e4d89b7c456fbd44a93d241c881075b342af22431d93dca56e52076ed75ce&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6iavic0tIJIoZCwKvUYnFFiaibgSm6mrFp1ZjAg4ITRicicuLN88YodIuqtF4DcUs9sruBa0bFLtX59lQQ/640?wx_fmt=gif)

靶场实操，戳 “阅读原文 “