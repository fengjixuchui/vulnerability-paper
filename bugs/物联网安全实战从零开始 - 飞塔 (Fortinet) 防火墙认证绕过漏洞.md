<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/tHqFusrt0Q74RUGkLiukEg)

![](https://mmbiz.qpic.cn/mmbiz_png/JA6Gh35o8GSBp76s63jq6FvzrkXWTzL7nR4Mv8NAwGUkpJrzQdt6icYhiaEoKB1ffG66beKwic4OWQAz6JoBKHYdg/640?wx_fmt=png)

本环境是蛇矛实验室基于 "火天网演攻防演训靶场" 进行搭建，通过火天网演中的环境构建模块，可以灵活的对目标网络进行设计和配置，并且可以快速进行场景搭建和复现验证工作。

背景
==

Fortinet FortiOS 是美国飞塔（Fortinet）公司的一套专用于 FortiGate 网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web 内容过滤和反垃圾邮件等多种安全功能。10 月 10 日，Fortinet 官方发布安全公告，修复了其多个产品中的一个身份验证绕过漏洞（CVE-2022-40684），其 CVSSv3 评分为 9.8。攻击者可以通过向易受攻击的目标发送特制的 HTTP 或 HTTPS 请求，有权访问管理界面的远程攻击者可以执行管理员操作。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag7cUDQ6iccLapZiaSnO9bmKudQXH2L8GldwxkAfwbNQLPVXicO58mDlYsQ/640?wx_fmt=png)

漏洞分析
====

CVE 信息中说明了该漏洞为身份认证绕过漏洞，并且可以 RCE。在开始分析前，我们需要先搭建漏洞环境。由于该漏洞影响范围如下，这里我使用防火墙的版本为 forigate-vm64 7.2.1，内部 Fotios 版本与防火墙版本一致。

```
FortiOS 版本 7.2.0 - 7.2.1FortiOS 版本 7.0.0 - 7.0.6FortiProxy 版本 7.2.0FortiProxy 版本 7.0.0 - 7.0.6FortiSwitchManager 版本 7.2.0FortiSwitchManager 版本 7.0.0
```

下面开始配置 Fortigate 防火墙，使其能够与我们的攻击机网络互通。

注意：Fortigate-VM-7.2.0 以后使用新的证书方式，需要有 fortinet 账号获得永久试用，这里需要 fortigate 联网。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag7jMRU9Dc1rkpyNAoMJHVKXfaH2v6Xwkx1N4nMjg5Xt7JktDbM4xRQA/640?wx_fmt=png)

使用浏览器访问 ip 后，使用 admin:password 进行登录，登录后界面如下所示。至此，fortigate 环境已配置完毕，接下来我们进行分析。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag00wFKic4OFpcvjSPqFo4zdeeTQntwQuBSVQ2PicmN460TzFbhSOckwdg/640?wx_fmt=png)

libguestfs 是一组 Linux 下的 C 语言的 API ，用来访问虚拟机的磁盘映像文件，几乎可访问任意类型的文件系统。debian 系安装命令为 "sudo apt install libguestfs-tools"，安装完成后会有很多 "virt - 开头的命令。

将 fortios.vmdk 从下载好的 fortigate 压缩包中解压出来，使用 "sudo virt-filesystems -a fortios.vmdk" 也是查看磁盘的分区情况。然后使用 "sudo guestmount -a fortios.vmdk -m /dev/sda1 --ro mount_dir_name" 进行挂载。

mount 成功后，rootfs.gz 为文件系统压缩包，我们将其复制出来。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiaguTAnVKeY7YTIV3egh0NXYZkvtGy48oErvIhMs86SvGWdD6S4Kiawhvw/640?wx_fmt=png)

rootfs.gz 解压后为 rootfs，使用 "cpio -i 2> /dev/null <rootfs" 命令进行提取。提取后发现大量文件系统的目录和. tar.xz 文件，.tat.xz 文件使用 xz 解压时会失败，我们可以使用文件系统中自带的 (sbin/xz) 程序进行解压，这里只需注意它的链接器路径(将其修改至主机系统的链接器路径)，我们 patch 后并保存。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagmianC5gAyHFfuuGJgKeJRTZOA834XJsWP7AwAqe15wiaIqNxLzFibgswQ/640?wx_fmt=png)

xz 解压后提取出各个文件系统目录，进入到 bin 目录后寻找 httpsd 程序。httpsd 是 init 程序的软连接，并且这里可以看出 init 程序非常大，逆向该程序比较费时。所以我们可以根据调试信息先来逆向程序逻辑。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagrUu8SicgBV8mc8hiaFb9pOTwBg1d0ofDjlWgriandxGJmf391AlKBQ4wg/640?wx_fmt=png)

运行以下命令开启 httpsd 程序的调试信息，当开启调试信息后，当我们对 fotigate 的 web 服务进行操作时，该操作的信息就会打印到屏幕上。

```
diagnose debug enablediagnose debug application httpsd -1diagnose debug cli 8
```

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagFXPYuImk0czfvmr4WEN14OB0ddj633b4kpMMxibMJtybJJwtm3ZRJiaw/640?wx_fmt=png)

调试开启后，下面以登录授权访问 api 为例，简单分析一下流程，当我们在浏览器输入 admin:password 点击登录后访问 api 打印的调试信息如下

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiagiasrg6a3NLfibWROiaDK7M7iarbiaFIYCdxUcmd5yusdibgWuCXCsdR3ib70A/640?wx_fmt=png)

我们根据调试信息打印的字符在程序中进行搜索，根据字符串引用进行定位，发现程序执行了 fweb_debug_init 函数

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagV7C0J6OS7heeIt5WiblQKm6h6Nwjic0km0p3muBicBM6lBiaRQ1xOBcVcw/640?wx_fmt=png)

大致浏览一遍后发现后发现程序使用了 Apache Portable Runtime 库，我们可以根据函数库对函数的使用进行查询。这里的 apr_table_get 函数为从表单中取出 key 值对应的 value。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagN0ZfUbD9vpPWF0RxPKd3MJ25zExFHngSqlo1yGficTUBvdHnpXHmYRQ/640?wx_fmt=png)

对 fweb_debug_init 函数进行交叉引用，发现 sub_C4BF20 调用了 fweb_debug_init 函数，这个函数与上面中的调试信息并无联系，我们继续往上跟。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagnUZuiaIhUe9etJUwYh1k4KC9FViaVY2DtrZLW0o7h5NeMn7OicdrvcbNw/640?wx_fmt=png)

sub_C4C480 调用了 sub_C4BF20 函数，并且后面的 fweb_debug_final 函数与上面图中最后登录成功后的最后产生的调试信息相同。那么 fweb_debug_init 与 fweb_debug_final 之间的俩个函数 v3[1] 函数和 sub_C4C2A0 产生了大量调试信息。我们跟进分析一下 v3[1] 函数

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag6fRCk2bBtoZH22zgAMY1oYT88FbTh5nJfib0omjmqoluK41ibQbJnryQ/640?wx_fmt=png)

v3 由参数 a2 赋值，a2 为 sub_C4C480 函数的参数，

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagUicB7IaFfO0K603tZoia54DKGpuo8aiahLWdJJ5RJ00sMdDSgPol1XaoA/640?wx_fmt=png)

a2 参数为 off_3FEA400 函数数组的地址

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagLb13AYC2MWquOXWVAiaDQ3kFeFy3PHWlbFK8dic109xo9KmcKPnqhsjQ/640?wx_fmt=png)

off_3FEA400 函数数组为传入 sub_C4C480 函数的参数，当函数执行完 fweb_debug_init 后，通过参数加索引的方式调用相应 hanler 函数，这里 v3[1] 执行 sub_c929F0 函数

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagzicVic15icwErY1waJovdx4RoxVC7Z0FhIhmGXzZmU3AIj0YZvlAeraCQ/640?wx_fmt=png)

sub_c929F0 函数中调用了 api_check_access 函数，并且程序会根据 api_check_access 返回值返回用户对应响应码的 reponse。我们进入 api_check_access 函数中进行查看  

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagKNVdCS4sS8E5GWXyic1466axEAEkBbfx8tvN3wZ0MxeUjlLpHMgGkcA/640?wx_fmt=png)

api_check_access 函数的返回值由几个子函数共同决定，当我们根据调试信息追函数流程时，发现在 api_check_access 中并没有输出任何调试信息，而是在 sub_c929F0 函数中调用了 handle_cli_request 输出了调试信息。同时 handle_cli_request 函数输出完 vdom "root" 后，该 handler 函数执行完毕并返回执行 fweb_debug_final 函数，随后结束该次 event 响应。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagtOEvRdib5WIAy1Zl08ibyUTMUSjrzhVN4nMaLIyaAdezeS1cou0gyLVg/640?wx_fmt=png)

上面我们大概知道了访问 api 时程序执行大概流程，但是具体细节和身份验证的流程我们还是不知道。下面我们直接用已公开的 poc 进行测试，并关注其调试信息以方便逆向。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagtPolloryvzciaF5j0EavC1mibhVzYCyBIhcddpErkTjGLTUOrLyrVuSA/640?wx_fmt=png)

此时调试如下，我们发现和上面已授权登录相比，多了俩条调试信息，分别是 fweb_authorize_all 和 api_access_check_for_trusted_access，下面我们跟进去分析一下。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag4ZXH1Sbsdbz87hLU0A6JibKRlMItxLBMUUm3c2otj3Kd2z57gRlZlGg/640?wx_fmt=png)

当我们跟进去时发现 sub_C4AC70 函数先调用了 sub_C4B590 函数，然后 ap_hook_handler hook 前面我们分析的 sub_C4AC60 函数。sub_C4B590 也同样是 ap_hook_check_access_ex hook 的 fweb_authorize_all 函数。那么到此所有的流程我们已经知道了，接下来我们分析一下漏洞是如何形成的。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiagk81kuTAAf3AYSQHcyhxba89CFYekkTvibuM8Xqem4ktykC63J5AuM9Q/640?wx_fmt=png)

在认证过程中，函数首先调用 fweb_authorize_all 判断 v2+64 是否等于 "127.0.0.1"，即判断是否本机访问，如果本机访问则 sub_C50E80 函数内部继续判断接口如果是否为 vsys_fgfm 接口。随后取 Forwarded 头的 value 值，strstr 函数查找 "for=" 的位置，随后执行 if 结构体内容，再次判断 Forwarded_header_content_tmp 中是否存在 "by" 字符，如果判断不通过并不会进入到 api_check_access 函数中。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagWCvAhgib5Gvh28IcTxeFuK41YWYLq18pqmNXhmAvw5Eoibgqia0icdkbgw/640?wx_fmt=other)

api_access_check_for_trusted_access 函数中调用 sub_C510D0，传入参数为 "Node.js"

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagUKoLwc4ExEnSZZIlZO3craF1CMFCV71VDdtdvbCjRcWqpUicEAicEtVA/640?wx_fmt=png)

sub_C510D0 函数中判断表单中 User-Agent 的 value 值是否与 Node.js 是否相同

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagL07ickq7Gwm62pIvZ3cNdcHrgyx4P1o59ecMFVdZClWXUY6ekYmPJ2A/640?wx_fmt=png)

如果不是 "Node.js"，则判断 User-Agent 的 value 值是否与 Report Runner 是否相同

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiagrn3j49l6R7Z2zZM6jBVulw50RQibxLBia3fRxDdUXpae02wib7CMpPX7w/640?wx_fmt=png)

进入到过以上俩种方式中的某一种，用户赋值为 "Local_Process_Access"，此时会绕过身份认证。也就是说要想攻击成功，需要设置 Forwarded 头 value 值必须为 "for="，后面可以设置 127.0.0.1 来隐藏防火墙中的攻击记录，而 User-Agent 的 value 可以设置 "Node.js" 和 "Report Runner" 俩种中的一个。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagYma4CJcW5NEO2icGcej1AzN460EibZaez9c4Alu1AvvQBQpJerJYqCcw/640?wx_fmt=png)

以上俩种绕过测试只在 Fortigate-VM-7.2.1(Fortigate-VM-7.2.0 由于没有镜像所以没有测) 有效，当 fortigate-vm 版本在 7.0.0-7.0.5 中 User-Agent 需要为 Node.js(7.0.6 没测)。

漏洞复现
====

未攻击前，使用 ssh 连接 fortigate 的 admin 用户需要密码登录。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagKvbmghg2icYCd0W57CsvrGYSTPgmRyK4laiadHAQj5LiatkACc0fC7kIQ/640?wx_fmt=png)

使用 kali 生成 ssh-pulibc-key，然后利用漏洞绕过身份认证，并使用 PUT 方法设置 fortigate 的 ssh-public-key1(实现这种攻击方式需设置 User-Agent 头为 "Report Runner")，点击 send 进行攻击 (或使用 github 已公开的 exp 脚本进行攻击)。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5Wjiaiag4Ql0wUDlso6QibhJykia2um97RuE9gD5UylWCm6rQaqOAqtUPCSdiaqwA/640?wx_fmt=png)

出现 "SSH key is good." 后，说明攻击成功，此时使用 ssh 连接 fortigate 防火墙则需不要输入密码。获取 fortigate 终端后，可执行任意命令。

![](https://mmbiz.qpic.cn/mmbiz_png/WGegAIkTRicic5FDZIGe9icK95PPa5WjiaiagZezPhYMWalUoxV7YLticP2iclPB0qm8RM6FuhsdKicE6K6HCo7WrIT18Q/640?wx_fmt=png)

总结
==

我们这一小节简单了解了身份认证绕过流程，分析并复现了 fortigate 防火墙身份认证绕过漏洞的形成过程以及如何利用。

![](https://mmbiz.qpic.cn/mmbiz_png/JA6Gh35o8GSBp76s63jq6FvzrkXWTzL7nR4Mv8NAwGUkpJrzQdt6icYhiaEoKB1ffG66beKwic4OWQAz6JoBKHYdg/640?wx_fmt=png)

蛇矛实验室成立于 2020 年，致力于安全研究、攻防解决方案、靶场对标场景仿真复现及技战法设计与输出等相关方向。团队核心成员均由从事安全行业 10 余年经验的安全专家组成，团队目前成员涉及红蓝对抗、渗透测试、逆向破解、病毒分析、工控安全以及免杀等相关领域。