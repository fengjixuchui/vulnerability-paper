> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1010)

> 奇安信攻防社区 - PHP 正则表达式绕过姿势之异或绕过

做 web 题时经常为绕不过正则表达式匹配而头疼，今天学习了一种新的绕过姿势——异或绕过，可以解决大多数的正则表达式匹配题，可谓是正则表达式大杀器了。

下面我们以一道题为例给大家演示一下这种绕过方法：

以题代讲
----

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-14b14cfc111ea08f05837ecd683a12a154bd9230.png)

我们现在只关注题目的下半部分，我们发现 code 中不能出现字母和数字以及 +/，过滤的条件极为苛刻，并且通过题目中给出的提示，我们要执行`eval(getflag())`, 那我们就需要利用异或绕过的方法

**1. 写一个符号两两异或成字母（/ 数字）的脚本**

例如：

```
word = input("Input word:")
```

这个示例脚本的作用就是将我们输入的一个字母字符串中每个字母字符，是通过哪两个特殊字符异或生成的过程，输出出来。

* _类似的脚本都可以在网上找到，也可以自己写_

例如：输入 cat

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f85411ed9c503e07c72d8ba47e8dd8ed866cd973.png)

打印出来的 payload 就是 cat 中每个字符通过特殊字符两两异或的过程，每个字符异或操作用 “()” 包含，并且用 “.” 连接，这是 PHP 的语法要求。

这里我们需要输入 getflag，得到 getflag 的 payload：

`("'"^"@").("%"^"@").("/"^"[").("&amp;"^"@").(","^"@").("!"^"@").("'"^"@")`

这个 payload 在 php 里就会自动运算解析成 “getflag” 字符串。

**<u> 至于 PHP 为什么将 payloads 视为字符串？</u>**

因为 ^ 是互斥或运算符，这意味着我们实际上正在使用二进制值。因此，PHP 允许我们分解一个值为另外两个值的异或。

二进制值的 XOR 异或运算符将返回 1，其中只有一位为 1，否则返回 0（0 ^ 0 = 0，0 ^ 1 = 1，1 ^ 0 = 1，1 ^ 1 = 0）。对字符使用 XOR 异或时，将使用其 ASCII 值。这些 ASCII 值是整数，因此我们需要将其转换为二进制值以查看实际情况。

**2. 将 payload 手动编码**

因为有些字符在浏览器中不会被手动编码，所以这里我们必须进行手动编码，这里我使用的是利用 hackbar

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9661d3383bf8f026d1c8520f7640c442b74ce2ec.png)

选中异或构造的 payload 部分

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f33f7c4821afc2d045ae099d585b5bdc48a9c7f6.png)

选择 ENCODING -》URL encode

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-7205ac18ff64272de7b470e8cceb9ad31b268b51.png)

效果如下图所示：

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d756af84b47f26097c578da75d42f7012c721dcb.png)

**3. 将 payload 赋值给一个变量**

这一步是必须的，因为如果直接让 `code = (手动编码过的)payload();`是无法执行的，要让`code = 一个变量 = (手动编码过的)payload;变量名();` 因为先要让一个变量保存 payload 的异或结果，然后执行这个变量，才能执行我们想要的函数。

**<u> 并且这里有一个关键的细节:</u>**

因为前面的正则表达式 ban 掉了所有字母和数字，那么我们要用来储存异或构造的运算结果的变量名的选择就很叼钻了，我们来看一下 PHP 中的变量命名规则：

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-54f7810a3732fd47a5f41596734027218e8c3a04.png)

初看命名规则我们可能会觉得字母和数字都被 ban 了，我们肯定无法命名出一个变量了，但是细心的小伙伴可能会发现，还有 “_“（下划线）能用，所以我们构造的变量名就是”_“，即变量表示为`$_`。

_从这里我们也可以发现如果 “_“（下划线）也被 ban 了的话，我们也就不能使用异或构造了，因为一定需要有一个变量来储存异或构造的运算结果的。_

所以最终的完整 payload 为：

`?code=$_=(%22'%22%5E%22%40%22).(%22%25%22%5E%22%40%22).(%22%2F%22%5E%22%5B%22).(%22%26%22%5E%22%40%22).(%22%2C%22%5E%22%40%22).(%22!%22%5E%22%40%22).(%22'%22%5E%22%40%22);$_();`

**4. 执行完整 payload**

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-69a1c52c3a6fe5f176a14878cc051c7c5d50df41.png)

最后加上本题的上半部分 post 传参 + 数组绕过 md5 比较就能得到完整的 flag 了。

总结
--

异或绕过不仅可以应对苛刻的正则表达式匹配，还可以应用于很多不同的需要绕过情况中。具体在什么时候使用异或绕过呢？我个人认为是在需要的字母或数字被 ban 时，就可以拿出这门大杀器了，但是当 “_“(下划线）也被 ban 时就不要使用了哦。