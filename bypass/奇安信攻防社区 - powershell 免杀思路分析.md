> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/936)

> 奇安信攻防社区 - powershell 免杀思路分析

# powershell 免杀思路分析 ## 写在前面 powershell 做为微软 windows 系统自带的软件包，具有十分强大的功能，Windows PowerShell 是一种命令行外壳程序和脚本环境, 使命令行用户和脚本编写者...

写在前面
----

powershell 做为微软 windows 系统自带的软件包，具有十分强大的功能，Windows PowerShell 是一种命令行外壳程序和脚本环境, 使命令行用户和脚本编写者可以利用 .NET Framework 的功能，在 IT / 系统管理员间得到普及。总的特点来说就是: 方便、有效和隐蔽。举例来说，利用这些合法工具可以让威胁活动混在正常的网络流量或 IT / 系统管理工作内，也让这些恶意威胁能够留下较少的痕迹，使得侦测更加困难。在经过各种变形、加密、混淆、恶意文件放在远程服务器上，通过下载到内存中执行等方式来执行，导致其在防护这块还是存在很多技术难度，powershell 后门和挖矿也越来越受人关注。在内网渗透中，免杀技术显得格外重要，在免杀的学习中，经常陷入一个误区，按照教程复现一遍，甚至不知道别人再讲什么，只知道可以免杀，而一旦别人的免杀技巧给查杀，自己对其免杀思路就束手无策，而正所谓授人以鱼不如授人以渔，接下来将使用 CS 生成的后门对国内主流的某绒、某 60 来查杀分析。

前期知识准备
------

**Powershell 执行策略**

```
powershell.exe Get-ExecutionPolicy  获取执行策略
```

**常用 powershell 参数请参考：**

[https://blog.csdn.net/qq_51524329/article/details/121579801](https://blog.csdn.net/qq_51524329/article/details/121579801)

**免杀方式主要考虑的问题：**

1、免杀工具执行的条件

2、文件的大小

3、是否能够正常使用（这里是能否正常上线）

cs 生成一个 powershell 后门，某绒、某 60 直接查杀。

```
Restricted: 脚本不能运行(默认设置)
```

### 本地执行代码 - 编码分析

本地执行代码的含义就是将 powershell 脚本直接上传至目标服务器来进行执行，现在我们首先要做的是什么呢？当然是先定位特征码。何为特征码，特征码就是病毒特有的特征，一般杀软件检测是根据特征码来检测，特征码检测指一种精确地检索一组匹配字符串的直接模式，每个病毒及其 变种的特征都包含在扫描器的定义库中，而这些特征是不会出现在未被感 染的文件中的。

在 powershell 脚本如何手动定位特征码呢？直接一段一段代码删除，每次都使用杀毒软件查杀，就可以定位特征码（exe 程序定位特征码）在该 powershell 脚本中杀毒软件主要对 DoIt 变量的内容进行查杀。这里特别要注意 base64 编码的选择器，有些网上的在线编码器编码后并不能执行。

```
RemoteSigned: 在本地创建的脚本可以运行，网上下载的脚本无法运行(拥有数字证书签名例外)
```

将上述 powershell 脚本拿去查杀，发现某绒查杀，某 60 不查杀且成功上线，就不截图了，因为下面还有很多尝试如果每次进行查杀实验都要截图的话看过去很反感。那这说明了什么？说明某绒对静态代码查杀能力强，某 60 对静态代码查杀能力弱。

#### 远程下载执行—替换 & 拆分 & 干扰

远程下载执行含义：

[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-4a328dc322b753f57d066188778390be3d1b3480.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-4a328dc322b753f57d066188778390be3d1b3480.png)  
**远程执行**  
将上述的 powershell 后门脚本放置我们的服务器，在目标服务器执行以下命令

```
AllSigned: 仅当脚本由受信任的发布者签名时才能运行
```

某绒直接查杀，某 60 也直接查杀  
**替换文件名**  
这个又是干嘛呢？其实就是将 powershell.exe 中的内容复制到文本中，此时的文本就相当于是 powershell.exe。

```
Unrestricted: 允许所有脚本运行
```

此时过某绒且成功上线，某 60 查杀。

**拆分 http**

以变量的方式拆分 http，然后再进行拼接进行下载并执行

此时过某绒且成功上线，某 60 查杀。  
**两种方式结合**  
如果将上述两种方法相结合又会产生什么样的效果呢？

```
Set-ExecutionPolicy <Policy name>  设置执行策略
```

此时过某绒且成功上线，某 60 查杀。  
**添加垃圾字符**

```
Set-StrictMode -Version 2
```

此时过某绒且成功上线，某 60 查杀。  
如果我将上面三种方法全部结合又会出现什么样的结果呢？免杀思路就是不断尝试，不断的去思考。

此时过某绒且成功上线，某 60 查杀。

通过上面的分析应该有点清楚免杀的思路了吧，对于上面的测试我们只是将未编码的 powershell 后门脚本放置我们的服务器，然后下载并执行，如果我将编码过后的放置到服务器又会擦出什么样的火花呢？这里我也尝试过了，结果与上面的一致，通过这个现象我们能够发现什么问题呢？说明在远程下载执行的时候，杀毒软件查杀的并不是我们服务器上的代码，而是检测 powershell 进程。为什么这么说，因为我们放置服务器的代码并不能绕过某绒。在同时也可以发现某绒对进程的检测能力一般，而某 60 对进程的查杀能力很强。别急，下面我们继续尝试其他方法。

远程下载 && 混淆编码
------------

对于第一开始的 base64 编码混淆，我们的方式还是太简单，那么有没有一款工具能够对 powershell 很好的进行编码混淆呢？完成一个复杂的编码混淆呢？这里介绍一款专门用于 powershell 脚本进行编码混淆的工具。

Invoke-Obfuscation

下载地址：[https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)

**基本使用命令：**

```
$DoIt = @'
```

连工具都杀，为什么连工具都杀呢？先继续看下面，后面我会一一道来。  
[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-a52d660aa5dcc84230e58e51a5ccbdfa757feb22.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-a52d660aa5dcc84230e58e51a5ccbdfa757feb22.png)

对其源码进行编码

[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-5efe30b4e70f7f7772031614feb00230ea85f3bf.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-5efe30b4e70f7f7772031614feb00230ea85f3bf.png)

这里随便选一个进行编码，来看一下编码后的内容吧！可以看到经过混淆的代码非常复杂，我们一般是非常难混淆出这么复杂的代码的。

```
function func_get_proc_address {
```

此时进行查杀某 60 过，某绒不过。

经过第一编码 360 绕过，火绒还是没有绕过，在进行第二次编码后某 60 过，某绒不过。

```
Param ($var_module, $var_procedure)
```

通过上面的实验又发现了什么问题呢？首先工具被杀的原因是什么呢？因为该工具已经被列入杀毒软件的指纹库，所以会被查杀，而 powershell 经过该工具混淆编码后还是被查杀，是由于杀毒软件已经检测到该编码后的内容是用该工具进行编码的，同样也会被查杀，这就好比菜刀、蚁剑、sqlmap 等工具的流量等特征已经被明确的加入到杀毒软件的指纹库中，所以这些工具会被拦截。问题来了，既然会被查杀那么又有什么意义呢？换一种思路，刚刚我们是对所有的 powershell 脚本进行编码，那么如果我只对部分的代码进行编码又会出现什么样的情况呢？  
这时我采用的是将第一开始经过 base64 编码的 shellcode 代码放置到远程服务器，然后下载执行。代码如下：

```
$var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
```

此时又会出现什么样的结果呢？此时某绒不查杀，而某 60 在执行的时候还是拦截。而现在要做的就是将上面的部分代码利用 Invoke-Obfuscation 工具来进行部分编码，那么现在我就是利用该工具依次尝试对每段代码进行编码，再对`start-job { param($a) IEX $a } -RunAs32 -Argument $mksec | wait-job | Receive-Job`进行处理后，某 60 成功绕过，并且成功上线。  
这里选了第五个进行编码，其他自己尝试，因为有太多种可能。  
[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-96049f971dc326b9e4c8fc18105863d90784e675.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-96049f971dc326b9e4c8fc18105863d90784e675.png)  
代码如下：

```
$var_gpa = $var_unsafe_native_methods.GetMethod('GetProcAddress', [Type[]] @('System.Runtime.InteropServices.HandleRef', 'string'))
```

此时拿去 vt 上查杀，免杀率为 0

[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-717d05420745420dc63ec6c085c6c443162bce28.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-717d05420745420dc63ec6c085c6c443162bce28.png)  
这里需要强调一点，其实很多文章都有介绍一些免杀工具，很多免杀工具已经被杀毒软件列入指纹库，可以使用以上的方式，说不一定可以达到意想不到的效果。

总结
--

[![](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-488d8295779caeee1328b597789f0c24f3b2445d.png)](https://shs3.b.qianxin.com/attack_forum/2021/11/attach-488d8295779caeee1328b597789f0c24f3b2445d.png)  
通过以上的分析我们要能够学到什么？其实并不是说自己能够复现一遍就行，因为免杀只是暂时的，公布出来很快就会被列入指纹库，我们需要做的是要能够清楚的知道上面的免杀方式，能够将多种免杀思路进行结合，好比在 web 攻击中 cors+xss 打组合拳一样来提升危害，而免杀思路也是一样的，将这些排列组合，那么免杀的方式将非常多，在最后的一个免杀中，我还并未将所有的免杀方式进行融合，vt 免杀效果就为 0，要是将所有的融入呢？免杀效果又会怎么样呢？可以自己尝试。免杀也是一个不断尝试的过程，要敢于尝试。通过这篇文章希望你对其他语言进行免杀时也能够触类旁通。