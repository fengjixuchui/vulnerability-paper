<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/k6IZ3Tukd8IyjQgsmRpj4g)

基础知识
====

**用户帐户控制** (User Account Control) 是 Windows Vista（及更高版本操作系统）中一组新的基础结构技术，可以帮助阻止恶意程序（有时也称为 “恶意软件”）损坏系统，同时也可以帮助组织部署更易于管理的平台。

使用 UAC，应用程序和任务总是在非管理员帐户的安全上下文中运行，但管理员专门给系统授予管理员级别的访问权限时除外。UAC 会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改。

用户帐户控制 (UAC) 是**新版 Windows** 的核心安全功能，也是其最常被人误解的众多安全功能当中的一种。

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2Tb42uVEjJUwMSkIsl3huBwrchsyCyvEnQYs75ZvP54dxUDal7BGVibhw/640?wx_fmt=png)

而在这些程序里面，有的需要授权、有的不需要，是因为 UAC 是分授权等级的

首先请按 Win+R，输入 gpedit.msc，打开组策略。

然后我们在左侧窗口找到 “计算机配置–Windows 设置–安全设置–本地策略–安全选项”，再在右侧窗口找到 “用户帐户控制：管理员批准模式中管理员的提升权限提示的行为”，双击该条目，打开设置窗口，如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2Tvjgo4bYq9Ulcsyfl5LomB3EtT9C5sRFL4Uc6p011lNeGiaINGbcaiagQ/640?wx_fmt=png)

> 不提示直接提升：关闭 UAC，需要权限时直接提升权限。
> 
> 在安全桌面上提示凭据：需要权限时在安全桌面上输入管理员密码提升权限。
> 
> 在安全桌面上同意提示：需要权限时在安全桌面上选择 “允许” 提升权限。
> 
> 提示凭据：需要权限时在普通窗口中输入管理员密码提升权限。
> 
> 同意提示：需要权限时在普通窗口中选择 “允许” 提升权限。
> 
> 非 Windows 二进制文件的同意提示：(默认设置)当非 Microsoft 应用程序的某个操作需要提升权限时，选择 “允许” 提升权限。

因为普通应用执行权限有限，某些操作必然会要求更高的管理员权限。此时，通常就需要一个权限提升的操作。程序可以向系统请求提权，系统会将此请求通过提一个提示框，请用户确认。

如果当前用户的用户组权限不是管理员，提权操作是要求输入管理员密码的，这点和在 Linux 中的相应操作类似。

• 程序只能在运行前要求提权。如果已经在运行了，那么将失去申请提权的能力 • 权限提升仅对此次进程有效

提升权限的操作大致有两个：

• 自动提权请求 • 手动提权请求

手动提权就是 “以管理员身份运行”，自动提权请求就是程序本身就一运行就开始申请权限，如：注册表编辑器

在开发的过程中，程序员若要开发一个程序，可以在编译器配置，写入一个配置文件，用于向系统标识该应用程序是必须要管理员权限运行的。

**visual studio 里面的 uac**

在 visual studio 里面有一个 manifest 文件，这个文件本质上是一个 xml 文件，用于标识当前应用程序的配置属性。其中这几个级别明细如下

> •aslnvoker 默认权限 •highestAvailable 最高权限 •requireAdministrator 必须是管理员权限

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2Tia1MwgyxQC4vSoQr9riaqUL39OGmDPibibmibbCTMzzADDleq5XZaVrLB6A/640?wx_fmt=png)

将编译选项调整为 requireAdministrator，则当用户运行程序后，将获得管理员权限会话, 不需要绕过 UAC。

挖掘白名单的 uac 程序
=============

有一些系统程序是会直接获取管理员权限同时不弹出 UAC 弹窗，这类程序被称为白名单程序。这些程序拥有 autoElevate 属性的值为 True，会在启动时就静默提升权限。

那么我们要寻找的 uac 程序需要符合以下几个要求：

```
1. 程序的manifest标识的配置属性 autoElevate 为true2. 程序不弹出UAC弹窗3. 从注册表里查询Shell\Open\command键值对
```

首先是寻找 autoElevate 为 true 的程序，这里就写一个 py 脚本去批量跑一下，这里就找 system32 目录下面的

```
import os from subprocess import *  path = 'c:\windows\system32' files = os.listdir(path) print(files) def GetFileList(path, fileList):     newDir = path     if os.path.isfile(path):         if path[-4:] == '.exe':             fileList.append(path)     elif os.path.isdir(path):         try:             for s in os.listdir(path):                 newDir=os.path.join(path,s)                 GetFileList(newDir, fileList)         except Exception as e:             pass     return fileList files = GetFileList(path, []) print(files) for eachFile in files:     if eachFile[-4:] == '.exe':         command = r'.\sigcheck64.exe -m {} | findstr auto'.format(eachFile)         print(command)         p1 = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)         if '<autoElevate>true</autoElevate>' in p1.stdout.read().decode('gb2312'):             copy_command = r'copy {} .\success'.format(eachFile)             Popen(copy_command, shell=True, stdin=PIPE, stdout=PIPE)             print('[+] {}'.format(eachFile))             with open('success.txt', 'at') as f:                 f.writelines('{}\n'.format(eachFile))
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2Tht1UoicUk65ZN8MUZCTZfVbu7fWlZ6GOhxY7mcOXrpkbdWNVQQ2P7UQ/640?wx_fmt=png)

整理之后 exe 如下所示

```
c:\windows\system32\bthudtask.exe c:\windows\system32\changepk.exe c:\windows\system32\ComputerDefaults.exe c:\windows\system32\dccw.exe c:\windows\system32\dcomcnfg.exe c:\windows\system32\DeviceEject.exe c:\windows\system32\DeviceProperties.exe c:\windows\system32\djoin.exe c:\windows\system32\easinvoker.exe c:\windows\system32\EASPolicyManagerBrokerHost.exe c:\windows\system32\eudcedit.exe c:\windows\system32\eventvwr.exe c:\windows\system32\fodhelper.exe c:\windows\system32\fsquirt.exe c:\windows\system32\FXSUNATD.exe c:\windows\system32\immersivetpmvscmgrsvr.exe c:\windows\system32\iscsicli.exe c:\windows\system32\iscsicpl.exe c:\windows\system32\lpksetup.exe c:\windows\system32\MSchedExe.exe c:\windows\system32\msconfig.exe c:\windows\system32\msra.exe c:\windows\system32\MultiDigiMon.exe c:\windows\system32\newdev.exe c:\windows\system32\odbcad32.exe c:\windows\system32\PasswordOnWakeSettingFlyout.exe c:\windows\system32\pwcreator.exe c:\windows\system32\rdpshell.exe c:\windows\system32\recdisc.exe c:\windows\system32\rrinstaller.exe c:\windows\system32\shrpubw.exe c:\windows\system32\slui.exe c:\windows\system32\Sysprep\sysprep.exe c:\windows\system32\SystemPropertiesAdvanced.exe c:\windows\system32\SystemPropertiesComputerName.exe c:\windows\system32\SystemPropertiesDataExecutionPrevention.exe c:\windows\system32\SystemPropertiesHardware.exe c:\windows\system32\SystemPropertiesPerformance.exe c:\windows\system32\SystemPropertiesProtection.exe c:\windows\system32\SystemPropertiesRemote.exe c:\windows\system32\SystemSettingsAdminFlows.exe c:\windows\system32\SystemSettingsRemoveDevice.exe c:\windows\system32\Taskmgr.exe c:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exe c:\windows\system32\WindowsUpdateElevatedInstaller.exe c:\windows\system32\WSReset.exe c:\windows\system32\wusa.exe
```

然后再去寻找不弹 uac 框的程序，这里我就从上往下开始尝试，找到的是`ComputerDefaults.exe` 这个 exe

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TN9HDKDS7ZURLvibMOULUqg2PzJcJT89bmTialyoWEpkMONHickbFhDZHw/640?wx_fmt=png)

运行之后直接就会出现默认应用这个界面

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2T1fkTLd0Hg7kCmbb2ksQP0ib0qtkkibvHc1qXAbLabXNE8j0YrHQRdp0A/640?wx_fmt=png)

uac 程序特性探究
==========

通常以 shell\open\command 命名的键值对存储的是可执行文件的路径，如果 exe 程序运行的时候找到该键值对，就会运行该键值对的程序，而因为 exe 运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了 uac。所以我们把恶意的 exe 路径写入该键值对，那么就能够过 uac 执行我们的恶意 exe。

这里使用 proc 监听`ComputerDefaults.exe`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TibVFde6jPBw0vMUzfTK38WiaWPz3Xwz6h6ibxpTuY8AaUX4BcnRX7byYQ/640?wx_fmt=png)

发现他会去查询`HKCU\Software\Classes\ms-settings\Shell\Open\command`里面的值

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2Ts8AFl3ONibjHD3dek7re95CysG8KibWARqIH93uqjp02ANv8nrNDvbGw/640?wx_fmt=png)

那么我们创建一个`HKCU\Software\Classes\ms-settings\Shell\Open\command`路径，再对`ComputerDefaults.exe`进行监听尝试

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2ToxfHnWuPwx5Ls23vZLnpZsek5jmQ6guQKp7II2WNAHa5UxIx752NUA/640?wx_fmt=png)

然后发现他还会去查询`HKCU\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute`，而且 Result 显示的是 NAME NOT FOUND，那么可以认为首先去查询`HKCU\Software\Classes\ms-settings\Shell\Open\command`路径下的注册表，再去查询`HKCU\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute`是否存在

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TpqhYa7f3daibX8C2LibDOqx6ch5jHdXertqF2iadVEYh1ianLKHGyxryLQ/640?wx_fmt=png)

那么这里我创建一个 DelegateExecute 的键值对，然后把默认键值对指向我的一个程序进行尝试

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TEulcrXuqiaBTdUkk8QTEOrSbGMeaerFibTcaKcOrk6BavsicBxWTCic5fQ/640?wx_fmt=png)

当我运行`c:\windows\system32\ComputerDefaults.exe`的时候，发现不再弹出的是默认进程的界面，而是打开了我自己的程序

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TSdicMOdF4Xc6jmOVk0mpefSicqbxIkabwmXYqxbCibW71JcicTZ71z82cg/640?wx_fmt=png)

那么这里就可以大胆的猜测一下，首先运行`ComputerDefaults.exe`这个程序之前，会查询`HKCU:\Software\Classes\ms-settings\shell\open\command`这个目录是否存在，若存在继续寻找同目录下是否有`DelegateExecute`这个键值对，若两者都存在则执行`HKCU:\Software\Classes\ms-settings\shell\open\command`指向的 exe 路径

为了验证猜想，这里我将 exe 路径改为 cmd，若猜测成立则可以获得管理员权限的 cmd

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TTq0JNdJaibKf2PcspQqib4VFqO989NAM2HWWrvgicUKg7DfZIRsutFf0g/640?wx_fmt=png)

`whoami /priv`查看一下果然成功

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2T4kU2MGfsXJCm0MkglVrsWsENvLNADF758mT10tytl1Gj7nPORthAzA/640?wx_fmt=png)

bypass 的实现
==========

经过上面的探究过后，我们整理下思路，首先要创建注册表，并添加`DelegateExecute`这个键值对，并修改`command`的指向 exe 路径即可 bypassuac，那么这里用到一下几个函数

**RegCreateKeyExA**

首先是创建注册表项，对应的是之前创建`HKCU\Software\Classes\ms-settings\Shell\Open\command`这个路径的操作，这个路径默认情况下是不存在的

```
LSTATUS RegCreateKeyExA(  [in]            HKEY                        hKey,  [in]            LPCSTR                      lpSubKey,                  DWORD                       Reserved,  [in, optional]  LPSTR                       lpClass,  [in]            DWORD                       dwOptions,  [in]            REGSAM                      samDesired,  [in, optional]  const LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [out]           PHKEY                       phkResult,  [out, optional] LPDWORD                     lpdwDisposition);
```

> hkey: 句柄
> 
> lpSubKey: 此函数打开或创建的子项的名称
> 
> Reserved: 保留参数，必须为 0
> 
> lpClass: 该键的用户定义类类型。可以忽略此参数。此参数可以为 **NULL**
> 
> dwOptions: 有几个值，使用的时候具体查询
> 
> samDesired: 指定要创建的密钥的访问权限的掩码
> 
> lpSecurityAttributes: 指向 SECURITY_ATTRIBUTES 结构的指针
> 
> phkResult: 指向接收打开或创建的键的句柄的变量的指针
> 
> lpdwDisposition: 指向处置值变量的指针

**RegSetValueExA**

再就是修改注册表项，指向我们的恶意 exe 路径

```
LSTATUS RegSetValueExA(  [in]           HKEY       hKey,  [in, optional] LPCSTR     lpValueName,                 DWORD      Reserved,  [in]           DWORD      dwType,  [in]           const BYTE *lpData,  [in]           DWORD      cbData);
```

> hkey: 句柄
> 
> lpValueName: 要设置的值的名称
> 
> Reserved: 保留参数，必须为 0
> 
> dwType:lpData 参数指向的数据类型
> 
> lpData: 要存储的数据
> 
> cbData:lpData 参数指向的信息的大小，以字节为单位

**RegDeleteTreeA**

执行 exe 过后我们为了隐蔽最好是删除这个路径，那么就需要用到这个 api

```
LSTATUS RegDeleteTreeA(  [in]           HKEY   hKey,  [in, optional] LPCSTR lpSubKey);
```

> hkey: 句柄
> 
> lpSubKey: 密钥的名称

这里测试一下，先把路径写成 cmd.exe

```
char filePath[] = "C:\\Windows\\System32\\cmd.exe";
```

实现效果如下

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TrCEdxUIIjjQzoDImUXiblGzTfkRoSpyIpHHica6lthNmhibPxYrN1TROA/640?wx_fmt=gif)

这里 cmd 的实现成功了，那么直接使用 cs 的马上线能不能够直接 bypassuac 呢，实验一下，这里把路径改为 cs 马的路径

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2THefb1WoDnbfWV5mDa1e0AXrlLPQwIUbfPdXjZDNJ08J0DsxjcIHicJA/640?wx_fmt=png)

实现效果如下

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2T9gwFAhUS5Im8lJC98Hsr4M2TgjDetrQQsywNYrFkE5MNzic7d2rBpZA/640?wx_fmt=gif)

这里为了验证已经 bypass 了 uac，我后面手动自己点了一下 cs 的木马，第一个就是我们通过我们写的程序上线的，第二个就是直接点击上线的，看一下区别

仔细看的话这里 bypass 过的右上角有一个 *

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TkuvIp2F03y7O6GypolibziaOSwUW1ARBvibxe4IicRNia5SNpgJw4nmicoRw/640?wx_fmt=png)

首先看一下第一个对话

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2T0N9PyXcwK7UW3c4kOpeGwcys3lO8MA3abs5h2XcRzpMqB5vPnWltNw/640?wx_fmt=png)

再看下第二个对话，很明显这里已经 bypass 过了 uac

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TJ9XggrkiazibfxwfSWb8Fm4Mib7JKFOJmkZG2TbXurP3qhbVw4Qiaruia7w/640?wx_fmt=png)

思考
==

我们所使用的几个 api，如`RegCreateKeyExA`、`RegSetKeyExA`都是直接修改注册表的操作，这种操作应该被归类为敏感操作，那么这里会不会被杀软拦截呢，去测试一下

windows defender 正常上线

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2T7NibPcvYfZLUaBc99ibTtXFZH4sHPFpSgDZznBQUOQJtonWx6Ec5GpvQ/640?wx_fmt=png)

获取到的权限也是 bypassuac 后的权限

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TmuwuvdNfcyNXYiborKIOcavP6UCmxUjh2lrNxSngcGVlH9am1ztA5hw/640?wx_fmt=png)

再看一下 360，这里我试了两个方法，第一种方法是直接对`artifact.exe`做一下免杀，然后执行`bypassuac.exe`可以正常上线并 bypassuac，但是如果使用注入 shellcode 到其他的 exe 就不能够获得 uac 权限

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TDPyopOHF7qd4n1GUGXSIC9JEQkHZJuSqRAXUcOOPr7FD2fEnYEy8xg/640?wx_fmt=png)

如图所示，这里我思考了一下，因为如果注入 shellcode 到其他程序，注册表指向的还是这个注入 shellcode 到其他程序的 exe，所以后面那种方法是不能够 bypassuac 的

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9Vjuofv4AiauHyH7VyV2M2TaNmPHhYBiaUUQZOZwn26WvaBtYFx2jw3sE3bkp1ceP6UicomoRheHgvg/640?wx_fmt=png)

工具已经打包至 github：

https://github.com/Drunkmars/BypassUAC

切勿用于非法用途！

![](https://mmbiz.qpic.cn/mmbiz_png/ndicuTO22p6ibN1yF91ZicoggaJJZX3vQ77Vhx81O5GRyfuQoBRjpaUyLOErsSo8PwNYlT1XzZ6fbwQuXBRKf4j3Q/640?wx_fmt=png)

**推荐阅读**

[**干货 | HOOK 技术实战**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500704&idx=1&sn=03ddbc3756466ae79c367e464720f1e0&chksm=ec1c969fdb6b1f891f3742aa24c7124a7ff119671c3eb58aa1a99b718a52b49850562e048c69&scene=21#wechat_redirect)  

[**干货 | 免杀沙箱调试与反调试实战**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500664&idx=1&sn=0280597588368e0f7ee559c07135f1e1&chksm=ec1c9647db6b1f517a15fa769e684289281368f949dd6191cc3c78e6d57c842782623a83b299&scene=21#wechat_redirect)  

[**干货 | Certutil 在渗透中的利用和详解**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500599&idx=1&sn=7911b606612671a76e6e5d78ebc0a8d3&chksm=ec1c9608db6b1f1e43ab0060ed74225bfc5e2210a258082763de4a01a4db6cff0f1514d7c6b0&scene=21#wechat_redirect)  

[**干货 | DLL 注入常用的几种方式**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500596&idx=1&sn=aec77e5ee4347553cb395a616386ffa1&chksm=ec1c960bdb6b1f1d64827ce3c6464b3e81d7f2f88245e52bf7dea85ce712a24cbfec92df3d80&scene=21#wechat_redirect)  

[**实战 | DLL 劫持思路和研究**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500891&idx=1&sn=26efaa137118bb40bdf457a922edee26&chksm=ec1c9164db6b1872a9e2009f91784a64d8ad24cd38a59d4932d7115a55d5131d77ff3d4cef8f&scene=21#wechat_redirect)  

[**实战 | 通过 VEH 异常处理规避内存扫描实现免杀**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500909&idx=1&sn=d4092fd716364e15073cfc37f74cd89c&chksm=ec1c9152db6b1844c61d6a021dc86a9bde42e9c56649acddcc9ae2b9002fd9beb645d89104e1&scene=21#wechat_redirect)  

**点赞    在看    评论**

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8QfeuvouibQiaEkicNSzLStibHWxDSDpKeBqxDe6QMdr7M5ld84NFX0Q5HoNEedaMZeibI6cKE55jiaLMf9APuY0pA/640?wx_fmt=gif)