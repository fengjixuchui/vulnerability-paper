> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [nosec.org](https://nosec.org/home/detail/4952.html)

> 如今，从进程中删除 EDR 的钩子已经成为一种非常普及的技术：攻击者经常利用这种技术来规避反恶意软件。

前言  

-----

如今，从进程中删除 EDR 的钩子已经成为一种非常普及的技术：攻击者经常利用这种技术来规避反恶意软件。防御者曾试图对抗这些攻击，但最终都以失败告终，因为他们都将主要精力放在确保恶意可执行文件无法在端点上运行方面，比如白名单或其他访问控制技术。防御方期望通过这些技术与密集的日志记录相结合，来检测这些攻击，防止任何进一步的操作，从而斩断攻击链。  

不幸的是，攻击方会不断地通过发明新的方法来适应当前的防御机制。随着 EDR 产品开始使用 Windows 事件跟踪 (ETW) 来增强其检测能力，攻击方也开始篡改这些功能，以防止触发 ETW 事件。当涉及到规避访问控制时，攻击方通常依赖于可信的应用程序或无文件落地的攻击。这些类型的攻击一般难以阻止或检测，因为它们使用合法的应用程序来执行恶意操作。  

本文将讨论无文件落地攻击的有效性等主题，包括它们的用例。我们还将讨论 Ivy，这是一个新的 payload 创建框架，它利用 Microsoft 的 OfficeVBA 环境以编程方式从进程中解除 EDR 的钩子。然后，该框架会加载、解密和执行 shellcode，同时避免被基于签名的 VisualBasic 应用程序（VBA）宏攻击规则所发现。Ivy 技术都是基于 VBA 代码的无文件落地攻击（就像典型的 Office 宏 payload 一样），但是，这些攻击不会受到部署内置在 Office 产品中的 “禁用宏功能” 所制肘。在本文中，我们将详细讨论这些技术的内部工作原理，以及防御者应该如何检测这些类型的攻击。  

无文件的恶意软件  

-----------

所谓无文件的恶意软件技术，通常是指利用合法进程加载代码或脚本来执行恶意活动，如在法进程的内存中执行 shellcode。因此，我们在磁盘上几乎找不到它们的踪迹。如今，一些老辣的攻击者会经常使用这种类型的攻击，不仅是为了防止被反恶意软件（如 EDR）的发现，也是为了规避白名单机制等访问控制。  

无文件恶意软件最明显的例子是 PowerShell 脚本攻击。在很长一段时间内，这被攻击方用作在终端上执行恶意代码而不被发现，或防止在磁盘上留下踪迹的一种方式。这主要是由于 PowerShell 进程能够从远程位置将 PowerShell 脚本导入内存，例如通过 HTTP 请求从托管该脚本的网站完成加载。一旦加载，模块就能被调用，脚本将运行，并在该 PowerShell 进程的内存环境中执行恶意代码。  

![](https://nosec.org/avatar/uploads/attach/image/78a479002b45a0e877e044a746b1a622/1.jpg)

图 1：PowerShell 无文件落地型脚本投递示意图  

对于这种技术，另一个很好的例子是 Casey Smith（@subTee）的研究。Casey 的技术利用本地的 wmic.exe 二进制文件和样式表来执行内存中的 shellcode。这是通过将 vb sc ript 嵌入样式表（.xsl）来完成的，并且通过调用组件对象模型（COM）中的对象来执行相应的动作。该技术之所以成功，是因为 wmic.exe 中的多个命令行参数接受 “/format” 选项——该选项可以检索包含嵌入的 vb sc ript 代码的远程样式表，并将其加载到内存中。  

![](https://nosec.org/avatar/uploads/attach/image/236a0f20323c9e1408658906fafbdf17/1.jpg)

图 2：Calc.xsl 文件  

![](https://nosec.org/avatar/uploads/attach/image/7e918038d8b331e76add7dca0a8447dd/1.jpg)

图 3：基于内存攻击的 WMIC 启动了 Calc.exe  

通过与其他技术 (如 DotNetToJsc ript) 结合实现在内存中加载.Net 程序集，并将其反序列化以运行，可以更进一步提高该技术的威力。这些攻击主要特点是 “无文件落地的”，但当针对更高级的 EDR 产品 (如 MicrosoftDefender) 进行测试时，它们会提示存在 WMIC 样式表攻击。  

![](https://nosec.org/avatar/uploads/attach/image/c6b98b80e8849f8973782488e86fb3d6/1.jpg)

图 4：WMIC Web 缓存示例提交  

因此，这些攻击并不是真正的无文件落地型攻击，但由于它们的特性，通常很难被 EDR 检出并进行取证分析。为了成功发动攻击，他们需要利用端点上已经存在的组件。现在，让我们开始考察所有使用微软办公套件的公司都需要面对的一个东西：宏，它是用 VBA 编写的，并保存在启用宏的 Office 文档中。尽管它们通常是出于合法的原因创建的，如文档的自动化处理，但攻击者也可以创建相应的宏来获得访问权限或绕过其他安全控制。  

VBA 与更常见的脚本子集 vb sc ript(VBS) 有一点不同。VBS 可以创建小规模应用程序、自动化处理等，并且历史上一直用作独立的脚本，在基于 Office 的应用程序环境之外提供恶意软件。也就是说，VBA 和基于宏的 payload 并不是什么新鲜事物。  

宏的特征（或签名）  

------------

虽然用来执行基于宏的 payload 的方法五花八门，但它们大多都具有以下共同属性：  

1.     它们存在于支持宏的 Office 文档中
2.      这些文件必须在磁盘（而非在内存）中才能运行
3.      它们只能在 “启用宏的文档” 中执行
4.      为了在终端上执行操作，需要调用或加载 Office 以外的外部资源  
    

考虑到这些，使用一些常见的手段就可以很容易地检测并阻止它们执行，如 “禁用宏功能”，就可阻止所有宏在端点上执行，并且该功能可由管理员进行设置。虽然这种方法能防御基于宏文档的 payload，但对于使用 VBA 对象模型的恶意软件却无能为力：因为 Office 的 VBA 环境内的对象可以从外部资源中调用。  

Ivy 框架简介  

-----------

Ivy 是一个 payload 生成框架，可以直接在内存中执行任意的 VBA（宏）源代码。Ivy 的加载器通过利用 VBA 对象环境中的编程能力来加载、解密和执行 shellcode。这种技术尽可能地接近于真正的无文件攻击，因为大多数无文件落地型攻击需要将某种形式的文件 (如临时文件) 放在磁盘上，从而绕过了用于检测 VBA 代码的基于签名的标准规则。  

Ivy 提供了两种不同类型的加载器来执行这些操作。第一个是 Inject，它执行进程注入攻击，在挂起状态下产生一个新进程，并在进程恢复之前将 Shellcode 注入到该进程中。虽然注入攻击生成的是一个非 Excel 进程，但 EDR 非常善于检测为注入而创建并挂起的进程。  

第二个选项是 Thread，它直接将 shellcode 加载到当前的 Excel 进程中，在该进程中生成一个新的线程供 shellcode 运行之用。并且，这种加载方式还提供了额外的功能以避免被发现，具体来说就是直接调用某些 Windows 系统调用。这是由于 VBA 环境允许我们根据堆栈来定义和调用特定的函数（只要我们事先对齐了相应的寄存器）。最后，这种加载器还用了一个未公开的系统调用来执行 shellcode，这使得它很难检测出来。  

如果默认情况下禁用了宏，那么这种攻击仍然奏效吗？  

是的，Ivy 并不依赖于传统意义上的宏执行。为了执行 shellcode，我们需要以编程方式启用 “信任对 Microsoft Visual Basic for Applications （VBA）项目对象模型的访问”。这个选项允许 Office 应用程序以编程方式访问 Office 的 VBA 环境中的对象或代码。如果没有启用这个设置，未经授权的程序在建立可能危及终端的 “自我复制” 代码的时候会更加困难。因此，这种攻击不受微软 Office 中 “禁用所有宏” 选项的影响。由于没有系统管理权限的用户也可以修改它，这就意味着在端点上任意完整性级别下运行的所有用户进程都可以随意编辑这个值。  

![](https://nosec.org/avatar/uploads/attach/image/f743298bfba2a714c6d646cc94055698/1.jpg)

图 5：宏设置  

下面的代码块将为 Wsc ript.Shell 创建一个 COM 对象，以便访问 Windows 操作系统的 shell 功能。攻击者可以利用操作系统 shell 与 Windows 注册表互动。通过这种方式，加载器可以检查系统上安装的微软 Office 的版本，然后创建与 VBA 环境的可信访问相关的注册表键（或者修改该键，如果它已经存在但被设置为零的话）。这样一来，就可以对任何可以访问 VBA 的 Microsoft Office 产品都启用编程访问。  

```
var Shell = newActiveXob ject("Wsc ript.Shell");var strRegPath = "HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\<OfficeVersion>\\Office Application>\\Security\\Shell.RegWrite(strRegPath, 1,"REG_DWORD")
```

![](https://nosec.org/avatar/uploads/attach/image/e75934a4756ca3fe43035776ddb98be7/1.jpg) 

图 6：宏的安全设置——允许访问 VBA 对象模型  

几年前，微软发布了一个组策略，以帮助缓解 AccessVBOM 的程序性滥用。通过启用该组策略，该选项变得不可用（甚至本地管理权限也不能启用该设置）。这是微软防止恶意软件自我复制和执行恶意代码的方法。  

![](https://nosec.org/avatar/uploads/attach/image/dab509514b15edfcc833fddc4a965ef7/1.jpg)

图 7：禁止用户模式对 AccessVBOM 的访问  

但是，这并意味着无法激活该设置。通过使用另一个注册表项，我们可以启用 “信任对 VBA 项目对象模型的访问”，从而获得相同级别的访问权限。这是通过创建 “安全” 文件夹的方法来实现的：  

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Office\<OfficeVersion>\<Office Application name>\Security
```

虽然这种方法是有效的，但会收到一个警告。若要修改 HKEY_LOCAL_MACHINE 下注册表中的任何内容，进程需要提升权限。  

![](https://nosec.org/avatar/uploads/attach/image/ce7b4190e7e0a32ad42b8b629c99a651/1.jpg)

图 8：本地计算机注册表绕过技术  

一旦在端点上启用了 AccessVBOM，加载器就可以通过调用 “createob ject（Excel.Application）” 来创建 Office 进程的 COM 实例。其中，Excel.applicationCOM 对象表示整个 Excel 应用程序，并且表示自动化形式运行，并允许与它进行编程交互。Excel.Application 的另一个重要特性是，它显然是在服务宿主进程（svchost.exe）下而不是父进程下生成的。  

![](https://nosec.org/avatar/uploads/attach/image/95dfedb0f06e80250b51d7b3cae3382a/1.jpg)

图 9 通过 Svchost.exe 运行 Excel  

之后，加载器将生成一个隐藏的 Office 进程，并将加密的字符串加载到一个 VBA 函数。一旦进入内存，恶意代码就可以被执行了。这是通过使用 ActiveX 来模拟等效的 GUI 操作来完成的。ActiveX 为 Jsc ript 和 vb sc ript 等脚本引擎提供了支持，使它们能够与 Windows 或第三方应用程序互动。  

这就绕开了很多监控执行的传统防御措施。因此，解密函数和 shellcode 可以直接从一个内存缓冲区移动到另一个内存缓冲区，而无需在磁盘中落地。最后，加载器使用 command-GUI 调用并执行 run 函数，以模拟在 VBA 的 GUI 面板上点击运行宏按钮的行为。这就就会启动解密函数，并实际执行相应的 shellcode。  

使用 VBA 代码解除 EDR 的钩子  

----------------------

Ivy 不仅在端点上执行 shellcode 的方式非常新颖，同时，它还有另外一个独特之处，即从 Office VBA 对象环境中解除 EDR 的钩子。由于 EDR 依赖用户模式钩子的特性，任何有效的加载器都需要执行某种类型的 EDR 解钩处理。由于钩子存在于用户模式中并钩入我们的进程，所以，我们可以设法控制它们。而且，由于进程是在用户的上下文中运行的，所有加载到我们进程中的代码，我们都能通过这种方加以处理。值得注意的是，一些敏感的内存区域被设置为执行、读取（ER-）权限，而没有赋予写权限，这就阻止了对这些区域的修改。我们将介绍绕过这一限制的各种方法，但如果你很好奇，想了解更多关于解除用户空间的 EDR 钩子的信息，请参考相关文章（EndpointDetection and Response: How Hackers Have Evolved）或框架 ScareCrow（[https://github.com/optiv/ScareCrow](https://github.com/optiv/ScareCrow)）。  

虽然这些文章谈到了如何使用二进制代码和 DLL 来解钩和加载 shellcode，但 Ivy 却可以直接从它运行的进程中解除 EDR 的钩子，或使用 VBA 脚本引擎从另一个进程中解钩，并且所有操作都是在内存中完成的。这使得 Ivy 能够使用低级别的系统调用，如在 VBA 中声明它自己版本的 Windows 函数 WriteProcessMemory。  

除此之外，Ivy 还可以覆盖不可写的内存区域，而不需要调用任何改变内存属性的 API 函数。实际上，这是通过 WriteProcessMemory 函数完成的，该函数将内存区域的权限暂时改为可写的（也就是说，这要求我们具有足够的权限；别担心，我们的确拥有相应的权限，因为我们是这个进程的拥有者）。在写入相应的内容后，该函数将恢复内存区的原始权限，但是，它并不会调用 VirtualProtect 函数；相反，它自动调用相关的 Syscall（NtProtectVirtualMemory 函数）。  

因此，Ivy 不需要利用自定义 Syscall 来调用 NtWriteVirtualMemory 函数，因为 WriteProcessMemory 这个内置函数可以临时修改内存区域的访问属性。这已被微软列为一项功能，它能使调试器更加稳定。如果调试器想临时修改内存访问属性，那么，它们可以直接修改，而不必执行多个任务。(关于这个函数的更多信息，请参考微软的相关文章)。  

Ivy 不是重新加载被钩住的 DLL 的整个.text 部分，而是针对被钩住的特定 API 函数。通过审查和监测以前研究的 EDR 钩住的地方，Ivy 解除了众多系统加载的 DLL 中的特定 API 的钩子。从进程的角度来看，解除钩子的过程如下所示：  

*       Ivy 通过 VBA 中的声明功能和 WriteProcessMemory 所需的参数和参数类型，创建一个对 WriteProcessMemory API 函数的引用。这个函数调用 WriteProcessMemory 所在的确切内存地址。(它看起来像是对寄存器 RAX 的调用，而不是调用 kernel32.dll 库的 WriteProcessMemory 函数）。这意味着我们没有直接调用 WriteProcessMemory，但是仍然能够使用其所有的功能。  
    

![](https://nosec.org/avatar/uploads/attach/image/6a63742a370c4646a17f2431062efab9/1.jpg)  

图 10：在 VBA 中声明 WriteProcessMemory  

*      EDR 只会看到一串汇编代码，它们不匹配任何恶意指标，并指向一个内存地址。这个内存地址是一个函数的开始位置，但由于 ASLR 的缘故，这个函数地址是唯一的。所以，这里需要对每个函数都进行查询。
*       在执行写操作之前，系统调用 ZWQueryVirtualMemory 将被执行，以查看该内存区域的访问权限。如果这个内存没有被设置为可写，就会调用 NtProtectVirtualMemory 来修改相应的权限。
*       8 字节的汇编代码被写到特定的内存地址。NtProtectVirtualMemory 被再次调用以恢复原来的访问权限。这会导致汇编指令 jump call（即钩子）被删除，原始值被恢复为相应的 API。  
    

![](https://nosec.org/avatar/uploads/attach/image/3a12537e88f1286cc10c5b3ae60bf0f9/1.jpg)

图 11：被挂钩后的 Excel 进程  

![](https://nosec.org/avatar/uploads/attach/image/344eae04133453fc14eb1887ea849305/1.jpg)

图 12：解除钩子后的 Excel 进程  

Ivy 能够解除 EDR 产品可能钩住的各种 API。实际上，EDR 通常并不会只钩住 Ntdll.dll，所以，如果只是解除 Ntdll.dll 的钩子的话，EDR 仍能收到遥测数据——如果在同一链中存在其他用户模式的钩子，遥测数据仍会被发送到 EDR。  

例如，如果你解除了 Ntdll.dll 中的 NTAllocateVirtualMemory 的钩子，而 VirtualAllocate（位于 Kernelba se.dll 中）也被钩住了，这时，前者为了获得所需的数据，仍然需要调用后者，这意味着任何通过 VirtualAllocate 的东西仍然被 EDR 读取。一旦所有的 EDR 钩子都被清除掉，加载器就会执行正常的动作来执行 shellcode。根据选择的是 Thread 还是 Inject 方法，Ivy 将使用一个特定的函数来分配内存空间，然后再次使用 WriteProcessMemory 将 shellcode 复制到内存中，最后通过相应的 API 将执行控制权转移给 shellcode。  

![](https://nosec.org/avatar/uploads/attach/image/922c48f1e91e6e0e4ac27a1a6bca8543/1.jpg)

图 13：建立远程连接  

这些技术已经按照相应的流程负责任地披露给微软安全响应中心。微软审查了我们所提供的信息，认为目前的安全控制措施足以防御这些技术。因此，我们提供了初步的防御性控制，以检测这些技术的可利用性。  

OpSec 注意事项  

-------------

Ivy 高度依赖于微软 Office 套件，这使得在没有安装 Office 的系统（如服务器）上，这个框架是难以奏效的。  

使用 Ivy 生成文件时，您需要同时输入 64 位和 32 位的 shellcode。这是因为：虽然操作系统可能是 64 位的，但正在运行的 Office 版本实际上可能是 32 位的。因此，Ivy 在加载 payload 之前需要检测要使用哪种架构。  

防御措施  

-------

目前，Ivy 依赖于将注册表项 AccessVBOM 设置为 “1”。如果没有这个设置，Ivy 大部分情况下都会失败。Ivy 尝试在执行时将正确的值写入（或创建）注册表项。默认情况下，注册表项 AccessVBOM 被设置为 “0”（如果存在的话）。由于对于大多数进程而言，正常的执行过程无需访问这个注册表项，因此，通过检测对它的修改，可以有效发现野外类似 Ivy 这样的进程。  

例如，以下 EDR 搜索将显示 Ivy 执行情况：  

```
CarbonBlack:“(regmod_name:*\\Security\\AccessVBOM)” CrowdStrike: “RegValue*\\Security"
```

对该事件发出警报（或阻止）可能有助于降低在环境中执行 Ivy 的风险。当然，只有在 AccessVBOM 注册表项通常设置为 “0” 时，这才会起作用，所以建议将警报与上述的组策略修复结合起来。需要注意的是，可能存在启用 AccessVBOM 的正常业务案例，并且应该对这些业务操作进行审查，以确保不会产生错误或误报。  

如果在一个环境中怀疑存在类似 Ivy 的攻击活动，那么检查 AccessVBOM 注册表项设置是否正确也是一个很好的做法。目前，Ivy 的 EDR 脱钩过程发生在 AccessVBOM 修改之后，但是可以进行相应的改动，使 EDR 脱钩发生在注册表修改之前。如果对 AccessVBOM 注册表项的定期检查时发现，当环境的其余部分被策略设置为 “0”，但是系统的设置为 “1”，则需要进一步进行检查。  

除了直接检测 Ivy 的执行情况外，更重要的是要考虑该工具的使用环境，因为它只是整个链条中的一个环节。像其他通常以用户工作站为目标的恶意软件 payload 一样，Ivy 的代码可以通过多种不同的逻辑文件格式进行传递，而不仅限于文件附件。例如，在使用这个工具之前，会有一些初始访问技术，如通过鱼叉式网络钓鱼向用户投递武器化的文件，或可能通过 PowerShell 命令从远程主机下载代码。因此，通过额外的系统加固措施来限制脚本的使用，或者通过 AppLocker 或 Windows Defender 等防御软件，可以进一步增强对代码执行的预防控制。  

这些项目都可以在 GitHub（[https://github.com/optiv/Ivy](https://github.com/optiv/Ivy)）上找到。  

```
本文由secM整理并翻译，不代表白帽汇任何观点和立场
原文地址：https://www.optiv.com/insights/source-zero/blog/defeating-edrs-office-products
```