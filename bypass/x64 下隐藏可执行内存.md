<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/t3rAe92g97C13YzFqpOi0w)

******点击****蓝****字 / 关注我们******

前言
==

我们如果想要实现进程隐藏在 3 环通常会使用到 PEB 断链去达到隐藏进程的效果，但是那只是表面上的进程隐藏，所有内存的详细信息都会被储存在 vad 树里面，这里我们就来探究在 64 位下如何隐藏可执行内存

vad
===

VAD 是管理虚拟内存的，每一个进程有自己单独的一个 VAD 树，使用`VirtualAlloc`申请一个内存，则会在 VAD 树上增加一个结点，其是`_MMVAD`结构体

```
dt _MMVAD
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJOBNvdcrvfynoSYg7rV4PoTF707EziaRaT19nibRyW5Z1hdyPTGwPIm3w/640?wx_fmt=png)image-20220329154007738.png

这里找一个进程，因为是根节点所以没有父节点

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJTtbicb8twtYJOq45ib1vyyPZfGDbYdVFURHR80usSIozw2vcy5iaFxbAw/640?wx_fmt=png)image-20220329154131189.png

然后往左遍历二叉树，在下一个节点处的父节点指向了上一个二叉树

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJktpYD1PjN4QgQWqqInCv0jul4DtNQ7KQEY5pD2iaAiabK50Jahnblr0w/640?wx_fmt=png)image-20220329154230061.png

注意`StartingVpn`和`EndingVpn`这两个结构，描述了当前页的位置，以 4kb 为单位，即 0x400000 到 0x488000 这一块内存空间已经被占用了

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJcwSUjR5nQIeh2H3cADEHJlq89XiaYkySYKSdDsYuvMqJzO1lmGl7l6Q/640?wx_fmt=png)image-20220329154654585.png

在 0x18 有一个`ControlArea`结构，描述了这块结构体到底被谁占用，这里跟进去看 0x24 有一个`FilePointer`结构，如果这里的值为 0 就是一个真正的物理页，如果有值继续往里面找

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJb9WSWEr9VWjxvc52pvia6aWXDjP7j335ibKibawh00LYqNPyTnAnIPGLg/640?wx_fmt=png)image-20220329155005328.png

这里对应了`Dbgview.exe`

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJTKZEeLGgWzABDVbUVeqqic9bznVVautJQJF3CTFwjw9N1hh7oAtueyA/640?wx_fmt=png)image-20220329155328329.png

在操作系统里面分配的内存只可能有两种类型，一种是`VirtualAlloc`自己分配的内存，一种是文件映射使用`CreateFileMapping`的内存，当`ControlArea`的`FilePointer`值为空的时候则是我们自己用`VirtualAlloc`分配的内存，还没有对应，如果值不为空则是文件映射的内存

分页机制
====

在 32 位里面有`2-9-9-12`、`10-10-12`两种分页模式，而在 64 位下只有一种分页模式，即`9-9-9-9-12`分页模式

随着计算机技术的发展，64 位系统逐渐占据主流地位，那么也就表示 CPU 的最大寻址范围为 64 位。但实际上，CPU 只使用了其中的 48 位用于寻址，并使用`9-9-9-9-12`分页模式。即便如此，在未来较长一段时间里，48 位寻址范围也足够大部分人的日常使用了

`9-9-9-9-12`分页表示物理地址拥有四级页表，在 Intel 开发手册中，将这四级页表分别称为`PML4E`、`PDPTE`、`PDE`、`PTE`，但微软的命名方式略有不同，将这四级页表分别称为`PXE`、`PPE`、`PDE`、`PTE`，`WinDbg`中也是如此

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJzByooXW7sxpDjfNgGwNqRO02NYrLyUrQFpzRhtPysvXOibcDFZHm6KA/640?wx_fmt=png)image-20220504165636253.png

启用分页模式条件：`cr0.PG = 1` 且 `cr0.PE = 1`

根据不同 CPU 架构及特性主要分为三种模式，处于哪种模式视寄存器属性不同：

*   • 32-bit paging(32 位 OS): `cr0.PG = 1` 、 `cr4.PAE = 0`
    
*   • PAE paging(32 位 OS 且开启了 PAE): `cr0.PG = 1` 、 `cr4.PAE = 1` 、 `IA32_EFER.LME = 0`
    
*   • IA-32e paging(64 位 OS): `cr0.PG = 1` 、 `cr4.PAE = 1` 、 `IA32_EFER.LME = 1`
    

**需要注意的是**：

1.  1. 32bit 下，每个 entry（表项）是 4 字节大小；而在 PAE 和 IA-32e 下，每个 entry 是 8 字节大小
    
2.  2. 在 x64 体系中只实现了 48 位的`virtual address`，高 16 位被用作符号扩展，这高 16 位要么全是 0，要么全是 1。所以在讨论 64bit 地址的时候，高 16 位不使用
    

我们主要研究的是`IA-32e`模式下的内存，这里`IA-32e`提供了三种页转换模型：

*   • 4k：PML4t,PDPT,PDT 和 PT
    
*   • 2M：PML4T，PDPT 和 PDT
    
*   • 1G：PML4T 和 PDPT
    

在 4kb 小页的情况下，64 位可以拆分为一下几段，即 9-9-9-9-9-12 分页

> sign extended -- 符号扩展位 --- 在线性地址 48~63bit 
> 
> PML4 entry -- 在线性地址 39～47bit 用于索引 PML4 entry，指向 PDP 
> 
> PDP entry -- 在线性地址的 30～38bit 用来索引 PDP entry，指向 PDE 
> 
> PDE entry -- 在线性地址的 21～29bit 用来索引 PDEentry，指向 PTE 
> 
> PTE entry -- 在线性地址的 12～20bit 用来索引 PTE entry，指向 page offset
> 
> page offse t -- 在线性地址的 0～11bit 提供在页中的 offset

这里我们手动去找一下，前 3 位为符号扩展位，直接去掉

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJRXY9dE1DohcwSC5Ow582FXwQqXuNW8gpWVF9kFWOd6ssVUWQ3SEzBA/640?wx_fmt=png)image-20220420103031572.png

可以看到`PXE`、`PPE`、`PDE`、`PTE`都是能够对应上的

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJdUa49LFicPr2lb6eibzCw6z5faYPebrvqy9bG6eH6FhZKyAe5o9QzufA/640?wx_fmt=png)image-20220420103147049.png

页表基址
====

*   • 一个进程该如何访问自己的物理页呢？可以通过读取 Cr3 的值进行访问吗？
    

答案是不行，Cr3 中保存的页表基址是物理地址，程序如果直接访问这个地址，虽然看上去值是一样的，但实际上访问的是一个线性地址，会被虚拟内存管理器解析成另一个地址

实际上，操作系统会将当前进程的物理页映射在某个线性地址中，以供程序读取自己的页表内容

在 x86 系统中，页表基址是固定的，位于`0xC0000000`，将这个线性地址进行解析，访问其物理页的内容，会发现从这个地址开始，里面保存的数据为当前程序的所有物理页地址

而在 x64 系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的可以在 WinDbg 中查看 0 地址对应的线性地址来确定当前的页表基址

可以看到，当前系统的页表基址的线性地址为`0xFFFFF38000000000`，注意，只有后 48 位才是有效地址

其中，每个物理页占 8 个字节，例如，第一个物理页地址位于线性地址`0xFFFFF38000000000`，第二个物理页地址位于线性地址`0xFFFF800000000008`，每个物理页中包含 1024 个字节的数据

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJlcxrQ4fbOCIHrGwYLv7aCricJT7EX1tJtkFF7OlxGVNZDNgevriaibpIg/640?wx_fmt=png)image-20220419212509051.png

MiIsAddressValid
================

我们在这里初步了解了 windows 的内存管理，那么这里我们去看一下 windows 是如何实现分页机制的，这里使用到`MiIsAddressValid`这个 API

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJCfwhbmuvJPU7skyq1VCg9KpT7NumBkcibXrDoAjEIAC1agORTgAujdw/640?wx_fmt=png)image-20220504170429995.png

我们首先看一下 win7 下`MiIsAddressValid`的实现

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJE6uLkucUgrgpklVvXWjfBgmfjvKuUnPeLdSTKQotzricicp3Rn8PiavOQ/640?wx_fmt=png)image-20220504171516062.png

`shr eax, 14h`和`and eax, 0FFC`相当于 eax 右移 16 位再乘以 4，然后判断`PS`位是否为 0，如果为 0 则不合法，则将 al 清零

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ6aBXxXjGR4EibBtk0t30krBPGWibkfOgr2nDz172UwmTJH85CYsgwv5A/640?wx_fmt=png)image-20220504204400160.png

在 64 位下，存在三种不同大小的页面，分别为大页、中页、小页。其大小分别为 1GB、2MB、4KB。这里判断`al`不等于 0 则继续向下执行，这里`jns`是通过判断`SF=0`，如果`SF=0`成立则跳转

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJPZJT1cHN8npiaHvMDlibVTTqXKiagHn3Y9LOsGuMUdCiaFib0XJEeR4UY8Q/640?wx_fmt=png)image-20220504205545977.png

这里仍然后一个右移的操作，是为了将段选择子分为`9-9-9-9-12`五部分，然后判断 P 位是否有效和`PAT`是否为 1

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJn1YrYUIS29bWDjjKBrPIDKicdhrswdwWUfzjeIIqy9m0TdaeEzXhwvQ/640?wx_fmt=png)image-20220504205653192.png

这里其实看伪代码逻辑会更清晰一点，我们可以可以发现通过一系列的移位操作得到对应的`PXE`、`PPE`、`PDE`、`PTE`并判断 P 位验证是否有效

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJe3N1ibxtJ4Cdo0Z23icfB9nDZsOp2KSWY6RwooKkTQz2JzgWp8mxKTeg/640?wx_fmt=png)image-20220504210754899.png

那么这里我们就可以通过减去的数值取反，然后加 1 即可得到对应基址，通过计算得到 win7 64 位下的`PTE_Base = fffff68000000000`

我们再去看一下 win10 下的`MiIsAddressValid`函数

```
.text:00000001400AD930 _MmIsAddressValid proc near             .text:000000014000FB6E
.text:00000001400AD930                                         
.text:00000001400AD930                 mov     rax, rcx
.text:00000001400AD933                 sar     rax, 48                               
                                                 ;取得线性地址的   高16位
.text:00000001400AD937                 inc     rax
.text:00000001400AD93A                 cmp     rax, 1
.text:00000001400AD93E                 ja      loc_1400AD9D3   
                                 ; 高16位要么全0, 要么全1 ，加一后大于1则不合法，直接返回false
.text:00000001400AD944                 mov     rax, rcx
.text:00000001400AD947                 mov     rdx, 0FFFFF6FB7DBED000h
                                                     ; PML4T 的虚拟地址
.text:00000001400AD951                 shr     rax, 39        
                                                   ; 将虚拟地址右移39位
.text:00000001400AD955                 and     eax, 1FFh      
                                                   ; 拿到pml4数组的下标
.text:00000001400AD95A                 test    byte ptr [rdx+rax*8], 1
                                                 ; 检测PML4T项p位
.text:00000001400AD95E                 jz      short loc_1400AD9D3
                                                  ; p=0 则直接返回false
.text:00000001400AD960                 mov     rax, rcx
.text:00000001400AD963                 mov     rdx, 0FFFFF6FB7DA00000h
.text:00000001400AD96D                 shr     rax, 27         
                                                ; 右移30位 ，再 乘 8 ,相当于右移27位
.text:00000001400AD971                 and     eax, 1FFFF8h   
                                                ; 8字节对齐 得到PDPT的偏移
.text:00000001400AD976                test    byte ptr [rax+rdx], 1
                                               ; 检测PDPT项的p位 rax+rdx=PDPT的首地址
.text:00000001400AD97A                jz      short loc_1400AD9D3
.text:00000001400AD97C                 mov     rdx, -0FFFFF6FB40000000h
.text:00000001400AD986                 mov     rax, rcx
.text:00000001400AD989                 shr     rax, 18        
                                                  ; 右移21位，再乘8 ,相当于右移18位
.text:00000001400AD98D                 and     eax, 3FFFFFF8h       
                                                   ;得到PDT的偏移
.text:00000001400AD992                 sub     rax, rdx      
                                                 ; rax = rax + 0FFFFF6FB40000000h  
.text:00000001400AD995                 mov     rdx, [rax]               
                                                ;此时rax指向PDT中的 某一项
.text:00000001400AD998                 test    dl, 1         
                                                  ; 检测PDT项p位
.text:00000001400AD99B                 jz      short loc_1400AD9D3
.text:00000001400AD99D                 test    dl, dl
.text:00000001400AD99F                 js      short loc_1400AD9D6
                                                     ; 是否开启PSE,是的话直接返回真
.text:00000001400AD9A1                 shr     rcx, 9         
                                                    ; 右移12位,再乘 8 ,相当于右移9位
.text:00000001400AD9A5                 mov     rax, 7FFFFFFFF8h ; 8字节对齐
.text:00000001400AD9AF                 and     rcx, rax               
.text:00000001400AD9B2                 mov     rax, -0FFFFF68000000000h
.text:00000001400AD9BC                 sub     rcx, rax
.text:00000001400AD9BF                 mov     rax, [rcx]       
                                                   ;此时RCX指向PT的的某一项
.text:00000001400AD9C2                 test    al, 1
.text:00000001400AD9C4                 jz      short loc_1400AD9D3
                                                   ; 检测PT项的P位
.text:00000001400AD9C6                 mov     r8b, 80h
.text:00000001400AD9C9                 and     al, r8b
.text:00000001400AD9CC                 cmp     al, r8b
.text:00000001400AD9CF                 setnz   al            
                                                  ; 检测PT项的PAT位是否存在，不存在返回真
.text:00000001400AD9D2                 retn
.text:00000001400AD9D3 ; ---------------------------------------------------------------------------
.text:00000001400AD9D3
.text:00000001400AD9D3 loc_1400AD9D3:                          
.text:00000001400AD9D3                                         
.text:00000001400AD9D3                 xor     al, al
.text:00000001400AD9D5                 retn
.text:00000001400AD9D6 ; ---------------------------------------------------------------------------
.text:00000001400AD9D6
.text:00000001400AD9D6 loc_1400AD9D6:                         _
.text:00000001400AD9D6                 mov     al, 1
.text:00000001400AD9D8                 retn
.text:00000001400AD9D8 _MmIsAddressValid endp
```

在 win10 `1607`版本以后，微软更改了策略，将页目录基址更改为了随机地址，那么我们之前在 win7 里面直接定位`PTE_Base`的方法就不可用，那么我们就可以使用提取特征码的方式去定位内核模块的地址

首先在 WinDbg 中定位内核模块的地址

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJM4MWTGgRcLtHEPSnT4gpQ9fDXH1ry7VWcu3lGWZAaiaQcYjibfND010A/640?wx_fmt=png)image-20220420102547386.png

然后在内核模块中搜索与当前页表基址相同的值出现的位置，当前页表基址为`0xFFFF800000000000`

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJT3qP99ryL3YDwYK87C17hVOia7zYPYr60CnAQ9GKB1iaQ0m8bDLq7YWw/640?wx_fmt=png)image-20220420102559314.png

接着，在 IDA 中定位到数据所在的位置，可以看到是某行代码引用了这个值的硬编码

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJNC2RzAzB7fLTDRn09riclbT0zSmy5WydMSvyVx1yJ7HomIuV9cpWEdg/640?wx_fmt=png)image-20220420102611892.png

在 WinDbg 中查看这段代码，能够识别到位于`CcUnpinFileDataEx`函数。那么，由于系统每次启动时基址是不固定的，因此这些值也不可能是固定的硬编码，肯定对这些值进行了修改，在需要使用时，可以通过固定的偏移量提取硬编码，从而得到页表基址，但要注意不同版本的内核文件的偏移量可能是不同的

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJlTCNNJds8jRECqAK04qF5iamBNgvWGq10wZr4Kk8nNCZd4I9tDicg1dA/640?wx_fmt=png)image-20220420102628929.png

代码实现
====

那么这里我们首先编写 4 个函数分别定位`PTE`、`PDE`、`PPE`、`PXE`，这里`g_PTE_BASE`就分为两种情况

```
PULONG64 GetPteAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 12) << 3) + g_PTE_BASE);
}

PULONG64 GetPdeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 21) << 3) + g_PDE_BASE);
}

PULONG64 GetPpeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 30) << 3) + g_PPE_BASE);
}

PULONG64 GetPxeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 39) << 3) + g_PXE_BASE);
}
```

当系统为 win7 或者 win10 `1607`以下版本的时候就可以直接将`g_PTE_BASE`定义成固定的地址

```
    if (versionNumber == 7600 || versionNumber < 14393)
    {
        g_PTE_BASE = 0xFFFFF68000000000ull;
        return g_PTE_BASE;
    }
```

如果为 win10 `1607`以上的版本就需要自己通过逆向的方式提取硬编码进行定位，这里我通过`MmGetVirtualForPhysical`函数加偏移的方式进行定位

```
        UNICODE_STRING Name = { 0 };
        RtlInitUnicodeString(&Name, L"MmGetVirtualForPhysical");
        PUCHAR func = (PUCHAR)MmGetSystemRoutineAddress(&unName);
        pte_base = *(PULONG64)(func + 0x22);
        return pte_base;
```

那么这里要得到系统版本，就需要用到`RtlGetVersion`进行判断，这里注意，在 win7 以后如果直接使用`GetVersion`会失败，必须调用更底层的`RtlGetVersion`才能得到具体的版本

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJgIiaOdHIAGoicvgGoOAH8Jq3sUmzp6v8X4DTvxZ3yVyxaksVEDN87tRw/640?wx_fmt=png)image-20220504214628464.png

```
NTSTATUS status = RtlGetVersion(&version);
```

这里我们明确一下思路，我们想要隐藏可执行内存，那么就可以首先申请一块可读可写的内存，然后通过修改 PXE 的最高位为 0 即可达到可执行的效果

例如下面的程序，PXE 的最高位为 8，则内存是没有可执行权限的

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ7L0KGBsDWJH0pKNiboMlBx1fO4a5IZ0SAhXPBoxPhNLNf7cQVAbPVdw/640?wx_fmt=png)image-20220424202559150.png

那么这里我们找到目标进程，然后通过`KeStackAttachProcess`函数实现进程挂靠，即把自己的 cr3 换成目标进程的 cr3

```
    NTSTATUS status = PsLookupProcessByProcessId(pid, &Process);
    KAPC_STATE kapc_state = { 0 };
    KeStackAttachProcess(Process, &kapc_state);
```

我们将 cr3 切换为目标进程的 cr3 之后就可以使用`ZwAllocateVirtualMemory`先分配一块可读可写的内存

```
status = ZwAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &size, MEM_COMMIT, PAGE_READWRITE);
```

通过`RtlMoveMemory`写入 shellcode 并修改内存为可执行权限，这里我们直接定位到 pte 和 pde 修改即可将 pxe 的最高位置 0

首先将前 3 位符号位去掉得到内存的起始地址和结束地址

```
    ULONG64 startAddress = VirtualAddress & (~0xFFF); 
    ULONG64 endAddress = (VirtualAddress + size) & (~0xFFF); 
```

这里写一个循环判断，必须每一块内存都需要修改

```
for (ULONG64 i = startAddress; i <= endAddress; i += PAGE_SIZE)
```

结合`MmIsAddressValid`并判断`valid`是否为 1，这里如果`valid`为 0 则该块内存无效，然后将`no_execute`置 0 即可获得可执行权限

```
PHardwarePte pde = GetPdeAddress(i);
PHardwarePte pte = GetPdeAddress(i);

if (MmIsAddressValid(pde) && pde->valid == 1)
{
    pde->no_execute = 0;
    pde->write = 1;
}

if (MmIsAddressValid(pte) && pte->valid == 1)
{
    pte->no_execute = 0;
    pte->write = 1;
}
```

那么这里我们调用`SetExecute`函数将我们之前分配的可读可写内存修改为可读可写可执行权限

```
SetExecute(BaseAddress, size);
```

然后使用`KeUnstackDetachProcess`还原 cr3

```
KeUnstackDetachProcess(&kapc_state);
```

实现效果
====

在 64 位下`VadRoot`位于`EPROCESS`结构体的`7d8`偏移处

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ6Npbu9ibmaloYXAibicfwUjgy234exia5Dia6hFzNx6EGKtfQV0uzpeEOkw/640?wx_fmt=png)image-20220504221446105.png

起一个`notepad.exe`进程定位到`vad`树

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJl3ucS8WQmpGqHqlKzfda3eGAjJNmibZ4eud7ib7CgZ5SiafxLLxm3tmxg/640?wx_fmt=png)image-20220504221800112.png

然后这里可以看到有 97 块内存

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJRQQr5PiaWeQpGCqqHbf6pwiaql8B3G5qN4WdVv2qm38nf2IryxzxJrFg/640?wx_fmt=png)image-20220504221852378.png

我们加载一下驱动，可以看到修改了`pte`的值，将最高位的 8 改为了 0，分配的这块内存地址为`222F5EB0000`

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ0NKicjpFOYkoibGibEEOwhpbGtg95KUGrySadIenm72d3iaVPkB0ETwTtw/640?wx_fmt=png)image-20220504223225749.png

我们看下没有加载驱动之前 vad 树里面是没有这块内存的

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJxsuwBqhApohJic6b3OMenOYWsUWteRwtMDWcEAmujuKjQI0e0WLVsGg/640?wx_fmt=png)image-20220504223334000.png

加载驱动之后可以看到这是一块`READWRITE`内存

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ8b7yuetG8tYQhFQibIoGV300z1bAk4rBoftdgtUy41aZe3CKx0xmnKg/640?wx_fmt=png)image-20220504223354777.png

这里定位到地址可以看到 shellcode 执行成功，证明这块内存已经修改为可执行内存，但是在 vad 树里面仍然显示为可读可写内存

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3IbzbMKayicKSW7Obc16kjJ4x1AfGgz1kawmVbDoTnRPic4yRE6ryupicP1FfHLxTFKqgcslkxWUB0Q/640?wx_fmt=png)image-20220504223943911.png

**推荐阅读：**

[Shiro 历史漏洞分析](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247489093&idx=1&sn=a152d824764fcb8736affbd3ef8b9e5e&chksm=c17107d4f6068ec247834014d3d1b8d30cdad5bbc9f01be1a7f433186f6fdfbf2b86885f4cf0&scene=21#wechat_redirect)

[浅谈 pyd 文件逆向](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247488872&idx=1&sn=6f9049e42e19ff4a04e172750c62e479&chksm=c17104f9f6068deff8184a99c1226d7cf390bdbb87d32e2f8dc4ff05dc5208ad28e19f872a8e&scene=21#wechat_redirect)

[CVE-2022-23222 漏洞及利用分析](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247488478&idx=1&sn=5eec4a19c6d838dd1dcdc76bd56cd91c&chksm=c171024ff6068b59177daed4601bc84714d2cff52a712ef243fafae08edf42c28af8c261d0a2&scene=21#wechat_redirect)  

[Mimikatz 详细使用总结](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247488474&idx=1&sn=3b943fbe21016467df3558278029023d&chksm=c171024bf6068b5d32ac4d4e4f4472b16519a099b3bb3d14dcd6a63c78eb424bfc2097b5c929&scene=21#wechat_redirect)

[CobaltStrike Malleable PE](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247490699&idx=1&sn=de3bfe5754ccab8a0f4ad8b1de9a9a9a&chksm=c1710d1af606840ce818a94a0998815c388a4371ac5751efec685a4203287c04d575e8c71686&scene=21#wechat_redirect)  

跳跳糖是一个安全社区，旨在为安全人员提供一个能让思维跳跃起来的交流平台。

跳跳糖持续向广大安全从业者征集高质量技术文章，可以是漏洞分析，事件分析，渗透技巧，安全工具等等。

通过审核且发布将予以 500RMB-1000RMB 不等的奖励，具体文章要求可以查看 “投稿须知”。

阅读更多原创技术文章，戳 “阅读全文”

加下方 wx。拉你一起进群学习

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibZ6uZjjH3v4WZgYJeibL4XoXol2MibfTeNPUTuUmqkgMFFf3icptn2CEN5kJEOOPWMg7STl235fSLQMgQ8GuSmWSg/640?wx_fmt=jpeg)

往期推荐

[

Demo 版菜刀



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501693&idx=1&sn=418ba0866f99fa7e03e402444c9ad15d&chksm=ce677dc1f910f4d7fb73c5e079ed60b6c7967c7b9ec1d03d04e133d8ac384b6f9524f0614d4c&scene=21#wechat_redirect)

[

浅谈 EDR 绕过



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501111&idx=1&sn=feee7191c9abe3845e032baf17316198&chksm=ce677f8bf910f69d98e260afec8ee2e765055a6558bc9f7ddb20467fbccdc89a3c5b505dc25c&scene=21#wechat_redirect)

[

tomcat 原理刨析之手写 tomcat



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501070&idx=1&sn=1d0036241200590d3bda901f0607fdfa&chksm=ce677fb2f910f6a4f0e01452d9aad1a7336b463c5114848c41f2a74188d2e34f3a84ca93023d&scene=21#wechat_redirect)

[

ETW 的攻与防



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501025&idx=1&sn=83fab640dab00a504a8a983a46697651&chksm=ce677e5df910f74be805ff3f1a116901d295d83627ea40a023d1165a2c663731757c6ffc7d2c&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（四）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501017&idx=1&sn=aa602658159907822f7c59c85c427576&chksm=ce677e65f910f773422d910e57e8fa4cb2f0278b88319945839cd8f3a2262c6dc264e7767dcd&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（三）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500845&idx=1&sn=73e9a559ce1c1d48b6895d87cfcda078&chksm=ce677e91f910f787c4c8c403dfb3e23027bb379e47053a1b3f489d8487d86b75f7dd6286fa05&scene=21#wechat_redirect)

[

记一次内部红队渗透——定位张三



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500656&idx=1&sn=654bbdcc1f6c5da944740c3519c3fc5a&chksm=ce6779ccf910f0daddbcbe77b77a0f44a2450dbd82f5e1c4269c311fe29858e76399ea625102&scene=21#wechat_redirect)

[对抗无落地的 shellcode 注入](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500063&idx=1&sn=911e115c9c99ea88a582a947737a0cc1&chksm=ce677ba3f910f2b51cce3135c7fa709067498098e9d4b2de5f8df66f8760853d8ce8b74ea978&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)