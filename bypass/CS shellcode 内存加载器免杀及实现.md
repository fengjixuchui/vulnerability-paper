> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ljsObduEueFRAnAIrTVIDA)

> 相关代码以及免杀项目实现:  
> https://github.com/crisprss/Shellcode_Memory_Loader

0x01. 前言
--------

前段时间看到小刚师傅的文章分享了几个加载器的相关实现, 本篇文章在此基础上扩展了一些加载器实现的思路, 并使用 C# 结合反射注入的方式实现发现免杀效果挺不错, 最近用 Golang 结合内存加载以及其他免杀细节的方式重构了一遍, 基本能过常见杀软和 Defender, 因此在这里记录一下内存免杀的思路以及相关实现细节, 已将 Golang 实现上传至项目

0x02. 何为内存加载免杀
--------------

免杀的方式多种多样, 例如分离免杀、通过反射等方式, 但其本质其实是一种特征码免杀技术, 首先我们要知道特征码查杀恶意病毒是运用程序中某一段或几段 64 字节以下的代码作为判别程序病毒的主要依据

分离免杀之所以能获得很好的效果就是因为 shellcode 加载器本身并不包含恶意代码，自然也不会包含恶意软件的特征码，而只有当加载器运行时，它才会从程序之外加载 shellcode 执行, 通过这种方式能够有效避免基于特征码的查杀方式, 当然也是偏静态的

那么基于 shellcode 的分离免杀, PE 文件同样也能实现, 将 PE 文件以某种加密方式进行存储后使用加载器读取 PE 文件并且解密, 最后放入到内存当中执行, 那么该程序被识别为恶意程序的可能性就大大降低了, 实际上反射 DLL 注入也是基于这样, 通过从内存中而不是在磁盘加载 DLL, 这样避免了文件落地

试想我们开辟一块内存, 然后直接将 shellcode 写入到对应的内存中并且该内存是可读可写可执行的状态, 那么这种方式太容易被 AV 所查杀, 因此当我们如果是利用 Windows 自身提供的 API 来将加密或者封装好的 shellcode 写入到内存执行的话, 将会大大增加查杀的难度

0x03. 通过 UUID 方式实现内存加载
----------------------

利用 UUID 向内存写入 shellcode 的方式早在 17 年就已经出现, 不过在近一年中国内也是利用较多, 俺在今年 HVV 中查到的样本还有利用 UUID 方式免杀的 (x

### 3.1 UUID 是什么

通用唯一识别码 (UUID), 是用于计算机体系中以识别信息数目的一个 128 位标识符，根据标准方法生成，不依赖中央机构的注册和分配，UUID 具有唯一性。

> 这里注意一下 UUID 是一种标准而 GUID 是 UUID 标准的一种具体实现

### 3.2 如何转换 UUID

Python 的官方文档中记录了 UUID 转换的函数以及相关原型和用法  
https://docs.python.org/3/library/uuid.html  
这里要注意的是`uuid.UUID`函数接受一个 16 个字节的 byte, 因为前文说过 uuid 是一个 128 位的标识符也就是 16 字节, 当剩余字节数不满 16 个可添加`\x00`补充字节数

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0tD8t4we7HZiajCKean4ojiaRkOOIBJDaKicHckp2W4nlc44iajKtgrI5lw/640?wx_fmt=png)

如果我们要将 shellcode 转为 UUID 格式, 注意就需要将全部的`shellcode`全部转化为 uuid  
最后`shellcode`转为 UUID 的效果就是这样

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0WiaHztZnffvd596hYbjXNqqYO23bhcX1kLSpiaBjQAZpr8GAhxNSNTmg/640?wx_fmt=png)

### 3.3 UUID 如何写入内存

我们从 MSDN 上关注下这两个 API 函数  
1.UuidFromStringA

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0AZcCEeUJ8R39P4mnX6FDbeiaesF9DqYuzf7SNkvqPqFjezYIfzIHkzA/640?wx_fmt=png)

我们需要提供两个参数, 指向 UUID 字符串的指针, 这里也就是我们之前转换后的 UUID 字符串, 后一个参数可以理解为就是内存中的一块区域, 将 UUID 转化成二进制写入到了这一块内存区域中, 因此这一块内存通过转化后已经写入 shellcode

> 注意该 API 是调用了动态链接库，因此我们在使用过程中也需要进行链接:

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0wtjWDCTYAaEmISLGTH0QEickzTEfiaPSybibX5f5URVeGPEO2LZichGIdg/640?wx_fmt=png)

因此利用的时候, 首先我们需要创建一块内存, 这里使用`HeapCreate`创建内存, 然后申请内存的大小, 并且设置该内存为可读可写可执行, 注意申请内存的大小`len(shellcode)*16`

因为有多少 UUID 转化为二进制后就会有多少个 16 字节, 因此申请内存时也需要注意这个问题

在实现过程中还需要考虑一些细节上的实现, 例如在申请内存的 API 函数选择上, 传统的`VirtualAlloc/HeapAlloc`等方式可能已经被杀软 Hook, 在这里我经过多次比对, 在`RtlCopyMemory`和`ZwAllocateVirtualMemory`中选择了后者, 使用内核层面 Zw 系列的 API，绕过杀软对应用层的监控

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0MBaiaEGca7W9e144ZCj4cUMH7hoqv5o91ZRibvsDwj3FOibDludIlYomw/640?wx_fmt=png)

这里比较粗暴的设置了申请内存的大小为`0x100000`, 然后我们要对每一个 UUID 逐个调用`UuidFromStringA`函数写入到我们申请的内存中

> 注意每一次 UUID 的转换都会伴随内存地址都会增大 16 字节
> 
> ![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0v4RmSV1ZLmzbiccSZcmaK9rkl3Jia5LFNw9qQQEWkDczQ1DwsH0mibYTA/640?wx_fmt=png)
> 
>   

### 3.4 如何执行内存中的 shellcode

其实执行的方式也有多种多样, 一方面我们可以直接调用 Golang 的 syscall 包从底层来直接执行

> syscall 包包含一个指向底层操作系统原语的接口。

尽管 Go 语言具有 cgo 这样的设施可以方便快捷地调用 C 函数，但是其还是自己对系统调用进行了封装，以`amd64`架构为例， Go 语言中的系统调用是通过如下几个函数完成的：

```
// In syscall_unix.go
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
```

在这里介绍另外一种通过函数回调方式执行 shellcode 的函数`EnumSystemLocalesA`

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl09JfSaSeIL3FpJuWoUFQ80qu2z4f891H6IwA7MlM0Sz4nk8jrwSNiaXA/640?wx_fmt=png)

细节 1  
为了避免直接调用 syscall, 我们可以通过利用这种较为冷门的 API 函数来执行内存中的 shellcode 同样可以避开杀软的监控, 通过 callback 方式来触发执行 shellcode 的方式可以参考:  
https://www.freebuf.com/articles/web/269158.html

```
1.EnumTimeFormatsA2.EnumWindows3.EnumDesktopWindows4.EnumDateFormatsA5.EnumChildWindows6.EnumThreadWindows7.EnumSystemLocales8.EnumSystemGeoID9.EnumSystemLanguageGroupsA10.EnumUILanguagesA11.EnumSystemCodePagesA12.EnumDesktopsW13.EnumSystemCodePagesW
```

其中的函数在 MSDN 中也有对应的说明和其他方法的实现, 例如以`EnumSystemLocalesA`为例, 就有`EnumSystemLocalesW`和`EnumSystemLocalesEx`均可以替代进行回调

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl02VfmOpZOvgZW0TJwOVKf9icQRjs20SFoDF7h6UcNpWia8xYia0VnksoDA/640?wx_fmt=png)

最后回调即可:

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0QPKoSLrIOgCVPZXbJBNRtn4U5A2A0sr9ZAeFpb2A7fUGL7h03RfZ0Q/640?wx_fmt=png)

最终的免杀效果尚可

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl07B6xian9DHezmBqbkIs1D2icXIFf5j9HicS1tkrXWYHwOy091ReXfdbuA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0QRnYJS6hdJ9vps8UFyEvubkEwl5dFkaJiao4uh1uLxes6f0YVOibmu9w/640?wx_fmt=png)

免杀项目实现已上传到 Github 上

0x04. 利用 MAC 实现内存加载
-------------------

我们知道在这里实现内存加载的一种方式就是去寻找各种 API,MSDN 上提供了各式各样的 API, 如果某一种 API 函数实现了某种可逆的变形并且最终写入到二进制指针当中, 那么也就实现了内存加载

### 4.1 MAC 是什么

MAC 地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡的 EPROM 一种闪存芯片，通常可以通过程序擦写。IP 地址与 MAC 地址在计算机里都是以二进制表示的，IP 地址是 32 位的，而 MAC 地址则是 48 位（6 个字节）的

### 4.2 如何将 shellcode 转为 MAC

`RtlEthernetStringToAddressA和RtlEthernetAddressToStringA`便是其中的一种  
分别从 MSDN 中查看两个 API 函数的相关信息:  
RtlEthernetAddressToStringA 函数原型

```
NTSYSAPI PSTR RtlEthernetAddressToStringA(  const DL_EUI48 *Addr,  PSTR           S);
```

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl059bs7hatmGe5I5hHsdLjzKykXFicCnCK7ygTOLiaTqoVCuzmICpKAHeg/640?wx_fmt=png)

> 注意 6 个字节转换一个 mac 值，\x00 是一个字节, 当使用该函数后 6 个字节会变成 18-1(`\x00`) 个字节, 即 17 个字节, 当剩余字节数不满 6 个需要添加`\x00`补充字节数，必须将全部的 shellcode 全部转化为 mac 值

因此需要每隔六个字节进行一次转换，内存地址递增 17, 直到转换完所有的 shellcode 为止

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0ZuI7c6UpZs3EQGWoTa54k3slRic23Yaj9C2ib8O0f0ocWYJkzyzwUKlQ/640?wx_fmt=png)

针对转 MAC 的方式其实是这样转换的:

```
\xfc\x48\x83\xe4\xf0\xe8=>FC-48-83-E4-F0-E8
```

因此将 shellcode 转为 MAC 也可以不用上面的写法, 不过在这里就还是使用小刚师傅的脚本利用原生 Win API 转 shellcode

### 4.3 如何将 MAC 还原为 shellcode 写入内存

前文提到的两个函数其实是一个可逆的过程, 因此我们只要使用`RtlEthernetStringToAddressA`便可以将 MAC 值从字符串形式转为二进制格式

```
FC-48-83-E4-F0-E8=>\xfc\x48\x83\xe4\xf0\xe8
```

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0YzBHsBaobgL40OibbBLhZ1kNm0fwLeZuwfibr5HrxTRukJPcUtZHLY1w/640?wx_fmt=png)

这里需要提供 3 个参数, 这里我们第一二个参数都为指向 shellcode 转化为 MAC 后的指针即可, 第三个参数传入接收的内存指针

那么我们同样需要申请内存中一块可读可写可执行的空间, 在这里我选择另外一种方式

为了逃避检测申请内存的行为，可以采用渐进式加载模式，也就是申请一块可读可写不可执行的内存，再使用`VirtualProtect`函数将内存区块设置为可执行，从而规避检测。

细节 2  
在这里用小刚师傅分享的`AllocADsMem`函数来替代`HeapAlloc`申请指定大小的内存空间, 因为类似`VirtualAlloc/HeapAlloc`等 API 被杀软 Hook 的情况很常见, 利用冷门的 API 能够有效避开杀软的探测

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0vE7pBy5eibSibGtKUHcGiaSOxibqhURk6RS8efY9eskpHMMF6tkPleCIKg/640?wx_fmt=png)

参数是要分配的内存大小，成功调用则返回一个指向已分配内存的非 NULL 指针， 如果不成功，则返回 NULL, 该内存空间是可读可写不可执行的, 因此我们还需要调用`VirtualProtectEx`来实现将该内存空间设置为可执行

因此写入内存的步骤也就比较清晰了:

*   1. 使用 AllocADsMem 申请 len(shellcode)*6 的空间大小的内存
    
*   2. 对每一个 MAC 字符串都调用`RtlEthernetStringToAddressA`写入到刚申请的内存中
    
*   3. 每一次调用结束后写入一个 mac 二进制需要将指针移动 6 个字节, 内存地址都会增加 6 个字节
    
*   4. 调用`VirtualProtectEx`将该区域的内存设置为可执行
    

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0jvS60NfZtfEfJJaWDyJXAWC0RgDqpliaUozx5zL5qLdBUfYttbomf7g/640?wx_fmt=png)

最后同样可以使用回调函数执行内存, 这里使用`EnumSystemLocalesW`

细节 3  
在今年 DEFCON 29 中介绍了 golang 的一些作为红队使用语言的优势，议题主要介绍的是题主自己用 golang 实现的一系列红队工具，外加一些其他的补充, 其中就有从内存中加载 DLL 动态链接库, 个人认为就是类似于反射 DLL 注入的方式, 然后进行调用，相当于实现了自己的`LoadLibrary`而不需要调取系统的`LoadLibrary`  
https://github.com/Binject/universal/  
在实现中我也用到了该项目:

```
var ntdll_image []byte
ntdll_image, err = ioutil.ReadFile("C:\\Windows\\System32\\ntdll.dll")
ntdll_loader, err := universal.NewLoader()
ntdll_library, err := ntdll_loader.LoadLibrary("main", &ntdll_image)
_, err = ntdll_library.Call("RtlEthernetStringToAddressA", uintptr(unsafe.Pointer(&u[0])), uintptr(unsafe.Pointer(&u[0])), addrptr)
```

通过上述代码避免了直接使用`Loadlibrary`或者`NewLazySystemDLL`懒加载的方式来导入动态链接库, 这样杀软并不会在导入表中也检测不到我们使用了`RtlEthernetStringToAddressA`函数

最终的免杀效果和 UUID 类似, 虽然 VT 上显示会被微软查杀, 但测试的时候最新 Windows Defender 也能过, 不是很理解, 但是个人认为免杀效果比 UUID 可能好点

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0FsM6WdpV8icbctznjO4Sa6ia4UcxZia7FlbUVT2bn8eVlHjB3KqaWicA9g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0y09x8m6Ikicw1Wkc9mA8FerxXDg77AQ5sYl5TE9ZS3M8dV2RynfCULw/640?wx_fmt=png)

0x05. 利用 Ipv4 方式实现内存加载
----------------------

既然 Windows 中存在处理 MAC 的相关函数, 笔者因此想到肯定存在 IPV4 的相关处理函数, 我们定位到 MSDN 关于`IP2String.h`的相关介绍上:

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0RRLQgYic2iaLpxKNTDib7alvquOUn1ffTYpOHmibTicb3qH5tYroNaslO6A/640?wx_fmt=png)

### 5.1 IPV4 是什么

IPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。

IPv4 使用 32 位（4 字节）地址，因此地址空间中只有 4,294,967,296（232）个地址。

### 5.2 如何将 shellcode 转为 Ipv4 格式

因此可以看到在这里我们同样可以利用 IPV4 的方式实现内存加载，同样使用到了两个 API 函数:`RtlIpv4AddressToStringA/RtlIpv4StringToAddressA`  
第一个函数的函数原型如下:

```
NTSYSAPI PSTR RtlIpv4AddressToStringA(  [in]  const in_addr *Addr,  [out] PSTR          S);
```

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0I2rAibaeewu6nXVuRia3Y2lXNoadNbNwzbg1G9Mrojz9fwpyrIcjyMUg/640?wx_fmt=png)

此函数可以将二进制转化为 IPV4 的格式

> 注意 4 个字节转换一个 Ipv4 值，\x00 是一个字节, 当使用该函数后 4 个字节会变成 16-1(`\x00`) 个字节, 即 15 个字节, 当剩余字节数不满 4 个需要添加`\x00`补充字节数，必须将全部的 shellcode 全部转化为 Ipv4 值

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0ibWFRLVnMob0DXhZ0ImFHiaX482adQVygSicY6h9Wjann9ia5Txl2kDbBw/640?wx_fmt=png)

当使用如上图所示代码, 我们便能够将 byte 类型的 shellcode 转化为 Ipv4 格式:

```
b'\xfc\x48\x83\xe4\'=>252.72.131.228\x00
```

注意这里如果没有到 15 个字节则会以自动以`\x00`进行补充, 最后一个字节即第 16 个字节是字符串结束符

### 5.3 如何将 Ipv4 还原为 shellcode 写入内存

这里就是使用到了第二个 API 函数:`RtlIpv4StringToAddressA`  
函数原型如下:

```
NTSYSAPI NTSTATUS RtlIpv4StringToAddressA(  [in]  PCSTR   S,  [in]  BOOLEAN Strict,  [out] PCSTR   *Terminator,  [out] in_addr *Addr);
```

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl0Y24LOeLibMSUmia3XNJbwQoPavkzxHNK11TeedNAia5Wf29RNicUH5bWAg/640?wx_fmt=png)

因此这里还原写入 shellcode 的步骤为:

*   1. 申请一片内存, 其内存大小应该是`len(shell_ipv4)*4`, 因为该函数还原后每一个 IPv4 就会变成对应的 4 个字节
    
*   2. 通过`RtlIpv4StringToAddressA`将每次的 4 个字节写入到内存中, 此时内存在递增 4 个字节
    
*   3. 使用`VirtualProtectEx`将内存设置为可执行
    

![](https://mmbiz.qpic.cn/mmbiz_png/VXs6byTkU8ICQHKJuafRY1mjUSgVbcl01IpqHAia4wkk3E7bjM7phkdYg0kOEH4GjMCzkicCBv5Yrmm3phsK1hPg/640?wx_fmt=png)

细节 4  
这里使用了比较简单的反沙箱技术, 当今大多数真实机具有 4GB 以上的 RAM, 我们可以检测 RAM 是否大于 4GB 来判断是否是真实的运行机器, 同样大多数真实机拥有 4 核心 cpu，许多在线检测的虚拟机沙箱是 2 核，我们可以通过核心数来判断是否为真实机器或检测用的虚拟沙箱，当然反沙箱还有更多高端操作以及其他判断源，例如可以从系统开机时间、临时文件夹的文件数目

例如我们编写如下一个程序, 将收集好的信息通过`socket`回调给服务器, 然后服务器监听对应的端口即可:

我们主要获取 CPU 核心数和物理内存数, 以某沙箱为例:

可以看到该沙箱的环境为 1 核 2G, 并且其桌面都是一些随机命名的检测文件等, 因此这就可以作为我们反沙箱的要点:

这里我们判断 4 核 2G 之下就为虚拟机, 如果是虚拟机我们就直接退出, 不在继续进行相关操作, 对于一般的沙箱而言也能够有效避免被沙箱获得 IP 或者网络通信情况

使用该内存加载方式和前两者区别同样不大, 市面上主流杀软都能够过, 免杀效果尚好。

0x06. 结语
--------

最后, 有心的师傅们可能注意到 MSDN 中不仅提供了 IPv4 的相关转换函数, IPv6 自然也存在对应的转换函数, 因此利用 IPv6 同样也能够进行内存加载达到免杀的目的, 不过在这里有兴趣的师傅可以自己去实现, 最后免杀项目使用 Golang 进行开发, C# 实现效果也很好, 不过这里就不再展开赘述, 只是分享内存免杀的一种思路和一些免杀细节的实现

0x07. 文章来源
----------

转自安全客，作者：Crispr

原文链接：https://www.anquanke.com/post/id/262666  

如侵权后台请后台私聊删除文章

0x08. 友情提示
----------

本文最终解释权归本文作者所有！！！
=================

由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者不为此承担任何责任。  

一切法律后果均由攻击者承担！！！

日站不规范，亲人两行泪！！！

日站不规范，亲人两行泪！！！

日站不规范，亲人两行泪！！！

*   专注于信息安全方面分享，非营利性组织，不接商业广告
    
*   关注不迷路，点赞！关注！转发！评论！！
    
*   要投稿的后台留言即可，会第一时间回复，谢谢！
    
*   公众号