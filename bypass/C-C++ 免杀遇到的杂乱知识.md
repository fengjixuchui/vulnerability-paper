> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/cDMxewbHtkvd8XmV_zeiwA)

![](https://mmbiz.qpic.cn/mmbiz_jpg/zbTIZGJWWSO06MkK8Knicc883LswVgqp7c1iceMoVYFIP5U5ys3SC1qZrq00ErpRagJSSloTLeZyicNtn2BkBd18A/640?wx_fmt=jpeg)  

一位苦于信息安全的萌新小白帽

本实验仅用于信息防御教学，切勿用于它用途

公众号：XG 小刚

杂乱知识

总结几个最近研究 C/C++ 免杀入门时遇到的几点属性配置问题  

看网上很多 C/C++ 的源码都会在源码开头看到类似的代码

```
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")
```

```
#pragma comment(linker, "/INCREMENTAL:NO")
```

```
#pragma comment(linker, "/section:.data,RWE")
```

这是干嘛的?  

#pragma 是预处理指令之一，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。

comment 是 #pragma 下的一个子命令，使用注释方式引入库或编译目录。

然后括号里面就是对应的属性和属性的值。

其实这些代码和 VS 编辑该项目属性的配置是对应的，我们右键打开属性

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSO06MkK8Knicc883LswVgqp7vq0CbrhuywIMnb44KE8kojf6srRWESwza85fqK0ODdqQL1RZo3fJnQ/640?wx_fmt=png)

看到的这些属性值和上面所展示的代码效果是一样的，都是修改该编译器的一些状态。

增量链接

```
#pragma comment(linker, "/INCREMENTAL:NO")
```

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSO06MkK8Knicc883LswVgqp7iacwkbLibeajFRkz8uvA2uaT47fuUgXicoMvwCJXfpyhSSNwyk0aOwU3A/640?wx_fmt=png)

VC++ 中如果设置不是增量链接，每次我们修改了 c/c++ 文件后，会重新生成 obj 文件 (Microsoft 推出的程序编译中间代码文件)。

然而在增量链接后， obj 文件会对每个函数预留一部分空间, 编译链接时, 只是修改你修改过的函数对应的代码, 其它二进制代码保持不变。

设置控制台和入口函数

```
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")
```

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSO06MkK8Knicc883LswVgqp77GDEa7RmnrfnDKdjicqYMaib3PlRE8evRF054eibLwXrR9hHuMnMnfCiag/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSO06MkK8Knicc883LswVgqp78nWLrOTpeu7yheKiaOcFCULfoEgZxm1mtLFCl3z6Ia1r7pnzlnVbJSg/640?wx_fmt=png)

设置这俩是干嘛的? **不弹出 DOS 框。**

我们在 win 开发的时候，我们一般不是开发控制台应用就是桌面应用，一般是在创建项目时候就选择好了。当然可以在上面的属性里面修改，通常可以指定四种方式：“CONSOLE|WINDOWS|NATIVE|POSIX”

如果开发的控制台应用 console，我们运行是就会弹出一个黑色的框。

开发的是桌面应用 windows，则不会弹控制台，而是需要我们自己写一个桌面显示出来。

开发不一样的程序，需要的入口函数不一样，控制台我们常用 main 函数当入口函数，桌面则是 WinMain 当入口函数。

  
而我们在属性 -> 连接器设置的入口函数是 mainCRTStartup 或 WinMainCRTStartup 。

通常控制台程序运行会先调用 mainCRTStartup 再调用你自己编写的 main 函数。

桌面程序则是调用 WinMainCRTStartup，再调用你自己写的 WinMain 函数。

详情可看看这个:https://www.cnblogs.com/mlgjb/p/8573838.html

这样我们运行程序时将以桌面方式运行，不弹出控制台，但入口函数使用 main 进行运行。  

.data 段可读可写

```
#pragma comment(linker, "/section:.data,RWE")
```

.data 段是啥需要去了解一下 PE 结构，这是一个 PE 文件的数据段，存放一下我们定义的变量。

下面是一段很基础的加载器

```
#include
#include
#pragma comment(linker, "/section:.data,RWE")

unsigned char buf[] = "\xfc\xe8\x89\x00....";
int main()
{
           __asm
           {
                      lea eax, buf;
                      jmp eax;
           }
           return 0;
}
```

```
unsigned char buf[] = "\xfc\xe8\x89\x00....";
```

这是我们的 shellcode，我们定义这个变量，在编译完成之后会将数据存放到.data(数据段)

```
__asm
{
  lea eax, buf;
  jmp eax;
}
```

使用 lea 汇编指令获得 buf 的地址

使用 jmp 汇编指令，无条件跳转到指定的段，然后继续运行程序。

由于数据段受系统保护，是不允许被执行的，所以我们需要提前修改该段属性为 RWE(可读可写可执行)，否则程序运行错误。

变量通常放在数据段，但我们写成下面格式，会放在.text 代码段，导出 shellcode 时候需要用到

```
char buf={'\x00','\x00',....}
```

为啥生成这种格式？  

在 C 中定义字符串使用 char buf[]="\x00\x00..." 格式，会将 shellcode 存放在数据段，buf 只是个指针，我们导出 shellcode 是代码段，所以该数据不会跟着导出。使用 char buf={'\x00','\x00',....} 格式会存放在代码段，会随我们导出 shellcode 一起导出。