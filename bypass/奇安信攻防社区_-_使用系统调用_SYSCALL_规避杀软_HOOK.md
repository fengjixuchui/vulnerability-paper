<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1014)

> 奇安信攻防社区 - 使用系统调用 SYSCALL 规避杀软 HOOK

在进程注入的时候会出现一些敏感函数被 HOOK 的情况 像 VirtualAllocEx，WriteProcessMemory 都是重点关注的函数 本文通过直接调用系统调用号绕过杀软 HOOK，syscall 限于 64 位 ## 0x01 系统...

在进程注入的时候会出现一些敏感函数被 HOOK 的情况

像 VirtualAllocEx，WriteProcessMemory 都是重点关注的函数

本文通过直接调用系统调用号绕过杀软 HOOK，syscall 限于 64 位

0x01 系统调用号
----------

打个比方

VirtualAllocEx 不是用户层的最后一个函数

VirtualAllocEx->VirtualAllocExNuma->ZwAllocateVirtualMemory

最后 ZwAllocateVirtualMemory 函数进入内核层

这些底层的函数都有一个数字，在 windows10 的情况下 ZwAllocateVirtualMemory 对应的号就是 0x18 号

简单说就是底层函数对应的那个数字就是系统调用号

下面用 dbg 跟一下 VirtualAllocEx

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9ccbefcccd241b9b46b45f3e44ad4b4450771719.png)

这是主函数里面 VirtualAllocEx 用 F7 跟进

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6597473225fc78f7070e91475268d2d07db4eec8.png)

上面调整下堆栈，然后 jmp 到 VirtualAllocEx 函数位置

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a8115471df6a0124704359df87e9c625ad6ea956.png)

这里看到调用了 VirtualAllocExNuma

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9691e5c13bdc71f6c0f693205f310d628ddfbd18.png)

这里就调到了 ntdll.dll 里面的 ZwAllocateVirtualMemory，基本到 ntdll.dll 里面是用户层底层函数了

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-16d6725f48bf3a5bdaae207d6c39d5d0a56113e3.png)

到这里就可以看到调用号是 18 了，上面也有一些别的调用号对应的函数

```
mov r10,rcx
```

上面这段就是执行系统调用号对应的函数

test byte ptr ds:[7FFE0308],1  
jne ntdll.7FFAA5D22B15

这是用来校验的可以删掉

```
mov eax,18
```

上面的四行就可以调用用户层最下层函数

不同系统的系统调用号是不同的，可以在下面这个网站查询，找不到的函数 Zw 修改 Nt 就可以

[https://j00ru.vexillium.org/syscalls/nt/64/](https://j00ru.vexillium.org/syscalls/nt/64/)

0x02 代码实现
---------

VirtualAllocEx -> NtAllocateVirtualMemory -> 0x18  
WriteMemory -> NtWriteVirtualMemory -> 0x3a  
CreateRemoteThread -> NtCreateThreadEx -> 0xc6

这是三个敏感函数对应的底层函数

这次不使用 NtWriteVirtualMemory 函数就用普通的 WriteMemory 写内存，因为 NtWriteVirtualMemory 涉及内存保护比较麻烦

ZwOpenProcess->ZwProtectVirtualMemory->ZwWriteVirtualMemory

要这样写，还没研究过就先不看了

上面的系统调用号都是 windows11 的，网站上只到 windows10，所以有些对不上

这里就不写找的过程了，和上面是相同的

```
test byte ptr ds:[7FFE0308],1
```

写过 Hook 的师傅可能知道，内联 Hook 都是直接修改函数的汇编，把正常执行的汇编跳到某个想执行的地方

上述方法直接调用底层函数，普通的 Hook 已经定位不到了，再高级一点 Hook 住 ntdll.dll 也是没用的，因为这里的 syscall 并不是通过 ntdll.dll 的，理论上来说已经避免了 R3 的 Hook 了

0x03 动态获取系统调用号
--------------

上面的代码还有个问题，不同版本的系统系统调用号也是不同的，甚至有些小版本的系统调用号也不同，这样写兼容肯定是很不好的，需要找到一种动态获取系统调用号的方法

先看一段代码

```
jne ntdll.7FFAA5D22B15
```

用 dbg 查看下

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-5f29b72bd88c4737493aa24d71e09550656ba763.png)

GetProcAddress 得到了函数指针存在 ebx 然后 call 过去

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-8f7799b6e5f54171734ffc2e61b3541a7ea605a6.png)

这里过去同样可以找到 syscall 号

可以通过得到函数指针，往后推四个字节得到 syscall 号

可以写个函数实现一下

```
syscall
```

这样就实现了动态获取系统调用号

0x04 参考
-------

[https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav](https://idiotc4t.com/defense-evasion/overwrite-winapi-bypassav)

[https://idiotc4t.com/defense-/dynamic-get-syscallid](https://idiotc4t.com/defense-/dynamic-get-syscallid)