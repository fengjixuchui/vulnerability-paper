<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/99lpEnYbrr5rA6qWKA5RgA)

  DPAPI 是啥？这里就不多说了，用处呢？主要就是用来解微软系的凭据啥的。

但微软给出了 DPAPI 的开发文档，我们也可以用它来加解密数据。

可以去看之前的文章：[获取已控机器本地保存的 RDP 密码](http://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&mid=2247484902&idx=1&sn=34368d206718cb54c25b313269e2aad1&chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&scene=21#wechat_redirect)

加密函数：

https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata

```
DPAPI_IMP BOOL CryptProtectData(
  DATA_BLOB                 *pDataIn,
  LPCWSTR                   szDataDescr,
  DATA_BLOB                 *pOptionalEntropy,
  PVOID                     pvReserved,
  CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
  DWORD                     dwFlags,
  DATA_BLOB                 *pDataOut
);
```

解密函数：

https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptunprotectdata

```
DPAPI_IMP BOOL CryptUnprotectData(
  DATA_BLOB                 *pDataIn,
  LPWSTR                    *ppszDataDescr,
  DATA_BLOB                 *pOptionalEntropy,
  PVOID                     pvReserved,
  CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
  DWORD                     dwFlags,
  DATA_BLOB                 *pDataOut
);
```

其中的 DATA_BLOB 和 CRYPTPROTECT_PROMPTSTRUCT 为内置的结构体：

https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)

```
typedef struct _CRYPTOAPI_BLOB {
  DWORD cbData;
  BYTE  *pbData;
} CRYPT_INTEGER_BLOB, *PCRYPT_INTEGER_BLOB, CRYPT_UINT_BLOB, *PCRYPT_UINT_BLOB, CRYPT_OBJID_BLOB, *PCRYPT_OBJID_BLOB, CERT_NAME_BLOB, CERT_RDN_VALUE_BLOB, *PCERT_NAME_BLOB, *PCERT_RDN_VALUE_BLOB, CERT_BLOB, *PCERT_BLOB, CRL_BLOB, *PCRL_BLOB, DATA_BLOB, *PDATA_BLOB, CRYPT_DATA_BLOB, *PCRYPT_DATA_BLOB, CRYPT_HASH_BLOB, *PCRYPT_HASH_BLOB, CRYPT_DIGEST_BLOB, *PCRYPT_DIGEST_BLOB, CRYPT_DER_BLOB, PCRYPT_DER_BLOB, CRYPT_ATTR_BLOB, *PCRYPT_ATTR_BLOB;
```

cbData 为大小、pbData 为数据。

https://docs.microsoft.com/en-us/windows/win32/api/dpapi/ns-dpapi-cryptprotect_promptstruct

```
typedef struct _CRYPTPROTECT_PROMPTSTRUCT {
  DWORD   cbSize;
  DWORD   dwPromptFlags;
  HWND    hwndApp;
  LPCWSTR szPrompt;
} CRYPTPROTECT_PROMPTSTRUCT, *PCRYPTPROTECT_PROMPTSTRUCT;
```

至于调用就比较简单了，先声明一个此类的结构体，然后调用加密函数来加密它

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XOqLEiaumtOcg4NkzJO5mPVkASlb9Qic4dcmeFCSuxWKMwrMIXh23huicvqhRoRbNFbntiaYmDYuaKtg/640?wx_fmt=png)

得到加密后的值。

关于参数值，可以直接将鼠标移动过来，自己看含义。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XOqLEiaumtOcg4NkzJO5mPVydJibOhMia9owshf53ewS20AcOSlvHkeCQsZXLUabu3hTez7ESJz6E1w/640?wx_fmt=png)

然后就是调用解密函数对其解密，然后 VirtualAlloc、RtlMoveMemory、CreateThread、WaitForSingleObject 加载即可。

当然 C# 中也有相关的库可以实现对应操作：

```
using System.Security.Cryptography;
byte[] entropy = { };
byte[] encryptedText = ProtectedData.Protect(buf, null, DataProtectionScope.LocalMachine);
```

由于其 dpapi 为本地 dpapi，其他机器都解不了，所以有一定的反沙箱效果，缺点就是只能先在目标机器上获取一下加密的值才能做后续操作。效果还算可以啦：

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XOqLEiaumtOcg4NkzJO5mPVvhpwEn0pR11AyIokS7S5Dx97BpkC6E7mNHTC8iczR2UKQkqYtibDg3Eg/640?wx_fmt=png)

当然啦，官方给出了的 DPAPI 也不是只能加密字符的，内存也是可以的，也就是变相的绕过一些杀软的内存扫描啦。

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XOqLEiaumtOcg4NkzJO5mPVjElZeXCUErMVTy6ib7sBXUcHIDRKtApWOAxjbhFiadQGfP5lq9LTOWPg/640?wx_fmt=png)

  

  

  

  

  

     ▼

更多精彩推荐，请关注我们

▼

**请严格遵守网络安全法相关条例！此分享主要用于学习，切勿走上违法犯罪的不归路，一切后果自付！**

![](https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08XZjHeWkA6jN4ScHYyWRlpHPPgib1gYwMYGnDWRCQLbibiabBTc7Nch96m7jwN4PO4178phshVicWjiaeA/640?wx_fmt=png)