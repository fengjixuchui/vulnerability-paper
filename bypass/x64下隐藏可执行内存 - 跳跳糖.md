<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1589/)

[前言](#toc_)
===========

我们如果想要实现进程隐藏在3环通常会使用到PEB断链去达到隐藏进程的效果，但是那只是表面上的进程隐藏，所有内存的详细信息都会被储存在vad树里面，这里我们就来探究在64位下如何隐藏可执行内存

[vad](#toc_vad)
===============

VAD是管理虚拟内存的，每一个进程有自己单独的一个VAD树，使用`VirtualAlloc`申请一个内存，则会在VAD树上增加一个结点，其是`_MMVAD`结构体

```
dt _MMVAD 
```

[![image-20220329154007738.png](https://storage.tttang.com/media/attachment/2022/05/04/7d03de80-2122-46c8-8ff2-54624eb6f7c8.png)](https://storage.tttang.com/media/attachment/2022/05/04/7d03de80-2122-46c8-8ff2-54624eb6f7c8.png)

这里找一个进程，因为是根节点所以没有父节点

[![image-20220329154131189.png](https://storage.tttang.com/media/attachment/2022/05/04/71db160e-c8f2-4563-9520-5ec6b5d9c74c.png)](https://storage.tttang.com/media/attachment/2022/05/04/71db160e-c8f2-4563-9520-5ec6b5d9c74c.png)

然后往左遍历二叉树，在下一个节点处的父节点指向了上一个二叉树

[![image-20220329154230061.png](https://storage.tttang.com/media/attachment/2022/05/04/9b1d61e3-c55c-49e9-a3be-768f25220df8.png)](https://storage.tttang.com/media/attachment/2022/05/04/9b1d61e3-c55c-49e9-a3be-768f25220df8.png)

注意`StartingVpn`和`EndingVpn`这两个结构，描述了当前页的位置，以4kb为单位，即0x400000到0x488000这一块内存空间已经被占用了

[![image-20220329154654585.png](https://storage.tttang.com/media/attachment/2022/05/04/405a3d2c-3879-4ca1-98e7-d9b21f83f8bd.png)](https://storage.tttang.com/media/attachment/2022/05/04/405a3d2c-3879-4ca1-98e7-d9b21f83f8bd.png)

在0x18有一个`ControlArea`结构，描述了这块结构体到底被谁占用，这里跟进去看0x24有一个`FilePointer`结构，如果这里的值为0就是一个真正的物理页，如果有值继续往里面找

[![image-20220329155005328.png](https://storage.tttang.com/media/attachment/2022/05/04/74aaa488-404f-4b4a-a1e4-0ea331e0c4f2.png)](https://storage.tttang.com/media/attachment/2022/05/04/74aaa488-404f-4b4a-a1e4-0ea331e0c4f2.png)

这里对应了`Dbgview.exe`

[![image-20220329155328329.png](https://storage.tttang.com/media/attachment/2022/05/04/dcc92445-19df-4368-9955-39875ff6ce1b.png)](https://storage.tttang.com/media/attachment/2022/05/04/dcc92445-19df-4368-9955-39875ff6ce1b.png)

在操作系统里面分配的内存只可能有两种类型，一种是`VirtualAlloc`自己分配的内存，一种是文件映射使用`CreateFileMapping`的内存，当`ControlArea`的`FilePointer`值为空的时候则是我们自己用`VirtualAlloc`分配的内存，还没有对应，如果值不为空则是文件映射的内存

[分页机制](#toc__1)
===============

在32位里面有`2-9-9-12`、`10-10-12`两种分页模式，而在64位下只有一种分页模式，即`9-9-9-9-12`分页模式

随着计算机技术的发展，64位系统逐渐占据主流地位，那么也就表示CPU的最大寻址范围为64位。但实际上，CPU只使用了其中的48位用于寻址，并使用`9-9-9-9-12`分页模式。即便如此，在未来较长一段时间里，48位寻址范围也足够大部分人的日常使用了

`9-9-9-9-12`分页表示物理地址拥有四级页表，在Intel开发手册中，将这四级页表分别称为`PML4E`、`PDPTE`、`PDE`、`PTE`，但微软的命名方式略有不同，将这四级页表分别称为`PXE`、`PPE`、`PDE`、`PTE`，`WinDbg`中也是如此

[![image-20220504165636253.png](https://storage.tttang.com/media/attachment/2022/05/04/251199e5-6917-4b49-8f4c-bc8951a60b1e.png)](https://storage.tttang.com/media/attachment/2022/05/04/251199e5-6917-4b49-8f4c-bc8951a60b1e.png)

启用分页模式条件：`cr0.PG = 1` 且 `cr0.PE = 1`

根据不同CPU架构及特性主要分为三种模式，处于哪种模式视寄存器属性不同：

*   32-bit paging(32位OS): `cr0.PG = 1` 、 `cr4.PAE = 0`
*   PAE paging(32位OS且开启了PAE): `cr0.PG = 1` 、 `cr4.PAE = 1` 、 `IA32_EFER.LME = 0`
*   IA-32e paging(64位OS): `cr0.PG = 1` 、 `cr4.PAE = 1` 、 `IA32_EFER.LME = 1`

**需要注意的是**：

1.  32bit下，每个entry（表项）是4字节大小；而在PAE和IA-32e下，每个entry是8字节大小
2.  在x64体系中只实现了48位的`virtual address`，高16位被用作符号扩展，这高16位要么全是0，要么全是1。所以在讨论64bit地址的时候，高16位不使用

我们主要研究的是`IA-32e`模式下的内存，这里`IA-32e`提供了三种页转换模型：

*   4k：PML4t,PDPT,PDT和PT
*   2M：PML4T，PDPT和PDT
*   1G：PML4T和PDPT

在4kb小页的情况下，64位可以拆分为一下几段，即9-9-9-9-9-12分页

> sign extended -- 符号扩展位 --- 在线性地址48~63bit  
> PML4 entry -- 在线性地址39～47bit用于索引PML4 entry，指向PDP  
> PDP entry -- 在线性地址的30～38bit用来索引PDP entry，指向PDE  
> PDE entry -- 在线性地址的21～29bit用来索引PDEentry，指向PTE  
> PTE entry -- 在线性地址的12～20bit用来索引PTE entry，指向page offset  
> page offse t -- 在线性地址的0～11bit提供在页中的offset

这里我们手动去找一下，前3位为符号扩展位，直接去掉

[![image-20220420103031572.png](https://storage.tttang.com/media/attachment/2022/05/04/668f0018-c199-4fbb-97e2-19d6a3e2c4df.png)](https://storage.tttang.com/media/attachment/2022/05/04/668f0018-c199-4fbb-97e2-19d6a3e2c4df.png)

可以看到`PXE`、`PPE`、`PDE`、`PTE`都是能够对应上的

[![image-20220420103147049.png](https://storage.tttang.com/media/attachment/2022/05/04/7b49bc92-03c7-45f5-8011-27b215929dfc.png)](https://storage.tttang.com/media/attachment/2022/05/04/7b49bc92-03c7-45f5-8011-27b215929dfc.png)

[页表基址](#toc__2)
===============

*   一个进程该如何访问自己的物理页呢？可以通过读取Cr3的值进行访问吗？

答案是不行，Cr3中保存的页表基址是物理地址，程序如果直接访问这个地址，虽然看上去值是一样的，但实际上访问的是一个线性地址，会被虚拟内存管理器解析成另一个地址

实际上，操作系统会将当前进程的物理页映射在某个线性地址中，以供程序读取自己的页表内容

在x86系统中，页表基址是固定的，位于`0xC0000000`，将这个线性地址进行解析，访问其物理页的内容，会发现从这个地址开始，里面保存的数据为当前程序的所有物理页地址

而在x64系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的可以在WinDbg中查看0地址对应的线性地址来确定当前的页表基址

可以看到，当前系统的页表基址的线性地址为`0xFFFFF38000000000`，注意，只有后48位才是有效地址

其中，每个物理页占8个字节，例如，第一个物理页地址位于线性地址`0xFFFFF38000000000`，第二个物理页地址位于线性地址`0xFFFF800000000008`，每个物理页中包含1024个字节的数据

[![image-20220419212509051.png](https://storage.tttang.com/media/attachment/2022/05/04/a174e608-cfc4-4fad-993c-043731eae044.png)](https://storage.tttang.com/media/attachment/2022/05/04/a174e608-cfc4-4fad-993c-043731eae044.png)

[MiIsAddressValid](#toc_miisaddressvalid)
=========================================

我们在这里初步了解了windows的内存管理，那么这里我们去看一下windows是如何实现分页机制的，这里使用到`MiIsAddressValid`这个API

[![image-20220504170429995.png](https://storage.tttang.com/media/attachment/2022/05/04/bd163342-ffae-4faf-bb30-887d3ddbbcc2.png)](https://storage.tttang.com/media/attachment/2022/05/04/bd163342-ffae-4faf-bb30-887d3ddbbcc2.png)

我们首先看一下win7下`MiIsAddressValid`的实现

[![image-20220504171516062.png](https://storage.tttang.com/media/attachment/2022/05/04/301b74bf-73f7-42b3-ad7f-1741657dfb9d.png)](https://storage.tttang.com/media/attachment/2022/05/04/301b74bf-73f7-42b3-ad7f-1741657dfb9d.png)

`shr eax, 14h`和`and eax, 0FFC`相当于eax右移16位再乘以4，然后判断`PS`位是否为0，如果为0则不合法，则将al清零

[![image-20220504204400160.png](https://storage.tttang.com/media/attachment/2022/05/04/73666377-4a0b-4bec-8d4b-b7a1c6aa47fa.png)](https://storage.tttang.com/media/attachment/2022/05/04/73666377-4a0b-4bec-8d4b-b7a1c6aa47fa.png)

在64位下，存在三种不同大小的页面，分别为大页、中页、小页。其大小分别为1GB、2MB、4KB。这里判断`al`不等于0则继续向下执行，这里`jns`是通过判断`SF=0`，如果`SF=0`成立则跳转

[![image-20220504205545977.png](https://storage.tttang.com/media/attachment/2022/05/04/cdd7c5d3-4106-405c-b8eb-5072924132f1.png)](https://storage.tttang.com/media/attachment/2022/05/04/cdd7c5d3-4106-405c-b8eb-5072924132f1.png)

这里仍然后一个右移的操作，是为了将段选择子分为`9-9-9-9-12`五部分，然后判断P位是否有效和`PAT`是否为1

[![image-20220504205653192.png](https://storage.tttang.com/media/attachment/2022/05/04/10a7b7d2-4805-4bba-9d37-349b1fe2a5cc.png)](https://storage.tttang.com/media/attachment/2022/05/04/10a7b7d2-4805-4bba-9d37-349b1fe2a5cc.png)

这里其实看伪代码逻辑会更清晰一点，我们可以可以发现通过一系列的移位操作得到对应的`PXE`、`PPE`、`PDE`、`PTE`并判断P位验证是否有效

[![image-20220504210754899.png](https://storage.tttang.com/media/attachment/2022/05/04/e1e2dee7-d7a1-404f-97fe-a0b6cb40136d.png)](https://storage.tttang.com/media/attachment/2022/05/04/e1e2dee7-d7a1-404f-97fe-a0b6cb40136d.png)

那么这里我们就可以通过减去的数值取反，然后加1即可得到对应基址，通过计算得到win7 64位下的`PTE_Base = fffff68000000000`

我们再去看一下win10下的`MiIsAddressValid`函数

```
.text:00000001400AD930 _MmIsAddressValid proc near             .text:000000014000FB6E
.text:00000001400AD930                                         
.text:00000001400AD930                 mov     rax, rcx
.text:00000001400AD933                 sar     rax, 48                               
                                                 ;取得线性地址的   高16位
.text:00000001400AD937                 inc     rax
.text:00000001400AD93A                 cmp     rax, 1
.text:00000001400AD93E                 ja      loc_1400AD9D3   
                                 ; 高16位要么全0, 要么全1 ，加一后大于1则不合法，直接返回false
.text:00000001400AD944                 mov     rax, rcx
.text:00000001400AD947                 mov     rdx, 0FFFFF6FB7DBED000h
                                                     ; PML4T 的虚拟地址
.text:00000001400AD951                 shr     rax, 39        
                                                   ; 将虚拟地址右移39位
.text:00000001400AD955                 and     eax, 1FFh      
                                                   ; 拿到pml4数组的下标
.text:00000001400AD95A                 test    byte ptr [rdx+rax*8], 1
                                                 ; 检测PML4T项p位
.text:00000001400AD95E                 jz      short loc_1400AD9D3
                                                  ; p=0 则直接返回false
.text:00000001400AD960                 mov     rax, rcx
.text:00000001400AD963                 mov     rdx, 0FFFFF6FB7DA00000h
.text:00000001400AD96D                 shr     rax, 27         
                                                ; 右移30位 ，再 乘 8 ,相当于右移27位
.text:00000001400AD971                 and     eax, 1FFFF8h   
                                                ; 8字节对齐 得到PDPT的偏移
.text:00000001400AD976                test    byte ptr [rax+rdx], 1
                                               ; 检测PDPT项的p位 rax+rdx=PDPT的首地址
.text:00000001400AD97A                jz      short loc_1400AD9D3
.text:00000001400AD97C                 mov     rdx, -0FFFFF6FB40000000h
.text:00000001400AD986                 mov     rax, rcx
.text:00000001400AD989                 shr     rax, 18        
                                                  ; 右移21位，再乘8 ,相当于右移18位
.text:00000001400AD98D                 and     eax, 3FFFFFF8h       
                                                   ;得到PDT的偏移
.text:00000001400AD992                 sub     rax, rdx      
                                                 ; rax = rax + 0FFFFF6FB40000000h  
.text:00000001400AD995                 mov     rdx, [rax]               
                                                ;此时rax指向PDT中的 某一项
.text:00000001400AD998                 test    dl, 1         
                                                  ; 检测PDT项p位
.text:00000001400AD99B                 jz      short loc_1400AD9D3
.text:00000001400AD99D                 test    dl, dl
.text:00000001400AD99F                 js      short loc_1400AD9D6
                                                     ; 是否开启PSE,是的话直接返回真
.text:00000001400AD9A1                 shr     rcx, 9         
                                                    ; 右移12位,再乘 8 ,相当于右移9位
.text:00000001400AD9A5                 mov     rax, 7FFFFFFFF8h ; 8字节对齐
.text:00000001400AD9AF                 and     rcx, rax               
.text:00000001400AD9B2                 mov     rax, -0FFFFF68000000000h
.text:00000001400AD9BC                 sub     rcx, rax
.text:00000001400AD9BF                 mov     rax, [rcx]       
                                                   ;此时RCX指向PT的的某一项
.text:00000001400AD9C2                 test    al, 1
.text:00000001400AD9C4                 jz      short loc_1400AD9D3
                                                   ; 检测PT项的P位
.text:00000001400AD9C6                 mov     r8b, 80h
.text:00000001400AD9C9                 and     al, r8b
.text:00000001400AD9CC                 cmp     al, r8b
.text:00000001400AD9CF                 setnz   al            
                                                  ; 检测PT项的PAT位是否存在，不存在返回真
.text:00000001400AD9D2                 retn
.text:00000001400AD9D3 ; ---------------------------------------------------------------------------
.text:00000001400AD9D3
.text:00000001400AD9D3 loc_1400AD9D3:                          
.text:00000001400AD9D3                                         
.text:00000001400AD9D3                 xor     al, al
.text:00000001400AD9D5                 retn
.text:00000001400AD9D6 ; ---------------------------------------------------------------------------
.text:00000001400AD9D6
.text:00000001400AD9D6 loc_1400AD9D6:                         _
.text:00000001400AD9D6                 mov     al, 1
.text:00000001400AD9D8                 retn
.text:00000001400AD9D8 _MmIsAddressValid endp 
```

在win10 `1607`版本以后，微软更改了策略，将页目录基址更改为了随机地址，那么我们之前在win7里面直接定位`PTE_Base`的方法就不可用，那么我们就可以使用提取特征码的方式去定位内核模块的地址

首先在WinDbg中定位内核模块的地址

[![image-20220420102547386.png](https://storage.tttang.com/media/attachment/2022/05/04/6ca345ea-6864-4aae-8d2b-8a3a7dbe4299.png)](https://storage.tttang.com/media/attachment/2022/05/04/6ca345ea-6864-4aae-8d2b-8a3a7dbe4299.png)

然后在内核模块中搜索与当前页表基址相同的值出现的位置，当前页表基址为`0xFFFF800000000000`

[![image-20220420102559314.png](https://storage.tttang.com/media/attachment/2022/05/04/e8abebef-1533-4396-9b15-f306b8bc1116.png)](https://storage.tttang.com/media/attachment/2022/05/04/e8abebef-1533-4396-9b15-f306b8bc1116.png)

接着，在IDA中定位到数据所在的位置，可以看到是某行代码引用了这个值的硬编码

[![image-20220420102611892.png](https://storage.tttang.com/media/attachment/2022/05/04/6241fd88-306c-4afc-9f33-9d7b577f96d5.png)](https://storage.tttang.com/media/attachment/2022/05/04/6241fd88-306c-4afc-9f33-9d7b577f96d5.png)

在WinDbg中查看这段代码，能够识别到位于`CcUnpinFileDataEx`函数。那么，由于系统每次启动时基址是不固定的，因此这些值也不可能是固定的硬编码，肯定对这些值进行了修改，在需要使用时，可以通过固定的偏移量提取硬编码，从而得到页表基址，但要注意不同版本的内核文件的偏移量可能是不同的

[![image-20220420102628929.png](https://storage.tttang.com/media/attachment/2022/05/04/bc2e096b-8025-4952-b836-4dff1817b90a.png)](https://storage.tttang.com/media/attachment/2022/05/04/bc2e096b-8025-4952-b836-4dff1817b90a.png)

[代码实现](#toc__3)
===============

那么这里我们首先编写4个函数分别定位`PTE`、`PDE`、`PPE`、`PXE`，这里`g_PTE_BASE`就分为两种情况

```
PULONG64 GetPteAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 12) << 3) + g_PTE_BASE);
}

PULONG64 GetPdeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 21) << 3) + g_PDE_BASE);
}

PULONG64 GetPpeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 30) << 3) + g_PPE_BASE);
}

PULONG64 GetPxeAddress(PVOID addr)
{
    return (PULONG64)(((((ULONG64)addr & 0xffffffffffff) >> 39) << 3) + g_PXE_BASE);
} 
```

当系统为win7或者win10 `1607`以下版本的时候就可以直接将`g_PTE_BASE`定义成固定的地址

```
 if (versionNumber == 7600 || versionNumber < 14393)
    {
        g_PTE_BASE = 0xFFFFF68000000000ull;
        return g_PTE_BASE;
    } 
```

如果为win10 `1607`以上的版本就需要自己通过逆向的方式提取硬编码进行定位，这里我通过`MmGetVirtualForPhysical`函数加偏移的方式进行定位

```
 UNICODE_STRING Name = { 0 };
        RtlInitUnicodeString(&Name, L"MmGetVirtualForPhysical");
        PUCHAR func = (PUCHAR)MmGetSystemRoutineAddress(&unName);
        pte_base = *(PULONG64)(func + 0x22);
        return pte_base; 
```

那么这里要得到系统版本，就需要用到`RtlGetVersion`进行判断，这里注意，在win7以后如果直接使用`GetVersion`会失败，必须调用更底层的`RtlGetVersion`才能得到具体的版本

[![image-20220504214628464.png](https://storage.tttang.com/media/attachment/2022/05/04/feb7f2dd-4283-4384-93f8-3259ea70de5e.png)](https://storage.tttang.com/media/attachment/2022/05/04/feb7f2dd-4283-4384-93f8-3259ea70de5e.png)

```
NTSTATUS status = RtlGetVersion(&version); 
```

这里我们明确一下思路，我们想要隐藏可执行内存，那么就可以首先申请一块可读可写的内存，然后通过修改PXE的最高位为0即可达到可执行的效果

例如下面的程序，PXE的最高位为8，则内存是没有可执行权限的

[![image-20220424202559150.png](https://storage.tttang.com/media/attachment/2022/05/04/2325cc0a-e440-4e9b-aa4c-8f56a8bae327.png)](https://storage.tttang.com/media/attachment/2022/05/04/2325cc0a-e440-4e9b-aa4c-8f56a8bae327.png)

那么这里我们找到目标进程，然后通过`KeStackAttachProcess`函数实现进程挂靠，即把自己的cr3换成目标进程的cr3

```
 NTSTATUS status = PsLookupProcessByProcessId(pid, &Process);
    KAPC_STATE kapc_state = { 0 };
    KeStackAttachProcess(Process, &kapc_state); 
```

我们将cr3切换为目标进程的cr3之后就可以使用`ZwAllocateVirtualMemory`先分配一块可读可写的内存

```
status = ZwAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &size, MEM_COMMIT, PAGE_READWRITE); 
```

通过`RtlMoveMemory`写入shellcode并修改内存为可执行权限，这里我们直接定位到pte和pde修改即可将pxe的最高位置0

首先将前3位符号位去掉得到内存的起始地址和结束地址

```
 ULONG64 startAddress = VirtualAddress & (~0xFFF); 
    ULONG64 endAddress = (VirtualAddress + size) & (~0xFFF); 
```

这里写一个循环判断，必须每一块内存都需要修改

```
for (ULONG64 i = startAddress; i <= endAddress; i += PAGE_SIZE) 
```

结合`MmIsAddressValid`并判断`valid`是否为1，这里如果`valid`为0则该块内存无效，然后将`no_execute`置0即可获得可执行权限

```
PHardwarePte pde = GetPdeAddress(i);
PHardwarePte pte = GetPdeAddress(i);

if (MmIsAddressValid(pde) && pde->valid == 1)
{
    pde->no_execute = 0;
    pde->write = 1;
}

if (MmIsAddressValid(pte) && pte->valid == 1)
{
    pte->no_execute = 0;
    pte->write = 1;
} 
```

那么这里我们调用`SetExecute`函数将我们之前分配的可读可写内存修改为可读可写可执行权限

```
SetExecute(BaseAddress, size); 
```

然后使用`KeUnstackDetachProcess`还原cr3

```
KeUnstackDetachProcess(&kapc_state); 
```

[实现效果](#toc__4)
===============

在64位下`VadRoot`位于`EPROCESS`结构体的`7d8`偏移处

[![image-20220504221446105.png](https://storage.tttang.com/media/attachment/2022/05/04/03e9bb36-d370-484f-8afd-aba37fe5d6ce.png)](https://storage.tttang.com/media/attachment/2022/05/04/03e9bb36-d370-484f-8afd-aba37fe5d6ce.png)

起一个`notepad.exe`进程定位到`vad`树

[![image-20220504221800112.png](https://storage.tttang.com/media/attachment/2022/05/04/4ca2e997-7a7f-4a19-afbb-247687b4ba9d.png)](https://storage.tttang.com/media/attachment/2022/05/04/4ca2e997-7a7f-4a19-afbb-247687b4ba9d.png)

然后这里可以看到有97块内存

[![image-20220504221852378.png](https://storage.tttang.com/media/attachment/2022/05/04/2b35c1df-373c-404e-9a2a-c87de217d953.png)](https://storage.tttang.com/media/attachment/2022/05/04/2b35c1df-373c-404e-9a2a-c87de217d953.png)

我们加载一下驱动，可以看到修改了`pte`的值，将最高位的8改为了0，分配的这块内存地址为`222F5EB0000`

[![image-20220504223225749.png](https://storage.tttang.com/media/attachment/2022/05/04/a2bf02be-cef2-4cf4-bead-3d0d5d5a5da2.png)](https://storage.tttang.com/media/attachment/2022/05/04/a2bf02be-cef2-4cf4-bead-3d0d5d5a5da2.png)

我们看下没有加载驱动之前vad树里面是没有这块内存的

[![image-20220504223334000.png](https://storage.tttang.com/media/attachment/2022/05/04/9fb5406c-8ee6-4b5b-95c3-947689c793a4.png)](https://storage.tttang.com/media/attachment/2022/05/04/9fb5406c-8ee6-4b5b-95c3-947689c793a4.png)

加载驱动之后可以看到这是一块`READWRITE`内存

[![image-20220504223354777.png](https://storage.tttang.com/media/attachment/2022/05/04/7856bb4f-5506-4d7e-bd44-bce722365e4e.png)](https://storage.tttang.com/media/attachment/2022/05/04/7856bb4f-5506-4d7e-bd44-bce722365e4e.png)

这里定位到地址可以看到shellcode执行成功，证明这块内存已经修改为可执行内存，但是在vad树里面仍然显示为可读可写内存

[![image-20220504223943911.png](https://storage.tttang.com/media/attachment/2022/05/04/ba9fe5bf-432e-4ae6-8227-6bacf9b42023.png)](https://storage.tttang.com/media/attachment/2022/05/04/ba9fe5bf-432e-4ae6-8227-6bacf9b42023.png)