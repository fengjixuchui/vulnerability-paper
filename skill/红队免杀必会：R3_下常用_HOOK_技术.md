<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/58KtpwG1Pv6wfCxAUTVVJg)

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODv058icFziakGc3QJbCoicHZavCia2A6Kmf6Q0B68IwVE66fqiaPXl56QneZ1ZdTGA0o5Ln3oLBMhZJp2Q/640?wx_fmt=gif)

点击上方 “蓝字”，关注更多精彩

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavCRa1mmlZwXADCmOcPAMGBuaVA25wsVKKWUQpC7Xs8icRtnt2l1tJ3qg/640?wx_fmt=png)

**前言**

最近看了《加密与解密》，跟着大佬们的思路学习了 Hook 相关知识，如理解有误请不吝赐教，以免误导他人。

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavMh9NyJa1SmP1x7gib3JNRf4icp0wSotYJ12RqIxecRFBq4QaZNHlvQDQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavJZHLicqpdT6JYveyfibwDDR86nc7zj2f88CibuAHZVEdUgfUyspGeBkcQ/640?wx_fmt=png)

Inline HOOK
===========

API 函数都保存在操作系统提供的 DLL 文件中，当在程序中调用某个 API 函数并运行程序后，程序会隐式地将 API 函数所在的 DLL 文件加载入内存中，这样，程序就会像调用自己的函数一样调用 API。Inline Hook 这种方法是在程序流程中直接进行嵌入 jmp 指令来改变流程的。

简而言之，就是将函数开头修改为 jmp 指令，跳转到我们自定义的函数上去。

首先用 CreateProcessA API 写一个测试程序，功能很简单，程序启动后，按下任意键，调用 CreateProcessA 创建进程，为了直观这里是直接弹一个计算器：

```
#include <windows.h>
#include <stdio.h>
#include "createprocess.h"

#define EXE_PATH "C:\\Windows\\System32\\calc.exe"

BOOL CreateProcessR(char* szExePath) {
SECURITY_ATTRIBUTES psa = { 0 };
SECURITY_ATTRIBUTES tsa = { 0 };
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
BOOL Ret;
Ret = CreateProcessA(szExePath, NULL, &psa, &tsa, false, 0, NULL, NULL, &si, &pi);
//TerminateProcess(pi.hProcess, 0); //结束进程
return Ret;
}
int main(int argc,char *argv[]) {

system("pause");
CreateProcessR(EXE_PATH);

return 0;
}
```

下面就 HOOK CreateProcessA：

将生成的 EXE 拖到 Xdbg 中，定位到 CreateProceessA 这里，在调用 CreateProcessA 前有一段汇编代码：

mov edi edi,

push ebp

mov ebp,esp

16 进制：8B FF 55 8B EC

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavPMtPeIe9xc4PkgOW8bkRjU038vzMMhXn0JVz6jUFJrF3oPFkchSyGA/640?wx_fmt=png)

HOOK 的话肯定要准备一个自定义的函数， call addr ，假如它的地址为 12345678，那么我们 HOOK 的操作就是将上面的命令替换为：JMP 12345678，也就是 e9 addr。  

解除的 HOOK 的话就是将替换的字节恢复。

  Inline Hook 流程

1.  构造跳转指令。
    
2.  在内存中找到欲 Hook 函数地址，并保存欲 Hook 位置处的前 5 字节。
    
3.  将构造的跳转指令写入需 Hook 的位置处。
    
4.  当被 Hook 位置被执行时会转到自己的流程执行。
    
5.  如果要执行原来的流程，那么取消 Hook，也就是还原被修改的字节。
    
6.  执行原来的流程。
    
7.  继续 Hook 住原来的位置。
    

代码如下，关键步骤已注释：

```
//Myhook.cpp
#include "Myhook.h"

CHOOK::CHOOK()
{
MyFuncaAddress = NULL;
memset(MyOldBytes, 0, 5);
memset(MyNewBytes, 0, 5);
}

CHOOK::~CHOOK()
{
UnHOOK();
MyFuncaAddress = NULL;
memset(MyOldBytes, 0, 5);
memset(MyNewBytes, 0, 5);
}

BOOL CHOOK::Hook(LPSTR pszModuleName, LPSTR pszFuncName, PROC pfnHookFunc)
{
HMODULE hModule = GetModuleHandle(pszModuleName);
MyFuncaAddress = (PROC)GetProcAddress(hModule, pszFuncName);
if (MyFuncaAddress == NULL) {
return FALSE;
}
//读地址   将原来的5个字节的数据保存
ReadProcessMemory(GetCurrentProcess(), MyFuncaAddress, MyOldBytes, 5, 0);
//JMP ADDRESS JMP 123456789 E9
MyNewBytes[0] = '\xE9';
*(DWORD*)(MyNewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)MyFuncaAddress - 5;
WriteProcessMemory(GetCurrentProcess(), MyFuncaAddress, MyNewBytes, 5, 0);
return TRUE;
}
VOID CHOOK::UnHOOK()
{
if (MyFuncaAddress != NULL) {
WriteProcessMemory(GetCurrentProcess(), MyFuncaAddress, MyOldBytes, 5, 0);
}
return VOID();
}
BOOL CHOOK::ReHook()
{
if (MyFuncaAddress != NULL) {
WriteProcessMemory(GetCurrentProcess(), MyFuncaAddress, MyNewBytes, 5, 0);
}
return 0;
}
```

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。

#include "Myhook.h"

CHOOK MyHookObject;
BOOL
WINAPI
MyCreateProcessA(
   _In_opt_ LPCSTR lpApplicationName,
   _Inout_opt_ LPSTR lpCommandLine,
   _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
   _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
   _In_ BOOL bInheritHandles,
   _In_ DWORD dwCreationFlags,
   _In_opt_ LPVOID lpEnvironment,
   _In_opt_ LPCSTR lpCurrentDirectory,
   _In_ LPSTARTUPINFOA lpStartupInfo,
   _Out_ LPPROCESS_INFORMATION lpProcessInformation
)
{
   if (MessageBox(NULL, "是否拦截", "Notice", MB_YESNO) == IDYES)
  {
       MessageBox(NULL, "程序已拦截", "Notice", MB_OK);
  }
   else
  {
       MyHookObject.UnHOOK();
       CreateProcessA(
           lpApplicationName,
           lpCommandLine,
           lpProcessAttributes,
           lpThreadAttributes,
           bInheritHandles,
           dwCreationFlags,
           lpEnvironment,
           lpCurrentDirectory,
           lpStartupInfo,
           lpProcessInformation
      );
       MyHookObject.ReHook();
  }
   return true;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                      DWORD  ul_reason_for_call,
                      LPVOID lpReserved
                    )
{
   switch (ul_reason_for_call)
  {
   case DLL_PROCESS_ATTACH:
       MyHookObject.Hook((LPSTR)"Kernel32.dll", (LPSTR)"CreateProcessA",(PROC)MyCreateProcessA);
       break;
   case DLL_THREAD_ATTACH:
       break;
   case DLL_THREAD_DETACH:
       break;
   case DLL_PROCESS_DETACH:
       MyHookObject.UnHOOK();
       break;
  }
   return TRUE;
}
```

效果如下：

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavNqZGAbcH3iaWjlXicYTXkRlFfHvobbTbwcVbJib9QYQlPSV3WsJQ4WNcA/640?wx_fmt=png)

IAT Hook  

===========

IAT Hook 是 Address Hook 的一种方式，顾名思义就是通过修改函数的地址进行 Hook。

IAT（Import Address Table，输入表）是 PE 中的一种结构，如图：

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavNkyhibtldm7PddFmabXRhOYOQqzz7WFqxRiaY6Ak7pDhqHtET9c2BuibQ/640?wx_fmt=png)

再用一张图来理解导入表结构：  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavEqhnLOtQFmcKk8pTRomympoKN9j8G4t0G1FedW6dVwN5UhRb1qTWhQ/640?wx_fmt=png)

需要注意的是：因为 IAT 具体指某个 PE 模块的 IAT，所以他的作用范围只针对被 Hook 的模块，且必须在以静态链接的方式调用 API 时才会被 Hook，所以它的作用范围只针对被 Hook 的模块，且必须以静态链接的方式调用 API 时才会被 Hook，在使用 Loadlibrary 或 GetProcAddress 进行动态调用时不受影响。要想对已加载的所有模块起作用，就必须遍历进程内的所有模块，对目标 API 进行 Hook。

现在开始 Hook，这里是通过注入来 Hook 其他的程序，将代码写在 DLL 里面

为了保证原来的函数不受影响，我们先将要被 Hook 的函数的地址保存下来：

```
OldMesageBoxA = (FncMessageBoxA)GetProcAddress(GetModuleHandleA("user32.dll"), "MessageBoxA");
```

然后就是**解析 PE 文件，获取函数导入表中的函数地址表，并替换：**

解析 PE 文件前面已经学习过了，下面过程直接走一遍：

*   获取 DOS 头
    

```
 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
//当传入参数为NULL时，获取的是PE文件的imagebase，通过类型强制转换就获取到了dos_header
```

*   获取 NT 头
    

```
PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader->e_lfanew);
```

pDosHeader->e_lfanew 的数据类型为 **DWORD，**前面定义了 pDosHeader 的数据类型为 **PIMAGE_DOS_HEADER**，要和 pDosHeader 相加需将 pDosHeader 类型转换为 **DWORD**，最后再将得到的结果转换为 **PIMAGE_NT_HEADERS**。

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavHoX9BIXACWP3LEibHgwhH7bXedfmOfpturL53LINdBDAIBtWWC8JccA/640?wx_fmt=png)

*   获取扩展头
    
    ```
    PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)&pNtHeader->OptionalHeader;
    //扩展头是NT头的一个成员
    ```
    
*   从扩展头中获取数据目录表中的导入表
    

获取导入表前，要先找到它的偏移：

```
DWORD dwImportTableOffset = pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; //获取导入表偏移
```

获取导入表：

```
PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(DWORD)pDosHeader + dwImportTableOffset;
```

*   遍历导入表
    

有多个导入表结构，所以要遍历每个导入表：

因为导入表是依靠一个全零的结构来判断结束的，所以我们就采取对比 **pImportTable->Characteristics** 为 0 和 **pImportTable->FirstThunk** 为 NULL 时，来判断结束，然后在其中判断函数地址是否与我们所得到的原函数地址一致，如果一致说明找到了：

```
DWORD* pFirstThunk;
//遍历导入表结构
while (pImprotTable->Characteristics && pImprotTable->FirstThunk != NULL)
{
pFirstThunk = (DWORD*)(pImprotTable->FirstThunk + (DWORD)pDosHeader);
while (*(DWORD*)pFirstThunk != NULL)
{
//如果相当了，就说明当前的数组元素就是我们要找的函数地址表中的函数地址
if (*(DWORD*)pFirstThunk == (DWORD)OldMesageBoxA)
{
DWORD oldProtected;
VirtualProtect(pFirstThunk, 0x1000, PAGE_EXECUTE_READWRITE, &oldProtected);
DWORD dwFuncAddr = (DWORD)MyMessageBoxA;
memcpy(pFirstThunk, (DWORD*)&dwFuncAddr, 4);
VirtualProtect(pFirstThunk, 0x1000, oldProtected, &oldProtected);
}
pFirstThunk++;
}
pImprotTable++;
}
```

最后，为了保证程序的稳定，我们需要构造与被 HOOK 的函数一样结构的函数，同时为了保证原函数功能的正常运行，再定义一个函数指针，在自己的功能执行完成后，调用原来程序正常的功能：

```
typedef int
(WINAPI*
FncMessageBoxA)(
_In_opt_ HWND hWnd,
_In_opt_ LPCSTR lpText,
_In_opt_ LPCSTR lpCaption,
_In_ UINT uType);
FncMessageBoxA OldMesageBoxA = NULL;
int
WINAPI MyMessageBoxA(
_In_opt_ HWND hWnd,
_In_opt_ LPCSTR lpText,
_In_opt_ LPCSTR lpCaption,
_In_ UINT uType)
{
SECURITY_ATTRIBUTES psa = { 0 };
SECURITY_ATTRIBUTES tsa = { 0 };
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA(EXE_PATH, NULL, &psa, &tsa, false, 0, NULL, NULL, &si, &pi);
return 0;
}
```

要 HOOK 的 API 是 MessageBoxA (X32)，写一个简单的程序：

```
#include <windows.h>
int main() {
system("pause");
MessageBoxA(0, 0, 0, 0);
system("pause");
return 0;
}
```

要达到的目的是当测试程序运行时，注入 DLL，Hook 住 MessageBoxA，使其指向 CreateProcessA api：

正常运行：

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavdEJlzia9rFPibaoAygPVDpt1Uiag1X0CsqxoVP46jAqZaAbNI3gkq79UQ/640?wx_fmt=png)

Hook 后：  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavCZRomV1wdz7KT7Elv4evlicZVnzXpibJs9jEuVVFukzDy51X6KNAxXbA/640?wx_fmt=png)

VirtualTable（虚函数） Hook  

=========================

在代码编译为程序后，虚函数表就是一个固定的表了，它位于 PE 的. data 段。在对虚函数表进行 Hook 时，虽然原理也是查找原函数的位置，修改页面属性，写入 Detour 函数这样的过程，但是虚函数有些特殊。

同样是 Hook 地址，它不能像 IAT Hook 那样直接定义一个函数来替换目标函数，而必须把它定义为类的成员函数。我们知道面向对象的三要素: 封装、继承、多态 。在多态里有类特殊的是虚函数（以 virtual 修饰）， 32 位系统下，对象里有 4 个字节保存虚表的数组，其值为每一项虚函数的地址。

针对虚函数的 HOOK 就是通过保存对象中的虚表的值，针对每一项进行替换。

这次虚函数的 Hook 就在程序本身执行了，dll 注入的方式需要对程序进行逆向分析，暂时放一下：

```
#include <stdio.h>
#include <windows.h>

class MyClass
{
public:
MyClass();
~MyClass();
virtual void print();
private:

};

MyClass::MyClass()
{
}

MyClass::~MyClass()
{
}

void MyClass::print()
{
printf("hello\r\n");
}

void Myfunc() {
MessageBoxA(NULL, "hello", "title", NULL);
}
int main() {
MyClass obj;
MyClass& vobj = obj;
vobj.print();
//寻找虚表指针,虚表指针通常情况下位于对象的头4字节上
int nAddr = *(int*)&obj;
//更改内存属性
DWORD dwOldProtect = 0;
VirtualProtect((void*)nAddr, 0x100, PAGE_EXECUTE_READWRITE,&dwOldProtect);
//将自己的函数地址替换过去，前面说到了数组的值就是虚函数的地址，我们写的测试例子中就写了一个虚函数，所以其地址就是第一个值
(*(int*)nAddr) = (int)Myfunc;
VirtualProtect((void*)nAddr, 0x100, dwOldProtect,&dwOldProtect);
vobj.print();
system("pause");
}
```

效果如下：

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZav42gNEUP4YHNu3mMSdQHhHZSYSeD3PuItgTMJFficVribPs3CsLuibqLFA/640?wx_fmt=png)

HotPatch （热补丁）Hook  

=====================

热补丁 Hook 是微软提供的一种安全的 Hook 的机制，也是将函数开头修改为 jmp 指令，跳转到自定义的函数地址执行，和 IAT Hook 类似却又有不同。

以 IAT Hook 中的测试程序为例:

我们可以看到 CreateProcessA 函数的首字节为 **mov edi,edi（88 FF**），**这句汇编意思就是将 edi 的值放入 edi，实际上并没有什么用**。

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavId5sa8ybTle4NiadhuI6vbfYWmBe5AIjiamwicAzx21PRTlLvnL5qsrRw/640?wx_fmt=png)

我们还看到在这个 API 上边有大段的 int3 中断。这就给了我们一种新的 Hook 思路，即将前两个字节改为短跳转指令（EB E9），使其跳到函数上边五字节处，这五个字节的 int3 中断实际上就是一段空闲空间：  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavVh4rzCYjFmRn2vZxTY5pt727kFIQG3xmGXicaXGXjc8AXCVpZVcxLIg/640?wx_fmt=png)

然后再将这五个字节改为长跳转指令（E9 xxxxxxxx）。这样，即使 Hook 失败，也不影响函数的继续执行。  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavicKI3adAJiaydybrJnib70egcCBnkGjicLjSPpCZ2ZiaGHRTEy2CQoV6ibHw/640?wx_fmt=png)

这样，hook 函数的时候，先是一个短跳跳到自定义的函数然后执行。如果要恢原流程，则找到函数地址并 + 2，直接跳过 E8 F9 ，从 push ebp 开始执行。  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavkSvoPAn1ajI2uzgaZjibq2pJoCMBWG6mSgDt6eRQ6qUAK836dliaokqg/640?wx_fmt=png)

然后开始写代码, 有了其他 Hook 方式的经验，这次直接写一个通用的 Hook：  

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include <stdio.h>
#include <Windows.h>
#define EXE_PATH "C:\\Windows\\System32\\notepad.exe"

int
WINAPI MyFunc(
_In_opt_ HWND hWnd,
_In_opt_ LPCSTR lpText,
_In_opt_ LPCSTR lpCaption,
_In_ UINT uType)
{
SECURITY_ATTRIBUTES psa = { 0 };
SECURITY_ATTRIBUTES tsa = { 0 };
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA(EXE_PATH, NULL, &psa, &tsa, false, 0, NULL, NULL, &si, &pi);
return 0;
}


BOOL HOOK(const char* szModuleName, const char* szFuncName, PROC pfnFunc)
{
BYTE ShortJmp[2] = { 0xEB,0xF9 }; //短跳
BYTE LongJmp[5] = { 0xE9,0, }; //长跳
DWORD dwOldProtect = 0;
FARPROC pOldFuncAddr = (FARPROC)GetProcAddress(GetModuleHandleA(szModuleName), szFuncName); //找原函数地址
VirtualProtect((LPVOID)((DWORD)pOldFuncAddr - 5), 7, PAGE_EXECUTE_READWRITE, &dwOldProtect); //修改页保护属性
DWORD dwAddr = ((DWORD)pfnFunc - (DWORD)pOldFuncAddr);
*(DWORD*)(LongJmp + 1) = dwAddr;
memcpy((LPVOID)((DWORD)pOldFuncAddr - 5), LongJmp, 5);
memcpy(pOldFuncAddr, ShortJmp, 2);
VirtualProtect((LPVOID)((DWORD)pOldFuncAddr - 5), 7, dwOldProtect, &dwOldProtect); //还原页保护属性
return TRUE;
}

BOOL APIENTRY DllMain(HMODULE hModule,
DWORD  ul_reason_for_call,
LPVOID lpReserved
)
{
switch (ul_reason_for_call)
{
case DLL_PROCESS_ATTACH:
HOOK("User32.dll", "MessageBoxA", (PROC)MyFunc);
break;
case DLL_THREAD_ATTACH:
break;
case DLL_THREAD_DETACH:
break;
case DLL_PROCESS_DETACH:
break;
}
return TRUE;
}
```

还是以这个测试程序为例：  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavQ33UyRFyzwWX0B3A1tq5icxXwicOqpQIvOaplIxULABXO71QmPicmaa8A/640?wx_fmt=png)

将生成的 dll 注入，hook 后，当执行到 MessageboxA 时会劫持住它原来流程去执行 CreateProcessA，如图弹出了 notepad.exe:  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavK1ScLYA6ZMZwG8soZ1fLg9dq1F3xv843XOibAAQdTNRUSl6FLObJoaw/640?wx_fmt=png)

补充：并不是所有的 api 都能使用 HotPatch 的方式进行 Hook，比如 CreateProcess，当然或许是我代码写错了：)  

VEH 异常（基于软件断点） Hook
===================

简单介绍一下 windows 的异常机制：

Intel 在 386 开始的 IA-32 家族处理器中引入了**异常**和**中断**。中断是指外部硬件设备或异步事件引发的，而异常是由内部事件产生的，又可分为故障，陷阱和终止三类。故障和陷阱是可恢复的，终止是不可恢复的，如果出现了了终止异常，则需要重启操作系统解决。

Windows 中主要的异常处理机制：VEH、SEH、C++EH。

SEH：结构化异常处理。就是平时用的`__try` `__finally` `__try` `__except`, 是对 c 的扩展。

VEH：向量异常处理。一般来说用`AddVectoredExceptionHandler`去添加一个异常处理函数，可以通过第一个参数决定是否将 VEH 函数插入到 VEH 链表头，插入到链表头的函数先执行，如果为 1，则会最优先执行。

C++EH 是 C++ 提供的异常处理方式，执行顺序将排在最后。

在用户模式下发生异常时，异常处理分发函数在内部会先调用遍历 VEH 记录链表的函数， 如果没有找到可以处理异常的注册函数，再开始遍历 SEH 注册链表。

主要区分一下 SEH 和 VEH：

*   优先级：VEH 优先 SEH 调用。如果 VEH 处理了异常，则 SEH 无法处理该异常。
    
*   作用范围：SEH 机制基于线程，VEH 基于进程。就是说同一进程里的 A 线程无法用 SEH 捕获 B 线程的异常，而 VEH 在整个进程范围内都有效，可以捕获和处理所有线程产生的异常。
    
*   注册机制：SEH 的相关信息主要保存在栈中，而且后注册的回调函数总是处于 SEH 链的前端。当异常发生时，异常总是由内层回调函数优先处理，只有在内存回调函数不处理异常时，外部回调函数才有机会获得控制权。而 VEH 的相关信息保存在独立的链表中，在注册 VEH 时可以指定回调函数是位于 VEH 链表的首部还是尾部。
    
*   VEH 不需要栈展开。VEH 的实现不依赖栈，所以 VEH 在调用 VEH 回调函数前不需要栈展开，只有一次被调用的机会。而 SEH 的注册和使用依赖于函数调用的栈帧，在调用 SEH 回调函数时会涉及栈展开的问题，SEH 由两次被调用的机会。
    

然后开始写代码，主要流程如下：

*   1. 注册一个 VEH 异常回调
    
*   2. 找到一个 API
    
*   3.API 头部第一个字节改为 CC
    
*   4. 当 API 被调用，会执行 CC，然后触发 INT3 异常，接着异常被 VEH 回调接管，最后执行自定义函数
    

在调试模式下，当 MessageBox 被调用时，会触发 int3 异常：

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavtyfH4SqgH4fqvQp3Lv5C0ZPvPRLM294w59sSvhUdobrfay2YKLvbvQ/640?wx_fmt=png)

将项目编译为 PE 文件再次运行，已经成功 Hook：  

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavKgSf9cPz7dsH3fFxxhIkRYrYKtGsD2YevhFctZD8Qapm8ZmAJTgBMg/640?wx_fmt=png)

代码如下：  

```
#include <iostream>
#include <list>
#include <windows.h>
using namespace std;

struct EXCEPTION_HOOK {
   ULONG_PTR ExceptionAddress;
   UCHAR oldCode;

};
list<EXCEPTION_HOOK> HookInfo;

//1.注册一个VEH回调
//2.找到一个API
//3.API头部第一个字节改为CC
//4.当这个API被调用，就会执行到CC，然后出发int 3异常，然后异常被VEH回调接管，然后为所欲为。
LONG Handler(
   struct _EXCEPTION_POINTERS* ExceptionInfo
)
{
   for (list<EXCEPTION_HOOK>::iterator i = HookInfo.begin(); i != HookInfo.end(); ++i)
  {
       if (i->ExceptionAddress == (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress && ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
      {
           ULONG OldProtect;
           BOOL bRet = VirtualProtect((PVOID)ExceptionInfo->ContextRecord->Eip, 1, PAGE_EXECUTE_READWRITE, &OldProtect);
           if (!bRet)
          {
               cout << "属性修改失败" << endl;
               return FALSE;
          }
           *(UCHAR*)ExceptionInfo->ContextRecord->Eip = i->oldCode;
           //MessageBoxA 已经调用 cc中段 stack 中保存了传入的数据
           const char* szStr = "hello";
           *(DWORD*)(ExceptionInfo->ContextRecord->Esp + 0x8) = (DWORD)szStr;
           VirtualProtect((PVOID)ExceptionInfo->ContextRecord->Eip, 1, OldProtect, &OldProtect);
           return EXCEPTION_CONTINUE_EXECUTION;
      }
  }
   return EXCEPTION_CONTINUE_SEARCH;
}
BOOL Hook(ULONG_PTR ulAddress) {
   EXCEPTION_HOOK ExceptionInfo;
   ExceptionInfo.ExceptionAddress = ulAddress;
   for (list<EXCEPTION_HOOK>::iterator i = HookInfo.begin(); i != HookInfo.end(); ++i)
  {
       if (i->ExceptionAddress == ulAddress)
      {
           cout << "HOOK success" << endl;
           return FALSE;
      }
  }
   ULONG OldProtect;
   BOOL bRet = VirtualProtect((PVOID)ulAddress, 1, PAGE_EXECUTE_READWRITE, &OldProtect);
   if (!bRet)
  {
       cout << "属性修改失败！" << endl;
       return FALSE;
  }
   ExceptionInfo.oldCode = *(UCHAR*)ulAddress;
   *(UCHAR*)ulAddress = 0xCC;
   HookInfo.push_back(ExceptionInfo);
   BOOL bRet2 = VirtualProtect((PVOID)ulAddress, 1, OldProtect, &OldProtect);
   return TRUE;
}

int main()
{

   PVOID pVeh = AddVectoredExceptionHandler(1, (PVECTORED_EXCEPTION_HANDLER)Handler);
   if (pVeh == NULL)
  {
       cout << "AddVectoredExceptionHandler Failed" << endl;
       system("pause");
       return -1;
  }
   Hook(ULONG_PTR(MessageBoxA));
   MessageBoxA(0, 0, 0, 0);
   return 0;
}
```

如果要实现 Hook 其他程序，只需将函数写到 dll 文件中然后进行注入：

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include <stdio.h>
#include <Windows.h>

size_t MessageBoxAddr = (size_t)GetProcAddress(GetModuleHandleA("user32.dll"), "MessageBoxA");

struct EXCEPTION_HOOK
{
ULONG_PTR ExceptionAddress;
UCHAR OldCode;
};

EXCEPTION_HOOK HookInfo;

LONG NTAPI Handler(
struct _EXCEPTION_POINTERS *ExceptionInfo
) {
if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
{
if ((ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress == HookInfo.ExceptionAddress)
{
const char * szSrt = "hello";
*(DWORD *)(ExceptionInfo->ContextRecord->Esp + 0x8) = (DWORD)szSrt;
ExceptionInfo->ContextRecord->Eip += 2;
return EXCEPTION_CONTINUE_EXECUTION;
}
return EXCEPTION_CONTINUE_SEARCH;
}
}

VOID SetHook(ULONG_PTR Address)
{
DWORD dwOldProtect = 0;
VirtualProtect((LPVOID)Address, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect);
HookInfo.ExceptionAddress = Address;
HookInfo.OldCode = *(UCHAR *)Address;
*(UCHAR *)Address = 0xCC;
VirtualProtect((LPVOID)Address, 1, dwOldProtect, &dwOldProtect);
}


BOOL APIENTRY DllMain( HMODULE hModule,
                      DWORD  ul_reason_for_call,
                      LPVOID lpReserved
                    )
{
   switch (ul_reason_for_call)
  {
   case DLL_PROCESS_ATTACH:

AddVectoredExceptionHandler(1, Handler);
SetHook(MessageBoxAddr);
break;
   case DLL_THREAD_ATTACH:
break;
   case DLL_THREAD_DETACH:
break;
   case DLL_PROCESS_DETACH:
       break;
  }
   return TRUE;
}
```

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavPJzW0WWW1GzaJQ4yp141nygBAGE0u35YribMhicAibO049V07xt5R3Uxw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODsGoxEE3kouByPbyxDTzYIgX0gMz5ic70ZMzTSNL2TudeJpEAtmtAdGg9J53w4RUKGc34zEyiboMGWw/640?wx_fmt=png)

END

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODsGoxEE3kouByPbyxDTzYIgX0gMz5ic70ZMzTSNL2TudeJpEAtmtAdGg9J53w4RUKGc34zEyiboMGWw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODtIZ5VYusLbEoY8iaTjibTWg6AKjAQiahf2fctN4PSdYm2O1Hibr56ia39iaJcxBoe04t4nlYyOmRvCr56Q/640?wx_fmt=gif)

**看完记得点赞，关注哟，爱您！**

**请严格遵守网络安全法相关条例！此分享主要用于学习，切勿走上违法犯罪的不归路，一切后果自付！**

  

关注此公众号，回复 "Gamma" 关键字免费领取一套网络安全视频以及相关书籍，公众号内还有收集的常用工具！

  

**在看你就赞赞我！**

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODtaCxgwMT2m4uYpJ3ibeMgbThXaInFkmyjOOcBoNCXGun5icNbT4mjCjcREA3nMN7G8icS0IKM3ebuLA/640?wx_fmt=gif)

![](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODtaCxgwMT2m4uYpJ3ibeMgbTkwLkofibxKKjhEu7Rx8u1P8sibicPkzKmkjjvddDg8vDYxLibe143CwHAw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/96Koibz2dODuKK75wg0AnoibFiaUSRyYlmhIZ0mrzg9WCcWOtyblENWAOdHxx9BWjlJclPlVRxA1gHkkxRpyK2cpg/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODtaCxgwMT2m4uYpJ3ibeMgbTicALFtE3HLbUiamP3IAdeINR1a84qnmro82ZKh4lpl5cHumDfzCE3P8w/640?wx_fmt=gif)

扫码关注我们

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODtaCxgwMT2m4uYpJ3ibeMgbTicALFtE3HLbUiamP3IAdeINR1a84qnmro82ZKh4lpl5cHumDfzCE3P8w/640?wx_fmt=gif)

扫码领 hacker 资料，常用工具，以及各种福利

![](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODtaCxgwMT2m4uYpJ3ibeMgbTnHS31hY5p9FJS6gMfNZcSH2TibPUmiam6ajGW3l43pb0ySLc1FibHmicibw/640?wx_fmt=gif)

转载是一种动力 分享是一种美德