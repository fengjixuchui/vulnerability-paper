> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Mqq4DA7PKkb3g034mUrJ7w)

  

> 通过从 proc 文件系统入手，来检测可能的 ptrace 进程注入

探究
--

根据`man proc`的结果，在 `/proc/[pid]/status`的字段描述有这么一段

> * TracerPid: PID of process tracing this process (0 if not being traced).

说明可以从进程的`status`文件这个字段得到该进程的跟踪进程。

看一下对进程使用`ptrace`是否会设置这个字段。

由于`gdb`是基于`ptrace`实现的，可以使用`gdb`来检查一下效果。

> 可以下载`gdb`代码搜索`ptrace`验证

选用`oseec-remoted`进程做例子

```
[root@localhost code]# ps aux|grep remoted
ossecr      2238  0.1  0.3 1254156 14188 ?       Sl   Aug09   2:27 /var/ossec/bin/ossec-remoted


```

它的`pid`是 2238。可以看到它的`TracerPid`的值是 0

```
[root@localhost code]# grep "TracerPid" /proc/2238/status
TracerPid: 0


```

在另外一个窗口使用`gdb`附加到 2238 进程

```
[root@localhost buckxu]# gdb -p 2238 -q
Attaching to process 2238
[New LWP 2265]


```

这时，它的`TracerPid`的值变了

```
[root@localhost code]# grep "TracerPid" /proc/2238/status
TracerPid: 18669


```

看一下 18669 这个进程是哪个

```
[root@localhost code]# cat /proc/18669/cmdline 
gdb-p2238-q


```

可见，`TracerPid`字段确实可以知道哪个进程对另外一个进程使用`ptrace`。

那么，接下来的检测的思路就非常简单了。

检测思路
----

对`/proc`下的进程进行扫描：

1.  读取进程的`status`文件`TracerPid`字段
    
2.  如果字段为 0，则跳过，否则就看`/proc/<TracerPid>/cmdline`，获取程序信息
    
3.  把程序信息上报
    

分析端获取到上报数据后，就对照白名单，如果使用`ptrace`的程序不在白名单，那么就有可能是可疑程序，需要进一步分析了。

> 扫描的程序需要静态编译，使用`-static`，因为这样扫描出那些使用`/etc/ld.so.preload`来隐藏自身的进程。

缺点
--

一般`ptrace`注入过程时间非常短，而遍历`/proc`的时间会比较长，往往会错过那些快速注入的恶意进程。而把扫描频次调高，又会引起对系统性能的占用。

**暗号：94c89**