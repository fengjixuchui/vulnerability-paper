<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/K8tgxvuOdz11xKzbfOsB7Q)

![](https://mmbiz.qpic.cn/mmbiz_png/v7pS4bibUibhZic0lSiaMyNeTBdfhYD8Uk0vcGj43Ihia00tCkHXUJ68twHicy3wGr6dHGPtAcuWGN7mxvuLmUmRIjCg/640?wx_fmt=png)

**背景**

![](https://mmbiz.qpic.cn/mmbiz_png/B6m8Lp2cVfGwcyqSnEzXoyUTgQwkCSM863XlRTqgLCXcFzHHic78eQerK7AEao1QWVlRA3VJBR2o1OylibMaKiang/640?wx_fmt=png)

在 android 系统中，进程之间是相互隔离的，两个进程之间是没办法直接跨进程访问其他进程的空间信息的。那么在 android 平台中要对某个 app 进程进行内存操作，并获取目标进程的地址空间内信息或者修改目标进程的地址空间内的私有信息，**就需要涉及到注入技术**。

通过注入技术可以将指定 so 模块或代码注入到目标进程中，只要注入成功后，就可以进行访问和篡改目标进程空间内的信息，包括数据和代码。

Android 的注入技术的应用场景主要是进行一些非法的操作和实现如游戏辅助功能软件、恶意功能软件。

**下面主要进行对 zygote 注入、ptrace 注入、修改 so 文件注入，这三种注入方式进行详细解析。**

![](https://mmbiz.qpic.cn/mmbiz_png/v7pS4bibUibhZic0lSiaMyNeTBdfhYD8Uk0vcGj43Ihia00tCkHXUJ68twHicy3wGr6dHGPtAcuWGN7mxvuLmUmRIjCg/640?wx_fmt=png)

**zygote 注入**

![](https://mmbiz.qpic.cn/mmbiz_png/B6m8Lp2cVfGwcyqSnEzXoyUTgQwkCSM863XlRTqgLCXcFzHHic78eQerK7AEao1QWVlRA3VJBR2o1OylibMaKiang/640?wx_fmt=png)

zygote 是一个在 android 系统中是非常重要的一个进程，因为在 android 中绝大部分的应用程序进程都是由它孵化 (fork) 出来的，**fork 是一种进程复用技术**。也就是说在 android 系统中普通应用 APP 进程的父亲都是 zygote 进程。

zygote 注入目的就是将指定的 so 模块注入到指定的 APP 进程中，这个注入过程不是直接向指定进程进程注入 so 模块，而是先将 so 模块注入到 zygote 进程。

在 so 模块注入到 zygote 进程后，在点击操作 android 系统中启动的应用程序 APP 进程，启动的 App 进程中包括需要注入到指定进程的 so 模块，太都是由 zygote 进程 fork 生成，因而在新创建的进程中都会包含已注入 zygote 进程的 so 模块。

**这种的注入是通过间接注入方式完成的，也是一种相对安全的注入 so 模块方式。目前 xposed 框架就是基于 zygote 注入。**

**zygote 注入 so 模块流程**

1. 通过注入器将要注入的 so 模块注入到 zygote 进程；

2. 手动启动要注入 so 模块的 APP 进程，由于 APP 进程是通过 zygote 进程 fork 出来的，所以启动的 APP 进程都包含 zygote 进程中所有模块；

3. 注入的 so 模块劫持被注入 APP 进程的控制权，执行注入 so 模块的代码；

4. 注入 so 模块归还 APP 进程的控制权，被注入进程正常运行。

**Zygote 注入器的实现流程**

**(注入器主要是基于 ptrace 注入 shellcode 方式的进程注入)**

1.  通过 ptrace 进行附加到 zygote 进程。
    
2.  调用 mmap 申请目标进程空间，用于保存注入的 shellcode 汇编代码。
    
3.  执行注入 shellcode 代码（shellcode 代码是注入目标进程中并执行的汇编代码）。
    
4.  调用 munmap 函数释放申请的内存。
    
5.  通过 ptrace 进行剥离 zygote 进程。
    

**下面是关键的 zygote 代码注入实现**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMbDO3Qej0qbmia43Umx3dwicdITAmlUnbB8DLHBHrbQrMHTQHHhdDMQdw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMPGicYxiakuJwRlTZgUA6vr62YojjJkib4xMcu7xcnXV3DSkClNePYr1UQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyM7sd28ZibcrX4xanvfafyKibdD60kXK0OUyW3psrawB32ZrNAw6iaKflTQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/v7pS4bibUibhZic0lSiaMyNeTBdfhYD8Uk0vcGj43Ihia00tCkHXUJ68twHicy3wGr6dHGPtAcuWGN7mxvuLmUmRIjCg/640?wx_fmt=png)

**ptrace 注入**

![](https://mmbiz.qpic.cn/mmbiz_png/B6m8Lp2cVfGwcyqSnEzXoyUTgQwkCSM863XlRTqgLCXcFzHHic78eQerK7AEao1QWVlRA3VJBR2o1OylibMaKiang/640?wx_fmt=png)

**ptrace 注入实现上分类：**

1.  通过利用 ptrace 函数将 shellcode 注入远程进程的内存空间中，然后通过执行 shellcode 加载远程进程 so 模块。
    
2.  通过直接远程调用 dlopen、dlsym、dlclose 等函数加载被注入 so 模块，并执行指定的代码。
    

**ptrace 直接调用函数注入流程：**

1.  通过利用 ptrace 进行附加到要注入的进程；
    
2.  保存寄存环境；
    
3.  远程调用 mmap 函数分配内存空间；
    
4.  向远程进程内存空间写入加载模块名称和函数名称；
    
5.  远程调用 dlopen 函数打开注入模块；
    
6.  远程调用 dlsym 函数或需要调用的函数地址；
    
7.  远程调用被注入模块的函数；
    
8.  恢复寄存器环境；
    
9.  利用 ptrace 从远程进程剥离。
    

**关键的 ptrace 直接调用系统函数实现**  

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMp6Rhl51WHCpRhpQT7LcUwoyKKxViaOnkVRWy9ErUAoQicqgxWSbHV12Q/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMlGDN8Nyq0v9E1WTG9maXneBc5rhDKMiabQCiaicICr5s6HqR5Q1mRFtaA/640?wx_fmt=png)

**ptrace 的 shellcode 注入原理**

shellcode 注入就是通过将 dlopen/dlsym 库函数的操作放在 shellcode 代码中，注入函数只是通过对远程 APP 进程进行内存空间申请，接着修改 shellcode 代码中有关 dlopen、dlsymdlclose 等函数使用到的参数信息，然后将 shellcode 代码注入到远程 APP 进程申请的空间中，最后通过修改 PC 寄存器的方式来执行 shellcode 的代码。

**ptrace 注入 shellcode 的详细步骤**

1. 在 shellcode 中编写好 dlopen、dlsym 等函数的调用，来加载 so 模块和执行函数，但需要将参数地址、函数地址、寄存器地址先随便填充值为我们真实地址保留；

2. 附加到远程 APP 进程、保存 APP 进程中寄存器的数据，为后面恢复远程进程的继续执行准备；

3. 向远程 APP 进程申请内存空间，选好 shellcode 存放的具体位置，准备存放 shellcode 和参数数据；

4. 计算本地 so 模块函数对应到，远程 APP 进程中的 so 模块函数地址，填充到 shellcdoe 中的参数中。计算好库函数参数、寄存器存值相对 shellcode 起始位置的偏移再加上远程进程中 shellcode 存放的起始位置，得到的结果就是远程进程的内存空间中这些参数存放的位置，将这些地址填充到 shellcode 的参数中；

5. 设置寄存器的值来让执行库函数；

6. 恢复寄存器的值让远程进程继续正常执行。

**关键 的 ptrace 注入 shellcode 代码实现**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMicI0bmOTia7f07zPrhRf6bYl80gDrsUAe8nLsp6iaRucEicmHJYDnjCOjQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMt8ZgXbmTxibiaNHSnzH8SMricrrCxDZjWWwxfAArtWmn6NibEgw22CTtHw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/v7pS4bibUibhZic0lSiaMyNeTBdfhYD8Uk0vcGj43Ihia00tCkHXUJ68twHicy3wGr6dHGPtAcuWGN7mxvuLmUmRIjCg/640?wx_fmt=png)

**修改 ELF 文件注入**

**![](https://mmbiz.qpic.cn/mmbiz_png/B6m8Lp2cVfGwcyqSnEzXoyUTgQwkCSM863XlRTqgLCXcFzHHic78eQerK7AEao1QWVlRA3VJBR2o1OylibMaKiang/640?wx_fmt=png)**

在 android 平台 Native 层的可执行文件 SO 文件，它是属于 ELF 文件格式，通过修改 ELF 文件格式可以实现对 so 文件的注入。

通过修改 ELF 二进制的可执行文件，并在 ELF 文件中添加自己的代码，使得可执行文件在运行时会先执行自定义添加的代码，最后在执行 ELF 文件的原始逻辑。

**修改二进制 ELF 文件需要关注两个重要的结构体：**

**ELF Header、Program Header Table**

其中 ELF Header 它是 ELF 文件中唯一的，一个固定位置的文件结构，它保存着 Program Header Table 和 Section Header Table 的位置和大小信息。

**Program Header Table 它保存 ELF 文件的加载过程中各 Section 的内存映射和依赖库相关信息，用来告诉 android 系统中如何创建进程映像。**

修改 ELF 文件实现 so 文件注入实现原理为：通过修改 Program Header Table 中的依赖库信息，添加自定义的 so 文件信息，APP 进程运行加载被该修改过的 ELF 文件，它也同时会加载并运行自定义的 so 文件。

**Program Header Table 表项结构**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyM8XuqI1m6icmYmLGLF1gPpViaicpBwssuXbzXNHzibHpzPB17gPMmSN2Zxw/640?wx_fmt=png)

**程序头表项中的类型选项有如下**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMsfxQc5LboQg5eByfMxIkH9wIf9nAiaCoOSWIzSD4pWQdC9S0iaPV0gfg/640?wx_fmt=png)

当程序头表项结构中的类型为 PT_DYNAMIC 也就是动态链接信息的时候，它是由程序头表项的偏移 (p_offset) 和 p_filesz(大小)指定的数据块指向. dynamic 段。这个. dynamic 段包含程序链接和加载时的依赖库信息。

**修改 ELF 文件的注入实现过程**

1. 修改. dynamic 段指向的字符串表中添加 自定义的 so 模块名称；

2. 通过修改 Program Header Table 中添加 PT_LOAD 表项，新添加的表项将保护 so 模块名称的字符串表数据映射到内存中。同时将 Program Header Table 移动到文件末尾；

3. 修改. dynamic 段的数组数据，使得指向新的字符串表，并指向自定义的 so 模块名称；

4. 修改 ELF HEADER 结构中 Program Header Table 的位置信息，并指向新的 Program Header Table。

**关键 ELF 文件修改代码实现**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMezm16G5WpewG0q7Mw85Ic99nv0zsKWDB1zdHpiaibPFPhLZdo1YezSFQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5J76mSdwI5ePCz0SL9KYyMqwJf3icsssobBJs0meoD7WDibXOzz04oJSX61TK4iaTES4OwtG1VqqNNA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/AP7uYGaic65eecXicbzickFEbg36XW3HLu8Eia6SlqAnewYKsTLBOCRc1UiaAQKCZg30AZu4tFv4sYOY08GnpjRiau8g/640?wx_fmt=png)

E N D

![](https://mmbiz.qpic.cn/mmbiz_png/IYjOKYiazV1iaUatQzJKmFn3FhlZt2aMNibdXAeLbiclsALJO7riaWgZYNXm1GlfZbsIp9Cvd3ic9JXW4X6MZmHIYibYA/640?wx_fmt=png)

公众号

![](https://mmbiz.qpic.cn/mmbiz_png/fZBTYwCDQsg0e77vU3AJEzgntvp6orI7SnQPfN20x4vPa9rlKPtXkib9ejY2QSYg3Rkm3km3cb5JB2g9NwOib8ow/640?wx_fmt=png)

点个赞、在看你最好看