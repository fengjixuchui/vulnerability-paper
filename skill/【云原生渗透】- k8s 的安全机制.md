<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/SczjHY4ptUBmTUGzkhaTfw)

1. 认证阶段 2. 鉴权阶段 3. RBAC、角色、账号、命名空间参考链接

访问 k8s 集群的时候，需要经过三个安全步骤完成具体操作。过程中都要经过 apiserver，**apiserver 做统一协调**。

第一步 **认证**，判断用户是否为能够访问集群的合法用户。

第二步 **鉴权**，通过鉴权策略决定一个 API 调用是否合法。

第三步 **准入控制**，就算通过了上面两步，客户端的调用请求还需要通过准入控制的层层考验，才能获得成功的响应。大致意思就是到了这步还有一个**类似 acl 的列表**，如果列表有请求内容，就通过，否则不通。它以插件的形式运行在 API Server 进程中，会在鉴权阶段之后，对象被持久化 etcd 之前，拦截 API Server 的请求，对请求的资源对象执行自定义（校验、修改、拒绝等）操作。

这里学习认证和鉴权的安全机制。

1. 认证阶段
-------

认证策略大概有 4 种：

**匿名认证**：（Anonymous requests）

匿名认证一般默认是关闭的。

**白名单认证**：（BasicAuth 认证）

白名单认证一般是服务启动时加载的 basic 用户配置文件，并且通常没有更多设置的话 basic 认证仅仅只能访问但是没有操作权限。

**Token 认证**：（Webhooks、ServiceAccount Tokens、OpenID Connect Tokens 等）

token 认证更涉及到对集群和 pod 的操作，这是我们比较关注的。

**X509 证书认证**：（clientCA 认证，TLS bootstrapping 等）

X509 证书认证是 kubernetes 组件间内部默认使用的认证方式，同时也是 kubectl 客户端对应的`kube-config`中经常使用到的访问凭证，是一种比较安全的认证方式。

2. 鉴权阶段
-------

当 API Server 内部通过用户认证后，就会执行用户鉴权流程，即通过鉴权策略决定一个 API 调用是否合法，API Server 目前支持以下鉴权策略：

**Always**：当集群不需要鉴权时选择 AlwaysAllow

**ABAC**：基于属性的访问控制

**RBAC**：基于角色的访问控制

RBAC 是目前 k8s 中最主要的鉴权方式。

**Node**：一种对 kubelet 进行授权的特殊模式

Node 鉴权策略主要是**用于对 kubelet 发出的请求**进行访问控制，限制每个 Node 只访问它自身运行的 Pod 及相关 Service、Endpoints 等信息。

**Webhook**：通过调用外部 REST 服务对用户鉴权

可自行编写鉴权逻辑并通过 Webhook 方式注册为 kubernetes 的授权服务，以实现更加复杂的授权规则。

3. RBAC、角色、账号、命名空间
------------------

RBAC，基于角色的访问控制（Role-Based Access Control）

在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，**权限赋予给角色**，而把**角色又赋予用户**，这样的权限设计很清楚，管理起来很方便。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoibCqD0othUbpmYiafzZNUs4JK9loj0nickQkvBuAqlKMGVO72pCzwX384Q/640?wx_fmt=png)

在 k8s 中，只有对角色的权限控制，访问主体都必须通过角色绑定，绑定成 k8s 集群中对应的角色，然后根据绑定的角色去访问资源。而每种角色又只能访问它所对应的命名空间中的资源。

**命名空间**

k8s 支持**多个虚拟集群**，它们底层依赖于同一个物理集群。这些虚拟集群被称为**命名空间**（namespace）。

```
# 查看命名空间
kubectl get ns

```

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoib7OUPaAftqPicMT193qKknx5rg2FrH0DhSYlpiaUdghuiaia0BO4UzwXdgw/640?wx_fmt=png)

系统默认 4 个命名空间，分别是：

**default**：没有指明使用其它命名空间的对象所使用的默认命名空间

**kube-system**：Kubernetes 系统创建对象所使用的命名空间

**kube-public**：此命名空间下的资源可被所有人访问（包括未授权用户）

**kube-node-lease**：集群之间的心跳维护

重点关注 **default** 和 **kube-system** 两个命名空间。

**角色分配**

RBAC 中一直强调角色，这里角色也分为两种，一种是普通角色 **role**，一种是集群角色 **clusterrole**。

普通角色 role 用于平常分配给运行的容器，而集群角色更多承担管理工作。

查看普通角色，没有特别指明的话查看都是在 default 空间中。

指定 kube-system 空间，可以看到很多系统自带的角色。

```
kubectl get role -n kube-system

```

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoib0zLOBuMc1Vy7Z8vpVyzl1m9s2tWOR62hERf8gPzPzE40PBp37wyQsg/640?wx_fmt=png)

集群角色在 default 和 kube-system 中都是一样的。

```
kubectl get clusterrole

```

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoibp9FvYS4AqtNcVeKkWzcKyQ0jiauW0zk7M9QEqIfF1aR5hFd38jZMpoQ/640?wx_fmt=png)

集群中有个最高权限角色 cluster-admin，它的拥有集群所有资源的所有权限。因此如果访问主体绑定到该角色的话，就会引发很大的安全问题，后续说到的未授权访问就是基于此种情形。

普通的 admin 权限也比较大，但是比起 cluster-admin 还是差了太多。

角色权限授予用户：

```
# 创建一个clusterrolebinding，名称为cluster-admin
# --clusterrole=cluster-admin 角色
# --user=user1 授权给user1用户
# --group=group1 授权给group1组

kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-admin --user=user1 --user=user2 --group=group1

```

**服务账号 service account**

访问主体中除了常用的用户，组以外，还有一类叫做服务账号，**service account**。service account 是 k8s **为 pod 内部的进程访问 apiserver 创建的一种用户**。因为是 pod 里面的，所以也会对应各自的命名空间。

在 k8s 中设计了一种资源对象叫做 Secret，分为两类，其中一类是容器运行时配置的敏感信息（如密码等），另一类就是**用于记录 ServiceAccount 的 service-account-token**。

看看 kube-system 中的 secret 存储的 serviceaccount 信息。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoibNNYrCxsTPicVf3GWvxwjpAVh3fyZejeak5mDicib73XhWq5fKKXEwiaV1w/640?wx_fmt=png)

可以看到很多 serviceaccount name，每个 name 下都有 3 个标识，**分别是 Token**、**ca.crt**、**namespace**。

token 是使用 API Server 私钥签名的 JWT。用于访问 API Server 时，Server 端认证。

ca.crt，根证书。用于 Client 端验证 API Server 发送的证书。

namespace, 标识这个 service-account-token 的**作用域名空间**，这里的 namespace 就是 kube-system。

举个例子：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUHOcuUdvcgkvz8NmCBbkoib60ia6wKrq21qAlZYkmTHeBLNCGCqrXN9A16tGcXp8gj34T4QibAInh9w/640?wx_fmt=png)

**账号名**在 - token 前，就叫 default。

给这个服务账号绑定 cluster-admin 这个角色：

```
kubectl create clusterrolebinding default-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default

# namespace:账号名

```

我们把这个账号赋予新角色名 default-admin，成功绑定到集群角色 cluster-admin 了，这就意味着我们的 default 这个 serviceaccount 拥有了集群最高权限，自然以它建立的 pod 也是集群最高权限的 pod。

参考链接
----

[https://mp.weixin.qq.com/s/T2QGLlKwjaUByDtGFL94PQ](https://mp.weixin.qq.com/s?__biz=MzIxNTIzMzM1Ng==&mid=2651104364&idx=1&sn=a22dac0da090751552d46a8b622bfbbc&scene=21#wechat_redirect)