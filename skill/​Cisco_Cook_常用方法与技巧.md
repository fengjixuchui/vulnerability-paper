<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/0gfjSa0Q21qFovIhpKfeLw)

在之前公众号的文章中对 Cisco IOS 整体进行了一些介绍 ([https://mp.weixin.qq.com/s/L030HpZGX_JglySsin7WzA](http://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247493251&idx=1&sn=dfb2736408b8d8c2e51e21564b114efc&chksm=e89dce5bdfea474d800240c12030be0a12577ef6b9f944cfd5bb9f6cb64652004baea5c6b16f&scene=21#wechat_redirect))，今天介绍一下具体的一些常用方法与技巧。

### 一、介绍

#### 1.Cisco 近几年的安全漏洞：

Cisco 近几年披露了诸多的安全漏洞。The Holy Grail Cisco IOS Shellcode And Exploitaion Techniques---Michael Lynn：披露如何绕过 Cisco 堆检查；GeekPwn 大会上的相关内容；以及众多主要的漏洞：IKEv2 Exploit（cve-2016-1287）、EXTRABACON（snmp 协议）、IKEv1 Exploit（cve-2016-1287）、Cisco Cluster Management Protocol（CMP）（cve-2017-3881）…..

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPlqU5h7YCT5ATWLvM2fOGSswRHUkkhRtzSNwMdfPibfnrarKjbVpibjUxQ/640?wx_fmt=png)

#### 2.Cisco diversity  

Cisco 的多样性是其一项标志性特征，主要分为系统多样性和指令架构多样性。  
系统多样化：Cisco IOS、Cisco IOS XE、Cisco NX-OS、Cisco IOS XR、ASA OS    
指令架构多样化：PowerPC、MIPS、x86_64

#### 3. 常见目标特征：

（1）需要对 Cisco IOS 固件进行逆向分析    
（2）通常镜像都是一个大型二进制文件，需要静态分析    
（3）在 IOS 中，所有代码都是在提权模式下进行，因此可以使用特权指令    
（4）在 IOS 中，好几段虚拟内存可能映射的是同一段物理空间（例如 20000000 与 80000000）    
（5）溢出执行完 shellcode 要将控制流返回至正常服务    
（6）当 IOS 服务触发异常时，Cisco IOS 会重启设备（dos 攻击很简单，RCE 需要再构造）    
Cisco IOS 没有其他的 API 函数或者指令支持，因此如果想调用里面的一些功能（比如 tcp 连接），需要去定位相关的功能函数

#### 4. 常见防护：

（1）DEP：栈、堆等内存中不可执行，要做 ROP 攻击  
（2）ASLR：栈、堆具有随机化特征，要绕过地址随机化  
（3）堆检查：IOS 会在固定时间检查堆结构，在堆释放的时候也会进行堆检查（具体的检查方法在之前的公众号文章里有讲），而且 IOS 的栈的空间也是在堆中的，因此栈溢出和堆溢出利用都可能被检查  
（4）代码完整性检查：完整性检查会是否在镜像文件里植入了后门或者 shellcode（一般利用签名）  
（5）计时器：如果 shellcode 运行时间太久，计时器会触发然后终止攻击进程  
（6）Cisco 多样化：思科镜像多样性，exp 在镜像间的移植需要时间  
（7）I-cache、D-cache 防护：Powerpc 架构的处理器会隔离代码区域和数据区域，因此有时候将控制流劫持到数据区域是无法执行的

#### 5.Cisco IOS 漏洞利用整体思路：

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPl2pf1C0mVDyzL38a69qRau5kZgmPvDeRWyR4gqPmiaz0iaxlV29z9jt4A/640?wx_fmt=png)

### 二、常用 cook 方法：  

#### 1.Exploit Debugging：

想要实现漏洞利用首先是需要能执行漏洞调试，这里主要介绍两种调试方式。  
虚拟平台调试：  
①安装 Cisco dynamips 调试平台（并支持 gdb 调试版本）：

```
git clone https://github.com/Groundworkstech/dynamips-gdb-modcd dynamips-gdb-mod/srcupdatedblocate libelf.a
```

②利用 dynamips 启动对应的模拟调试：

```
dynamips -Z +连接的端口 -j（禁用JIT编译器） -P +模拟的硬件平台 -t 2621 -s 0:0:tap:tap1 -s 0:1:linux_eth:eth0 +镜像文件
```

③利用 gdb 连接调试：  
注意，这里用的 gdb 连接调试需要使用对应架构的 gdb，有两种解决方案：  
一是利用 gdb-multiarch；二是利用 buildroot 或者交叉编译工具链交叉编译一个对应架构的 gdb 调试工具。

```
gdb$ target remote 192.168.9.1:6666
```

虚拟调试平台脚本：https://github.com/Groundworkstech/dynamips-gdb-mod

实体设备调试：  
虽然虚拟平台调试比较方便，但是有很多版本以及型号的限制，因此最好使用实体设备进行调试。实体设备调试需要利用 cisco 设备自带的调试栈开启调试。  
①实体设备连接：  
首先进行串口调试配置，对于 Linux 系统，需要指定串口驱动程序。因此需要先查找相应串口驱动模块：

```
lenovo@ubuntu:~$ dmesg l grep ttyS*[      0.00000] console [tty0]enabled[838830.952225] usb 2-2.1:FTDI USB serial Device converter now attached to ttyUSB1[844005.477214] ftdi_sio ttyUsB0: FTDI USB Serial Device converter now disconnected fron ttyUSB1[1471721.288079] usb 2-2.1:FTDI USB serial Device converter now attached to ttyUSB1
```

利用串口通信工具连接至指定串口驱动模块，并设置 Cisco IOS 串口通信的硬件信息，即可建立连接：

```
lenovo@ubuntu:~$ sudo picocom -b 9600 /dev/ttyUSB1picocom v1.7port is   : /dev /ttyUSB1flowcontrol   : nonebaudrate is   : 9600parity is   : nonedatabits are   : 8
```

②使用 gdb kernel 在实体设备上启动 gdb 调试模式：

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPl0QItric8nWmXHs8w7zIusicS6r9WwibCgqiaG6YuicN5OuOP113eVI7RTvw/640?wx_fmt=png)

对于 Cisco IOS 新版本，会屏蔽相应调试功能，需要进入 ROMMON 中开启调试功能。

```
rommon1>confreg 0x2100C1921(config)#config-register 0x2100MIPS: break ‘0000000d’PPC:trap ‘7fe00008’
```

③利用调试脚本连接对应串口，实现调试功能：

```
python 调试脚本.py /dev/ttyUSB1
```

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPlMPOxs9dKMoT0gCQHqXQ1gZLy2CmdX3flQ78r5Rr9KlkkUIfwibkVLhA/640?wx_fmt=png)

调试脚本参考：  
https://github.com/klsecservices/ios_mips_gdb  
https://gist.github.com/nstarke/50a1519067f62c223e39a98ba32ed7d5  
        mips、arm 和 ppc 的调试脚本其实都大同小异，甚至可以自己编写修改调试脚本，注意对应不同的架构时，要修改 capstone 的对应架构，以及设置断点时的寄存器数值。

#### 2. 获取控制流：

通常利用栈溢出漏洞获取控制流（Phrack Magazine Burning the bridge Cisco IOS exploits (2002)）

#### 3.DEP 绕过：

利用 ROP 攻击绕过 DEP 防护，对于 ppc 指令，可以通过常见返回指令去找 gadgets：blr blrl bctr bctrl  
常见 ROP 利用技巧：    
（1）利用 ROP gadgets 直接构造 shellcode（cve-2017-3881）  
（2）利用 gadgets 直接重写指定数据甚至代码，看能不能起到效果  
（3）利用 gadgets 去禁掉 DEP 防护，然后在栈上执行 shellcode  
（4）开启在代码段的写权限  
ROP 攻击限制：ROP 攻击可能导致在栈上存放过多的数据（因为 shellcode 长的话，要在栈上构造很多个 gadgets 的地址），这样容易触发堆检查机制或者是影响其他的正常数据，因此在栈上不能构造太长的 ROP 攻击。

#### 4.Gadgets 构造的拓展技巧：

（1）Write-4 Primitive  
（参考 34c3 交流会议）因为前面所说，不方便构造太多的 gadgets，因此可以利用几个简短的 gadgets（这几个 gadgets 的功能就是向内存写一段在栈上存放的 4 字节的数据），将想执行的 shellcode 每 4 字节逐次写到内存中，最后再劫持控制流到内存中即可。这样的话 shellcode 不论长短，都可以写到内存中，因此不需要在栈上构造过长的 gadgets。  
在 mips 和 ppc 上都有这种类似的 write-4 的 gadgets：

```
lwz     r0,0x14(r1)mtlr    r0lwz     r30,8(r1)     #valuelwz     r31,0xC(r1)   #dst addressaddi    r1,r1,0x10blrstw     r30,0(r31)    #store valuelwz     r0,0x14(r1)mtlr    r0lmw     r30,8(r1)addi    r1,r1,0x10blr
```

（2）Blrl Gadgets  
由于 C 语言和 PowerPC 架构的调用约定，想找到从栈向 r3-r17 寄存器加载的 gadget 比较难，但是此类 gadget 又很常用，因为从 r3 开始的低号寄存器是 PPC 架构的传参寄存器，经常需要利用这种 gadget 向调用函数传参。  
解决方法一：可以分几个阶段，先初始化寄存器，再向大号寄存器进行传参（这种 gadget 很多），然后利用大号寄存器向小号寄存器进行赋值操作。这种办法可以，但是有点麻烦，浪费堆栈空间。  
解决方法二：利用 blrl gadget，blrl gadget 通常具有几个特点：通常都结合低号寄存器使用，而且通常比较多样，因此可以利用 blrl gadget，节省堆栈空间。

```
lwz     r5,0xC(r1)    #Load Word and Zeromr      r6,r20        #Move Registermtlr    r27           #Move to link registerblrl                  #Branch unconditionally
```

（3）Indirect Call Gadgets  
有时候 ROP 攻击的 shellcode 比较复杂，需要调用各类函数，比如 memcpy 函数，或者是禁止安全机制的函数，或者是调用另一个 shellcode，特别是当这些函数位于其他区段时，利用 Indirect Call Gadget 可以解决。

```
1.mtlr    r28        #Move to link register  blrl               #Branch unconditionally  lwz     r0,0x1C(r1)  mtlr    r02.mtctr   r0         #Move to count register  bctr3.mtctr   r31        #Move to count register  mr      r3,r30     #Move Register  bctrl              #Branch unconditionally  lwz     r0,0x10+arg_4(r1)  mtlr    r0
```

（4）Multitask Gadget  
有些一个 Gadget 可以执行多个功能，例如在栈上存储数据，下面就是一个例子，可以同时执行 3 个功能：

```
mtctr    r29          #Move to count registerbctrl                 #1st taskmtlr     r28          #Move to link registerblrl                  #2nd tasklwz      r0,0x1C(r1)mtlr     r0           #Move to link registerlwz      r28,8(r1)    #3rd tasklwz      r29,0xC(r1)lwz      r30,0x10(r1)lwz      r31,0x14(r1)addi     r1,r1,0x18   #Add Immediateblr
```

（5）Stack Keeper  
功能就是保存一下当前的栈指针，其实就是对 r1 寄存器进行一下赋值操作：

```
mr     r3,r1     #Move Registerblr              #Branch unconditionally
```

（6）Debug Gadget  
Debug gadget 是用来调用调试器的。

```
trap         #Trap Word Unconditionallyblr          #Branch unconditionally
```

上述只是对一些重要 gadgets 的举例，其中 Write-4 Primitive 是重要的构造技巧，因为可以实现很多 shellcode 的写入与执行。

#### 5. 调试中的地址随机化问题：

Cisco IOS 固件在 IDA 的解析中基址固定不变，但是某些型号的设备其 IOS 加载地址随机变化，但是可以通过指令计算 IOS 加载偏移：

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPliaqpCSxfvfSGJxLNTMIFmY777ibDuJ7CsNH3Gd3W7BUJecnlaNib3SVBg/640?wx_fmt=png)

根据 show region 得出的加载基址，同 IDA 加载基址进行偏移的计算，即可得出偏移量，然后对比 IDA 和实体设备 gdb 调试得到的汇编代码，解决 ASLR 问题。

#### 6. 漏洞利用中的代码随机化问题：

前面讲到，Cisco IOS 具有 DEP 防护机制，这种机制可以通过 ROP 攻击绕过，但是当代码段也存在地址随机化时，无法直接在栈上布置指定地址的 Gadgets，但是这个问题可以通过 ROMMON 解决。  
ROMMON 在内存中的加载地址一直不会变化，因此可以利用 ROMMON 中的代码构造 ROP 攻击。整体流程可以分为以下三步：  
（1）首先利用栈溢出，劫持返回地址进入 ROMMON 部分，构造 ROP 链。  
利用 ROP 攻击，通过 write-4 primitive 方法将 shellcode 写入内存。  
将 shellcode 写入内存段后，再构造栈溢出，控制流劫持到该内存区域，执行 shellcode。

#### 7. 利用路由器崩溃

Cisco IOS 可以将崩溃信息写道内存卡里或者闪存里，也可以通过 TFTP 服务器传到远端。不同版本路由器可能提供的转储信息记录功能不相同，但是基本信息都是可以记录的，可以通过路由器 crash 文件追踪漏洞所在位置。崩溃转储功能要进行一下配置。

```
radio#conf tEnter configuration commands，one per line. End with CNTL/Z.radio (config) #exception core-file radio-coreradio (config) #exception dump 192.168.2.5radio (config) #^2
```

### 三、cook 实例

2017 年，Cisco 官网披露并修复了 SNMP 协议中存在的漏洞，漏洞使得攻击者发送构造好的 SNMP 数据包，实现 Dos 攻击或 RCE 攻击。  
以 C1900 系列路由器为例，该漏洞位于 SNMP 服务处理函数中：

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPl36nBPuHSGrBHxtb1lWpqIlYaA7Ip197zvaIpoJ2OS4YAiaicM0cshPfw/640?wx_fmt=png)

其调用子函数 sub_23BEC474 进行处理，子函数主要功能为对 v19 地址进行赋值操纵，v19 在子函数中为参数 a1，主要功能为对 a1 地址进行赋值，写入长度由 a3 控制。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPl1qP6IkawcUo4oL0BucRJwtZCqukEalbBabbe8h62RktLG4OlPvLf0g/640?wx_fmt=png)

在子函数 sub_23BEC474 函数中，存在栈溢出漏洞。父函数的 v19 是长度为 16 的数组，存放在栈空间上，而子函数的赋值操作的次数可以人为控制，并且该函数的赋值操作没有额外的检查，因此会造成栈溢出。该函数赋值操作过长，会使栈上的 v19 所在地址的栈空间溢出，影响栈结构，造成溢出，因此可以覆盖父函数返回地址实现 ROP 攻击。  
我们首先利用前面所讲方法解决调试中的 ASLR 防护，通过 show region 计算出动态与静态加载基址的偏移量，解决地址随机化问题。通过检查汇编代码是否一致，来判断是否正确计算代码段偏移，可知整体偏移量为 0x5160。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPlJyWw86Fibpmzt19cDRpKZxP59GZJXrr8FXmpyliaiaOlgPUhj2xmElvHQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPlFesCQdPKjehiaia4VSvE2naHmG8iaoxGKeGYmHrkcuHYOwkGFlHrzzr8w/640?wx_fmt=png)

验证漏洞，利用 scapy 构造并发送超长的 SNMP 数据包：

```
>>> oid = "1.3.6.1.2.1.1.1.0'+".55'*100>>>sr1(IP(dst='192.168.88.1' )/UDP(sport=161,dport=161)/SNMP(community-"public" ,PDU-SNMPget(varbindlist=[ SNMPvarbind(oid=oid)]) ))Begin emission :Finished to send 1 packets.
```

根据代码偏移量，在父函数的返回地址处设置断点，查看返回地址的覆盖情况，成功实现栈溢出攻击。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPltBYsX7C6ShlSbAjXVn44G8wkWkhq6ms6iaxkI6ibjGMiatpUNJMNVod7g/640?wx_fmt=png)

继续执行，路由器崩溃重启。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSaIic1rtbggHuTvHnZjyMPl4aVPa5q8DQfasLwPaeibibTE8fRMJZjyGurjibUib05lUb8nP7qpQicq7RQ/640?wx_fmt=png)

因为 C1900 系列存在 ASLR 防护，如果想实现 RCE 攻击，可以利用 ROMMON 构造 ROP chain，注意一点，ROMMON 中的汇编代码具有非连续特点，因此需要编写 IDA python 脚本进行批量刷写。

### 四、参考

https://www.powerofcommunity.net/poc2017/george.pdf

结束

  

招新小广告

ChaMd5 Venom 招收大佬入圈

新成立组 IOT + 工控 + 样本分析 长期招新  

欢迎联系 admin@chamd5.org

  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBR8nk7RR7HefBINILy4PClwoEMzGCJovye9KIsEjCKwxlqcSFsGJSv3OtYIjmKpXzVyfzlqSicWwxQ/640?wx_fmt=jpeg)