<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/ywg_1994/article/details/112800703)

### 文章目录

*   *   [简述](#_1)
    *   [基本知识点](#_5)
    *   [第一种方式：Controller 注入](#Controller_10)
    *   [第二种方式：从 IOC 的 ApplicationContext 里面获取](#IOCApplicationContext_19)

简述
--

RequestMappingHandlerMapping 是 [springMVC](https://so.csdn.net/so/search?q=springMVC&spm=1001.2101.3001.7020) 里面的核心 Bean，spring 把我们的 controller 解析成 RequestMappingInfo 对象，然后再注册进 RequestMappingHandlerMapping 中，这样请求进来以后就可以根据请求地址调用到 Controller 类里面了。  
Controller 毕竟是写死的，在有的情况下我们可能还需要动态地注册一些 API 到 springMVC 的容器中，就需要注入了。但是注入的时候，会发现不一定好使，本文专门做一下解释说明。

基本知识点
-----

1.  RequestMappingHandlerMapping 对象本身是 spring 来管理的，可以通过 ApplicationContext 取到，所以并不需要我们新建。
2.  在 SpringMVC 框架下，会有两个 ApplicationContext，一个是 Spring IOC 的上下文，这个是 java web 框架的 Listener 里面配置，就是我们经常用的 web.xml 里面的 org.springframework.web.context.ContextLoaderListener，由它来完成 IOC 容器的初始化和 bean 对象的注入。
3.  另外一个是 ApplicationContext 是由 org.springframework.web.servlet.DispatcherServlet 完成的，具体是在 org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext() 这个方法做的。而这个过程里面会完成 RequestMappingHandlerMapping 这个对象的初始化。

第一种方式：Controller 注入
-------------------

你直接在 Controller 按照下述方法写：

```
    @Autowired
    RequestMappingHandlerMapping requestMappingHandlerMapping;

```

这样就可以了，很简单，非 Controller，Autowired 是不行的。

第二种方式：从 IOC 的 [ApplicationContext](https://so.csdn.net/so/search?q=ApplicationContext&spm=1001.2101.3001.7020) 里面获取
-------------------------------------------------------------------------------------------------------------------

这个方式是自己当时发现的，从 IOC 的 applicationContext 里面获取。  
如果你不想在 Controller 里面引用的话，就可以考虑这种方式，可以在任何地方使用。  
如下所示：

```
    private RequestMappingHandlerMapping requestMappingHandlerMapping;
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext=applicationContext;
    }
    private RequestMappingHandlerMapping getRequestMappingHandlerMapping(){
        if (this.requestMappingHandlerMapping==null){
            XmlWebApplicationContext xmlApplicationContext=(XmlWebApplicationContext) applicationContext;
            ApplicationContext servletApplicationContext=(ApplicationContext)(xmlApplicationContext.getServletContext().getAttribute(FrameworkServlet.SERVLET_CONTEXT_PREFIX+xmlApplicationContext.getServletConfig().getServletName()));
            this.requestMappingHandlerMapping=servletApplicationContext.getBean(RequestMappingHandlerMapping.class);
        }
        return this.requestMappingHandlerMapping;
    }

```

里面用到了 ApplicationContextAware，这个比较简单。

上面的那个代码看着可能有点长，但是比较简单。  
整体来讲就是：  
springMVC 有一个 ApplicationContext，但是他初始化完了以后，就把这个对象塞到了 ServletContext 的属性里面去了，属性名是：FrameworkServlet.SERVLET_CONTEXT_PREFIX+xmlApplicationContext.getServletConfig().getServletName()。而这个 ServletContext 可以从 SpringIOC 的容器里面取出来，所以就可以通过 SpringIOC 的 Context 取到 SpringMVC 的 Context，所以就可以取到 RequestMappingHandlerMapping。  
在不知道这个事情的时候，看了网上的一些文章，就直接用注解自动注入，但是一直报错没有这个 bean，最后花了我不少心思找到了这个，亲测可用。

这边稍微有一个问题注意下，就是使用这个方法的时机，一定要在 servlet 加载完了以后再使用，否则这个对象也是没有的。servlet 加载的时候才会初始化这个 Context。  
如果你希望在启动过程中去动态注册 API 的话，那么我推荐你使用 Controller 里面的注解注入，同时使用 PostContruct 注解；或者重写一下 DispatcherServlet 这个类的 init 方法，完成父类的 init 方法以后，再去执行你的业务逻辑，也肯定没有问题，我是这样干的。