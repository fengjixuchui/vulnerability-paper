<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/4JkmUHkyAejMNRkD_mqF3A)

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/Tp9VOk1IaycpsK4AXvozeaMLYk7OBLQau8mDrsWslNiajkybyodE8HbkJ9ibPO7IofWw3S4sE38LyCWYSxSZMjkQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1)

**免责声明**

由于传播、利用本公众号听风安全所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，公众号听风安全及作者不为**此**承担任何责任，一旦造成后果请自行承担！如有侵权烦请告知，我们会立即删除并致歉。谢谢！

0x1 前言  

=========

> if you have SeAssignPrimaryToken or SeImpersonate privilege, you are SYSTEM. ——@decoder_it

0x2 初代土豆：Hot Potato
===================

Hot Potato 在 2016 年被提出，其主要原理是通过 NTLM 中继和 NBNS 欺骗来提升权限。

0x01 NBNS 欺骗

> https://foxglovesecurity.com/2016/01/16/hot-potato/

当 Windows 进行 DNS 解析时，会按照以下的顺序进行：

1.  1. 查找本地 hosts 文件
    
2.  2. DNS 缓存或 DNS 服务器
    
3.  3. 链路本地多播名称解析（LLMNR）和 NetBIOS 名称服务（NBT-NS）
    

但在进行第 3 步的查找时，是通过广播的形式，询问所有主机，所以攻击者可以通过一个错误的主机名，让目标进行 LLMNR 和 NetBIOS 名称服务解析，再响应目标的询问，获取凭证信息。

嗅探网络流量需要本地管理员权限，但如果是本地提权的情况下，一般不具有该权限。

NBNS 数据包中存在一个`NAME_TRN_ID`，也叫交易 ID，用来确保请求包和响应包保持一致，大小为 2 字节：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1IayeYRq4A5jdRVVK4Zkz2Wdaz5DMUa89hMHzLliaEjhflrsXy0b3WfjNpaZ375cVgsxcAVd7OtibTVCog/640?wx_fmt=png)

  

所以在对本地（127.0.0.1）做 NBNS 欺骗时，可以通过遍历交易 ID 的方式来确保请求响应匹配。

为了防止所请求的 DNS 服务器记录中有我们要进行欺骗的域名，可以使用 UDP 端口耗尽技术，它可以使目标系统上所有 DNS 查询失败，原理是占用每个 UDP 端口。

将 NBNS 欺骗与 WPAD 代理结合，可以让目标的所有流量通过受控的代理服务器，即 127.0.0.1.

0x02 NTLM 中继
------------

低权限用户进行 NBNS 欺骗，高权限用户也会受到影响，这是提权的关键。

NTLM 中继有多种利用方式，这里用到的是`HTTP->SMB`，原因是最初的`SMB->SMB`被微软修补而无法使用（MS16-075）。

目前我们通过 NBNS 欺骗使得目标的所有 HTTP 流量都流经受控的代理服务器，这时将其重定向至一个请求 NTLM 身份验证的 URL，例如 401 验证，再将得到的 NTLM 凭据中继到本地 SMB 服务，就可以创建相应的服务。

当该请求高权限用户发起的时，最终就能以 SYSTEM 权限执行命令。

0x03 利用
-------

在利用方面，主要问题是如何触发 NTLM 验证，作者给了以下几种解决方案：

*   • Windows 7 下，利用 Windows Defender 更新机制触发
    
*   • Windows Server 2008 下，利用 Windows 更新机制触发，不过这个不够稳定
    
*   • Windows 8/10/Server 2012 下，利用不受信任证书的自动更新程序特性来触发，也不够稳定
    

PoC 地址：https://github.com/foxglovesec/Potato

微软已经给出了该漏洞的修复方案：Microsoft 安全公告 MS16-077 https://learn.microsoft.com/en-us/security-updates/securitybulletins/2016/ms16-077

顺带一提，该方案也是修复`BadTunnel`攻击的一部分，该攻击方式由著名的`@tombkeeper`提出，两者有一些相似之处，`Hot Potato`的作者还在新闻报道之后联系过`@tombkeeper`，以为是思路重合了，但交流过后发现并不是，他对 Tunnel 的思路非常赞赏。

0x3 二代土豆：Rotten Potato
======================

> https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/

在初代土豆提出后不久，该作者又找到了新的攻击方式，将其命名为 Rotten Potato.

相对之前的，Rotten Potato 使用了另一种方法来进行 NTLM 中继，即利用 DCOM/RPC 机制。

下图是攻击流程，我们参照该图来分析整个过程：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1IayeYRq4A5jdRVVK4Zkz2WdazZKjp58k3GDNCHmbf81vmPvpoR2ycwG1z6fOKE7CT4B28eImz6cXUeA/640?wx_fmt=png)

0x01 流程分析
---------

### 1. 利用 CoGetInstanceFromIStorage()

`CoGetInstanceFromIStorage()`的作用是加载指定对象的实例，通过该 API，我们可以加载 BITS 对象，那么 BITS 服务就会向受控的端口发起 RPC 连接。

作者的示例代码：

```
public static void BootstrapComMarshal(){    IStorage stg = ComUtils.CreateStorage();    // Use a known local system service COM server, in this cast BITSv1    Guid clsid = new Guid("4991d34b-80a1-4291-83b6-3328366b9097");     TestClass c = new TestClass(stg, String.Format("{0}[{1}]", "127.0.0.1", 6666)); // ip and port     MULTI_QI[] qis = new MULTI_QI[1];     qis[0].pIID = ComUtils.IID_IUnknownPtr;    qis[0].pItf = null;    qis[0].hr = 0;     CoGetInstanceFromIStorage(null, ref clsid, null, CLSCTX.CLSCTX_LOCAL_SERVER, c, 1, qis);}
```

这段代码的作用是通过指定的地址去加载指定对象的实例，其中指定地址由 IP 和端口构成，`TestClass`是对其进行包装的`IStorage`对象；指定对象则由`CLSID`确定，`CLSID`是 COM 组件的唯一标识符`Guid`的一种，另一种是针对接口的`IID`，这里指定的是 BITS 对象。

### 2. 发起 NTLM 协商

在成功与 BITS 服务通信后，我们尝试让其进行 NTLM 身份认证，NTLM 身份认证的第一步是协商（Type 1）.

### 3. 中继 NTLM 认证

本地的 6666 端口是我们控制的代理服务器，所以可以将 NTLM 身份认证数据包中继至本地的 RPC 服务即 135 端口处，之后调用`AcceptSecurityContext()`进行强制本地身份验证。

### 4. 中继 NTLM 质询

4 和 5 都会返回 NTLM 质询（Type 2），但数据包稍有不同，下面是对比图：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1IayeYRq4A5jdRVVK4Zkz2WdazyEN1sHiahrHqqO4zdgpV1PvoE0rJhw5AQKyYvWHNVhryjk0uX7WlmpA/640?wx_fmt=png)

  

可以看到，`Challenge`和`Reserved`值不同。因为我们的目的是进行本地权限提升，这两个值关乎认证的目标，所以 6 的数据包的两个值要跟 5 保持一致，这里需要做一下替换处理。

### 5. 中继 NTLM 验证

之后的 7 和 8，BITS 服务会返回 NTLM 验证（Type 3），需要将其中继至`AcceptSecurityContext()`处。

### 6. 协商模拟令牌提权

最终的 9，我们使用`QuerySecurityContextToken()`来获取访问令牌，提升权限。

0x02 利用
-------

利用该方法提权，需要当前用户具有`SeImpersonatePrivilege`特权或`SeAssignPrimaryTokenPrivilege`特权。

`Local Service`和`Network Service`通常都具有前者，所以实际场景中常常用来从 IIS 或 SQL Server 服务账户权限提升至 SYSTEM 权限。

PoC：https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1IayeYRq4A5jdRVVK4Zkz2WdazBa5C0uqiaAnw4yWBgeW31icF9ia3AP21Kx4182fKM8F5HzLgX69cXVhwA/640?wx_fmt=png)

  

微软同样修复了该漏洞，在≥Windows 10 1809 和 Windows Server 2019 的版本不可使用，原因是在这些版本上 IStorage COM 组件只能与 135 通信，无法重放。

0x03 Juicy Potato
-----------------

Juicy Potato 是 Rotten Potato 的改进版本，它允许自定义 COM 服务器监听端口（原版为 6666），允许修改 CLSID 来指定其他服务（原版为 BITS 服务），使用起来更灵活，适用范围和原版一致。

PoC：https://github.com/ohpe/juicy-potato

0x4 三代土豆：PrintSpoofer
=====================

> https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/

`PrintSpoofer`也叫`PipePotato`或`BadPotato`，这里沿用原作者的称呼。

因为微软通过对 COM 组件进行限制，导致无法再使用 RPC 协议进行中继，所以作者找到了使用命名管道进行中继的方法。

关于命名管道，有一个很有用的 API：`ImpersonateNamedPipeClient()`，它允许服务端进程模拟连接到它的客户端进程，也就是说，如果现在有一个非管理员权限的命名管道服务端进程，并且有一个管理员权限连接到该服务端，那么就可以模拟出管理员权限，当然这需要`SeImpersonatePrivilege`特权。

所以只需要使 SYSTEM 用户连接到我们的命名管道客户端，就可以获取 SYSTEM 令牌进行提权，漏洞作者解决该问题的方法是`Printer Bug`即打印机错误。

`Printer Bug`是利用了 MS-RPRN 协议中的`RpcRemoteFindFirstPrinterChangeNotificationEx()`：

```
DWORD RpcRemoteFindFirstPrinterChangeNotificationEx(   [in] PRINTER_HANDLE hPrinter,   [in] DWORD fdwFlags,   [in] DWORD fdwOptions,   [in, string, unique] wchar_t* pszLocalMachine,   [in] DWORD dwPrinterLocal,   [in, unique] RPC_V2_NOTIFY_OPTIONS* pOptions );
```

参数`pszLocalMachine`即指向客户端计算机名称的字符串指针，通过该参数，就可以达到强制该主机向其他主机进行身份验证的目的。

根据 MS-RPRN 协议文档，可以看到打印机服务端初始化时，RPC 接口是绑定在命名接口`\pipe\spoolss`上的：

![](https://mmbiz.qpic.cn/mmbiz_png/b589s5bWb3Aia7dgbWlCbvdJbJur6f1VSVgu6X07KsCkbibS1ClTJESBJo9lUqxzsVJa7srrC7fc0gtM3ApiaAhgQ/640?wx_fmt=png)  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1IayeYRq4A5jdRVVK4Zkz2Wdaz3ABbVATualVEicbnZBERz5DyhKnBeMZkVj2EibQkGAFic8zSMhz5iaU6xg/640?wx_fmt=png)

  

在本地提权的场景中，需要将认证请求的目标也设为自己，这时通知会发送到`\\IP\pipe\spoolss`，就带来两个问题：

*   • 该管道已经存在，并且是由 SYSTEM 控制，所以不能创建同名管道
    
*   • 不能使用`\\IP\pipe\test`来接收，这样无法通过路径验证
    

解决办法是一个小技巧，如果主机名包含`/`，这时可以通过路径验证，但是在计算要连接的命名管道的路径时，又会将其转换为`\`，所以利用这样的名称`\\IP/pipe/test`能够通过校验，最后会转换为`\\IP\pipe\test\pipe\spoolss`，该管道和`\\IP\pipe\spoolss`并不是同一个，所以符合要求。

0x5 土豆拾遗
========

0x01 Sweet Potato
-----------------

Sweet Potato 是 Juicy Potato 的优化版，并且集合了 PrintSpoofer.

PoC：https://github.com/CCob/SweetPotato

0x02 Rogue Potato
-----------------

Rogue Potato 是 Rotten Potato 的改进版，因为微软限制了 COM 组件导致无法控制 RPC 对特定的 IP 和端口进行通信，所以漏洞作者提出了使用其他远程主机的 135 端口进行转发，将数据传到本地的 RPC 服务器上，具体参看：https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/

0x03 其他
-------

还有一些土豆还没来得及研究，暂时将其列在这里，以后填坑：

*   • Ghost Potato
    
*   • Remote Potato
    
*   • Efs Potato
    
    0x6 参考链接
    ========
    
*   • https://www.geekby.site/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/
    
*   • https://tttang.com/archive/1560/
    
*   • https://www.wangan.com/p/7fy747c482c3331f
    

****原创首发：弱口令安全实验室****

****作者：白袍****

[点击我查看原文~](http://mp.weixin.qq.com/s?__biz=MzkyNzMyNjcwNQ==&mid=2247486034&idx=1&sn=b8efbb2f85ffaf3484a109cd41a59720&chksm=c22882ccf55f0bda7f19efddebf0146cb3a07f215249b68e10e2b6661a23256e428478e22f70&scene=21#wechat_redirect)  

· END ·  

点击下方名片，关注我们

觉得内容不错，就点下 “**赞**” 和 “**在看**”

如果不想错过新的内容推送，可以设为**星标**![](https://mmbiz.qpic.cn/mmbiz_png/Yv6ic9zgr5hTYyCkc91euAiaGULJSbiaHricFHs2dd2sib20WTJKwHYD90Jia9HCKxnmJUwnkicGU7rVP3EYCVh3dMnng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)哦