> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/PYJOhLTsH4L6JVlryDcsGg)

 ![](http://mmbiz.qpic.cn/mmbiz_png/haqlQiars3wrIJ0a6Vfic8AnrKAUMuscw7NI0MZJHvddaGYdjArhsDvESBdpiaPlicyXTD5ZNpNicJo9JWHGZAkxOJQ/0?wx_fmt=png) ** 编码安全 ** 专注于编程安全技术的分享。 40篇原创内容   公众号

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/My1Gumia3SKLeW5YKmZRUj1DicOJWicDUhqMc122V9S8icg9o3WlJxW962Q63Qp26ickjDaDMCCvFZgCc5Gvt1DibBLA/640?wxfrom=5&wx_lazy=1&wx_co=1)

Dex的理论基础

![图片](https://mmbiz.qpic.cn/mmbiz_png/N5gGFPMEm3B6B4eKDcfNt5VFLvBOq8S7oicKicuouHJxltjKNXAiaZs9SYym7mgmx7gkBnKyD2eibkaRJYwoBHwKDw/640?wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/hMjlYNLvPyRpUl2m3A1sdiawdLBktzcYbRjdeeXvJtOWbehuJxMOEUK9zxqK8c0PkoxZAVxv4B7PicGMo6sC3OcQ/640?wxfrom=5&wx_lazy=1&wx_co=1)

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/xicQVVic8TfFvDuZ1oRzgNicaicaRIsA1tE7Csu27FgSnBGgnbZNKdMLVbIwayvdMTA1Is6V3kp0SK7EDGjznOibzeQ/640?wxfrom=5&wx_lazy=1&wx_co=1)

**整体加壳，整体保护 :** 就是将原始App里边的classes*.dex文件隐藏起来，使用jadx这种静态反编译工具只能看到壳dex，看不到App应用逻辑所在的dex，运行的时候壳dex负责将App的dex解密还原并加载到虚拟机中。加载的方式可以采用文件加载或者内存加载。

**函数粒度的保护 :** 也就是函数抽取型壳，保护粒度降到了方法级别，将App dex中某些方法抽空，使用jadx这种静态反编译工具查看方法体全是nop指令，由壳代码在合适的时机将方法体还原回去，显而易见方法体的还原必须在函数执行前进行。函数抽取型壳需要禁用掉dex2oat过程。

**指令粒度的保护，保护效果最强** : 主要为VMP壳和dex2C,显著的特征是Java的方法native化了，VMP壳将保护级别缩小到了每条指令级别，通过自定义解释器来执行smail指令。而dex2C则将Java的方法等价转换为对应的native函数。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/My1Gumia3SKLeW5YKmZRUj1DicOJWicDUhqMc122V9S8icg9o3WlJxW962Q63Qp26ickjDaDMCCvFZgCc5Gvt1DibBLA/640?wxfrom=5&wx_lazy=1&wx_co=1)

壳的类型识别

![图片](https://mmbiz.qpic.cn/mmbiz_png/N5gGFPMEm3B6B4eKDcfNt5VFLvBOq8S7oicKicuouHJxltjKNXAiaZs9SYym7mgmx7gkBnKyD2eibkaRJYwoBHwKDw/640?wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/hMjlYNLvPyRpUl2m3A1sdiawdLBktzcYbRjdeeXvJtOWbehuJxMOEUK9zxqK8c0PkoxZAVxv4B7PicGMo6sC3OcQ/640?wxfrom=5&wx_lazy=1&wx_co=1)

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/xicQVVic8TfFvDuZ1oRzgNicaicaRIsA1tE7Csu27FgSnBGgnbZNKdMLVbIwayvdMTA1Is6V3kp0SK7EDGjznOibzeQ/640?wxfrom=5&wx_lazy=1&wx_co=1)

  

判断App是不是有进行加壳保护，通过使用jadx、androidkiller、jeb等工具打开App以后，查看App的四大组件类，如果组件类找不到实现，那么就是整体加壳了。

比如下面jadx看到qihoo相关的壳代码，App的代码被隐藏了。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/haqlQiars3wrRXZmI0gpP2JP491rKlwzc1U9Z58hBJaiaWawwiaTudiaEf5rFOmqvxAknDic4OZ9mfibBhUsziczLkcew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

判断App是不是函数抽取型壳就是看函数体是不是有意义的代码。

例如下面就是一个抽取型壳，可以看到函数体都是nop指令:

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

判断App是不是加了dex2C/VMP壳，就是要进行判断是不是有Java方法被native化了，至于到底是dex2C还是VMP则需要更一步的判断，比如native函数注册地址是否相同:

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

通用整体脱壳方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

加载Dex有很多种实现方式，每种壳的实现都不一定相同，如果想实现一个比较通用的整体脱壳方法，就必须寻找一个壳绕不开的方式来实现。这个关键的数据结构就是art虚拟机中定义的类art::DexFile,它的定义位于art/runtime/dex_file.h文件中。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这个类有两个成员变量，分别代表着dex文件加载到内存当中的起始地址以及大小，得到这两个信息以后通过内存dump的方式就可以轻轻松松的将dex文件dump下来。

这就表示一个事实: 在某个时机点内存当中一定会有解密后的完整dex存在。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

art::DexFile是通过加载dex文件的，不管是使用BaseClassLoader加载还是自定义类加载器，最终都需要art::DexFile。我们可以通过系统/art/runtime/class_linker.cc文件中的函数得到这一原理，像ClassLinker::DefineClass，ClassLinker::LoadMethod，ClassLinker::LoadClassMembers这些重量级函数都需要以DexFile对象做为参数

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**通过BaseDexClassLoader进行加载类**，它会进行执行art/runtime/native/dalvik_system_DexFile.cc文件的DexFile_defineClassNative函数。

这个函数的实现就是遍历Java层的DexFile的mCookie对象所表示的native层的art::DexFile，因为这个art::DexFile对象代表了dex文件在内存中的结构，所以可以通过类名在art::DexFile列表中查找到DexFile::ClassDef结构，才能继续调用ClassLinker::DefineClass()函数，最终才能得到一个虚拟机实现中的Class对象表示mirror::Class*,因此这个流程仍然离不开虚拟机中的art::DexFile类。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

整体脱壳实践

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

既然我们知道虚拟机中的art::DexFile类是dex在内存中的表现，那么只要得到这个对象就可以dump出dex文件。

接下来就是寻找一个合适的点可以得到art::DexFile对象,得到对象以后通过hook的方式或者修改源码的方式都可以dump下来了。

**通过修改系统源码具体实践方法。**

找到libart.so文件中所有导出函数中带有art::DexFile参数或者返回值的函数，那么这就是一个可以脱壳的点

**实现原理：通过修改系统源码，然后重新编译rom方式进行脱壳**

具体实现就是在art/runtime/dex_file.cc的DexFile::DexFile中添加代码

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

添加以下dump的脱壳代码即可脱壳

  

  pid_t pid = getpid();

  char dexFilePath[200] = {0};

  sprintf(dexFilePath,"/sdcard/dump_%d_%d_DexFile.dex",(int)size,(int) pid);

  int fd = open(dexFilePath, O_CREAT | O_RDWR , 666);

  if (fd > 0){

    int number = write(fd,base,size);

    if(number > 0){

    }

    close(fd);

  }

  

  

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

END

  

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

点个在看你最好看

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)