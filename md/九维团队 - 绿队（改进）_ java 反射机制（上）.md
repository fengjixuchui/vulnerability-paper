<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/8fwbm-2MruDKIuizp4DoJQ)

![](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOQ4y3CslMX5EINOxRsoicGxHxJnwtXjIau4usI94yHUKXTqh4LyuVL4A/640?wx_fmt=gif)

**一、何为反射**

反射即 Reflection，Java 的反射是指程序在运行期可以拿到一个对象的所有信息。即 Java 反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性 (包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为 java 语言的反射机制。

class（包括 interface）的本质是数据类型（Type），而 class 是由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存。

每加载一种 class，JVM 就为其创建一个 Class 类型的实例，并关联起来。

* 注意：这里的 Class 类型是一个名叫 Class 的 class。它长这样：

```
public final class Class {    
private Class() {}
}

```

以 String 类为例，当 JVM 加载 String 类时，它首先读取 String.class 文件到内存，然后，为 String 类创建一个 Class 实例并关联起来：

```
Class cls = new Class(String);

```

这个 Class 实例是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现 Class 类的构造方法是 private，只有 JVM 能创建 Class 实例，我们自己的 Java 程序是无法创建 Class 实例的。

所以，JVM 持有的每个 Class 实例都指向一个数据类型（class 或 interface）。

由于 JVM 为每个加载的 class 创建了对应的 Class 实例，并在实例中保存了该 class 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 Class 实例，我们就可以通过这个 Class 实例获取到该实例对应的 class 的所有信息。

这种通过 Class 实例获取 class 信息的方法称为反射（Reflection）。

**二、获取 class 的 Class 实例**

获取一个 class 的 Class 实例，有 4 种方法：

**方法一**

直接通过一个 class 的静态变量 class 获取：

```
Class cls = String.class;

```

**方法二**

如果我们有一个实例变量，可以通过该实例变量提供的 getClass() 方法获取：

```
String s = "Hello";
Class cls = s.getClass();

```

**方法三**

如果知道一个 class 的完整类名，可以通过静态方法 Class.forName() 获取：

```
Class cls = Class.forName("java.lang.String);

```

* 左右滑动查看更多  

**方法四**

利用 classLoader：

```
Class cls = 
ClassLoader.getSystemClassLoader().loadClass("java.lang.Runtime)

```

* 左右滑动查看更多

**比较**

因为 Class 实例在 JVM 中是唯一的，所以，上述方法获取的 Class 实例是同一个实例。可以用 == 比较两个 Class 实例：

```
Class cls1 = String.class;
String s = "Hello";
Class cls2 = s.getClass();
boolean sameClass = cls1 == cls2; // true

```

* 左右滑动查看更多

**获取基本信息**

获取 class 的基本信息：

```
package org.example;
import java.util.ArrayList;
public class App{
    public static void main(String[] args) {
        Class<String> cls1 = String.class;
        ArrayList a = new ArrayList();
        Class cls2 = a.getClass();
        printInfo(cls1);
        printInfo(cls2);
    }
    static void printInfo(Class cls){
        System.out.println("Class name : " + cls.getName());
        System.out.println("Simple name: " + cls.getSimpleName());
        if (cls.getPackage() != null) {
            System.out.println("Package name: " + cls.getPackage().getName());
        }
        System.out.println("is interface: " + cls.isInterface());
        System.out.println("is enum: " + cls.isEnum());
        System.out.println("is array: " + cls.isArray());
        System.out.println("is primitive: " + cls.isPrimitive());
    } }

```

* 左右滑动查看更多

**小结**  

1、JVM 为每个加载的 class 及 interface 创建了对应的 Class 实例来保存 class 及 interface 的所有信息；

2、获取一个 class 对应的 Class 实例后，就可以获取该 class 的所有信息； 

3、通过 Class 实例获取 class 信息的方法称为反射（Reflection）；

4、JVM 总是动态加载 class，可以在运行期根据条件来控制加载 class。

三

**三、访问字段** 

对任意的一个 Object 实例，只要我们获取了它的 Class，就可以获取它的一切信息。

我们先看看如何通过 Class 实例获取字段信息。

**获取字段的一些信息**

```
import java.util.Arrays;
public class Test{
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Class ot = OtherTest.class;
        System.out.println(Arrays.toString(ot.getFields()));    // 获取所有public的field（包括父类）
        System.out.println(Arrays.toString(ot.getDeclaredFields()));    // 获取当前类的所有field（不包括父类）
        System.out.println(ot.getField("a"));   // 根据字段名获取某个 public 的field（包括父类）
        System.out.println(ot.getDeclaredField("b")); // 根据字段名获取当前类的某个field（不包括父类）
        System.out.println(ot.getField("a").getName()); // 字段名称
        System.out.println(ot.getField("a").getType()); // 字段类型，也是一个Class实例
        System.out.println(ot.getField("a").getModifiers()); // 修饰符
    }
}
class OtherTest extends emmTest{
    public int a = 5;
    private int b;
}
class emmTest {
    public float cc;
}

```

* 左右滑动查看更多

```
[public int OtherTest.a, public float emmTest.cc]
[public int OtherTest.a, private int OtherTest.b]
public int OtherTest.a
private int OtherTest.b
a
int
1

```

* 左右滑动查看更多

**获取字段的值**

先获取 Class 实例，再获取 Field 实例，然后，用 Field.get(Object) 获取指定实例的指定字段的值。

```
package org.example;
import java.lang.reflect.Field;
public class App {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        OtherTest ot = new OtherTest("haha");
        Class cls = ot.getClass();
        Field f = cls.getDeclaredField("name");
        f.setAccessible(true);  // 设置访问权限，一律为true，不然不能访问 private 的
        Object value = f.get(ot);   // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象
        System.out.println(value);
    }
}
class OtherTest {
    private String name;
    public OtherTest(String name) {
        this.name = name;
    }
}
// 输出 haha

```

* 左右滑动查看更多

反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。

此外，setAccessible(true) 可能会失败。如果 JVM 运行期存在 SecurityManager，那么它会根据规则进行检查，有可能阻止 setAccessible(true)。例如，某个 SecurityManager 可能不允许对 java 和 javax 开头的 package 的类调用 setAccessible(true)，这样可以保证 JVM 核心库的安全。

**获取所有的字段**

```
public class APP {
    public static void main(String[] args) throws IllegalAccessException {
        OtherTest ot = new OtherTest("haha");
        Class cls = ot.getClass();
        Field[] f = cls.getDeclaredFields(); //取所有的字段
        for (Field field : f) {
            field.setAccessible(true);// 设置访问权限，一律为true，不然不能访问 private 的
            System.out.println(field.getName() + " " + field.getType()); // 获取field 的Name，Type
            System.out.println(field.get(ot));
        }
    }
}
class OtherTest {
    private String name;
    public OtherTest(String name) {
        this.name = name;
    }
}
// 输出
// name class java.lang.String
// haha

```

* 左右滑动查看更多

**修改字段的值**

```
package org.example;
import java.lang.reflect.Field;
public class App {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        OtherTest ot = new OtherTest("haha");
        Class cls = ot.getClass();
        Field f = cls.getDeclaredField("name");
        f.setAccessible(true);  // 设置访问权限，一律为true，不然不能访问 private 的
        f.set(ot, "modify");    // 反射修改值
        System.out.println(ot.getName());
    }
}
class OtherTest {
    private String name;
    public OtherTest(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}

```

* 左右滑动查看更多

**小结**

Java 的反射 API 提供的 Field 类封装了字段的所有信息：

1、通过 Class 实例的方法可以获取 Field 实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 

2、通过 Field 实例可以获取字段信息：getName()，getType()，getModifiers()； 

3、通过 Field 实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用 setAccessible(true) 来访问非 public 字段。

4、通过反射读写字段是一种非常规方法，它会破坏对象的封装。

**四、调用方法**

**获取方法**

通过 Class 实例获取所有 Method 信息。Class 类提供了以下几个方法来获取 Method：

```
import java.util.Arrays;
public class Test{
    public static void main(String[] args) throws NoSuchMethodException {
        Class<OtherTest> cls = OtherTest.class; // Class cls = ot.getClass();
        System.out.println(Arrays.toString(cls.getMethods()));  // 获取所有public的Method（包括父类）
        System.out.println(Arrays.toString(cls.getDeclaredMethods()));  // 获取当前类的所有Method（不包括父类）
        System.out.println(cls.getMethod("echoEver", String.class));    // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型)
        System.out.println(cls.getDeclaredMethod("echoEver", String.class));    // 获取当前类的某个Method（不包括父类）
    }
}
class OtherTest{
    public void echoEver(String thing){
        System.out.println(thing);
    }
}
// =====
/*
[public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()]
[public void org.example.OtherTest.echoEver(java.lang.String)]
public void org.example.OtherTest.echoEver(java.lang.String)
public void org.example.OtherTest.echoEver(java.lang.String)
*/

```

* 左右滑动查看更多

**调用方法**

*   获取 Class 实例
    
*   反射获取方法
    
*   invoke 调用方法
    

```
package org.example;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class App {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        OtherTest ot = new OtherTest();
        Class cls = ot.getClass();
        Method echoEver = cls.getDeclaredMethod("echoEver", String.class);
        echoEver.setAccessible(true);
        echoEver.invoke(ot,"test");  // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数
    }
}
class OtherTest{
    private void echoEver(String thing){
        System.out.println(thing);
    }
}

```

* 左右滑动查看更多

**示例**

这里再以 Java 中使用反射调取 Runtime 来执行命令注入：

```
// 传统使用Java 来执行Runtime进行命令执行代码
package org.example;
import java.io.*;
public class App {
    public static void main(String[] args) throws IOException{
    Process s = Runtime.getRuntime().exec("whoami");
        InputStream inputStream = s.getInputStream();
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }
    }
}

```

* 左右滑动查看更多

使用反射：

```
package com.ReflectTest;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class Reflect {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class clazz = Class.forName("java.lang.Runtime");
        Method method = clazz.getDeclaredMethod("exec", String.class);
        Process process = (Process) method.invoke(Class.forName("java.lang.Runtime").getDeclaredMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")), "whoami");
        // 这里细看Class.forName("java.lang.Runtime").getDeclaredMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))
        // 在这里，method.invoke 第一个参数是实例化的对象，从不使用反射的代码中看，应该是Runtime.getRuntime() 这个实例化对象
        // 然后要调用 getRuntime()的实例化对象则是Runtime，所以整合起来如下：
        // Class.forName("java.lang.Runtime").getDeclaredMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))
        // 这个就是上述调用exec方法的实例化对象RunTime.getRuntime()
        // 反射调用方法，就是从后往前依次寻找调用方法的实例化对象，加上参数
        InputStream inputStream = process.getInputStream();
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }
    }
}
class OtherTest {
    private void echoEver(String thing) {
        System.out.println(thing);
    }
}

```

* 左右滑动查看更多

**小结**

Java 的反射 API 提供的 Method 对象封装了方法的所有信息：

1、通过 Class 实例的方法可以获取 Method 实例：getMethod()、getMethods()、getDeclaredMethod()、getDeclaredMethods()；

2 、通过 Method 实例可以获取方法信息：getName()、getReturnType()、getParameterTypes()、getModifiers()； 

3 、通过 Method 实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 

4、通过设置 setAccessible(true) 来访问非 public 方法； 

5、通过反射调用方法时，仍然遵循多态原则。

**五、调用构造方法**

**举例**

我们通常使用 new 操作符创建新的实例：

```
Person p = new Person();

```

如果通过反射来创建新的实例，可以调用 Class 提供的 newInstance() 方法：

```
Person p = Person.class.newInstance();

```

* 左右滑动查看更多

调用 Class.newInstance() 的局限是，它只能调用该类的 public 无参数构造方法。如果构造方法带有参数，或者不是 public，就无法直接通过 Class.newInstance() 来调用。

为了调用任意的构造方法，Java 的反射 API 提供了 Constructor 对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor 对象和 Method 非常类似，不同之处仅在于它是一个构造方法，并且调用结果总是返回实例：

```
package org.example;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
public class App {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class<Integer> cls = Integer.class;
        System.out.println(cls.getName());
        System.out.println(Arrays.toString(cls.getConstructors()));
        // Integer.class.getConstructor(int.class);
        Constructor<Integer> cons1 = cls.getConstructor(int.class);
        Integer int1 = cons1.newInstance(123);
        System.out.println(int1);
        Constructor<Integer> cons2 = cls.getConstructor(String.class);
        System.out.println(cons2.newInstance("456"));
    }
}
/*
java.lang.Integer
[public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException]
123
456
*/

```

* 左右滑动查看更多

通过 Class 实例获取 Constructor 的方法如下：

*   getConstructor(Class...)：
    
    获取某个 public 的 Constructor；
    
*   getDeclaredConstructor(Class...)：
    
    获取某个 Constructor；
    
*   getConstructors()：
    
    获取所有 public 的 Constructor；
    
*   getDeclaredConstructors()：
    
    获取所有 Constructor。
    

注意 Constructor 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。

调用非 public 的 Constructor 时，必须首先通过 setAccessible(true) 设置允许访问，否则 setAccessible(true) 可能会失败。

**示例**

调用方法示例使用 invoke 方法反射调用 Runtime.getRuntime.exec(String.class) 方法，那么由 Construct 改写如下：

```
package com.ReflectTest;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class App {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
        Class clazz = Class.forName("java.lang.Runtime");
        Method method = clazz.getDeclaredMethod("exec", String.class);
        Constructor constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        // 实例化
        Runtime runtime = (Runtime) constructor.newInstance();
        // 使用exec调用
        Process process = (Process) method.invoke(runtime.getRuntime(), "whoami");
        InputStream inputStream = process.getInputStream();
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }
    }
}

```

* 左右滑动查看更多

**小结**

Constructor 对象封装了构造方法的所有信息；

1、通过 Class 实例的方法可以获取 Constructor 实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 

2、通过 Constructor 实例可以创建一个实例对象：newInstance(Object... parameters)；通过设置 setAccessible(true) 来访问非 public 构造方法。

（未完待续）

* * *

**往期回顾**

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zK9CpI1AR5hwPibGhicQHyvvusu0od1oxHl20hrKEtcDJScSzyrXbzEib9MS6VtZlsFfwnW3TuOibblhg/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247503784&idx=2&sn=bc990c6259149fdf93ba39e2bbd0f898&chksm=9ae18e90ad960786ff7b082ba3d2afcfe716606214a3c6ad6929bdd2f8d437e14383a619f490&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zJ0foOuva8NBvtQib9SjmIprRHj3dRjIETqB2giah3ElsHwKC6fofuibIY6XCgEns8cCKTCO4ibIB9icPg/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247513937&idx=1&sn=fc1cf469f35793211736507045901dd6&chksm=9ae1f669ad967f7f6e66434e4d793dbb9dccb7890bbde7d0a5d256ad1a352d77c08f262fc4e8&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zJ0foOuva8NBvtQib9SjmIprOL3be4QdLkuCWghqa9UibQe5lTib3DIFEq19Zd1G7d07lnLaUuGia1s8A/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247513741&idx=1&sn=563650d5dc9533283cd3a06a76e80f32&chksm=9ae1f7b5ad967ea3082573db21508a3feb2dfdb10d5543329a9120b178a91ddeb1092581b7a7&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zLTV9CIYCibFb6iarRicou1ADyAxjQrsQqfNJ1ZxAbJyUGIk1E6ibiaicxeB9Anbr2vnPPPhicJzsNYW64kg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247513364&idx=1&sn=04f7409413f41496096caefd8ff3fbbb&chksm=9ae1f42cad967d3ae982891667aeb0bedddd7bfd26acf25eb1dd4c701aeeca4d51203493d311&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zLMabTb2zvfCiaNYfqCpk8fBYWpW63KMoRFcFlLYa0iaPkRaUFW17l65RYu7viaxSLeWODzmNgcwklQg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247512539&idx=1&sn=7a70d53868adb1310d61af0325cd3458&chksm=9ae1f0e3ad9679f5b12a7efa3f1f35c3c1a2b1e5a696bd791e7d0513eee431e6ae9ac856329c&scene=21#wechat_redirect)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Ljib4So7yuWjVsaTygX5CCGxuYZaPeibrpfOOGAjXfTkTp3AIPeXv08iayGTH94Xcmvk4RJxs9NNSc2vzCoCiaXOSQ/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

  

**关于安恒信息安全服务团队**

**安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。**

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zIFIDZlXFuQeZrcKrV7Zd8Aeg98Fw5jzbGBgUW1hVQXIV3YpLZncEYibgw7MFwWtDU5vwnE2QFVP7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zL31gt4m6YIRLh7wJeOSwYPOIblCvhN6OgHhV9NMJNH0TBianlpMmRbaKG1ia7iaPsWb4UX4ImgfEJ0A/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOCUgD3ep5Jp4DE8e2S2Y3WnxsKjicicOg3OsGGRc9NPibQ61aRAqNXZQDA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)