> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/AG0OfLfQWW-winIWiOtwLQ)

Java RMI
========

0x01 RMI 简介
-----------

RMI(Remote Method Invocation) 远程方法调用，一种允许程序跨`JVM`调用对象的思想。

调用方法即会涉及到参数传递，在 Java 中，如果我们想完整的在网络中传递一个对象，通常会用到序列化，来安全的、完整的传递一个 Java 类对象。

在 JVM 之间通信时，RMI 对本地和远程对象的处理方式是不同的，RMI 并不是将远程对象复制一份传递给客户端，而是引入了两个概念，分别是`Stub`、`Skeleton`。

当 Client 试图调用一个远程的对象时，实际会调用的 Client 的代理类，这个代理类就是`Stub`，而在调用远程方法前，Server 端也会注册一个远程代理类，这个代理类就是`Skeleton`。

`Stub`对使用者是透明的，`Client`可以像调用本地方法一样直接通过它来调用远程方法。`Stub`中包含了远程对象的定位信息，如`Socket`端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节，因此`Stubs`、`Skeletons`的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动调用 RMI 的相关方法。

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5lUznVCEL2syfr5yDCqmrzEvjiasxed4m2Nmm5JOTb7Rbur0wCSnR0hQ/640?wx_fmt=png)

0x02 RMI 实例
-----------

运行一个 RMI 实例，我们需要：

*   需要被调用的接口 (Server): 这个接口必须继承`java.rmi.Remote`接口，所有方法都必须抛出`java.rmi.RemoteException`异常
    
*   接口的实现类 (ServerImpl): 需要提供一个构造函数并且抛出`RemoteException`异常，并且最好`java.rmi.server.UnicastRemoteObject`类 (后面会解释)
    
*   注册中心: 在服务端创建并运行
    
*   客户端代码: 查找远程对象并调用方法
    

那么又是如何创建注册中心，如何查找并调用远程对象的呢？

Java 为 RMI 引入了一个`Registry`，使用注册表来查找远程对象的引用。好比手机上的 "联系人"，存储着联系人的名字和电话。我们想获取某人信息时 (RMI)，只需要在 "联系人"(Registry) 上通过名字 (Name) 找到电话号码(Reference)，并通过号码找到人。

上述思想的实现即是`java.rmi.registry.Registry`和`java.rmi.Naming`

### Registry

即注册中心。

**创建注册中心**

`locateRegistry.createRegistry()`

### Naming

提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法。

该类的每个方法都有一个 URL 格式的参数，格式如下:

`//host:port/name`

**Naming 的方法**

*   lookup(): 查询
    
*   bind(): 绑定
    
*   rebind(): 重新绑定
    
*   unbind(): 取消绑定
    
*   list(): 列表
    

naming 其实就是一个对注册中心进行操作的类。

### 实例

需要被远程调用的接口`ExecServer`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5p8ROUdibibM6aqTIIibv5iak52o3kGwYvFYueaR2wIJKd20PZQFEZkVWhA/640?wx_fmt=png)

接口的实现类`ExecServerImpl`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5ob4BowJyiacibffK2XOFDVUKQbOsOZUIDibqSNU5wEXml9qa6Qev6XHeg/640?wx_fmt=png)

创建注册中心的服务端代码`RMIServer`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5ZO4libdVXA8yhUBSPAV2jvJZJ5Zxplqib3tXDTWdGWlHPghYxUhJjbEg/640?wx_fmt=png)

查找注册中心并调用 Stub 中存储的远程方法的客户端代码`RMIClient`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB50TZHuar0cfd8r0kSaGhKoEyibPTokywe1e19T20AtjvObQ7ykE8HVpw/640?wx_fmt=png)

启动`RMIServer`，然后启动`RMIClient`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB51wo2kU4tmGiaLjmVNfibJ0V1eF2lMjMmx2WuHSuwXGiaI3uKSKwPzFrWw/640?wx_fmt=png)

0x03 流程及原理
----------

### 1、创建需要被调用的远程对象

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB551aQUpLaQBzDBvsyOfZ76iamj82Xan3iallqZCqfB9946FlmOCFLno3w/640?wx_fmt=png)

首先在服务端的第一行，创建了远程对象`execServerimpl`, 该对象是继承自`UnicastRemoteObject`，在初始化时，会调用`UnicastServerRef#exportObject`来创建`execServerimpl`这个远程对象。

进入`exportObject`方法，发现调用了`Util.createProxy`方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5iaYmxWuEvzNAPhEpb3SeROT32qJRXECVKZwyr6A4q6p7p1st2UWYDUw/640?wx_fmt=png)

继续跟进，在`createProxy`方法中，可以看见创建了一个`InvocationHandler`类也就是`RemoteObjectInvacationHandler`类 var6，然后使用了动态代理，参数为 var4、var5、var6, 分别是 var0 的类加载器、所有接口的 Class 对象的数组、invocationHandler，被代理的对象是`execServerimpl`，也就是说这一步为我们创建的`ExecServerimpl`实现的`ExecServer`接口创建动态代理类

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5Xyo507hoyYjXUcucCB4icibaS5SzB7Hfq7Wdd7lEmk0fFn3LSZbFr0zg/640?wx_fmt=png)

继续跟进，回到`UnicastServerRef`, 在下方, new Target，并用该对象封装了刚刚生成的动态代理类 var5，也就是`Client_Stub`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB54IB0dJibA7hOQ0I3LkJAibbFQ1HmGup1GR9icicGqqBSqVEvKqh9yG7JGg/640?wx_fmt=png)

在下一行，调用了`this.ref.exportObject()`, 这里的 ref 就是该类的父类`UnicastRef`的成员变量`LiveRef`对象

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5ojwp4VtPJFnSccUbmay3luCGToqagO0Hlic5x3iaqdkdwJpH3XZPbV6A/640?wx_fmt=png)

跟进该`exportObject`方法，会发现首先调用了`LiveRef#exportObject`, 接着调用了`TCPEndpoint#exportObject`，对本地端口进行监听

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5b7QBw3svPEaBTPib3P5NL9ia483IxjrHzfYibm59d8UZuMZWHt2UApK3g/640?wx_fmt=png)

接着会调用`super(Transport).exportObject()`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5Ob8fIehzUeTXvuiaGqiaOcXto6ibPZTZriabGzejfibuMO57RteQsztEscw/640?wx_fmt=png)

在该方法中，调用了`ObjectTable.putTarget()`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5qG3r8j9hlAPVLaoiaEnQSFpIEJDAa9Hic3snaia7UA9HALvrwMgzVwjhg/640?wx_fmt=png)

ObjectTable 用来管理所有发布的服务实例 Target,ObjectTable 提供了根据 ObjectEndpoint 和 Remote 实例两种方式查找 Target 的方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5vMNMqgOJYUiaBDMnIKBKb9DmskQWDwKCqYqbSibWuWUJY9p9yI2hP67Q/640?wx_fmt=png)

* * *

这里我们顺便看一下`RemoteObjectInvacationHandler`这个类，由于是动态代理类，关注的重点必然是`invoke()`，在 invoke 中，对被代理对象做了一个判断，如果调用的 Object 的方法，则会调用`invokeObjectMethod()`方法，否则则会调用`invokeRemoteMethod()`方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5ibkicwOdy5WtdWibiaBD5K54icd6wY5OtEvO1HslI7fM7vTmaZthLJFQssg/640?wx_fmt=png)

而在`invokeRemoteMethod`中实际是委托`RemoteRef`的子类`UnicastRef#invoke`方法执行调用

`UnicastRef#invoke`方法是一个建立连接，执行调用，并读取结果并反序列化的过程。UnicastRef 包含属性 LiveRef,LiveRef 类中的 Endpoint,Channel 封装了与网络通信相关的方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5KfHF13JefqaS0QvJsvlCIbzElTia3BVr4efviaNjQVesdj0W2nF0ZMkw/640?wx_fmt=png)

真正的反序列化方法在`unmarshalValue()`，可以看出来会对除了 8 种基础类型的数据类型做反序列化处理。

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5xDWTFcUbo58eOdp89LaQW9BFr3eIIlyQUZpR4IE3V8hNZjm4icszWPQ/640?wx_fmt=png)

### 2、创建注册中心

在实例中，我们用于创建注册中心的代码如下：

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5UJbBRibYwywg6iacQ0ib9R9MGdINGgZ1GTMQlEsFMMdx1dc6DXqb8zWkQ/640?wx_fmt=png)

调用了 LocateRegistry.createRegistry()

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5njGfA8iaFdibLzjBoD8TonUXDIYuyABUaaUXHEAXQYEBgqibxE0ribv9qA/640?wx_fmt=png)

在`createRegistry()`中，实际是 new 了一个`RegistryImpl`对象

所以我们跟进一下`RegistryImpl`的构造方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5bJNPElwGsLheUmWxWa8SE7pj650JhKLRygbIibCbW2IyLdLpjk3ia4oA/640?wx_fmt=png)

在构造函数中，new 了两个对象：`LiveRef`和`UnicastServerRef`，var1 则是通过`createRegistry()`传入的端口

最后调用了`setup()`方法

跟入该方法

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5xCCEv4rJeLDMbyF6pzofR8ncpdJ5fDx6Ko0oSZaDqBK7P2S0MkBXyA/640?wx_fmt=png)

该方法中，调用了`UnicasetServerRef.exportObject()`来创建一个`RegistryImpl`

`exporotObject`则与第一步中创建动态代理类的步骤类似

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5aIdXFPniaTNOS9H1MVBnZXbnJkp5pyicaKGEoRa1YUOKiaL3ALLticx4DA/640?wx_fmt=png)

创建完代理类后，会通过`setSkeleton()`来创建服务端`Skeleton`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5iaGAWWgoyMrVUWRNpQWzcG2UPuhq8mqn9kXOxym6CTSy9ibUwtHFk2Bg/640?wx_fmt=png)

在该方法中调用了`createSkeleton()`来创建

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5MMibScchIRSEczHmoadXdsbLTDq0hZZOkM4wJJAD1bvj45jBFn0lGsg/640?wx_fmt=png)

在该方法中，通过反射加载`RegistryImpl_Skel`进内存，并返回实例化的`Skeleton`对象

创建注册中心大致就是这样，可以看出以创建远程对象类似

### 3、绑定服务

**Server 与 Registry 在同一端**

最终调用`registryImpl#bind()`进行绑定

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB54h70kicDrEFW6wmLbEaVPfyLBsHNDyrua8Knx1A9X74Ob4DxAedln4Q/640?wx_fmt=png)

**Server 与 Registry 在不同端**

通过`Naming.bind()`与`Registry.bind()`

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5DGeLTKdqb9PLnCdFgBAv2ZiaDy50vb9iaflyz3ggkmjcibexicaUd11cUw/640?wx_fmt=png)

最终都需要通过调用 LocateRegistry.getRegistry() 来创建 Registry，与创建注册中心的过程类似

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5wKD9OyKKL3IJvalBKniac8p6KyYFxYLxHbia6ASGrsICtFpjWryxbiarw/640?wx_fmt=png)

### 4、查找服务

查找服务就是指客户端查找到注册中心，并对注册中心进行操作

在 Client 端使用`LocateRegistry.getRegistry()`方法查找注册中心

### 5、远程调用对象方法

在客户端调用 lookup 方法时，会向 Registry 端传递序列化的 Name，然后将 Regisyry 端回传的结果反序列化

在 Registry 端，则是调用`Registry_Skel#dispatch()`, 然后调用`Registry#lookup()`最后将查询到的结果序列化

Client 在拿到 Registry 返回的序列化结果后，将其反序列化，对其进行调用，注意这里是通过动态代理让`RemoteRef#invoke()`方法进行远程通信，由于这个动态代理类保存了 Server 端的监听端口，因此在宏观上看，像是 Client 与 Server 端直接通信。

Server 接受请求后，由`UnicasetServerRef#dispatch()`来处理，在`hashToMethod_Map()`中寻找 Client 端对象执行 Method 的 hash 值，如果找到了，则反序列化客户端传来的参数，并反射调用。

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB5SricJuNjW0gsWK2iaeIEMmJ5y7wJPNCDiazPibgicUfeOXs4VQlyohHpreg/640?wx_fmt=png)

调用的结果在返回给客户端，客户端在进行反序列化，完成整个过程。

关于原理就是上述这样，不是太详细，建议大家自己跟调一下，这里放一张 su18 师傅博客的图片，这部分原理建议深入理解，有助于搞清楚漏洞攻击方法和原理。

![](https://mmbiz.qpic.cn/mmbiz_png/ZbPAVwRQJ3gkWialO8eYqNklu6w0bxbB57qzNFqtfTORASODYVhxicP4kTr3kKsmqL4vb1n0vmDIjQ0qg0hBbH4Q/640?wx_fmt=png)

在该图中，我们也可以比较直观的发现，所有的通信流程均通过反序列化实现，所以为什么说 RMI 是基于 100% 的反序列化的，而且在三个端点中，都有反序列化的操作，因此针对三个端点，都有攻击的可能，后续为大家展示不同端点的攻击方法以及 JEP290&bypass 的相关知识。