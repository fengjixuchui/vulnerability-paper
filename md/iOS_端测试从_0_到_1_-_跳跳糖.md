<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1381/)

> 跳跳糖 - 安全与分享社区

[0x00 测试环境搭建](#toc_0x00)
------------------------

### [越狱](#toc_)

#### [工具环境](#toc__1)

*   IPhone 7，固件版本为 12.4.1
    
*   爱思助手 7.0 官方最新版本
    

#### [操作步骤](#toc__2)

在进行越狱前，请先确保设备上的重要数据已经备份，比如通讯录等，因为越狱过程无法保证不出现问题，而一旦出现意外设备上的重要数据可能会丢失。

首先连接手机到 PC 电脑，在手机上弹出的允许设备访问中选择允许访问。

第二步，在爱思助手中选择一键越狱工具。工具箱 --> 一键越狱。

![](https://storage.tttang.com/media/attachment/2021/12/20/17104bd7-7f9e-44db-93f2-c4ae9bcb1432.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/cee9b691-4230-4e36-aaad-a7b844ba482a.png)

第三步，根据设备的固件版本选择越狱工具，推荐使用第一种越狱方法（unc0ver），笔者在测试过程当中就是用的这种方法，其余两种方法在测试过程中都没有成功，可能跟固件版本有关。

第四步，选择越狱方法，点击开始越狱按钮进行越狱工具安装，这一过程会自动在 iphone 设备上安装 unc0ver app。由于 app 的设备证书是自签名证书，所以在 app 安装完成后需要在设备管理当中信任该证书才能继续后面的操作。

![](https://storage.tttang.com/media/attachment/2021/12/20/cc39ade8-ebb3-46da-b0df-57e0614a833d.png)

第五步，app 安装完成并信任证书后，进入 app 页面，点击 JailBreak 进行越狱（这里由于笔者是已经越狱的设备，所以这里显示是 Re-JailBreak）。正常越狱的过程应该是很顺滑的，如果在越狱过程当中出现越狱失败的提示，可以在爱思助手上选择安装不同版本的 unc0ver app 进行尝试，笔者在测试过程当中，最新版本无法完成设备的越狱，选择低版本的 app 后，越狱成功。

![](https://storage.tttang.com/media/attachment/2021/12/20/041122ef-6168-41a3-85f6-9714b77460f9.PNG)

![](https://storage.tttang.com/media/attachment/2021/12/20/724de0f8-8137-4415-94cc-bc31fb703b0c.png)

第六步，越狱成功后，设备中会出现 Cydia 这个应用程序。通过 Cydia 可以安装第三方的 app，这里笔者先安装最新版的 frida server 端到设备上。在 cydia 中添加 frida 源 [https://build.frida.re](https://build.frida.re/)，点击添加源进行添加。

![](https://storage.tttang.com/media/attachment/2021/12/20/df0a90dc-ba8f-48d4-823d-a2735bec37fb.PNG)

添加完成后，在软件页面搜索 frida 进行安装。

![](https://storage.tttang.com/media/attachment/2021/12/20/1fe69ece-4e23-4026-91b5-cd25cea0a66a.png)

第七步，为了方便以后对 iphone 设备的管理过程，笔者通过 Cydia 安装了 OpenSSH，安装完成后，会自动启动，并且可通过 root/mobile 和默认密码 alpine 登录。注意，安装完成后，修改 root 用户和 mobile 用户的默认密码。

![](https://storage.tttang.com/media/attachment/2021/12/20/6fa88fec-4b66-4981-9bab-a816b76841a6.PNG)

![](https://storage.tttang.com/media/attachment/2021/12/20/c8c294dd-8bb2-4e40-a857-80b0bc3f3dca.png)

第八步，验证 Frida 安装情况。frida 安装完成后，会自动启动。验证是否安装成功，在命令行输入 frida-ps -U，查看进程输出信息。

![](https://storage.tttang.com/media/attachment/2021/12/20/e882ad1e-50e6-4615-b461-cb6ce09d9374.png)

出现上图类似的信息，证明安装成功，可以进行 hook 操作了。

[0x01 实战 APP 流量解密](#toc_0x01-app)
---------------------------------

笔者这次需要测试的 APP 为一款采用了 mpaas sdk 加密的应用。在 github 搜索了相关的解密工具之后，笔者发现一款 [MpaasPentestTool](https://github.com/cnmsec/MpaasPentestTool)，正好满足笔者需求（便捷的查看和修改请求包、返回包）。然而，当笔者使用该工具注入 app 进程后，进程会一段时间后结束运行退出。在经过一番实验之后，笔者确定 app 在检测到自身 OC 代码被 hook 之后，将会自动退出。

![](https://storage.tttang.com/media/attachment/2021/12/20/e6a37138-6e41-4801-bae4-2fffe1ba09fb.png)

请注意笔者这里的描述，是检测到自身 OC 代码被 hook。这是因为笔者在尝试 hook native 库和系统 OC 库之后，程序并没有检测到，也没有退出。

![](https://storage.tttang.com/media/attachment/2021/12/20/1a21d24e-4a75-410a-8b72-bf7d50431983.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/0891905c-eb8b-4b82-875d-61f0e0ef5c53.png)

此时笔者大胆猜测，该 APP 只会检测自身 OC 代码是否被 hook，自身 native 代码的检测情况这里先不管，因为跑 MpaasPentestTool 这个工具仅仅需要我们 hook OC 代码即可。接下来就是想尽办法进行绕过检测了，由于笔者 IOS 逆向水平处于入门水平，没有用 IDA 去看脱壳后的程序，分析哪里对 frida hook 进行了检测，这里笔者从 frida hook 代码编写上入手，看看能否从 hook 的地方绕过。

在 google 搜索和仔细查看了 Frida 官方的 API 文档后，笔者发现对 OC 代码进行 hook 有两者方式可以实现，一种是 MpaasPentestTool 采用的基于事件的方式，另一种是对函数直接进行替换。

![](https://storage.tttang.com/media/attachment/2021/12/20/64b5bd3f-3ae0-414d-8325-12df7d5e4245.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/cbad4ab8-8515-44ae-9994-98a884d35a18.png)  
在发现另一种 hook 方式之后，笔者将 MpaasPentestTool 原本的 hook 方式改为对函数直接进行替换的方式。结果出乎意料的是，竟然直接绕过了 app 对 hook 的检测。最终实现了 MpaasPentestTool 作者给出的效果。

![](https://storage.tttang.com/media/attachment/2021/12/20/e53f25e7-7112-455f-abe5-dce2640e06ce.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/eee7864f-ff51-4c26-a929-9ceccdc0947f.png)

[0x01 绕过原理分析](#toc_0x01)
------------------------

app 检测 frida hook 的原理其实是从 Hook 技术本身出发，检测 hook 的特征。通过 Google 学习，笔者了解到 OC 存在三种 HOOK 方式，分别是 objc_msgSend、inline hook、imp 替换 hook。笔者分别查看这两种方式 Hook 前后，imp 指针和函数头部指令的变化，确定这两种方式分别是哪种 hook 技术。

![](https://storage.tttang.com/media/attachment/2021/12/20/ac516eff-8a36-40f3-9070-223e8e2621d9.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/5bc6bb2a-6c3c-4235-885f-8b30e4aa35ca.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/eee6b427-c617-400c-befe-99af586f83ca.png)

分别进行注入，查看输出，最后一窥究竟。

Attach 实现方式其实是 Inline Hook。

![](https://storage.tttang.com/media/attachment/2021/12/20/130b1d7e-b20d-4299-bbde-bb74dc3317cc.png)

![](https://storage.tttang.com/media/attachment/2021/12/20/382ed505-1126-46c6-971f-762f216a32af.png)

Implement 实现方式是替换 IMP 指针。

![](https://storage.tttang.com/media/attachment/2021/12/20/4efb38c2-34c4-4772-a6b0-4c2214c4b0a8.png)

通过分析 Hook 技术的实现不同，可以大胆猜测，app 检测自身是否被 hook 采用了检测 imp 指针指向函数的头部指令是否是 ldr + br 跳转，如果是则认为自身代码被 hook，那么将会直接退出程序自身。

[0x01 参考资料](#toc_0x01_1)
------------------------

*   [为什么使用汇编可以 Hook objc_msgSend（下）- 实现与分析](https://zhuanlan.zhihu.com/p/167924620)
*   [为什么使用汇编可以 Hook objc_msgSend（上）- 汇编基础](https://zhuanlan.zhihu.com/p/130680057)
*   [Objective-C 的 hook 方案（一）: Method Swizzling](https://blog.csdn.net/yiyaaixuexi/article/details/9374411)
*   [iOS hook](https://www.cnblogs.com/HugJun/p/14735373.html)