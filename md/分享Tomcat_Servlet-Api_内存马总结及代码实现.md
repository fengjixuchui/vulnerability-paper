<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/r-JHLX5UoccGNZCfJS3klg)

**前情提要**

谈起 WebShell 相信安全爱好者多少都有点来劲儿，无论是小马、大马还是一句话木马都曾各刑其道，给我们带来过快乐，但这些种在服务端的马都有一个共性：有文件落地。  

有文件落地就意味着更容易触发告警，更容易被安全设备捕获特征并查杀，随着近年来企业红蓝对抗和 HW 的开展，这种有文件落地的 WebShell 可以说已经日薄西山，气数将尽。与此同时，企业级应用仍然是 Java 语言和框架的江山，笔者在梳理内存 WebShell 的 “历史演进” 过程中，发现互联网上最早讨论 Java 内存 WebShell 技术的是 n1nty 大佬（《Tomcat 源代码调试笔记 - 看不见的 Shell》—2017-06-23），而且这种方法就是后文讨论的 JSP Filter 型内存马的实现，但当时并没有引起太多讨论；后来 rebeyond 大佬又提到一种 Java Agent 内存马（《利用 “进程注入” 实现无文件复活 WebShell》—2018-05-30），基于 instrument 机制，在利用过程中需要上传两个 jar 文件：inject.jar 和 agent.jar 然后执行，这种内存 WebShell 的利用条件相对比较苛刻（上传、命令执行），往往用于拿到 WebShell 后进一步的隐藏与维持访问。

时间匆匆过去两年，LandGrey 师傅在 2020-02-17 发表《基于内存 Webshell 的无文件攻击技术研究》，面向 Java 常用 Web 框架 SpringMVC，注册 Controller，实现注入内存 WebShell。

随后关于内存 WebShell 的讨论就开展起来，threedr3am 师傅提出《基于 tomcat 的内存 Webshell 无文件攻击技术》—2020-03-18，借用 kingkk 师傅反射修改控制变量的方式，通过 lastServicedRequest 和 lastServicedResponse 获取到上下文对象，然后在 Tomcat 里动态注册 Filter，整个过程需要执行两步。值得注意的是该方法对 Shiro 反序列化漏洞利用无效，因为反射修改 ApplicationDispatcher.WRAP_SAME_OBJECT 为 true 之前，Shiro 服务已经执行完所有 Filter 了。

Litch1 师傅在《基于全局储存的新思路 | Tomcat 的一种通用回显方法研究》—2020-03-20 里提出通过全局储存的思路，通过 Thread.currentThread().getContextClassLoader() 来获取 Tomcat 上下文，从而实现 Tomcat 的通用回显，该方法对 Shiro 反序列化漏洞有效，但是因为代码结构不同，导致该方法在 Tomcat7 下无法实现回显。

之后，l1nk3r 师傅发表《基于 Tomcat 无文件 Webshell 研究》—2020-03-29，对上面几篇文章的思路做了汇总，在 Servlet 内存马里提出了 addServletMapping 的添加方式，代码简洁优雅，令人耳目一新。

言归正传，在汇总了上面各位师傅的研究和互联网其他师傅基于上述研究实现的代码 demo 之后，千头万绪，思路纷乱，于是笔者决定进行一番梳理并将 Tomcat Servlet-Api 内存马的原理分别应用到 JSP 文件和反序列化漏洞利用场景中，阐述其具体实现，告别 demo，以贴合实战的 Cmd 回显内存马以及冰蝎内存马作为目的，分别实现 Tomcat 下 Filter、Servlet 和 Listener 的内存 WebShell。

根据 Tomcat 版本做了适配，具体实现代码见 github:

https://github.com/ce-automne/TomcatMemShell

当然，既然是 Tomcat 内存 WebShell，就需要先从 Tomcat 开始说起。

**Tomcat 简介**

Tomcat 本质上是一种 Servlet 容器，其顶层架构图如下：  

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370lNqLJGWbAiba1KBQnys7d6pWe9KPg79qjMZl1uBBvI60BXg6DllhBBg/640?wx_fmt=png)

Tomcat 中的 Server 代表服务器，一个 Server 包含至少一个 Service，而 Service 主要包含 Connector 和 Container，可以有多个 Connector，但仅有一个 Container。Connector 用于接受请求并将请求封装成 Request 和 Response，然后交给 Container 进行处理。Container 用于封装和管理 Servlet 以及具体处理 Request 请求。重点看一下 Container 的内部结构，如下图。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370P5ZEFyUWIxj3a1u8258O7rlKQqciaSldHeVffDW0NMB3ddrQaHsdHLA/640?wx_fmt=png)

Engine 作为最顶层的容器组件，其下可以包含多个 Host。对应组件的实现类如下：

```
Engine    实现类：org.apache.catalina.core.StandardEngine
Host      实现类：org.apache.catalina.core.StandardHost
Context   实现类：org.apache.catalina.core.StandardContext
Wrapper   实现类：org.apache.catalina.core.StandardWrapper
```

从上可以看到每个 Wrapper 封装着一个 Servlet，Servlet 是服务器的 Java 应用程序，用于处理 HTTP 请求并做出相应的响应。Filter 会在 HTTP 请求到达 Servlet 之前做一些过滤操作。另外一个接下来要讨论的对象就是 Listener，Listener 用于监听某些特定动作的监听器。当特定动作发生时，监听该动作的监听器就会自动调用对应的方法。  

Servlet、Filter 和 Listener 的执行优先级为：

**Listener > Filter > Servlet**

为了避免内容冗余，在下文的 JSP 内存 WebShell 中将会着重阐述注入方式，并以 Cmd 回显内存马为例；而在反序列化内存 WebShell 部分，将会着重说明注入冰蝎内存马的方法。

**JSP 内存 WebShell**

应用场景往往是攻击者上传或写入 JSP 文件让服务端解析，然后注入内存 WebShell。这严格意义上来说不能算是内存 WebShell，因为在 Tomcat 编译 jsp 文件的时候，会在 Tomcat 目录下有文件落地，如下图所示。当然，如果删掉下面 3 个文件，WebShell 还是有效的，除非重启 Tomcat 容器，否则会一直驻留在内存里。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370d4jBEbhNPwH6dSR6InrZcU0DTBT3M3UC61veibKZ0d5aCvgAmj3oh7A/640?wx_fmt=png)

**Filter 型内存马**

在 JSP 中获取上下文的 ServletContext 很方便，形如下面的代码

```
ServletContext servletContext = request.getSession().getServletContext();
```

接着再通过 ServletContext 就可以获取 standardContext。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370jlVm4o1xDp5t9tTE5T3Gl7zJNDI6LNa7FCV97fJ5QoJ3dYgd7XibubA/640?wx_fmt=png)

这里注入 Filter 型内存马的方法需要先说明如下 3 个对象的定义：

*   filterDefs 存放了 filter 的定义，比如名称跟对应的类
    
*   filterConfigs 除了存放了 filterDef 还保存了当时的 Context
    
*   FilterMaps 则对应了 web.xml 中配置的 <filter-mapping>
    

要实现 Filter 型内存马，需要经过如下步骤：

1. 创建一个恶意 Filter，这里的 doFilter 方法实现的是一个 Cmd 命令执行回显。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia3703EvFrwZDxyG1JWwcfrUNgZmfQCEB0sySXgv6C0MZtXBD8q9wYsblicg/640?wx_fmt=png)

2. 创建一个 FilterDef 并对 filter 进行封装，定义其名称和类名

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370QsGkP4dWprLztkptzAf9BjD9YodhtWwictmvxbWa3deWxpDcXjrtfgw/640?wx_fmt=png)

3. 创建一个 FilterMap 并对 filter 进行封装，定义其名称和 URLPattern

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370FxWIWJ6Pa4K2KLSvlv59iaFRu3T8bZs9JRE7vTPQ1x9sEc3DIjyUdJA/640?wx_fmt=png)

4. 将 filter 添加到 FilterConfig 中

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370iajZ7veQjA7ZEoLHCwYwIoHpfz7x1yx3ktmErcTgrcRjy4PUucfpsxA/640?wx_fmt=png)

最后需要注意的是 Tomcat7 和 Tomcat8/9/10 的 FilterDef、FilterMap 包名差异。

```
Tomcat 7:
org.apache.catalina.deploy.FilterDef
org.apache.catalina.deploy.FilterMap
Tomcat 8/9/10:
org.apache.tomcat.util.descriptor.web.FilterDef
org.apache.tomcat.util.descriptor.web.FilterMap
```

**Servlet 型内存马**

通过 Tomcat 的架构分析，我们知道 “每个 Wrapper 封装着一个 Servlet”, 因为在 JSP 里获取 StandardContext 的方法是一致的，所以直奔主题。

要实现 Servlet 型内存马，需要经过如下步骤：

1. 创建一个恶意 Servlet，在 service 方法里写入恶意代码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370muwHOYqCe6ibwOtpTBIDviblNhm2mpehd3cnEw0JT4AubIPPHcbJXiagA/640?wx_fmt=png)

2. 创建新的 Wrapper 对象，写入 Servlet 名称和类名。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370G16IlwTU0PgnasCTGhndslWzOn4N3dS4eZBfSs3olbibqGTIfkFPggg/640?wx_fmt=png)

3. 将 Wrapper 对象添加到 StandardContext 的 Children 中，并且绑定 URL。

Tomcat 7 使用 addServletMapping 方法

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370hEvMmjh11pJXJk6gqCrTwpWiaKMXpcIweSTREMtZ3EW2tT20geqATMA/640?wx_fmt=png)

Tomcat 8/9/10 使用 addServletMappingDecoded 方法

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia37027xeiaLsEb7jBOibFrpwUYRywjHv10LkBRYniciatIrAG2PicaXQyk9KibPQ/640?wx_fmt=png)

**Listener 型内存马**

当前业界讨论比较多的还是 Filter 型内存马，但是实际上 Listener 型内存马的优先级最高，且代码更简洁优雅。

比较好用的是 ServletRequestListener，因为可以拿到每次请求的 ServletRequestEvent，并通过其中的 getServletRequest() 函数拿到本次请求的 request 对象，从而拿到请求和响应。

实现 Listener 型内存马的逻辑很简单

1. 创建一个恶意的 Listener，并在 requestInitialized 方法里写入恶意代码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370x95L9lUCsFdW4TBldWYybDZ9CIU2dbUGbJxLUuibcEZxwpabTica2COA/640?wx_fmt=png)

2. 通过 addApplicationEventListener 方法添加恶意 Listener

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370SPBgqjjK6AQz6N6DX53LHHiayfTxIc2hsbdq3j6PcYBDnb2UXYbskcQ/640?wx_fmt=png)

没错，就是这么简单粗暴，即可实现一个 Listener 内存马。

**反序列化内存 WebShell**

鉴于反弹 shell 能够轻易地被 hids 等设备检测到，可以尝试打入内存马取得 WebShell 权限再做进一步横移。

通过反序列化漏洞注入内存 WebShell，实现真正的无文件落地 WebShell。

上面提到的 Cmd 回显内存马仅作为注入成功的证明，但在实际利用中，这种 Get 传参无加密的命令执行流量极易被安全设备捕获。接下来以冰蝎客户端为例，阐述利用反序列化漏洞注入冰蝎内存马需要注意什么。

**获取 StandardContext 的方式**  

考虑到代码的可用性和优雅性，这里使用了 Litch1 师傅在《基于全局储存的新思路 | Tomcat 的一种通用回显方法研究》中获取 StandardContext 的方法。

在 Tomcat 8/9/10 版本中，通过 Thread.currentThread().getContextClassLoader() 的方式来获取 Tomcat 上下文。

```
WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
```

获取到 StandardContext 之后，与 JSP 注入代码不同的地方是在 java 代码里需要使用反射机制，以注入 Listener 型内存马为例，如下代码所示。

```
LRain servletRequestListener = new LRain();
Method addlistener = Class.forName("org.apache.catalina.core.StandardContext").getDeclaredMethod("addApplicationEventListener", Object.class);
addlistener.invoke(standardContext,servletRequestListener);
```

**注入冰蝎服务端代码**

上文提到恶意代码都是写在对应的恶意 Filter、Servlet 或者 Listener 中，这里以 Listener 型内存马为例，代码结构如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370NCrrZNEHdnkMia0icr7VDoRI22VutvRtc8x5zBKx4YnZqewkDtGsyJ3Q/640?wx_fmt=png)

重点看一下怎么注入冰蝎服务端代码，首先看一下冰蝎在 github 里提供的 jsp 一句话木马。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370tbJxicp0Flo90RiaPIricfhMReXey6qf9HJlQ2jRXXGTMliaeaskicR568w/640?wx_fmt=png)

可以看到定义了一个继承 ClassLoader 的 U 类，用于执行 defineClass 方法。这也是冰蝎实现动态解析二进制 class 文件的核心方法。

我将核心代码封装到 RushThere 函数里，并把上面提到的 U 类通过字节码的形式进行调用，这样能够解决一些特殊利用场景下的问题，比如 Shiro 漏洞在使用 CC 利用链的时候会要求 extends AbstractTranslet，这样就会违背 java 不支持多重继承的机制。通过字节码定义后再通过反射来做后续的编码加密等操作。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370xDE3STeicEic86xFNVjTHEvn48UhDqleB0fV0uqG5UCP4BADeXPR4O5g/640?wx_fmt=png)

另一点需要注意的就是确保上下文的类是否匹配到 java.lang.ClassLoader，因为自定义的 RushThere 方法里需要调用 defineClass 方法联动冰蝎客户端，只有匹配到 java.lang.ClassLoader 才能正常执行。我这里使用了经典的 if-else 大法 0.0。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370fxccsz1HXWytQNzvrMibWjxwuTRElRmia6PEEiaO1lN5y9EIPBDwgt8HA/640?wx_fmt=png)

解决了这些问题之后，就可以通过反序列化漏洞注入 Servlet-Api 内存马。

**注入效果**

1.JSP 内存 WebShell 以 Listener 型为例，针对 Tomcat 环境，上传 jsp 文件并访问

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia3708xZwCllV3wza75yzkicPibYzmRgiaib7Gjg2am3kcKsEcf0b5BbZyM1ceA/640?wx_fmt=png)

返回 >@< 说明注入成功。

传参执行命令

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370lRsI8tXm7KuuSVjapu5IPQJp3B76EiapOhOJoCAvFObaXSzEvicgu6Bw/640?wx_fmt=png)

2．反序列化内存 WebShell 以 fastjson 反序列化漏洞为例，将 Filter 型冰蝎内存马的 class 文件通过 jndi 远程加载，成功实现注入。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370XWMITnrcT5ntYmJuwvTicQK0PmVer6kycibtcALX7sm1Qmx8ASHGfHlQ/640?wx_fmt=png)

使用冰蝎客户端成功连接

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370amciaT2oTvKIibBDE5zYO7SFJvXx7ibUCGNnf69oASq6MicFBRAZ51QfZA/640?wx_fmt=png)

**内存马检测**

Java 内存马的检测目前主要有两种方法：1）基于反射的检测 2）基于 instrument 机制的检测

对于 Tomcat Servlet-Api 型内存马基于反射就可以实现检测了，具体实现如 c0ny1 师傅的 java-memshell-scanner 项目 (https://github.com/c0ny1/java-memshell-scanner)，通过 jsp 脚本实现扫描和查杀。当前版本只支持对 Filter 和 Servlet 型内存马的检测与查杀。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia3705rrwKPmAUUEeVFWHibIRcpunBg1ztMVVAqFzFftHVpq3pU7qVt8bp0w/640?wx_fmt=png)

对于不方便上传 jsp 脚本的场景，可以基于 instrument 机制进行检测，相关实现如 LandGrey 师傅的 copagent 项目 (https://github.com/LandGrey/copagent)，支持对 Filter/Servlet/Listener 型内存马的检测，并按照风险等级排序。

下图为该项目的 Agent.java 查找实现 servlet 特殊接口的目标类的代码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia3704wibrbxYCpAAZQl8zxoKiavsmAeMCzZbDXKThLyy7J4EEgqXXowLgylg/640?wx_fmt=png)

将 cop.jar 上传到目标环境上并运行，它将会自动 attach jvm 进程并扫描，如果在 windows 环境 attach 失败则需要通过 - p 参数手动指定进程。以 fastjson 环境注入的 Listener 型内存马为例，查看扫描结果如下

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia3707wxDKQiawDAIDBl9dVgpyxnIbD0icOZJHIBET9ibMGibP3Z1XaYd7xJNsg/640?wx_fmt=png)

进一步查看反编译得到的 ILRain.java 文件，可以看到该 java 文件里与冰蝎进行了联动。

![图片](https://mmbiz.qpic.cn/mmbiz_png/c0lpcA1w7NueKhibtKeKGd6icCf0MHia370DROz6GuorWxr9A77Mq9UIo86BuplTyJtnoEQWLO0siatEGsVxKMSiaoA/640?wx_fmt=png)

”

参考链接

1. 利用 “进程注入” 实现无文件复活 WebShell

https://www.freebuf.com/articles/web/172753.html

2. 基于内存 Webshell 的无文件攻击技术研究

https://www.anquanke.com/post/id/198886

3. Tomcat 中一种半通用回显方法

https://xz.aliyun.com/t/7348

4. 基于 tomcat 的内存 Webshell 无文件攻击技术

https://xz.aliyun.com/t/7388

5. 基于全局储存的新思路 | Tomcat 的一种通用回显方法研究

https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651374294&idx=3&sn=82d050ca7268bdb7bcf7ff7ff293d7b3

6. 基于 Tomcat 无文件 Webshell 研究

https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652474966&idx=1&sn=1c75686865f7348a6b528b42789aeec8&scene=21#wechat_redirect

7. JSP Webshell 那些事 -- 攻击篇 (下)

https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w

8. 利用动态二进制加密实现新型一句话木马之 Java 篇

https://xz.aliyun.com/t/2744

9. Tomcat 源代码调试笔记 - 看不见的 Shell

https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw

10. 四张图带你了解 Tomcat 系统架构

https://blog.csdn.net/xlgen157387/article/details/79006434

11. Filter/Servlet 型内存马的扫描抓捕与查杀

https://gv7.me/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/