<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/12257)

> 先知社区，先知安全技术社区

1、前言
----

最近研究 RPC 在内网中的一些攻击面，主要是以红队视角来看，使用 RPC 协议有时候 Bypass EDR 等设备会有较好的效果，那么什么是 RPC 呢，RPC 代表 “远程过程调用”，它不是 Windows 特定的概念。RPC 的第一个实现是在 80 年代在 UNIX 系统上实现的。这允许机器在网络上相互通信，它甚至被 “用作网络文件系统（NFS）的基础”，其实简单的说就是它允许请求另一台计算机上的服务，本节内容主要是依靠 [Microsoft 官方文档](https://learn.microsoft.com/zh-cn/windows/win32/rpc/rpc-start-page "Microsoft官方文档")进行学习。

2、RPC 结构相关概念
------------

1、首先我们要理解 RPC 是如何进行通信的首先需要知道几个概念 IDL 文件，UUID，ACF 文件

IDL 文件：为了统一客户端与服务端不同平台处理不同的实现，于是有了 IDL 语言。IDL 文件由一个或多个接口定义组成，每一个接口定义都有一个接口头和一个接口体，接口头包含了使用此接口的信息 (UUID 和接口版本)，接口体包含了接口函数的原型相关细节查看。

UUID：通常为一个 16 长度的标识符，具有唯一性，在 Rpc 通信模型中，UUID 提供对接口、管理器入口点向量或客户端对象等对象的唯一指定。

ACF：(ACF) 的应用程序配置文件有两个部分： 接口标头，类似于 IDL 文件中的接口标头，以及一个 正文，其中包含适用于 IDL 文件的接口正文中定义的类型和函数的配置属性。

2、调用过程

[RpcStringBindingCompose](https://learn.microsoft.com/zh-cn/windows/win2/api/rpcdce/nf-rpcdce-rpcstringbindingcompose "RpcStringBindingCompose")：需要先创建一个绑定句柄字符串。。

[RpcBindingFromStringBinding](https://learn.microsoft.com/zh-cn/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcompose "RpcBindingFromStringBinding")：通过绑定句柄字符串返回绑定句柄。

3、存根分配和释放内存
-----------

在编写 RPC 调用的时候，必须将函数 MIDL_user_allocate 和 MIDL_user_free 在项目的中定义。

4、相关攻击面
-------

所有的 Demo 都在 [https://github.com/M0nster3/RpcsDemo](https://github.com/M0nster3/RpcsDemo) ，大家可参考。

### 1、IOXID Resolver 探测内网多网卡主机

我们发送一个 IOXID 的传输包，这个发送方式有很多种，我这里用的 K8 师傅的工具，用 Wireshark 抓包。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123013-6c398b02-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123013-6c398b02-bb0e-1.png)

上图中 TCP 的三个包就不用看了，就是很常见的 TCP 的三次握手，后四个包中可以如图看，主要关注的是最后一个包，前三个都是固定的，就是交互中用来协商版本之类的参数。

1、先来构造第一个数据包，由于这个包是固定的可以直接 Copy Wireshark 中的，如下图

```
05000b03100000004800000001000000b810b810000000000100000000000100c4fefc9960521b10bbcb00aa0021347a00000000045d888aeb1cc9119fe808002b10486002000000

```

2、后续第二个是接受的数据包，直接将第三个包复制就可以

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123034-7894fabc-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123034-7894fabc-bb0e-1.png)

```
050000031000000018000000010000000000000000000500

```

3、主要就是看我们如何剖析最后一个包，将他接收过来并且进行一个分割输出，首先我们是想要枚举他的多网卡信息，和主机信息。我们对数据包进行一个分割。是从 / 0x07/0x00 / 进行分割。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123052-837de984-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123052-837de984-bb0e-1.png)

结束的是在 0x09/0x00/0xff 这一块结束的, 把我们接受的数据进行一个分割。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123101-88632a90-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123101-88632a90-bb0e-1.png)

相关代码：[https://github.com/M0nster3/RpcsDemo/blob/main/OXIDINterka_network_card/OXID.go](https://github.com/M0nster3/RpcsDemo/blob/main/OXIDINterka_network_card/OXID.go)

效果图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123111-8ebfc0ba-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123111-8ebfc0ba-bb0e-1.png)

### 2、RPC SMB

RPC 还可以通过不同的协议进行一个访问，例如通过 SMB 协议传输的 RPC 服务就可以通过管道进行访问，加入在做项目的时候又有个域凭证就可以进行一写 RPC 借口的一个调用，比较好用的一个工具是 rpcclient，它是执行客户端 MS-RPC 功能的工具。 相关命令的一些总结我发在了 [https://github.com/M0nster3/RpcsDemo/blob/main/RPC%20over%20SMB/MS-RPC.md 中，大家有需要可以去提取。](https://github.com/M0nster3/RpcsDemo/blob/main/RPC%20over%20SMB/MS-RPC.md%E4%B8%AD%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8F%90%E5%8F%96%E3%80%82)

### 3、MS-SAMR 的那些事

该协议支持包含用户和组的帐户存储或目录的管理功能，简单来说就是该协议主要是对 Windows 用户以及用户组的一些相应操作，例如添加用户，用户组等操作。[官方参考.](https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380 "官方参考.")

1）添加本地用户  
调用的 API SamrCreateUser2InDomain() 可以创建一个用户.

```
long SamrCreateUser2InDomain(
   [in] SAMPR_HANDLE DomainHandle,
   [in] PRPC_UNICODE_STRING Name,
   [in] unsigned long AccountType,
   [in] unsigned long DesiredAccess,
   [out] SAMPR_HANDLE* UserHandle,
   [out] unsigned long* GrantedAccess,
   [out] unsigned long* RelativeId
 );

```

在创建用户的时候通过分档来看，不能直接创建到内置域（Builtin）中，需要先创建到账户域（账户）中，如下图。

关于内置域和账户域的相关内容可以参考[官方链接](https://learn.microsoft.com/zh-cn/windows/win32/secmgmt/built-in-and-account-domains "官方链接").

其实简单来说就是，账户域内的用户只能访问该账户所在计算机的资源，而内置域中的账户可以访问域的资源。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123230-bd8759b2-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123230-bd8759b2-bb0e-1.png)

由于使用 SamrCreateUser2InDomain 创建的账户存在禁用标识位，我们先需要为它 Set 一个属性，来清除禁用标识位。然后才可以将其加入到所在的内置域中。

使用 SamrSetInformationUser() 这个 API 为它设置。

```
long SamrSetInformationUser(
   [in] SAMPR_HANDLE UserHandle,
   [in] USER_INFORMATION_CLASS UserInformationClass,
   [in, switch_is(UserInformationClass)] 
     PSAMPR_USER_INFO_BUFFER Buffer
 );

```

编写脚本有两种方式一种是直接调用 MS-SAMR 协议去直接创建一个用户，微软官方给了 [IDL](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/1cd138b9-cc1b-4706-b115-49e53189e32e "IDL")，将其编译，然后构造，这种方式调用起来比较麻烦，另一种是使用神器 mimikatz 打包好的包，samlib 来进行调用，调用的时候将前面的 samr 改成 sam 就可以.

参考微软给的[官方例子](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/3d8e23d8-d9df-481f-83b3-9175f980294c "官方例子").

可以按照这个例子依次构造

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123321-dc0477c6-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123321-dc0477c6-bb0e-1.png)

首先先求出来账户域 Account 和内置域的 Builts 的 SID 为后续添加账户以及加入到内置域中做准备。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123330-e15294b0-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123330-e15294b0-bb0e-1.png)

然后获取域对象的句柄，然后为域对象添加用户, 并且清除禁用标识位，关键代码。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123337-e582e170-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123337-e582e170-bb0e-1.png)

到这里创建用户的准备工作就结束了，接下来，就是将用户添加到组里面，用到 [SamAddMemberToAlias](https://www.t00ls.com/Ihttps%3A//learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/9a5d2c35-e84b-4e59-b7b0-96c6fa0fc8d7 "SamAddMemberToAlias").

```
long SamrAddMemberToAlias(
   [in] SAMPR_HANDLE AliasHandle,
   [in] PRPC_SID MemberId
 );

```

相应的 Demo：[https://github.com/M0nster3/RpcsDemo/blob/main/MS-SAMR/AddUser/AddUser/main.c](https://github.com/M0nster3/RpcsDemo/blob/main/MS-SAMR/AddUser/AddUser/main.c)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123406-f6b3c676-bb0e-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123406-f6b3c676-bb0e-1.png)

2) Change Ntlm  
调用的关键 API 在 [SamrChangePasswordUser](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/9699d8ca-e1a4-433c-a8c3-d7bebeb01476 "SamrChangePasswordUser") .

当我们获取到了用户名，以及密码 NTLMhash，则可以是用这个 API 将用户的密码修改了。

```
long SamrChangePasswordUser(
   [in] SAMPR_HANDLE UserHandle,
   [in] unsigned char LmPresent,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD OldLmEncryptedWithNewLm,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithOldLm,
   [in] unsigned char NtPresent,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD OldNtEncryptedWithNewNt,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithOldNt,
   [in] unsigned char NtCrossEncryptionPresent,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithNewLm,
   [in] unsigned char LmCrossEncryptionPresent,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithNewNt
 );

```

这这里遇到了一个坑，就是只用旧的 Ntlm 就行修改而不对 LmCrossEncryptionPresent 和 NewLmEncryptedWithNewNt 进行传参，则会输出一个 C000017F 的错误，如下图。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123514-1f496f32-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123514-1f496f32-bb0f-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123521-238cdb6a-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123521-238cdb6a-bb0f-1.png)

我去查看一下这个错误发现是客户端使用当前密码 LM hash 作为加密密钥请求返回，不清楚为什么不能用当前的密码 LM hash，就改了一个其他的 LM hash, 关键代码。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123547-32f7f10c-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123547-32f7f10c-bb0f-1.png)

接下来就是编写 POC，我在这里使用微软官方的提供的 [IDL](https://www.t00ls.com/%20https%3A//learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/1cd138b9-cc1b-4706-b115-49e53189e32e "IDL") 进行编译，提供了我们需要的所有包，在我们编译好，生成 exe 的时候会有很多错误，直接将其都注释就好。

根据 RPC 的调用过程首先需要进行 RPC 的绑定

```
RPC_STATUS RpcStringBindingComposeW(
  RPC_WSTR ObjUuid,
  RPC_WSTR ProtSeq,
  RPC_WSTR NetworkAddr,
  RPC_WSTR Endpoint,
  RPC_WSTR Options,
  RPC_WSTR *StringBinding
);

```

其中的 ObjUuid 可以直接在提供的 IDL 中找到，如下图，但是发现这个例子有没有这个都可以，[最主要的必须定义一个命名管道端点 \PIPE\samr](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/13e9ee5d-4125-4492-bcc7-9a0061f2bbe7 "最主要的必须定义一个命名管道端点 \PIPE\samr")。 关键代码

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123733-7233f37a-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123733-7233f37a-bb0f-1.png)

绑定了之后接下来就是构造 SamrChangePasswordUser, 如果我们不熟悉 MS-SAMR 我们可以倒着堆整个调用流程。

```
long SamrChangePasswordUser(
   [in] SAMPR_HANDLE UserHandle,
   [in] unsigned char LmPresent,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD OldLmEncryptedWithNewLm,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithOldLm,
   [in] unsigned char NtPresent,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD OldNtEncryptedWithNewNt,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithOldNt,
   [in] unsigned char NtCrossEncryptionPresent,
   [in, unique] PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithNewLm,
   [in] unsigned char LmCrossEncryptionPresent,
   [in, unique] PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithNewNt
 );

```

根据上面的图，以及相关的官方文档，我们发现我们现在就需要传入一个 UserHandle 用户句柄，其他的就是我们需要输入的 NT hash，以及我们需要修改的新的 NT hash，那么这个 UserHandle 需要从哪里获取呢。这时候可以翻看官方文档。发现一个 API [SamrOpenUser()](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/0aee1c31-ec40-4633-bb56-0cf8429093c0 "SamrOpenUser()") 如下，可以为我们提供我们需要的 Userhandle，

这个 API 意思就是通过 RID 来获取用户句柄。

```
long SamrOpenUser(
   [in] SAMPR_HANDLE DomainHandle,
   [in] unsigned long DesiredAccess,
   [in] unsigned long UserId,
   [out] SAMPR_HANDLE* UserHandle
 );

```

继续查看这个 API 需要什么参数，需要一个域的句柄，所需要的[访问权限](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/c0be3f43-bcf9-43ee-b027-3d02ab372c53 "访问权限")查看文档，如下图，由于我们是要实现修改密码，所以我们需要一个指定修改用户密码的能力 USER_CHANGE_PASSWORD，最后还需要一个 RID。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305123846-9d95e0aa-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305123846-9d95e0aa-bb0f-1.png)

通过上面的分析，我们现在好需要两个参数，一个参数是 DomainHandle，另一个就是 UserId.

继续翻看文档发现这样一个 API [SamrLookupNamesInDomain](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/d91271c6-7b2e-4194-9927-8fabfa429f90 "SamrLookupNamesInDomain") 如下

就是将我们输入的用户名转化为 RID，输出一个 RID 号，到这里我们上面所需要的两个参数中的 UserId 就找到了。

这里需要的两个参数就是我们输入的用户名，还有和上面 SamrOpenUser 通向需要的的 DomainHandle。

```
long SamrLookupNamesInDomain(
   [in] SAMPR_HANDLE DomainHandle,
   [in, range(0,1000)] unsigned long Count,
   [in, size_is(1000), length_is(Count)] 
     RPC_UNICODE_STRING Names<li>,
   [out] PSAMPR_ULONG_ARRAY RelativeIds,
   [out] PSAMPR_ULONG_ARRAY Use
 );

```

我们继续找返现 [SamrOpenDomain](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/ba710c90-5b12-42f8-9e5a-d4aacc1329fa "SamrOpenDomain") 这个 API，通过 SID 号可以输出我们需要的域对象句柄。

```
long SamrOpenDomain(
   [in] SAMPR_HANDLE ServerHandle,
   [in] unsigned long DesiredAccess,
   [in] PRPC_SID DomainId,
   [out] SAMPR_HANDLE* DomainHandle
 );

```

到这里 SamrOpenUser 这个 API 所需要的条件就找全了。

我们需要继续为 SamrOpenDomain 寻找它所需要输入的内容，服务器句柄，SID 号

这一块可以使用 SamrLookupDomainInSamServer 来获取我们需要的 SID.

这个需要一个内置域的名称，也就是上面上面添加本地用户中提到的获取内置域的名称就可以，这里填写 “Builtin” 以及一个服务器句柄。

```
long SamrLookupDomainInSamServer(
   [in] SAMPR_HANDLE ServerHandle,
   [in] PRPC_UNICODE_STRING Name,
   [out] PRPC_SID* DomainId
 );

```

获取服务器对象的句柄使用到的 API [SamrConnect5](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/c842a897-0a42-4ca5-a607-2afd05271dae " SamrConnect5")。

这个 API 会返回服务器对象的句柄, 需要我们填入我们的服务器，直接填写机器名称就可以。

```
long SamrConnect5(
   [in, unique, string] PSAMPR_SERVER_NAME ServerName,
   [in] unsigned long DesiredAccess,
   [in] unsigned long InVersion,
   [in] [switch_is(InVersion)] SAMPR_REVISION_INFO* InRevisionInfo,
   [out] unsigned long* OutVersion,
   [out, switch_is(*OutVersion)] SAMPR_REVISION_INFO* OutRevisionInfo,
   [out] SAMPR_HANDLE* ServerHandle
 );

```

总结一下：

1、我们首先利用 SamrConnect5 获取服务器句柄。

2、利用获取到的服务器句柄经过 SamrLookupDomainInSamServer 获取服务器 SID,。

3、接着利用对一步中获取的服务器句柄以及第二步中的 SID 利用 SamrOpenDomain 获取域句柄

4、接下来利用获取到的域句柄利用 SamrLookupNamesInDomain 获取 RID 号

5、接着利用第四步中的 RID 以及第三步中的域句柄利用 SamrOpenUser API 获取用户句柄

6、最后利用用户句柄以及之前的 NT hash 和需要修改的 Nt Hash 调用 SamrChangePasswordUser 修改密码。

想要修改的 Nt hash 可以使用 python2 。

```
import hashlib,binascii
print binascii.hexlify(hashlib.new("md4", "123456".encode("utf-16le")).digest())

```

效果图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124039-e1587eb0-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124039-e1587eb0-bb0f-1.png)

完整的 Demo：

[https://github.com/M0nster3/RpcsDemo/blob/main/MS-SAMR/ChangeNTLM/ChangePass/main.c](https://github.com/M0nster3/RpcsDemo/blob/main/MS-SAMR/ChangeNTLM/ChangePass/main.c)

### 4、MS-TSCH

[MS - TSCH]：任务计划程序服务远程协议, 用于注册和配置任务以及查询远程计算机上运行的任务的状态。顾名思义就是利用这个 API 可以操纵计划任务。[https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-tsch/d1058a28-7e02-4948-8b8d-4a347fa64931](https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-tsch/d1058a28-7e02-4948-8b8d-4a347fa64931)

直接来看相关 API [SchRpcRegisterTask](https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-tsch/849c131a-64e4-46ef-b015-9d4c599c5167 "SchRpcRegisterTask")

直接向服务器注册一个任务，关键的两个参数一个是我们创建服务的路径，另一个就是定义计划任务的 xml。

```
HRESULT SchRpcRegisterTask(
   [in, string, unique] const wchar_t* path,
   [in, string] const wchar_t* xml,
   [in] DWORD flags,
   [in, string, unique] const wchar_t* sddl,
   [in] DWORD logonType,
   [in] DWORD cCreds,
   [in, size_is(cCreds), unique] const TASK_USER_CRED* pCreds,
   [out, string] wchar_t** pActualPath,
   [out] PTASK_XML_ERROR_INFO* pErrorInfo
 );

```

奇怪的是我们在编写的时候总是提示我们缺少参数，如下图, 我们缺少一个句柄，这个句柄就是我们写 RPC 时候的一个绑定句柄，这个 Demo 写起来就简单多了，不需要之前那么多要求，只要配置一个 RPC 绑定就可以了。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124119-f91dff98-bb0f-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124119-f91dff98-bb0f-1.png)

本来以为很简单直接写一个绑定就可以，没想到调用之前的绑定，发现总是失败，后来查找 github 别人的源码发现需要多一步验证，需要实现 RpcBindingSetAuthInfoExA, 真是吐了。

```
RPC_STATUS RpcBindingSetAuthInfoExA(
  RPC_BINDING_HANDLE       Binding,
  RPC_CSTR                 ServerPrincName,
  unsigned long            AuthnLevel,
  unsigned long            AuthnSvc,
  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
  unsigned long            AuthzSvc,
  RPC_SECURITY_QOS         *SecurityQos
);

```

关键代码

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124138-0454bafa-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124138-0454bafa-bb10-1.png)

效果图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124145-0837ad9e-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124145-0837ad9e-bb10-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124152-0c88ae8e-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124152-0c88ae8e-bb10-1.png)

相关代码：

[https://github.com/M0nster3/RpcsDemo/blob/main/MS-TSCH_DESK/RPCDESK/RPCDESK/main.c](https://github.com/M0nster3/RpcsDemo/blob/main/MS-TSCH_DESK/RPCDESK/RPCDESK/main.c)

### 5、MS-SCMR

[[MS - SCMR]](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-scmr/705b624a-13de-43cc-b8a2-99573da3635f "[MS - SCMR]")：服务控制管理器远程协议.

指定服务控制管理器远程协议，用于远程管理服务控制管理器 (SCM)，这是一个启用服务配置和服务程序控制的 RPC 服务器。其实就是一个管理服务的一个 RPC 协议。

需要调用 ROpenSCManagerA、RCreateServiceA 也可以创建服务，除了这个之外还可以查看很多文档，还有许多 API 来使用。

```
DWORD ROpenSCManagerA(
   [in, string, unique, range(0, SC_MAX_COMPUTER_NAME_LENGTH)] 
     SVCCTL_HANDLEA lpMachineName,
   [in, string, unique, range(0, SC_MAX_NAME_LENGTH)] 
     LPSTR lpDatabaseName,
   [in] DWORD dwDesiredAccess,
   [out] LPSC_RPC_HANDLE lpScHandle
 );

```

```
DWORD RCreateServiceA(
   [in] SC_RPC_HANDLE hSCManager,
   [in, string, range(0, SC_MAX_NAME_LENGTH)] 
     LPSTR lpServiceName,
   [in, string, unique, range(0, SC_MAX_NAME_LENGTH)] 
     LPSTR lpDisplayName,
   [in] DWORD dwDesiredAccess,
   [in] DWORD dwServiceType,
   [in] DWORD dwStartType,
   [in] DWORD dwErrorControl,
   [in, string, range(0, SC_MAX_PATH_LENGTH)] 
     LPSTR lpBinaryPathName,
   [in, string, unique, range(0, SC_MAX_NAME_LENGTH)] 
     LPSTR lpLoadOrderGroup,
   [in, out, unique] LPDWORD lpdwTagId,
   [in, unique, size_is(dwDependSize)] 
     LPBYTE lpDependencies,
   [in, range(0, SC_MAX_DEPEND_SIZE)] 
     DWORD dwDependSize,
   [in, string, unique, range(0, SC_MAX_ACCOUNT_NAME_LENGTH)] 
     LPSTR lpServiceStartName,
   [in, unique, size_is(dwPwSize)] 
     LPBYTE lpPassword,
   [in, range(0, SC_MAX_PWD_SIZE)] 
     DWORD dwPwSize,
   [out] LPSC_RPC_HANDLE lpServiceHandle
 );

```

通过创建的服务是没有开启的，这个时候我们就需要一个开启的 API RStartServiceA, 准备好了所有的东西，就可以开始编写 Demo。

相关 Demo 和之前的一样哪些搞就可以了，这里写几个注意的点。

1、当我们使用官方给的 IDL 编写的时候有很多重命名，我们直接注释就可以，还有一些我们代码中可能用不到的方法，但是由于是使用官方的 IDL 编译的，所以需要我们实现一下。

2、创建服务的时候只能直接将我们的 EXE 作为服务启动，因为不是所有程序都可以作为服务的方式运行，作为服务运行需要能返回运行情况等信息，所以有的程序添加后会，这里我提供一个方法，就是使用微软官方的程序 srvany.exe

​ 1）首先将 srvany.exe 添加到服务中并且启动。

​ 2）将我们要执行的内容路径放入到注册表中

```
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters /v AppDirectory /t REG_SZ /d "c:\" /f

```

​ 3）然后将程序放入注册表

```
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters /v Application /t REG_SZ /d "c:\xxx.exe" /f

```

```
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters /v AppParameters /t REG_SZ /d "如果程序需要参数则填在这里，如果不需要，清空这段文字或者整行" /f

```

效果图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124311-3bb39f66-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124311-3bb39f66-bb10-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124321-4183fd0a-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124321-4183fd0a-bb10-1.png)

这里我们将我们的 shellcode 执行一下, 添加注册表的时候需要将 servicesname 改为你添加任务的名字。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124327-459677f6-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124327-459677f6-bb10-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124334-4989da38-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124334-4989da38-bb10-1.png)

而且这里还是 system 权限。

### 6、Seclogon Dump Lsass

这个是 [splinter_code](https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-2.html "splinter_code ") 这个师傅发现的.

它的原理主要是，不直接调用 OpenProcess 去打开进程对象，而是利用已经打开的 Lsass 进程句柄，从而绕过检测，然后利用 RpcImpersonateClient 尝试使用 PID 做一个调用者的伪造。

关键细节可以看这个师傅的博客说的很详细了：

效果图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20230305124358-57edd69c-bb10-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20230305124358-57edd69c-bb10-1.png)

需要将我们的第一步 - t 1 的提取出来，不然直接使用 - t 2 解密之后会被杀软杀了。

参考  
[https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-3.html](https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-3.html) [https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-2.html](https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-2.html) [https://www.anquanke.com/post/id/245482#h3-5](https://www.anquanke.com/post/id/245482#h3-5) [https://mp.weixin.qq.com/s/ByW_tsipzLGKa9mUBImCqA](https://mp.weixin.qq.com/s/ByW_tsipzLGKa9mUBImCqA)