<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/UXFe5Zm9vd5rNBUXU23nbw)

前言
==

在 32 位的系统下，我们想要实现某些监控十分简单，只需要找到对应的 API 实现挂钩操作即可检测进程。但在 64 位系统下随着`Patch Guard`的引入，导致我们如果继续使用挂钩 API 的方式进行监控会出现不可控的情况发生。微软也考虑到了用户程序的开发，所以开放了方便用户调用的系统回调 API 函数，在 64 位系统下的监控，使用系统回调相对于直接 hook 的方式往往是更值得青睐的一方。

进程监控 & 保护
=========

PsSetCreateProcessNotifyRoutineEx
---------------------------------

这个函数主要是设置进程回调监控进程创建与退出

```
NTSTATUS PsSetCreateProcessNotifyRoutineEx(  [in] PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,  [in] BOOLEAN                           Remove);
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0gVhYYXWWX7ucuSrrsR3SibvhzKRFYrKWiapXwzXO04mDpvgvv1r7cIeg/640?wx_fmt=png)

`PsSetCreateProcessNotifyRoutineEx`这个函数并不是随便就能够使用的，微软为了确保安全性要求拥有数字签名的驱动才能够使用此函数。这里微软如何检测是否有数字签名呢？这里就使用到了强制完整性检查

强制完整性检查是一种确保正在加载的二进制文件在加载前需要使用签名的策略，`IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY`标志在链接时通过使用`/integritycheck`链接器标志在 PE 头中进行设置，让正在加载的二进制文件必须签名，这个标志使 windows 内存管理器在加载时对二进制文件进行签名检查

那么微软就是通过加载二进制文件时是否存在标志来确认驱动的发布者身份是否为已知状态，这就是强制完整性检查

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0GbDjVt64CxlRtlb3wQpnJWozQRDb9cSLHE0TlPIhMEEhv3BbJvbg0w/640?wx_fmt=png)

这里在内核里面，windows 使用到`MmVerifyCallbackFunction` 这个内核函数来判断

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0ich2Cs3MniaKR3Z0ibaJ2Q2gd3HdXWh1syBkw7RJRBFNhkff4p4VCibf8w/640?wx_fmt=png)

到 IDA 里面继续跟`MmVerifyCallbackFunction`这个函数，发现其逻辑就是通过比较`[rax+68h]`是否包含了 0x20 来判断是否拥有正确的数字签名

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0fL6libBqibbWPhkfq0cxGPtMYbacLIY26VGMxzCbBuUia0od5ibxeFCfrA/640?wx_fmt=png)

这里的`rax`表示`DriverSection`，而`DriverSection`指向的是`_LDR_DATA_TABLE_ENTRY`结构，那么`[rax + 0x68]`指向的就是`ProcessStaticImport`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0CHzgS89MCrmVYVZtI51GFOCFVnMmf5AaSrSkPCCK34nm2VKrcIzxVA/640?wx_fmt=png)

那么如果我们要使用`PsSetCreateProcessNotifyRoutineEx`这个函数就需要拥有数字签名，这里我们就可以将`DriverObject->DriverSection->Flags`的值与`0x20`按位或即可

这里我们就可以编写一个绕过强制完整性检查的函数，注意一下在 32 位和 64 位结构体的定义不同，需要分开定义

```
BOOLEAN bypass_signcheck(PDRIVER_OBJECT pDriverObject){#ifdef _WIN64 typedef struct _KLDR_DATA_TABLE_ENTRY {  LIST_ENTRY listEntry;  ULONG64 __Undefined1;  ULONG64 __Undefined2;  ULONG64 __Undefined3;  ULONG64 NonPagedDebugInfo;  ULONG64 DllBase;  ULONG64 EntryPoint;  ULONG SizeOfImage;  UNICODE_STRING path;  UNICODE_STRING name;  ULONG   Flags;  USHORT  LoadCount;  USHORT  __Undefined5;  ULONG64 __Undefined6;  ULONG   CheckSum;  ULONG   __padding1;  ULONG   TimeDateStamp;  ULONG   __padding2; } KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;#else typedef struct _KLDR_DATA_TABLE_ENTRY {  LIST_ENTRY listEntry;  ULONG unknown1;  ULONG unknown2;  ULONG unknown3;  ULONG unknown4;  ULONG unknown5;  ULONG unknown6;  ULONG unknown7;  UNICODE_STRING path;  UNICODE_STRING name;  ULONG   Flags; } KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;#endif PKLDR_DATA_TABLE_ENTRY pLdrData = (PKLDR_DATA_TABLE_ENTRY)pDriverObject->DriverSection; pLdrData->Flags = pLdrData->Flags | 0x20; return TRUE;}
```

到这里我们就已经绕过了微软的强制完整性检查，能够调用`PsSetCreateProcessNotifyRoutineEx`函数，可以看到`PsSetCreateProcessNotifyRoutineEx`的第一个参数指向`CREATE_PROCESS_NOTIFY_ROUTINE_EX`，来执行我们需要执行的回调函数，这里我们继续看`PCREATE_PROCESS_NOTIFY_ROUTINE_EX`这个结构

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0srRdetibJYVmQtjqiacW1L4UAXqrdZAf5kib2PC4yneydL5EXAvolVxNA/640?wx_fmt=png)

PCREATE_PROCESS_NOTIFY_ROUTINE_EX
---------------------------------

第一个参数是`Process`，指向`EPROCESS`结构，第二个参数`ProcessId`就是 PID，第三个参数`CreateInfo`是一个指向`PS_CREATE_NOTIFY_INFO`的指针，当它为`NULL`时表明进程退出，不为`NULL`时表明进程创建，里面存储着要创建的进程信息

```
PCREATE_PROCESS_NOTIFY_ROUTINE_EX PcreateProcessNotifyRoutineEx;void PcreateProcessNotifyRoutineEx(  [_Inout_]           PEPROCESS Process,  [in]                HANDLE ProcessId,  [in, out, optional] PPS_CREATE_NOTIFY_INFO CreateInfo){...}
```

msdn 的定义如下

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0lgMHmGOXSwpj7P6YAMibxOibgicvqLY7fQsL2s6jx63QSxib0FicoAXOKdw/640?wx_fmt=png)

然后我们再去看一下`PS_CREATE_NOTIFY_INFO`

PS_CREATE_NOTIFY_INFO
---------------------

```
typedef struct _PS_CREATE_NOTIFY_INFO {  SIZE_T              Size;  union {    ULONG Flags;    struct {      ULONG FileOpenNameAvailable : 1;      ULONG IsSubsystemProcess : 1;      ULONG Reserved : 30;    };  };  HANDLE              ParentProcessId;  CLIENT_ID           CreatingThreadId;  struct _FILE_OBJECT *FileObject;  PCUNICODE_STRING    ImageFileName;  PCUNICODE_STRING    CommandLine;  NTSTATUS            CreationStatus;} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;
```

msdn 定义如下

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0n3m84jIsQx9MdOSTbSOGv1URwYgo0ISGm8PrwnbHkNCh2zn6OHT4rg/640?wx_fmt=png)

这里的话我们要注意两个值，一个是`ImageFileName`即要创建的进程名，一个是`CreationStatus`，我们可以看到 msdn 里面说驱动程序可以将此值修改为错误代码以防止创建进程，这里我们如果想阻止进程创建就可以把这个值设置为`STATUS_UNSUCCESSFUL`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY00YLaxjUgUicph1q8998Ls7sEMTaCPVkyMgYICHAeRicRDbl1lQEsofJg/640?wx_fmt=png)

我们去 WRK 里面看一下实现，这个 API 是 64 位才有的，所以在 WRK 里面是没有`PsSetCreateProcessNotifyRoutineEx`这个函数的，但是在 32 位下有一个`PsSetCreateProcessNotifyRoutine`，我们看一下

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0Svx067SlxcXwIicWiaiajTjiauoGbeyn756IlWua05ib8XwZibfPzXic1Kd7A/640?wx_fmt=png)

通过源码可以发现是操作数组，这个数组里面存放的是我们填写的回调，而操作系统会依次调用回调，那我们跟随数组查看发现是个定长数组，里面只有 8 项，在 64 位系统下，这个数组的长度变为了 64 项

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0JI4tsNaUXHiaBx2umF5L3JExqH4oamCBVEMtKIsqat4Zv20AZZYB0Ag/640?wx_fmt=png)

根据`PCREATE_PROCESS_NOTIFY_ROUTINE_EX`的结构定义回调函数

```
VOID CreateProcessNotifyEx(    __inout PEPROCESS  Process,    __in HANDLE  ProcessId,    __in_opt PPS_CREATE_NOTIFY_INFO  CreateInfo    );
```

那么我们这里通过`PsSetCreateProcessNotifyRoutineEx`设置回调函数，通过判断`status`的返回值判断回调函数是否设置成功

```
NTSTATUS SetReFunction(){ NTSTATUS status = PsSetCreateProcessNotifyRoutineEx((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)CreateProcessNotifyEx, FALSE);    if (!NT_SUCCESS(status))    {        DbgPrint("回调函数设置失败, status=%X", status);    }    else    {        DbgPrint("进程监控已开启\r\n");    \}\}
```

然后进行回调函数的实现

```
VOID CreateProcessNotifyEx(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo)
```

首先判断`CreateInfo`的值，如果为`NULL`则表示进程退出，如果不为`NULL`才为进程的创建

```
if (CreateInfo == NULL){    DbgPrint("进程退出\n");    return;}
```

那么这里通过`PsGetProcessImageFileName`获取进程名之后进行判断，如果是我们想要拦截的进程就通过设置`CreationStatus`的值为`STATUS_UNSUCCESSFUL`来阻止进程的创建

```
else{    pszImageFileName = PsGetProcessImageFileName(Process);    if (pszImageFileName)         DbgPrint("新创建的进程是:%s\r\n", pszImageFileName);    if (strcmp(pszImageFileName, "test.exe") == 0)    {        CreateInfo->CreationStatus = STATUS_UNSUCCESSFUL;        DbgPrint("拦截进程:%s成功\r\n", pszImageFileName);    \}\}
```

这里我们的回调函数就已经完成，这里需要注意，在卸载驱动的时候就需要将回调函数摘除，否则新创建或者退出的进程会因为找不到回调函数而导致蓝屏

```
VOID DriverUnload(IN PDEVICE_OBJECT driverObject){    NTSTATUS status = PsSetCreateProcessNotifyRoutineEx((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)CreateProcessNotifyEx, TRUE);     if (!NT_SUCCESS(status))    {        DbgPrint("回调函数删除失败\r\n status=%X", status);    }    else    {        DbgPrint("回调函数成功删除\r\n");    }    DbgPrint("驱动卸载完成\r\n");}
```

实现效果
----

首先注册一下驱动

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0HjSEyDyn9LzhYiaygR1OQDNkuXIVwbJu7xEicmgAMqUo2HYiaG7VPszaw/640?wx_fmt=png)

然后这里首先执行一下我们的 exe

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY06RhF3b8LU4BuCzb0FCYMKb1NEAyyhZq5L1XME2hzwLyr577o9YeRAg/640?wx_fmt=png)

然后加载我们的驱动可以看到这里`test.exe`已经不能够运行

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0VSwhicSpP3Lv3WR7losyZDGWOPabtG23sw6OhvUS96Qt2C7uxVwns5A/640?wx_fmt=png)

那么这里我们再卸载一下驱动可以发现又可以运行成功

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY01icgz0Aaq8fpDbGMjP5qrwkf71IIQeLNI2EU2EQWBQuP8z8CngqIKgA/640?wx_fmt=png)

这里可能有点不太明显，我们将拦截的 exe 改成`notepad.exe`看下效果

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0Xr3EBPahwOQMO4t7JJaUKJwSZKAahd5DCPicHcVz7SXuKOPTNMwHoiaA/640?wx_fmt=png)

启动驱动可以看到这里启动失败

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0Eyn1RJetHz5r2mr1OzGyOeI3PgiaHhLkecWI5Gjg1fTsWOJF9uwcJqg/640?wx_fmt=png)

卸载驱动即可启动成功

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0ajowYTpz0aRASY2Qz5U59YIRfEuCozDSfJFosXu1Lp1ia422HNmvm6Q/640?wx_fmt=png)

线程监控 & 保护
=========

PsSetCreateThreadNotifyRoutine
------------------------------

线程监控使用到的 API 相对于进程监控简单，使用到`PsSetCreateThreadNotifyRoutine`，而这个值并不能像进程操作的 API 一样进行操作，这里我们首先先使用这个 API 来进行线程的监控

```
NTSTATUS PsSetCreateThreadNotifyRoutine(  [in] PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);
```

`NotifyRoutine`指向`PCREATE_THREAD_NOTIFY_ROUTINE`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0ibQIlfg4nveXHnclll5TCiaIDic9EaqbywOicLLdpJWcHCUibBjcIQMhacg/640?wx_fmt=png)

`PcreateThreadNotifyRoutine`的结构如下，第一个参数为 PID，第二个参数为 TID，第三个参数表示是创建线程还是删除线程，创建线程则为`TRUE`，删除线程则为`FALSE`

```
PCREATE_THREAD_NOTIFY_ROUTINE PcreateThreadNotifyRoutine;void PcreateThreadNotifyRoutine(  [in] HANDLE ProcessId,  [in] HANDLE ThreadId,  [in] BOOLEAN Create){...}
```

那么我们这里就可以写出`CREATE_THREAD_NOTIFY_ROUTINE`函数

```
VOID CreateThreadNotifyRoutine(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create){    if (Create)    {        DbgPrint("新创建的线程ID为:%d,所属进程ID为:%d\r\n", ThreadId, ProcessId);    }    else    {        DbgPrint("新销毁的线程ID为:%d,所属进程ID为:%d\r\n", ThreadId, ProcessId);    \}\}
```

这里如果要将函数摘除，就需要用到`PsRemoveCreateThreadNotifyRoutine`函数，定义如下

```
NTSTATUS PsRemoveCreateThreadNotifyRoutine(  [in] PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);
```

```
NTSTATUS status = PsRemoveCreateThreadNotifyRoutine(CreateThreadNotifyRoutine); if (!NT_SUCCESS(status)){    DbgPrint("回调函数删除失败\r\n status=%X", status);}else{    DbgPrint("回调函数成功删除\r\n");}
```

我们如果想让进行线程的保护该如何操作呢？我们想要阻止线程的创建，就首先要找到对应的进程，再去进行拦截，因为在 64 位下都是通过回调的方式实现，那么我们就可以通过找到线程回调的地址，然后直接改为`ret`即可起到拦截线程创建的效果

> 1. 通过 PID 找到 EPROCESS
> 
> 2. 通过 TID 找到 ETHREAD
> 
> 3. 通过 EPROCESS 得到进程路径
> 
> 4. 通过进程路径对应进程名
> 
> 5. 判断进程名是否相同
> 
> <1> 若相同则找到线程回调函数的地址修改内容为 ret
> 
> <2> 若不相同则退出

那么我们该如何找到线程回调函数的地址呢？这里查阅资料后发现，3 环将回调函数的地址放在了`ETHREAD + 0x410`偏移的`Win32StartAddress`里面

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0ZOHEQmFycoRBqwARhEJibg3DyLFv0UtmmPqFC6HUIKNGC0boiaeGWoVg/640?wx_fmt=png)

那么这里我们就能进行函数的编写，首先我们通过`PsSetCreateThreadNotifyRoutine`注册一个线程回调函数

```
NTSTATUS status = PsSetCreateThreadNotifyRoutine(CreateThreadNotify);    if (!NT_SUCCESS(status))    {        DbgPrint("回调函数设置失败, status=%X", status);    }    else    {        DbgPrint("线程监控已开启\r\n");    }
```

然后我们再去写`CreateThreadNotify`这个回调函数，首先获取`EPROCESS`、`ETHREAD`，然后通过`EPROCESS`获取进程名

```
status = PsLookupProcessByProcessId(ProcessId, &Process);  if (!NT_SUCCESS(status))  return;status = PsLookupThreadByThreadId(ThreadId, &Thread);    pszImageName = PsGetProcessImageFileName(Process);
```

然后再判断进程名是否为我们要保护的线程

```
if (strstr(pszImageName, "notepad") != NULL)
```

定位到回调函数的地址判断内存空间是否可用

```
pWin32Address = *(UCHAR**)((UCHAR*)Thread + 0x410);if (MmIsAddressValid(pWin32Address))
```

这里的话定位到了回调函数的地址，如果我们要修改回调函数的值就要修改页保护属性，但是在 64 位下是不允许使用内联汇编的，这里的话就需要使用到汇编生成`.obj`文件来使用

```
ClosePageProtect();      if (MmIsAddressValid(pWin32Address))      {        *pWin32Address = 0xC3;                       }      OpenPageProtect();
```

修改完成之后这里我们使用`ObDereferenceObject` ，减少引用计数

```
if( Process )    ObDereferenceObject(Process);    if( Thread )    ObDereferenceObject(Thread);
```

这里因为我在 win10 x64 上做的实验，这里在关闭保护属性的时候一直报错导致`0xC3`一直修改不成功，这里就不放图了

模块监控 & 保护
=========

PsSetLoadImageNotifyRoutine
---------------------------

和之前的函数一样都是指向一个结构，这里是`LOAD_IMAGE_NOTIFY_ROUTINE`

```
NTSTATUS PsSetLoadImageNotifyRoutine(  [in] PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine);
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0E33XAJibpp4GobQWbb3TkR6gXgv17Iz93JVA0ORG8gld8FE5rIqpgNQ/640?wx_fmt=png)

PLOAD_IMAGE_NOTIFY_ROUTINE
--------------------------

这里第一个参数是指向缓冲的 Unicode 字符串的指针，用于标识可执行映像文件，第二个参数表示 PID，第三个参数指向`IMAGE_INFO`

```
PLOAD_IMAGE_NOTIFY_ROUTINE SetLoadImageNotifyRoutine; void SetLoadImageNotifyRoutine(_In_opt_ PUNICODE_STRING FullImageName,_In_ HANDLE ProcessId,_In_ PIMAGE_INFO ImageInfo){ ... }
```

IMAGE_INFO
----------

```
typedef struct _IMAGE_INFO {  union {    ULONG Properties;    struct {      ULONG ImageAddressingMode : 8;      ULONG SystemModeImage : 1;      ULONG ImageMappedToAllPids : 1;      ULONG ExtendedInfoPresent : 1;      ULONG MachineTypeMismatch : 1;      ULONG ImageSignatureLevel : 4;      ULONG ImageSignatureType : 3;      ULONG ImagePartialMap : 1;      ULONG Reserved : 12;    };  };  PVOID  ImageBase;  ULONG  ImageSelector;  SIZE_T ImageSize;  ULONG  ImageSectionNumber;} IMAGE_INFO, *PIMAGE_INFO;
```

具体成员的作用如下

> *   Properties ImageAddressingMode 始终设置为 IMAGE_ADDRESSING_MODE_32BIT。
>     
> *   SystemModeImage 设置为一个用于新加载的内核模式组件（如驱动程序），或者对于映射到用户空间的映像设置为 0。
>     
> *   ImageMappedToAllPids 始终设置为 0。
>     
> *   ExtendedInfoPresent 如果设置了 ExtendedInfoPresent 标志，则 IMAGE_INFO 结构是图像信息结构的较大扩展版本的一部分（请参阅 IMAGE_INFO_EX）。在 Windows Vista 中添加。有关详细信息，请参阅本备注部分的 “扩展版本的图像信息结构”。
>     
> *   MachineTypeMismatch 始终设置为 0。在 Windows 8 / Windows Server 2012 中添加。
>     
> *   ImageSignatureLevel 代码完整性标记为映像的签名级别。该值是 ntddk.h 中的 #define SE_SIGNING_LEVEL_ * 常量之一。在 Windows 8.1 / Windows Server 2012 R2 中添加。
>     
> *   ImageSignatureType 代码完整性标记为映像的签名类型。该值是在 ntddk.h 中定义的 SE_IMAGE_SIGNATURE_TYPE 枚举值。在 Windows 8.1 / Windows Server 2012 R2 中添加。
>     
> *   ImagePartialMap 如果调用的映像视图是不映射整个映像的部分视图，则该值不为零; 0 如果视图映射整个图像。在 Windows 10 / Windows Server 2016 中添加。
>     
> *   Reserved 始终设置为 0。
>     
> *   ImageBase 设置为映像的虚拟基地址。
>     
> *   ImageSelector 始终设置为 0。
>     
> *   ImageSize 映像的虚拟大小（以字节为单位）。
>     
> *   ImageSectionNumber 始终设置为 0。
>     

那么我们首先还是定义一下回调函数

```
void SetLoadImageNotifyRoutine(_In_opt_ PUNICODE_STRING FullImageName,_In_ HANDLE ProcessId,_In_ PIMAGE_INFO ImageInfo)
```

我们的回调函数在接收到消息的时候模块已经加载完成了，那么这里我们就只能够进行模块的卸载操作，在模块的`ImageInfo` 结构里面提供了加载的`ImageBase`，那么我们只需要找到 OEP，即可计算得到`DriverEntry`的地址。那么我们找到入口点函数的地址之后，就可以修改错误码为`STATUS_ACCESS_DENIED` 即`0xC0000022`，就能够达到卸载驱动模块的效果

```
mov eax, 0xC0000022ret
```

对应的硬编码为`B8 22 00 00 C0 C3`

那么这里我们就可以进行卸载驱动模块函数的编写，首先定义指针指向 OEP

```
PIMAGE_DOS_HEADER pDosHeader = pLoadImageBase;
PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader + pDosHeader->e_lfanew);
PVOID pAddressOfEntryPoint = (PVOID)((PCHAR)pDosHeader + pNtHeaders->OptionalHeader.AddressOfEntryPoint);
```

然后写入 shellcode，通过`MmCreateMdl`写入，我们知道在内核里面是不能够随便进行读写操作的，这里就可以通过 MDL 写入的方式映射到虚拟内存实现 shellcode 的写入

```
ULONG CodeSize = 6;UCHAR pShellCode[6] = { 0xB8, 0x22, 0x00, 0x00, 0xC0, 0xC3 };PMDL pMdl = MmCreateMdl(NULL, pAddressOfEntryPoint, CodeSize);
```

使用`MmBuildMdlForNonPagedPool`更新 MDL 对物理内存的描述并映射到虚拟内存，然后写入数据，释放 MDL

```
MmBuildMdlForNonPagedPool(pMdl);
PVOID pVoid = MmMapLockedPages(pMdl, KernelMode);
RtlCopyMemory(pVoid, pShellCode, ulShellCodeSize);
MmUnmapLockedPages(pVoid, pMdl);
IoFreeMdl(pMdl);
```

然后我们再尝试对 DLL 模块进行卸载，这里的话就不能像卸载驱动模块直接在入口点返回，因为 DLL 的入口点函数的返回值并不能够确定 DLL 能否加载成功。这里 windows 提供了一个未文档化的函数`MmUnmapViewOfSection`用来卸载进程中已经加载的模块

那么我们要想卸载模块，首先就肯定要获取所有的模块，使用到`PsSetLoadImageNotifyRoutine`设置回调函数来获取模块的加载信息

windows 为了避免死锁，在进行模块加载回调函数的时候不能够进行其他操作，也就是说我们想要卸载 DLL 模块则需要等所有模块加载完毕之后才能进行卸载操作

这里来进行函数的编写

```
NTSTATUS NoLoadDll(HANDLE ProcessId, PVOID pImageBase){    NTSTATUS status = STATUS_SUCCESS;    PROCESS pEProcess = NULL;        status = PsLookupProcessByProcessId(ProcessId, &pEProcess);    if (!NT_SUCCESS(status))    {        DbgPrint("PsLookupProcessByProcessId error : %d\n", status);        return status;    }        status = MmUnmapViewOfSection(pEProcess, pImageBase);    if (!NT_SUCCESS(status))    {        DbgPrint("MmUnmapViewOfSection error : %d\n", status);        return status;    }        return status;}
```

实现效果
----

这里要实现的效果就是阻止`DriverTest.sys`的加载

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY09de2ZlQd5LNj8DdKRoQeqfO1icaiaVGdrs19BDpVNSjnvd49p4opejTg/640?wx_fmt=png)

首先启动我们的监控驱动，然后加载`DriverTest.sys`可以看到拒绝访问

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0OSoz67x4y4o3qwvDUwh0HTRuEHI8AddyE5o0BgAcTRUdhm2miawFDHw/640?wx_fmt=png)

然后再卸载我们的监控驱动之后`DriverTest.sys`加载成功

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0Uic78Af1icz34bicZe3ZNaK32yY9wLVp2dfXC6BehIMHhYMhnLVAuYWxQ/640?wx_fmt=png)

然后我们再尝试注入`Test.dll`，可以看到注入失败

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY00jkCY8cP8huDlGcAST3Z99KdtCtmxpvXF0bxz3HB7X70uiax4QuyMjw/640?wx_fmt=png)

我们再去 xp 上尝试一下，首先加载驱动

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0lA0mCBagyRYDRZe1BuZ2E62ywecNP1glyC7bjkwTSaDAOXwHwPJgQg/640?wx_fmt=png)

当我们打开一个程序的时候都会打印出当前进程加载的 dll 模块

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0ChPv5R2BaOeAoloQz5CibRqiaia1GnwHAlaZERLqUkQ24Nu9c9NEn9r6w/640?wx_fmt=png)

然后注入 DLL，也是被拦截

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v7dU0M5IG5w7txkGOuviaGY0DQIcM6aB7BSK1DE4hVibetrMjUlLmOJoG9icQyqYaj1gF5ME8p3zv2hw/640?wx_fmt=png)

往期推荐

[

一键击溃 360 全家桶 + 核晶



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503750&idx=1&sn=61f8d9ca458674d44de0019aeb39a875&chksm=ce67753af910fc2cb20170a97e7b519082c5f51805d6b86cc39b1469217e4c3539d61a9ba3f9&scene=21#wechat_redirect)

[

域内持久化后门



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503705&idx=1&sn=7a6039810c41637e376757f306ab6745&chksm=ce6775e5f910fcf3226422091a3858b8064fa353320e48c4a4998ed5b89f51febe82e992309d&scene=21#wechat_redirect)

[

从反制 Cobalt Strike 到 CVE-2022-39197 再到 RCE 的探索之路



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503700&idx=1&sn=2b8bdd154c1c796523a1c629748a9f1f&chksm=ce6775e8f910fcfe58e03d5a287af3fa6b69f1e9a1f4dc7ee719195ad30dac615455367d88b7&scene=21#wechat_redirect)

[

SPN 的相关利用



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247503628&idx=1&sn=6e95f32bf3d77a6115af55820dc614a4&chksm=ce6775b0f910fca601cdd24b465554ca618aca03ae127514926569004cf00f76967bee66ecad&scene=21#wechat_redirect)

[

什么？Windows defender 竟如此脆弱？



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502490&idx=1&sn=41fe27c02c5f0f5f6f856ac34d16e07b&chksm=ce677026f910f9303d105b7d5a13232b4d022223b60b397453febc053f70203a95bcb6e33c17&scene=21#wechat_redirect)

[

最新办法绕过 360 核晶添加计划任务



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502450&idx=1&sn=91dbbaed34489b54aff2879906c6be24&chksm=ce6770cef910f9d80c532e101b2bf847a949201c4943555895c25d87b42bc5cbd0f287363aa6&scene=21#wechat_redirect)

[

域内批量获取敏感文件



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502357&idx=1&sn=afe9aa38b2386df73b8ac31c1f2a2c3b&chksm=ce6770a9f910f9bf3248d60a71cac48d58837c117fb96cc56007e12d46f698ed82f94936b36a&scene=21#wechat_redirect)

[域内批量解析 chrome 浏览器](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502332&idx=1&sn=d05b68496442ee875bbe4d45398a4650&chksm=ce677340f910fa563cf2fa0b3914bb019a1cdc22997ac2b9a3022cd8151aedffa248312fa202&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)