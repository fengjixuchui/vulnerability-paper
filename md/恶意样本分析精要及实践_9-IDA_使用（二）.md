<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/XJjQsDhx4D2oYo65rXbHMw)

**STATEMENT**

**声明**

由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，雷神众测及文章作者不为此承担任何责任。

雷神众测拥有对此文章的修改和解释权。如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经雷神众测允许，不得任意修改或者增减此文章内容，不得以任何方式将其用于商业目的。

分子实验室 https://molecule-labs.com/

**前言**

**相关说明及声明：**  
文章原文为 K A, Monnappa. 2018 年发表的《Learning Malware Analysis》，本文的相关内容均为相关内容翻译及实践记录，仅为学术交流使用，如要引用请做原文引用如下所示：

[序号]K A, Monnappa. Learning Malware Analysis[M]. 2018.06. Published by Packt Publishing Ltd. Livery Place 35 Livery Street Birmingham B3 2PB, UK.

[_**恶意样本分析精要及实践 8-IDA 使用（一）**_](http://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652494660&idx=1&sn=c24e767c27ea115e1a6a8c4b0bd0b655&chksm=f25878f7c52ff1e19ad213d3f48e17e12cbd368204a5ec7105cb6398e98ffb7f6dbc77eb66dd&scene=21#wechat_redirect)

**使用 IDA 反汇编**

**3. 反编译 windows API**

恶意软件通常使用 windows API 函数影响操作系统（例如文件系统、进程、内存以及网络配置等）。如第二章静态分析和动态分析部分，windows 扩展主要依赖文件 DLL 动态连接库文件。可执行程序的引用和调用来自于大量 DLL 中的提供不同功能的 API。为了调用这些 dll 文件，需要先将其加载到内存中，然后调用 API 函数。检查一个恶意样本的 dll 引用情况可以指导我们分析其功能和能力。下面的表格展示了部分常见的 DLL 以及其执行功能：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcIcr4oRZUo54q2IPtc1mBUkoG5G67V3x19PNibyuMkNlhzIAEoQzKNRA/640?wx_fmt=png)

**3.1 弄清楚 Windows API**

为了展示病毒程序如何使用 windows API 并且帮助你了解关于一个 API 更多的信息。以一个病毒样本为例。加载样本到 IDA，在引用窗口展示出的相关 windows API 函数里，检查函数在 windows 引用情况。

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcZfFn3qwP8WG3ZgjibYFkUEb6CBK0NspKbpbWFSPTlmRRkibNMjHnuTjA/640?wx_fmt=png)

无论什么时候，在遇到 windows API 函数的时候，可以通过微软的开发者 MSDN 中搜索或者在谷歌中搜索，https://msdn.microsoft.com/。MSDN 文档对于 API 函数进行了相关描述，如函数参数、参数类型、返回值等。这里取 Creat or open file 作为举例。

如 https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx 所示。

通过文档可以知道这个函数的功能为创建和打开文件。第一个参数（lpfilename），用于记录文件名称。第二个参数（dwdesiredaccess），说明需要的权限如读或血的权限，第 5 个参数也是对文件创建和打开一个已经存在的文件。

```
HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);
```

Windows API 使用匈牙利语命名变量。在这个语法中，变量前缀增加数据种类，这个有助于我们了解给数据种类。如第二个参数 dwdesiredaccess，dw 的前缀代表 dword 32 位无符号整数。在 win32 API 支持的不同数据类型如 (https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx)。下面的表格未一些数据类型：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcA9zMf0tgGyYhYWdsxNicUXqhxr9P5SQgpibgziao2CqqSTlaNVOyjdV4w/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcbSBibhGth7ia8oJsQHonWLvs0icKnfGG8OKxXicibCM4L0FI05DIxmkBtWg/640?wx_fmt=png)

与数据类型和参数不同，之前的函数样本包括注释，例如_in_和_out_，描述了函数使用的参数和返回的值。_in_表示输入参数，调用必须通过提供参数给函数才能执行函数。_in_opt 表示可选的输入参数（可以为 null）。_out_表示输出的参数；表示函数将会输出参数作为返回值。这个特性对于了解函数调用后是否从存储中读取任何数据到输出函数很有帮助。_inout_对象可以让我们分辨函数参数和函数的输出。

在交叉参考中我们可以看到 API 调用情况，通过查阅相关 API 手册，我们可以知道，相关 API 的输入和输出参数。以 createfile 为例，通过查看函数的相关的两个函数，起始地址如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qc6o4L8wm49AsAPPUvQ06IR3b1LVTJhSntu4yJdGQicpJpwqkd9aUcORw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcr45jicdicX9bgMJDljsGN2mYahlnL6r0ekMrbtzToHxZl1hb1wCDExAg/640?wx_fmt=png)

双击第一个参数，调转到代码反汇编窗口对应位置。并且高亮显示。通过分散，IDA 提供了一个叫做快速识别库的技术（FLIRT），包括图像匹配算法用于确定函数函数是库函数还是一个引用函数（从 dll 引入的函数）。在这个例子中 IDA 能够识别引入的分散的函数，并且将其命名为 CreateFileA。IDA 的分辨引用函数和库函数的能力非常有用，因为当你分析恶意样本的时候，不会去浪费时间分辨是引用的函数还是库函数。IDA 还会为参数添加参数的名字作为注释，标记出 Windows API 函数调用的对应的参数的名称。

```
.text:00401708                 mov     dword ptr [esp+18h], 0 ; hTemplateFile
.text:00401710                 mov     dword ptr [esp+14h], 80h ; dwFlagsAndAttributes
.text:00401718                 mov     dword ptr [esp+10h], 3 ; dwCreationDisposition
.text:00401720                 mov     dword ptr [esp+0Ch], 0 ; lpSecurityAttributes
.text:00401728                 mov     dword ptr [esp+8], 3 ; dwShareMode
.text:00401730                 mov     dword ptr [esp+4], 80000000h ; dwDesiredAccess
.text:00401738                 mov     dword ptr [esp], offset FileName ; lpFileName
.text:0040173F                 call    ds:CreateFileA
```

第一个参数表示需要创建的文件名 lpFileName。第二个参数 dwDesiredAccess 内容 80000000h，通过 https://docs.microsoft.com/en-us/windows/win32/secauthz/access-mask-format，可以看到对应的是 generic_read 权限，这一部分应该在后面的针对 widnows 的 API 的详细解读中进一步细化。第 5 个参数值为 3，通过 https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea，可以知道代表 OPEN_EXISTING，只有当其退出的时候打开文件或设备。

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcxTXKibkgJLtOAkPte3j7GMWdxaYWtzZqZY8o7wAmTd0JYzhoia0reRZQ/640?wx_fmt=png)

IDA 的另一个特性是列出使用象征名标记 Windows API，或 C 标准库函数。例如在 80000000h 可以通过右键值，选择使用标准象征内容参数，标记内容；这个操作将会出现一个窗口展示所有有关选择的值的象征名字。你需要选择一个适当的标志名称这里就是 Generic_read。用相同的方式，你可以替换掉第五个参数内容 3，为象征名称，OPEN_EXISTING；

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcbb4NUcEE5cvfXZ0Sibfe7fow9WvL3BtFac26NB5DhnuUoMoY0zicuSicQ/640?wx_fmt=png)

在使用象征名替换了内容之后，反汇编窗口列被转化成下图所示内容。代码变得更加可读。在函数调用之后，句柄到文件（可以在 EAX 寄存器中找到）被返回。通过函数操作文件还可以通过其他 API 来实现，例如 readfile() 或者 writefile()，也可以实现类似的效果：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcZhmPT2ODprNCibLX7OxZQHbXF8ucqn3udy5uQeuIibxdxzVW9VckV1mg/640?wx_fmt=png)

**3.1.1 ANSI 和 Unicode API 函数**

windows 支持两个相似的 API 设置：一个是对于 ANSI 字符，另一个是 Unicode 字符。很多函数使用一个字符作为参数，在参数的名字后面包含 A 或者 W。例如 CreateFileA。换句话说，API 名称的尾部，可以让你分辨通过函数的字符的种类（ANSI 或 Unicode）。以上面的 CreateFileA 为例，A 表示函数使用一个 ANSI 字符作为输入。相应的 CreateFileW 则是表示函数使用一个 Unicode 字符作为输入。在恶意软件分析的过程中，当你看到一个函数名为 CreateFileA 或 CreateFileW 形式，可以删掉尾字母 A 或 W，然后在 MSDN 中搜索函数文档。

**3.1.2 执行 API 函数**

你可能会遇到很多名字带有 Ex 后缀的函数，例如 RegCreateKeyEx（扩展 RegCreateKey 的变体）。当 Microsoft 升级一个与旧函数矛盾的函数的时候，升级的函数命名在原函数名的基础上增加 Ex。

**3.2 32 位和 64 位 Windows API 对比**

让我们看一个 32 位恶意样本去了解恶意样本如何运用大量 API 函数去影响操作系统的，让我们尝试了解如何反汇编代码，去了解恶意程序的活动。在接下来的反汇编输出中，32 位的恶意样本调用了 RegOpenKeyEx API 开启了一个句柄执行 run 注册表的值。当我们执行 32 位恶意样本的时候，所有 regOpenKeyEx 的 API 参数被压到栈上。

相关的文档可以在 https://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx 找到。

输出参数 phkResult 是一个变量的指针（输出的参数由 **out** 注释指出）在函数调用后，指向打开注册表值的句柄。这里可以注意到，phkResult 的地址是从 ecx 寄存器复制过去的，这个地址是作为 RegOpenKeyEx API 的第 5 个参数录入的。

```
lea  ecx, [esp+7E8h+phkResult] ➊
push ecx ➋                        ; phkResult
push 20006h                       ; samDesired
push 0                            ; ulOptions
push offset aSoftwareMicros ;Software\Microsoft\Windows\CurrentVersion\Run
push HKEY_CURRENT_USER            ; hKey
call ds:RegOpenKeyExW
```

在恶意软件通过调用 RegOpenKeyEx 打开 run 注册值后，返回的句柄（在 phkResult 变量存储）被移动到 ecx 寄存器中，并且作为 RegSetValueExW 的第一个参数传递。从 MSDN 关于这个 API 的文档中，可以发现使用 RegSetValueEx API 设置一个变量到 run 注册表的值中（持久化）。变量通过的第二个参数设置，system 字符。对应的内容可以通过第五个参数的值去确认。从前面的描述中，可以确定 eax 保持由 pszPath 的地址的值。pszPath 变量与在运行时的相关内容相关；因此通过查看代码，很难判断数据是病毒添加到注册表里的（你可以通过调试病毒样本确认）。但是在这点，通过静态分析（反汇编），你可以确定病毒添加了一个入口到注册表中作为持久化的方式：

```
mov   ecx, [esp+7E8h+phkResult] ➌
sub   eax, edx
sar   eax, 1
lea   edx, ds:4[eax*4]
push  edx                     ; cbData
lea   eax, [esp+7ECh+pszPath] ➐
push  eax ➏                  ; lpData
push  REG_SZ                 ; dwType
push  0                      ; Reserved
push  offset ValueName       ; "System" ➎
push  ecx ➍ ; hKey
call  ds:RegSetValueExW
```

在添加了一个入口到注册表中之后，病毒通过在句柄获取值之前（存有 phkResult 变量）关闭句柄到注册表值，如下所示：

```
mov   edx, [esp+7E8h+phkResult]
push  edx                     ; hKey
call  esi                     ; RegCloseKey
```

之前的例子展示了恶意样本如何使用多个 windows API 添加一个入口到注册表中，该注册遍能够在计算机重启的时候自动运行。你还可以看到，恶意样本如何获得一个对象的句柄，并分享句柄到其他 API 函数执行其他行为。

当你在看从 64 位病毒程序反汇编输出的函数的时候，可能会略显不同，这是由于参数通过 64 位架构。接下的一个 64 位样本调用 CreateFile 函数。在 64 位架构下，在寄存器中前 4 个参数被使用（rcx，rdx，r8 和 r9），并且剩余的参数被放置在寄存器中。在接下来的反汇编中，注意到第一个参数是如何通过 rcx 寄存器，第二个参数在 edx 寄存器中，第三个参数在 r8，第四个在 r9 寄存器中。新增的参数被放置在栈中（注意这里没有 push 指令），这里使用 mov 指令。注意 IDA 如何识别参数柄添加注释到指令旁边的。函数的返回值（到文件的句柄）从 rax 寄存器中被移动到 rsi 寄存器中：

```
xor  r9d, r9d  ➍                           ; lpSecurityAttributes
lea  rcx, [rsp+3B8h+FileName] ➊             ; lpFileName
lea  r8d, [r9+1] ➌                          ; dwShareMode
mov  edx, 40000000h ➋                       ; dwDesiredAccess
mov  [rsp+3B8h+dwFlagsAndAttributes], 80h ➏  ; dwFlagsAndAttributes
mov  [rsp+3B8h+dwCreationDisposition], 2  ➎  ; lpOverlapped
call cs:CreateFileW
mov  rsi, rax  ➐
```

下面的反汇编为 WriteFile API 的，注意文件句柄在 API 调用之前被复制到 rsi 寄存器，现在通过 writeFile 函数第一个参数移动到 rex 寄存器。相同的方式，另一个参数被传入寄存器进入堆，如下所示：

```
and  qword ptr [rsp+3B8h+dwCreationDisposition], 0
lea  r9,[rsp+3B8h+NumberOfBytesWritten]       ; lpNumberOfBytesWritten
lea  rdx, [rsp+3B8h+Buffer]                   ; lpBuffer
mov  r8d, 146h                                ; nNumberOfBytesToWrite
mov  rcx, rsi ➑                               ; hFile
call cs:WriteFile From the preceding example,
```

从之前的案例可以看到，病毒程序创建一个文件和写入内容到文件，但是当你查找静态代码的时候，并不那么清楚的可以看出恶意软件创建了什么文件或者写入了什么内容到文件中。例如，想要知道软件创建的文件名，你需要检查 ipFileName（传入 CreateFile 的一个参数）地址的内容；但 ipFileName 变量并非硬编码，并且只有当程序运行的时候才存在。

**4. 使用 IDA 补丁二进制程序**

当完成恶意程序分析，你想要修改二进制程序改变其内部工作原理或者逆向逻辑以便个人使用。你可以使用选择 Edit/Patch program 菜单。需要注意的是，当你使用这个菜单堆二进制进行修改的时候，你并不会直接对二进制文件本身进行修改；这个修改只会在 IDA 数据库中进行操作。如果需要应用修改到原始的二进制文件的话，你需要使用 Apply patches to input file：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcTu0YHRswrBvJMvekFVic7dfhHR6t2LwXbnKzt21dfe1QencMpFrQwicA/640?wx_fmt=png)

**4.1 补丁程序字节**

考虑到代码通过 32 位恶意软件 dll 执行（RDSS rootkit），通过检测可以确保其运行与 spoolsv.exe 下面。这里的检测会使用字符对比功能；如果自负对比失败，则代码跳转到函数结束，并且回到函数调用。特殊的，这个 dll 的恶意行为只发生在当其被 spoolsv.exe 调用的时候；除此之外，其都无返回。

```
10001BF2     push offset aSpoolsv_exe  ; "spoolsv.exe"
10001BF7     push edi                  ; char *
10001BF8     call _stricmp  ➊ 
10001BFD     test eax, eax
10001BFF     pop ecx
10001C00     pop ecx
10001C01     jnz loc_10001CF9
 [REMOVED]
 10001CF9 loc_10001CF9: ➋      ; CODE XREF: DllEntryPoint+10j
10001CF9      xor  eax, eax
10001CFB      pop  edi
10001CFC      pop  esi
10001CFD      pop  ebx
10001CFE      leave
10001CFF      retn 0Ch

K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (p. 189). Packt Publishing. Kindle 版本.
```

假定你想要恶意 dll 执行恶意行为在任一程序下，例如执行在 notepad.exe 下面。你可以改变硬编码的字符从 spoolsv.exe 到 notepad.exe。为了实现这个，通过点击 aSpoolsv_exe 定位硬编码地址，在下面的内容中展示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcibBiaJjmwa7Vlo1jbodibOJrYGFV2dAodQeSTs5oWKtrl7cntRUDzQicCQ/640?wx_fmt=png)

现在，将鼠标放在变量名上（aSpoolsv_exe）。此时，hex 视图窗口中将会同步展示地址信息。在 hex-View-1 标签展示的 hex 和 ascii 导出内存地址。补丁字节内容，选择 Edit/patch program/change byte；将会如下图所示带来补丁字节日志。你可以修改原始的二进制字节通过输入一个新的二进制值到栏目中。Address 字段表示游标位置的虚拟地址，File offset 字段指定二进制文件中字节所在的文件偏移量。

  
Original value 字段显示当前地址的原始字节; 即使你修改了这些值，该字段中的值也不会改变:

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcUYibQaqfeyAjzleLuvIkOkvSeoKSxiaHE1icVY06BeWPx7kQbYJqfoMUg/640?wx_fmt=png)

您所做的修改将应用于 IDA 数据库; 要将更改应用到原始可执行文件，可以选择 “Edit | Patch program | apply patches to the input file”。下面的屏幕截图显示了“应用补丁到输入文件” 对话框。当您点击 OK 时，更改将应用到原始文件; 您可以通过检查 “创建备份” 选项来保存原始文件的备份; 在这种情况下，它会以. bak 扩展名保存你的原始文件:

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcCCwicChoXRzC1JTPfVXyd9KfBZhWARiakxbYVjHJt2KXLSUwBHLInmNw/640?wx_fmt=png)

前面的示例演示了修补字节; 以同样的方式，您可以通过选择 Edit | patch program | Change word 来一次打一个单词 (2 字节) 的补丁。您还可以从十六进制视图窗口中修改字节，通过右键单击一个字节并选择 Edit (F2)，您可以通过再次右键单击并选择 apply changes (F2)应用更改。

**4.2 补丁命令**

在之前的例子中，TDSS rootkit DLL 执行了一个检查判断程序是否在 spoolsv.exe 下面运行。可以通过修改程序中的二进制信息将 spoolsv.exe 改为 notepad.exe。可以通过逆向逻辑判断 DLL 可以运行在任意进程下面。为了实现这个想法，我们可以修改 jnz 命令使其变为 jz，通过选择 Edit｜patch program｜Assemble，如下所示。我们将要逆向逻辑并且让程序运行在 spoolsv.exe 下时，程序不会表现任何恶意行为表现，而运行在非 spoolsv.exe 时将会表现出恶意行为。在修改了命令之后，点击 OK，命令将会被汇编，但是对话仍然保持打开状态，提示你在下一个地址汇编下一个命令。如果没有其他需要会变的可以点击取消结束。为了将修改保存到原始文件中，选择 Edit｜patch program｜apply patches 将修改保存到文件中。

![图片](https://mmbiz.qpic.cn/mmbiz_png/HxO8NorP4JX1iaHz3OcohkmAQ6ygzr5qcibWaic6VibrtVeKOyh0YkRicwRibjOkZicqRUCxfjKxlko6xr2Rfb5icZ8ZPQ/640?wx_fmt=png)

当你给任何命令打补丁的时候，小心需要确保所有的的命令的结合是正确的；除此之外，补丁的程序可能会出现无法预料的行为。如果新的命令比原始命令短的话，你可以使用 nop 命令保持长度完整。如果你在汇编一个新的命令超出原始的命令，IDA 将会覆盖原始程序的后面的命令，这个行为可能并非我们希望如此的。

**RECRUITMENT**

**招聘启事**

**安恒雷神众测 SRC 运营（实习生）**  
————————  
【职责描述】  
1.  负责 SRC 的微博、微信公众号等线上新媒体的运营工作，保持用户活跃度，提高站点访问量；  
2.  负责白帽子提交漏洞的漏洞审核、Rank 评级、漏洞修复处理等相关沟通工作，促进审核人员与白帽子之间友好协作沟通；  
3.  参与策划、组织和落实针对白帽子的线下活动，如沙龙、发布会、技术交流论坛等；  
4.  积极参与雷神众测的品牌推广工作，协助技术人员输出优质的技术文章；  
5.  积极参与公司媒体、行业内相关媒体及其他市场资源的工作沟通工作。  
【任职要求】   
 1.  责任心强，性格活泼，具备良好的人际交往能力；  
 2.  对网络安全感兴趣，对行业有基本了解；  
 3.  良好的文案写作能力和活动组织协调能力。

简历投递至 

bountyteam@dbappsecurity.com.cn

**设计师（实习生）**  

————————

【职位描述】  
负责设计公司日常宣传图片、软文等与设计相关工作，负责产品品牌设计。  
【职位要求】  
1、从事平面设计相关工作 1 年以上，熟悉印刷工艺；具有敏锐的观察力及审美能力，及优异的创意设计能力；有 VI 设计、广告设计、画册设计等专长；  
2、有良好的美术功底，审美能力和创意，色彩感强；

3、精通 photoshop/illustrator/coreldrew / 等设计制作软件；  
4、有品牌传播、产品设计或新媒体视觉工作经历；  
【关于岗位的其他信息】  
企业名称：杭州安恒信息技术股份有限公司  
办公地点：杭州市滨江区安恒大厦 19 楼  
学历要求：本科及以上  
工作年限：1 年及以上，条件优秀者可放宽

简历投递至 

bountyteam@dbappsecurity.com.cn

安全招聘  

————————  
公司：安恒信息  
岗位：**Web 安全 安全研究员**  
部门：战略支援部  
薪资：13-30K  
工作年限：1 年 +  
工作地点：杭州（总部）、广州、成都、上海、北京

工作环境：一座大厦，健身场所，医师，帅哥，美女，高级食堂…  
【岗位职责】  
1. 定期面向部门、全公司技术分享;  
2. 前沿攻防技术研究、跟踪国内外安全领域的安全动态、漏洞披露并落地沉淀；  
3. 负责完成部门渗透测试、红蓝对抗业务;  
4. 负责自动化平台建设  
5. 负责针对常见 WAF 产品规则进行测试并落地 bypass 方案  
【岗位要求】  
1. 至少 1 年安全领域工作经验；  
2. 熟悉 HTTP 协议相关技术  
3. 拥有大型产品、CMS、厂商漏洞挖掘案例；  
4. 熟练掌握 php、java、asp.net 代码审计基础（一种或多种）  
5. 精通 Web Fuzz 模糊测试漏洞挖掘技术  
6. 精通 OWASP TOP 10 安全漏洞原理并熟悉漏洞利用方法  
7. 有过独立分析漏洞的经验，熟悉各种 Web 调试技巧  
8. 熟悉常见编程语言中的至少一种（Asp.net、Python、php、java）  
【加分项】  
1. 具备良好的英语文档阅读能力；  
2. 曾参加过技术沙龙担任嘉宾进行技术分享；  
3. 具有 CISSP、CISA、CSSLP、ISO27001、ITIL、PMP、COBIT、Security+、CISP、OSCP 等安全相关资质者；  
4. 具有大型 SRC 漏洞提交经验、获得年度表彰、大型 CTF 夺得名次者；  
5. 开发过安全相关的开源项目；  
6. 具备良好的人际沟通、协调能力、分析和解决问题的能力者优先；  
7. 个人技术博客；  
8. 在优质社区投稿过文章；

岗位：**安全红队武器自动化工程师**  
薪资：13-30K  
工作年限：2 年 +  
工作地点：杭州（总部）  
【岗位职责】  
1. 负责红蓝对抗中的武器化落地与研究；  
2. 平台化建设；  
3. 安全研究落地。  
【岗位要求】  
1. 熟练使用 Python、java、c/c++ 等至少一门语言作为主要开发语言；  
2. 熟练使用 Django、flask 等常用 web 开发框架、以及熟练使用 mysql、mongoDB、redis 等数据存储方案；  
3: 熟悉域安全以及内网横向渗透、常见 web 等漏洞原理；  
4. 对安全技术有浓厚的兴趣及热情，有主观研究和学习的动力；  
5. 具备正向价值观、良好的团队协作能力和较强的问题解决能力，善于沟通、乐于分享。  
【加分项】  
1. 有高并发 tcp 服务、分布式等相关经验者优先；  
2. 在 github 上有开源安全产品优先；  
3: 有过安全开发经验、独自分析过相关开源安全工具、以及参与开发过相关后渗透框架等优先；  
4. 在 freebuf、安全客、先知等安全平台分享过相关技术文章优先；  
5. 具备良好的英语文档阅读能力。

简历投递至

bountyteam@dbappsecurity.com.cn

岗位：**红队武器化 Golang 开发工程师**  

薪资：13-30K  
工作年限：2 年 +  
工作地点：杭州（总部）  
【岗位职责】  
1. 负责红蓝对抗中的武器化落地与研究；  
2. 平台化建设；  
3. 安全研究落地。  
【岗位要求】  
1. 掌握 C/C++/Java/Go/Python/JavaScript 等至少一门语言作为主要开发语言；  
2. 熟练使用 Gin、Beego、Echo 等常用 web 开发框架、熟悉 MySQL、Redis、MongoDB 等主流数据库结构的设计, 有独立部署调优经验；  
3. 了解 docker，能进行简单的项目部署；  
3. 熟悉常见 web 漏洞原理，并能写出对应的利用工具；  
4. 熟悉 TCP/IP 协议的基本运作原理；  
5. 对安全技术与开发技术有浓厚的兴趣及热情，有主观研究和学习的动力，具备正向价值观、良好的团队协作能力和较强的问题解决能力，善于沟通、乐于分享。  
【加分项】  
1. 有高并发 tcp 服务、分布式、消息队列等相关经验者优先；  
2. 在 github 上有开源安全产品优先；  
3: 有过安全开发经验、独自分析过相关开源安全工具、以及参与开发过相关后渗透框架等优先；  
4. 在 freebuf、安全客、先知等安全平台分享过相关技术文章优先；  
5. 具备良好的英语文档阅读能力。  
简历投递至

bountyteam@dbappsecurity.com.cn

END

![图片](https://mmbiz.qpic.cn/mmbiz_gif/CtGxzWjGs5uX46SOybVAyYzY0p5icTsasu9JSeiaic9ambRjmGVWuvxFbhbhPCQ34sRDicJwibicBqDzJQx8GIM3AQXQ/640?wx_fmt=gif)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/HxO8NorP4JUI3xRicv0zbSs96m4lmMVSG4jrUeVkeS7TdickHwKJG40R0WMZibt0kOyO3ySDQBUibQR4XIs8oBDuWw/640?wx_fmt=jpeg)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/0BNKhibhMh8eiasiaBAEsmWfxYRZOZdgDBevusQUZzjTCG5QB8B4wgy8TSMiapKsHymVU4PnYYPrSgtQLwArW5QMUA/640?wx_fmt=gif)

**长按识别二维码关注我们**