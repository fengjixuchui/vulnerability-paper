> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/AYWMuWqciiUVVNAmGXYHnA)

本文首发于FreeBuf，作者Me，文末阅读原文可直达Freebuf链接  

---------------------------------------

  

一、cms简介：
--------

因酷开源在线网校系统是由北京因酷时代科技有限公司研发并推出的国内首家Java版开源网校源代码建站系统。

本文是inxedu cms 漏洞分析学习的第一篇，将围绕存储型xss漏洞、文件上传漏洞进行分析学习，大纲：

```
1、环境搭建  
2、存储型xss漏洞分析  
3、文件上传漏洞分析
```

  

---

二、环境搭建：
-------

1、下载源码（v2.0.6），使用idea导入

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ehibzaP4CvW6E8Dnt7xpED10wkOCamsibd2CEDibZEtstNqvdn2KOeiczibzViaWHzsYzfEhyJQhoviavayHsYib2b7HHQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

然后更改配置文件：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

配置tomcat：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后run运行

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

---

三、漏洞分析
------

### ①存储型xss：

先黑盒测试可能存在漏洞的功能点，这里以提问列表为例（有可能管理员在后台能看到提问的内容，可尝试打管理员的cookie）

**1、首先来看插入数据库的过程，是否有什么过滤**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

抓包查看请求的路由：/questions/ajax/add

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

利用idea快捷键，直接全局搜索路由关键字：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

定位到控制器QuestionsController.java：

看到**addQuestions()**方法，接收的传参的为**Questions**类，然后判断用户是否登录，所以需要一个普通用户的权限，然后就调用了**sevice**层中的addQuestions()方法

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查看Questions类的属性中有哪些是String类型的，可以尝试在这些属性中插入xss payload

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

跟进**addQuestions()**方法：QuestionsService.java

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查看**QuestionsService**的实现类：

这个过程也没有对传参进行过滤，所以我们继续跟进dao层，看具体插入数据库的语句操作

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

dao层实现类：

这里根据insert中的关键字，找到对应mapper进行查看**createQuestions**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

QuestionsMapper.xml：

这里对**edu_questions**表插入数据

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

具体字段如下：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

演示：

添加问答：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

查看数据库的内容，xss payload已经被成功插入了：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

到此为止，添加问答的过程就分析完成了，对用户的提交的传参是没有进行任何的过滤然后直接调用对应的方法将内容直接插入到数据库中**edu_questions**表进行存储，那么接下来我们来看一下哪些地方对edu_questions表的内容进行查询且输出展示，如果输出展示的过程也没有进行任何限制，那么一枚存储型xss就产生了

**2、然后来看输出展示的过程**

在访问前台问答展示列表时，刚刚插入的xss payload被触发了

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

全局搜索路由/questions/list：

这里找到了两个路由，分别来自两个不用的控制器，根据名称来看，**AdminQuestionsController**更能吸引人，应该属于后台控制器，所以直接来看它

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

跟进AdminQuestionsController：

在**getQuestionsList()**方法中，首先设置了ModelAndView，待会再看具体的模板路径，然后调用了service层的getQuestionsList()方法进行数据的查询：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

跟进getQuestionsList()方法和其实现类：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

跟进dao层实现类：

这里根据关键字，找到对应mapper进行查看

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

QuestionsMapper.xml：

这里对edu_questions表的数据进行查询，具体的sql语句定义如下

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

那么我们回到controller中查询模板的赋值展示过程：

然后添加questionsList（就是从数据库中查询到的内容）到共享域中，在模板中用于输出

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

questionslist的值：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

定位到具体的jsp文件：\view\inxedu\admin\questions\questions_list.jsp

这里使用foreach对questionslist进行遍历，看到一个<td>标签中对title字段进行了输出，最终成功触发了xss payload

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

到后台功能中进行查看验证：

后台查看问答列表的功能中成功触发了xss弹窗，所以这个存储型xss不仅能打前台普通用户，还可以打后台管理员

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**②文件上传漏洞分析**

漏洞点：**common/controller/VideoUploadController.java**

在gok4()方法中，这里使用的是springmvc的方式进行文件上传，方法中接收了几个传参，fileType参数（允许的文件后缀）、param参数（文件路径），然后以逗号分割为数组赋值为type，然后传入setFileTypeList()方法，这里其实不重要，先略过

接着往后看，这里获取上传文件的后缀名，然后对和传入的fileType参数使用contains()进行比较（判断传入的fileType中是否包含指定的后缀名字符ext），如果包含则返回true，然后使用!取反，所以传入的fileType要包含ext，否则就会return错误

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后会进行文件路径的获取，跟进一下getPath()方法，首先定义了filePath参数，然后判断param如果不为null，且去除空格后长度大于0的话就拼接上param作为路径，否则就是项目绝对路径加上filePath，最后使用年月日的命名拼接完整的文件路径，又因为param参数是可控的，所以文件的上传路径可以使用../跨目录进行上传

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

分析完文件路径的命名方式，然后回到上传点，获取完文件路径后，如果不存在会进行目录创建，然后直接使用**transferTo()**进行上传，所以整个上传过程只是对fileTpye参数进行判断而已，但是**fileType**是我们可控的，只需要传入的fileType中包含上传文件的后缀名即可，最后还会对文件路径进行回显

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

上传数据包：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

连接webshell：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

本文对漏洞的成因和触发的过程进行详细的分析和跟进，文笔浅显，如有错误欢迎指出。