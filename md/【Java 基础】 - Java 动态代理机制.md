<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/iZfNfbXPK9bcBx38GPyy-A)

代理模式静态代理和动态代理的区别静态代理静态代理的优缺点动态代理为什么类可以动态的生成代码展示 InvocationHandler 和 Proxy 的主要方法 java.lang.reflect.InvocationHandlerjava.lang.reflect.Proxy 参考资料

Java 动态代理机制主要通过**反射机制**来实现的。

代理模式
----

代理模式是 Java 中**常用的设计模式**，主要有**公共接口**、**被代理类**和**代理类**等三部分组成。

代理类持有被代理类的实类，**代为执行**具体的类方法。

代理类和被代理类有同样的接口。

代理类与被代理类之间通常会存在关联关系，一个代理类的对象与一个被代理类的对象关联，**代理类的对象本身并不真正实现服务**，而是通过**调用被代理类对象的方法**来提供特定的服务。

**代理模式角色**分为 3 种：

*   **Subject（抽象主题）**：定义真实主题和代理类的公共对外方法，也是代理类代理真实主题的方法；
    
*   **RealSubject（真实主题）**：真正实现业务逻辑的类；
    
*   **Proxy（代理主题）**：用来代理和封装真实主题；
    

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ES7Q6vTBQyHg7OTNTuUqCpQXZDHE59JjILxjju6G7eKm1J8Xtq1x2iahA/640?wx_fmt=png)

静态代理和动态代理的区别
------------

**根据字节码的创建时机**来分类，可以分为静态代理和动态代理：

*   所谓**静态**也就是在**程序运行前**就已经存在**代理类的字节码文件**，代理类和真实主题角色的关系在运行前就确定了。
    
*   而动态代理的源码是在程序运行期间由 **JVM** 根据反射等机制**动态的生成**，所以在运行前并不存在代理类的字节码文件
    

静态代理
----

demo 示例：

```
package com.feng2;

public class test {
   public static void main(String[] args) throws Exception{
       new ProxyObject().echo();
  }
}

interface ProxyInterface {      // 公共接口
   void echo();
}

class RealObject implements ProxyInterface {        // 真实主题，需要实现接口
   public void echo(){     // 定义一个方法
       System.out.println("This is RealObject.");
  }
}

class ProxyObject implements ProxyInterface{        // 代理主题，需要实现接口
   public void echo(){
       System.out.println("AOP");
       new RealObject().echo();
       System.out.println("Write Log");
  }
}

```

代理类对象的 echo() 输出结果：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESaCfFOtqzyibh8XvGwpXYAX1bDDoCtDfxgqJ97TGejunPO3JR5xCpWaw/640?wx_fmt=png)

### 静态代理的优缺点

**优点**：

实现简单，很容易增强类的功能，而且没有侵入原代码

**缺点**：

1.  当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
    

*   只维护一个代理类，由这个代理类实现多个接口，但是这样就导致**代理类过于庞大**
    
*   新建多个代理类，每个目标对象对应一个代理类，但是这样会**产生过多的代理类**
    

3.  当接口需要增加、删除、修改方法的时候，**目标对象与代理类都要同时修改**，**不易维护**。
    

动态代理
----

让**代理类动态的生成**，就是动态代理。

### 为什么类可以动态的生成

Java 虚拟机的**类的加载过程**主要分成五个阶段：加载、验证、准备、解析、初始化。

**加载阶段**需要完成的 3 件事：

```
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口

```

关于第 1 点，**获取类的二进制字节流**（class 字节码）就有很多途径：

```
1. 从ZIP包获取，这是JAR、EAR、WAR等格式的基础
2. 从网络中获取，典型的应用是 Applet
3. 运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了ProxyGenerator.generateProxyClass 来为特定接口生成形式为 $Proxy 的代理类的二进制字节流
4. 由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类
5. 从数据库中获取等等

```

所以，动态代理就是想办法，**根据接口或目标对象**，**计算出代理类的字节码**。然后再加载到 JVM 中使用。

### 代码展示

`User.java`

定义一个`公共接口`和`真实主题`

```
package com.dynamic;

interface UserService{
   public void select();
   public void update();
}

class UserServiceImpl implements UserService{
   @Override
   public void select() {
       System.out.println("查询 selectById");
  }

   @Override
   public void update() {
       System.out.println("更新 update");
  }
}

```

`LogHandler.java`

定义一个传给代理类的 `请求处理器对象`，重写`invoke`方法，代理对象的所有方法都会调用该处理器对象的 invoke 方法

```
package com.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Date;

public class LogHandler implements InvocationHandler {
   Object target;      // 被代理的对象，真实主题，实际的方法执行者

   public LogHandler(Object target){
       this.target = target;
  }

   @Override
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       before();
       Object result = method.invoke(target, args);
       after();
       return result;      // 需要返回方法的执行结果
  }

   // 调用invoke方法之前执行
   private void before(){
       System.out.println(String.format("log start time [%s]", new Date()));
  }

   // 调用invoke方法之后执行
   private void after(){
       System.out.println(String.format("log end time [%s]", new Date()));
  }
}

```

`Client2.java`

创建调用`代理对象`

```
package com.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class Client2 {
   public static void main(String[] args) {
       // 1. 创建被代理的对象，UserService接口实现的类
       UserService userserviceimpl = new UserServiceImpl();

       // 2. 获取对应的ClassLoader
       ClassLoader classloader = userserviceimpl.getClass().getClassLoader();

       //3. 获取所有接口的Class，这里的UserServiceImpl类只实现了一个接口UserService
       Class[] interfaces = userserviceimpl.getClass().getInterfaces();

       // 4. 创建一个传给代理类的 **请求处理器对象**，处理所有的代理对象上的方法调用
       //   这里创建的是一个自定义的日志处理器（LogHandler），须传入实际的执行对象userserviceimpl
       InvocationHandler loghandler = new LogHandler(userserviceimpl);

       // 5. 根据上面的信息，创建 **代理对象**
       UserService proxy = (UserService) Proxy.newProxyInstance(classloader, interfaces, loghandler);
       /*
       a. JDK会根据传入的参数信息动态地在内存中创建和.class文件等同的字节码（classloader、所有接口的Class、请求处理器）
       b. 然后根据相应的字节码转换成对应的class
       c. 然后调用newInstance
        */

       proxy.select();
       proxy.update();
  }
}

```

### InvocationHandler 和 Proxy 的主要方法

#### java.lang.reflect.InvocationHandler

*   `Object invoke(Object proxy, Method method, Object[] args)`
    
    定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用
    

#### java.lang.reflect.Proxy

*   `static InvocationHandler getInvocationHandler(Object proxy)`  
    
    用于获取指定代理对象所关联的调用处理器，**调用处理器类实现了 InvocationHandler 这个接口**
    
*   `static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)`
    
    返回指定接口的代理类
    
*   `static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`
    
    构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法
    
*   `static boolean isProxyClass(Class<?> cl)`
    
    返回 cl 是否为一个代理类
    

参考资料
----

Java 动态代理机制

https://juejin.im/post/5c1ca8df6fb9a049b347f55c