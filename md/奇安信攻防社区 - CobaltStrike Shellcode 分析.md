> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/997)

> 奇安信攻防社区 - CobaltStrike Shellcode 分析

这次使用的 reverse_http 的 shellcode ## 0x01 生成木马 首先生成一个 C 语言版的 payload，用最简单的方法加载进内存 ```c++ #include&lt;stdio.h&gt; #include&lt;Windows.h&gt; #prag...

这次使用的 reverse_http 的 shellcode

0x01 生成木马
---------

首先生成一个 C 语言版的 payload，用最简单的方法加载进内存

```
#include<stdio.h>
```

这里让数据段可执行，这样就不需要动态开辟内存，调试的时候 shellcode 的地址不会变

0x02 DEBUG
----------

用二进制看下 payload

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ee4f54f74ddc6192f7c395a3c4f5f41c6b782a5a.png)

是可以看到一些正常字符的，说明 shellcode 里面不全部是代码，还放着一些数据

把程序放到 x32dbg 里面调试，可以图片搭配后面的汇编代码看可能会清晰一点

下面开始调试

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-391a179f72bf4f24b0b5a16d652f0bf0d9f956de.png)

CLD 先将 DF 标志位置零，对应的硬编码是 FC，印象里很多 shellcode 开头都是 FC，可能是为了严谨吧

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-c4b7e75714681aa0a2338408eab1467c78c3e898.png)

这里 CALL 到 5F40A7 后执行的代码

先把跳过来的下个地址保存到 ebp，这个地址是后面找函数的关键地址，找到函数后循环都会经过这里

push 了 wininet 字符串和 0x726774C，这几个字符串都是有用的，特别是 0x726774C 是一个特征码，后面就会看到是怎么用的

最后 CALL 回到 005F401E

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-5abd61eb734da92725944cb616faf325627e5f86.png)

这里截图截不全，下面汇编会把整段写明白

pushad 先把寄存器全部压栈

提升堆栈

edx 置零

后面这个应该挺熟悉的，在编写 shellcode 的文章里面有

```
#include<Windows.h>
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ca1e2062875bf1c10a2ddd8927902e8183d39ffc.png)

接上后面的代码

```
#pragma comment(linker, "/section:.data,RWE")
```

可以看到上面这种遍历的方法不要使用 GetProcAddress 得到函数地址，也不需要通过 push 字符串，有效的去掉了一些特征，除了遍历有点慢之外没什么缺点

在 ecx 遍历完之后会跳到 005F40A1 继续找下个 dll 的地址

当然下个就是 kernel32.dll 了

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b9782b0b2bc1c801e20dc0aa47fa57096aa71164.png)

这里就是匹配到之后执行的代码

```
unsigned char buf[] = "";
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9366b6c521e86b19cdbda2370ea5f1d900f11eab.png)

可以看到堆栈中返回地址是 005F40BA，LoadLibraryA 的参数是 wininet，EAX 中的参数是 LoadLibraryA 的函数指针

接下来走到这里

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-33a90c88d0b8f1b20e22ae99746746ce4e3e22e5.png)

这时候 wininet.dll 已经加载进内存了

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b7f89896bfb4a1ae59b3386a308813a332f84e11.png)

```
int main() {
```

到这里又是重复一次循环，去遍历函数名找到循环右移 13 位之后为 A779563A 的函数

这里就不重复写一遍了

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e3c07f2cb27f3b02db1a275b7402010cb5b39710.png)

A779563A 对应的函数是 InternetOpenA

```
__asm {
```

可以看到堆栈中参数都为 0000000，执行完之后 EAX 是 HINTERNET

跳到 005F40C8 继续

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-851111d3e6cc17a82e79efbad4f8f737062fb630.png)

005F4151 又跳了一次

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d95bca6572c61dc68703c671562cda92373ac19d.png)

005F40C8->005F4151->005F431F

```
mov ecx, offset buf
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-7e113c769068d83c313f83eb6c86ce2cb13759e6.png)

005F4324 后面的就是 IP 地址的字符串，就是指向字符串的指针，用 CALL 压入栈中跳到 005F40CD

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-297675c196f85ab763c3bfdb2e81772628d40e02.png)

```
jmp ecx
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-782a80652dc5ecdea663c7da47dc9933580c60d3.png)

InternetConnectA

```
}
```

对应上面的八个参数，执行完后跳到 005F40E4

接下来又是几次跳转

005F40E4->005F4156

还是相同的方法用 CALL 压入字符串后跳转

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-31dc2a098f3371611f7c683191746782c044c203.png)

这次压入的是完整 shellcode 的路径

跳到 005F40E6

直接贴代码吧不截图了

```
}
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-61129252290c4264d93c303cea6dd4af0560fc79.png)

HttpOpenRequestA

```
005F401E                   pushad
```

执行函数之后跳到 005F40FC 位置

下面是 005F40FC 执行的代码

```
005F401F                   mov ebp,esp
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-37fe98dcf154b764dd034607e28aa445afdabbc6.png)

找到函数 HttpSendRequestA

```
005F4021                   xor edx,edx
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-25396c052bae0123dad3f466a0b4e762c7f95fb5.png)

再跳到 005F4110

```
005F4023                   mov edx,dword ptr fs:[edx+30]
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-75f4b4402d9885c77865dc25b2f194051639e317.png)

GetDesktopWindow 函数无参，作用是获取桌面句柄

跳到 005F4132

```
005F4027                   mov edx,dword ptr ds:[edx+C]
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-689adf8e5eeaeee28f40cb2666e02357b53121a3.png)

InternetErrorDlg 函数是检测错误的，这个不是关键的函数就不提了，简单说如果有错误会在提供的窗口句柄上显示错误，所以上面要得到桌面的句柄

执行完之后跳到

```
005F402A                   mov edx,dword ptr ds:[edx+14]
```

这里应该是经典了，不用说师傅们都知道是 VirtualAlloc，开辟了一块 0x400000 大小的内存，可读可写可执行

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-aee87162e28430003136e1257439e75f7aa9625a.png)

执行完之后跳到 005F42F6

```
#这里先找到第一个LDR_DATA_TABLE_ENTRY结构
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b69b3bc35986d8ab854d4b7f48f6ae46fc7a4c53.png)

InternetReadFile

```
005F402D                   mov esi,dword ptr ds:[edx+28]
```

然后就是循环读 0x2000 大小

```
#找到BaseDllName，得到文件名
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e4aeb8ad42451d8d1bd2b373fa9bcffbae5b10ca.png)

0x03 汇编代码
---------

写个完整的

把汇编代码全部提取出来

写个 python 脚本

```
005F4030                   movzx ecx,word ptr ds:[edx+26]
```

下面是提取的汇编代码

```
#得到文件名的长度
```

0x04 总结
-------

0x0726774C———LoadLibraryA  
0xA779563A———InternetOpenA  
0xC69F8957———InternetConnectA  
0x3B2E55EB——-HttpOpenRequestA  
0x7B18062D——-HttpSendRequestA  
0x315E2145——-GetDesktopWindow  
0x0BE057B7——-InternetErrorDlg  
0xE553A458——-VirtualAlloc  
0xE2899612——-InternetReadFile

这是这段 shellcode 调用的所有函数

1.  LoadLibraryA 加载 wininet.dll
2.  InternetOpenA->InternetConnectA->HttpOpenRequestA->HttpSendRequestA 创建连接发起请求
3.  GetDesktopWindow->InternetErrorDlg 查找报错
4.  VirtualAlloc 开辟内存
5.  InternetReadFile 读入完整 shellcode

可以看到这段 shellcode 其实也只是一个远程下载的功能，当然整个 shellcode 一环扣一环感觉连接的很紧凑

不像之前学着写的那样先把全部函数读进来执行

除了循环多了点没有什么缺点，特别是 InternetReadFile 这里多次找这个函数，可以通过把函数地址压栈避免这个情况