<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1047)

> 奇安信攻防社区 - 侧信道攻击之时序攻击（Time attack）

侧信道分析是一种新型的密码破解手段，其针对加密设备在运行过程中产生的时间消耗、功率消耗或电磁辐射等旁路信息进行分析达到攻击效果。侧信道攻击的有效性远高于密码分析的数学方法。该技术发展至今已经有了许多种实现，如时序攻击、能耗攻击、电磁攻击等，对常见的加密算法如 AES 、 DES 、 RSA 和 ECC 都有对应的攻击手段。与传统密码分析学相比，侧信道攻击显著的攻击效果使其作为一种新的密码分析方法迅速称为研究的热点。而本文围绕时序攻击这个主题，用比较简单基础的例子来介绍这一种攻击手法（其实就是我本身水平也不高 XD

在密码学中, 时序攻击是一种侧信道攻击, 攻击者试图通过分析加密算法的时间执行来推导出密码。每一个逻辑运算在计算机需要时间来执行, 根据输入不同, 精确测量执行时间, 根据执行时间反推出密码。（来自百度百科）

实际上这种攻击手段和 SQL 注入中的时间盲注是类似的，都是利用 “时间” 这种旁路信息来判断程序内部的运行状态从而进行推导，最终获取目标信息。

Password 恢复
-----------

假设一个比较经典的场景，某个系统通过一个 `strcmp` 函数对用户输入的 `password` 和系统中内置的密码进行比较，一致就能登入系统。这里的 `strcmp` 实现如下：

```
int strcmp(const char *s1, const char *s2) {
```

这就是 C 语言本身 `strcmp` 的实现，思路比较简单：就是给定的**两个串逐位比较，遇到不相同的就直接返回**。

按照这种实现，我们用极限的思维去思考，假设我们系统设置的密码是 `'a'*∞` ，当我们输入 `abbbbbbb..` 时函数会很快返回，但是输入 `'a'*∞` 时函数内部则会一直逐位比较。也就是说这两种输入的比较次数不同，那么最直观的体现就是时间，前者很快就返回，后者则会无穷等待。

假设比较一次消耗的时间单位是 `1t` 且固定不变，那么不难得出 `strcmp("123","000")` 和 `strcmp("123","100")` 的执行时间分别是 `1t` 和 `2t` 。我们的攻击思路也就非常清晰了。

接下来进行模拟。由于现代的计算机算力非常发达，这种逐位对比的时间消耗差异是很微妙的，即使是现实中的一些算力比较低的设备也需要比较精准的仪器才能测量内部的差异。所以为了降低误差，我们需要对 `strcmp` 进行小改。改动后的函数实现如下：

```
for ( ; *s1 == *s2; s1++, s2++)
```

通过以上改动，字符判断相同的情况和不同的情况就会出现一个 `5ms` 的差异。但是需要注意的一点是，延时 `5ms` 是为了使模拟攻击更容易实现而人为添加的，实际的攻击中我们一开始是不知道这个差异时间是多少，这一点与 SQL 注入中的时间盲注是不一样的。所以我们需要进行简单的测试来得到这个差异。

```
if (*s1 == '\0')
```

其实就是通过对第一位进行猜解，可以得到一些数据样本：  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d9545ee17460266fba0c5365577c85d23bcb853b.png)  
这里模拟攻击的时间差异是非常明显的，当猜对时函数执行时间比猜错多了 `0.006s` 而且也是比较稳定的。但是在真实的攻击中往往需要多次测试获取更多的样本进行分析计算才能得出一个比较稳定的差异值。利用这个差异我们就可以判断出相应位的字符是否正确，就通过可以逐位猜解获得目标字符串。  
这里直接贴出代码：

```
return 0;
```

运行效果如图：  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9db401d0b497bc2b4ac8e1680c6f132620b661e1.png)

可以看到成功 leak 出了内置的密码，但是由于是模拟攻击，还是比较理想化的。在真实的攻击中往往还存在许多影响因素，所以往往需要多次采样，分析，剔除影响因素。  
这里抛出问题：采集时间差异是必要的吗？直接取耗时最高的是否可行？

GF(2^8) 有限域乘法的时序攻击
------------------

有限域乘法通俗的说就是运算结果都在一个域中，在密码学中很常用，例如 AES 用到的就是 GF(2^8) 有限域乘法。这里也不讲其原理，直接给出实现算法。  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-adbf266d2b721b57007727f255a1b7e1042c7ded.png)

用 C 语言实现

```
return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
```

简单的解释就是，输入字节 x 会先左移 1 位，如果原字节 x 的最高位 x7 为 1，那么还会再异或 `0x1B` 。也就是说 x7=0 时 x 会被处理 1 次，而 x7=1 时会被处理 2 次，这也就出现了差异，我们可以知道这个操作次数的差异是可以在时间上体现出来的。

那么我们先基于这个有限域乘法实现一个加密算法。

```
}
```

我们假设这个算法流程是公开的，其中的 xtime 和 S 盒 都是公开已知的，而 k 值就是由使用者给出，我们攻击者的目标就是获取 k 的值。

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-4a223931691f1e1089fe8a7298a0772ccf1d2bfc.png)  
以上画出一个简单的图，我们不难知道 xtime 的参数 `x2` 是和 `xor(a,k)` 相关的。同时 `a` 是我们可控的，且算法流程也知道，基于这点我们就可以利用时间差分来攻击这个加密算法。

还是一样，我们先进行比较理想的设定，把操作一次的时间设定为 `1t` 且不变, 那么 xtime 算法根据输入的不同就会出现执行时间为 `1t` 和 `2t` 两种情况。

我们的攻击思路如下：

首先准备一定数量的随机样本，然后喂给加密算法，并记录每个样本对应的加密时间。  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-818fe5f099c01cbe09f4612f254989742e1fd2f4.png)  
根据之前的设定，统计结果可以按加密时间分为两组，一组为 `1t` 另一组为 `2t` （通俗的说就是一部分加密时间比较短，另一部分加密时间相对较长）。得到这些**分组**的统计数据后，计算两组的平均时间 -> 作差 -> 求绝对值，结果不难得到是 `1t` 。

由于 k 值的范围在 0x00-0xFF，所以我们可以通过模拟这个加密算法，用不同的 k 值去加密相同的样本，同时和前面一样记录每个样本的加密时间。同样进行分组，但是这次的分组是按照前面的分组进行分组（稍微理解一下），也就是说，对于某个样本以及某个猜测的 k 值，不管其加密时间是长还是短，都按照**被攻击的 k 值的分组情况**进行分组。分组完成后，同样计算两组的平均时间 -> 作差 -> 求绝对值。

直接举例子：

```
int new_strcmp(const char*s1, const char*s2){
```

下面进行编码模拟攻击，首先需要小改一下 xtime 函数

```
for(;*s1==*s2;s1++,s2++,usleep(5000)) // 如果字符相同，增加一定的延时。
```

完整代码：

```
if(*s1=='\0')
```

编译运行：  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-acb7628aec520902c3a27aefe07c37bb94f47037.png)  
可以看到一些猜错的 k 值因为错误的分组所以差分后相关性比较弱。  
![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e4482c7b3b437d6e188e4a9f0b0989011c50784b.png)  
而猜对的时候由于分组完全符合，就可以计算出我们设定的 10ms 的差异结果，也就是说分组的相关性很强，这样就可以得到 k 值为 `0xAE` 了。

侧信道分析相比传统的密码分析学来说，它是一种比较旁门的手段，甚至可以说是猥琐。但是在安全攻防中，手段并没有什么高低贵贱之分，总会有些人为了达到目的用尽各种意想不到的手段。而安全的本质就是对风险和异常的管理，一切都应防范于未然，所以无论是侧信道还是什么偏门且猥琐的手段，都有其研究的价值和意义。不管是进攻还是防守，只有知己知彼才能百战百胜。