<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/X0ObwotUCuFWceBFhLncGg)

目录

一、 UPX 加壳的原理 3

1． UPX 的工作原理 3

2． UPX 实时解压的原理和流程 3

3． UPX 加壳应用的场景 3

4． 修改 UPX 源码需要注意以下几点 3

二、 UPX 加壳 Android so 的方法和步骤 3

三、 UPX 加壳 Android so 相关问题总结 11

四、 UPX 源码分析（upx 加壳的原理和流程分析）13

1． 对加壳函数的拆解分析 16

2． 对 pack1() 的分析 16

3． 对 pack2() 的分析 17

4． 对 pack3() 的分析 19

5． 对 pack4() 的分析 23

6． Loader 的获取 27

7． loader 的拼接 32

8． UPX 源码的核心头文件 32

9． 参考文献 33

10． 技术文档 34

五、 Android N 的限制（Android 7.0 以上版本 so 的兼容性问题）35

1. classloader-namespace 问题 35

2. Elf Section Header 完整性问题 35

3. 解决方法 36

六、 UPX 脱壳全过程分析 40

1． 先初始化 40

2． 进行代码还原 41

3． 进行 CALL 修复 41

4． 进行函数表还原 41

5． 节表初始化 41

6． 解码完毕飞向程序入口 41

7． IDA Pro 逆向工具常用快捷键 41

8． 参考文献 42

七、 附图 42

图一: Linux ELF 通用的 UPX 加壳文件格式，分为可执行文件和共享库 42

图二: Linux ELF 通用的 UPX 加壳文件格式，分为可执行文件和共享库 43

图三: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式 44

图四: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式 44

图五: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式 45

图六: UPX 解析 45

图七: Android OAT 文件结构 46

图八: Android Oat Format47

图九: Android ELF 文件格式 48

图十: Smali 代码注入总体流程图 49

图十一: Android 系统启动架构图 49

图十二: Android 的壳模型（一）50

图十三: Android 的壳模型（二）50

一、UPX 加壳的原理

1．UPX 的工作原理

1) 首先将程序压缩。所谓的压缩包括两方面，一方面在程序的开头或者其他合适的地方插入一段代码，另一方面是将程序的其他地方做压缩。压缩也可以叫做加密，因为压缩后的程序比较难看懂，主要是和原来的代码有很大的不同。最大的表现也就是他的主要作用就是程序本身变小了。变小之后的程序在传输方面有很大的优势。其次就是在程序执行时，实时的对程序解压缩。解压缩功能是在第一步时插入的代码完成的功能。联起来就是：upx 可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率，upx 和普通的压缩，解压不同点就算在于 upx 是实时解压缩的

2．UPX 实时解压的原理和流程

1) 最初代码的形式: 7==>8==>9==>5==>6

2) 用 upx 压缩之后形式: 1==>2==>3==>4==>5==>6

3) 执行时的形式: 1==>7==>8==>9==>5==>6

3．UPX 加壳应用的场景

1) 木马和病毒躲避杀毒软件时，发布的程序防止被反编译或破解时。upx 是一种典型的加壳程序或者压缩程序。因此已经有非常成熟的去壳程序或者解压缩程序

4．修改 UPX 源码需要注意以下几点

1) 保证修改后的加壳程序不会产生 upx 产生的特征码。有很多软件可以通过这些特征码识别出程序是经过 upx 加壳的

2) 保证加壳之后，程序仍然可以顺利执行

3) 在一定程度上保证效率不会下降太多

二、UPX 加壳 Android so 的方法和步骤

wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz

wget http://pkgs.fedoraproject.org/re ... /zlib-1.2.11.tar.xz

git submodule update --init --recursive

.tar.gz      格式解压为   tar -zxvf xx.tar.gz

.tar.bz2   格式解压为   tar -jxvf xx.tar.bz2

解压 tar.xz 文件: 先 xz -d xxx.tar.xz 将 xxx.tar.xz 解压成 xxx.tar 然后，再用 tar xvf xxx.tar 来解包

sudo apt-get install zlib1g-dev

apt-get install libucl-dev

lzma443.tar.bz2

zlib-1.2.3.tar.gz

zlib-1.2.8.tar.gz

vim /etc/profile

vim ~/.bashrc

export UPX_UCLDIR=/usr/local/android/upxmake/ucl-1.03

export UPX_ZLIBDIR=/usr/local/android/upxmake/zlib-1.2.3

export UPX_ZLIBDIR=/usr/local/android/upxmake/zlib-1.2.8

export UPX_LZMADIR=/usr/local/android/upxmake/lzma443

export UPX_LZMA_VERSION=0x443

export UPX_DIR=/usr/local/android/upxmake/upx-master

UPX 对 ELF 文件加壳要求 ELF 文件必须有_init 导出函数，否则会报 "UnknownExecutableFormatException" 错误，问题定位到 UPX 源码的 p_lx_elf.cpp 文件的 canPack() 函数中:

if (/*jni_onload_sym ||*/ elf_find_dynamic(Elf32_Dyn::DT_INIT))

也就是说 Dynamic 段中必须有类型为 DT_INIT 的字段，它指向 ELF 文件初始化函数在文件中的偏移。一般的 so 都不会有这个函数，加入如下代码:

#ifdef __cplusplus 

extern "C" { 

#endif   

    void _init(void){}   

#ifdef __cplusplus 

} 

#endif

Android.mk，添加 init 段，需要如下代码:

LOCAL_CFLAGS := -fvisibility=hidden   #隐藏符号表

LOCAL_CFLAGS += -Wl,-init=_init #添加 init 段

初始化和终止函数是使用 gcc 的 constructor 和 destructor 特性来定义的，在库被加载时需要执行的所有函数都应该定义成如下的形式:

void __attribute__((constructor)) some_name_load(void) {

   /*Initialization code*/

}

卸载函数的形式如下所示:

void __attribute__((destructor)) some_name_unload(void) {

   /*Initialization code*/

}

使用 gcc 的 constructor 和 destructor 特性还能创建主程序的初始化函数和终止函数

_init() 和_fini() 函数

用来完成共享库的初始化和终止工作的一项较早的技术是在库中创建两个函数_init() 和_fini()

当库首次被进程加载时会执行 void _init(void) 中的代码

当库被卸载时会执行 void _fini(void) 函数中的代码

如果创建了_init() 和_fini() 函数，那么在构建共享库时必须要指定 gcc -nostartfiles 选项以防止链接器加入这些函数的默认实现，可以使用 - WI,-init 和 - WI,-fini 链接器选项来指定函数的名称

有了 gcc 的 constructor 和 destructor 特性之后已经不建议使用_init() 和_fini() 函数了，因为 gcc 的 constructor 和 destructor 特性允许定义多个初始化和终止函数

so 加载时构造函数，在函数声明时加上 "__attribute__((constructor))" 属性

void __attribute__((constructor)) init_function(void){

   //to do

}

对应有 so 卸载时析构函数，在程序 exit() 或者 dlclose() 返回前执行

void __attribute__((destructor)) fini_function(void){

   //to do

}

c++ 全局对象初始化，其构造函数（对象）被自动执行

在 Android ndk 编程中，.init 段和. init_array 段函数的定义方式，如下所示:

编译生成后在. init 段

extern "C" void _init(void){

}

编译生成后在. init_array 段

__attribute__((constructor)) void _init(void){

}

带构造函数的全局对象生成的时候在. init_array 段里面

在 so 库文件中定义的. init 和. init_array 段处函数的执行

先调用. init 段的构造函数再调用. init_array 段的构造函数

// 先调用. init 段的构造函数

CallFunction("DT_INIT", init_func);

// 再调用. init_array 段的构造函数

CallArray("DT_INIT_ARRAY", init_array, init_array_count, false);

.init 段构造函数的调用实现

void soinfo::CallFunction(const char* function_name UNUSED, linker_function_t function){

   // 判断构造函数的调用地址是否符合要求

   if(function==NULL||reinterpret_cast(function)==static_cast(-1)){

      return;

   }

   //function_name 被调用的函数名称，function 为函数的调用地址

   //[Calling %s @ %p for '%s'] 字符串为在 /system/bin/linker 中查找. init 和. init_array 段调用函数的关键

   TRACE("[ Calling %s @ %p for'%s']", function_name, function, name);

}

.init_arrayt 段构造函数的调用实现

// 循环遍历调用. init_arrayt 段中每个函数

for (int i = begin; i != end; i += step) {

   TRACE("[ %s[%d] == %p ]", array_name, i, functions[i]);

   //.init_arrayt 段中，每个函数指针的调用和上面的. init 段的构造函数的实现是一样的

   CallFunction("function", functions[i]);

}

从. init 段和. init_arrayt 段构造函数的调用实现来看，最终都是调用的 void soinfo::CallFunction(const char* function_name UNUSED, linker_function_t function) 函数，因此 IDA 动态调试 so 时，只要守住 CallFunction 函数就可以实现对. init 段和. init_arrayt 段构造函数调用的监控

由于 Android 系统的 / system/bin/linker 文件中上面提到的很多 so 库文件加载过程的函数没有被导出设置为隐藏，在进行 so 库文件的动态调试后不好通过查找关键流程函数的方法来查找. init 和. init_array 段构造函数。根据. init 和. init_array 段构造函数的调用的特点，最终的构造函数的调用都是在 CallFunction 函数并且在调用. init 和. init_array 段构造函数之前有明显的特征字符串 [Calling %s @ %p for '%s']，因此使用 IDA 工具，通过在 / system/bin/linker 文件中搜索特征字符串 [Calling %s @ %p for '%s'] 来查找到. init 和. init_array 段构造函数调用的地方

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFYF7IibUicNT4QjXv7iafk3WibkaeCvzOicmZvRRPBK0xEqHjIL4SMFfZ4wg/640?wx_fmt=png)

Android jni 中 JNI_OnLoad 函数的执行

String doLoad(String name, ClassLoader loader) 函数的实现，doLoad 函数调用 native 层实现的 nativeLoad 函数进行 so 库文件的加载

nativeLoad 函数的本地方法实现 Dalvik_java_lang_Runtime_nativeLoad() 函数最终调用 Android4.4.4r1 源码 / dalvik/vm/Native.cpp 中的 dvmLoadNativeCode() 函数，在该函数中先调用 dlopen 函数加载 so 库文件到内存中，然后调用 dlsym 函数获取 so 库文件中 JNI_OnLoad 函数的导出地址，然后调用 JNI_OnLoad 函数执行开发者自定义的代码和实现 jni 函数的注册

字符串 [Calling JNI_OnLoad for \"%s\"] 可以作为查找 system/lib/libdvm.so 中 JNI_OnLoad 函数调用地址的依据

ALOGI("[Calling JNI_OnLoad for \"%s\"]", pathName);

通过 IDA 工具在 / system/bin/linker 文件中，查找特征字符串 [Calling %s @ %p for '%s']，根据字符串 [ Calling %s @ %p for '%s' ] 引用查询到. init 和. init_array 段构造函数调用的代码调用位置

再开一个 IDA 对该 so 库文件进行 Android 应用的附加调试，设置 IDA 调试时断在 so 库文件加载的位置，更保险的方法就是在 system/lib/libdvm.so 库文件的导出函数 dvmLoadNativeCode() 处下断点， 然后通过 IDA 工具获取 / system/bin/linker 的模块加载基址 linker_base（RA），因此 linker_base+0x0000274C 即为. init 和. init_array 段构造函数被调用的位置（VA），在此处下断点 F7 跟进即可进入. init 和. init_array 段构造函数的实际调用地址 VA 处，实现监控. init 和. init_array 段构造函数的代码行为。

静态的解析 so 库文件的可执行试图，获取到. init_array 段构造函数的调用地址（不是被调用的位置）的相对虚拟地址偏移 fun_rva，加上该 so 模块加载基址 so_base 即:so_base+fun_rva 即为. init_array 段构造函数的直接函数调用地址 VA

代码下载地址为: https://github.com/Chenyuxin/elf_initarray.git

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFbetMMPZR8vU8qmaJpwkNwibKicr4u8hN2wP2jYZxp5lQib0sibzBXPXMCA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFoK0IO71r9dbHQOZMn3FO6cuUgzSD36FX6r5X1em69KiagY6h4Tn3oMA/640?wx_fmt=png)

.init_array 段构造函数的调用地址的 RVA 获取到了，只要通过 IDA 调试 so 库的方法获取到该. init_array 段所在 so 文件的内存加载基址 so_base，因此 so_base+.init_array 段构造函数的调用地址的 RVA 即为. init_array 段构造函数的调用地址的 VA 也就是.init_array 段构造函数的动态实际调用地址，只要在这个地址处下断点即可

在使用 IDA 动态调试 so 库文件时，可以在函数 dvmLoadNativeCode() 上下断点，JNI_OnLoad 函数的调用就是在函数 dvmLoadNativeCode() 中，因此通过 _Z17dvmLoadNativeCodePKcP6ObjectPPc 即 dvmLoadNativeCode() 函数就可以定位到 JNI_OnLoad 函数调用的位置

upx 对 elf64 的 so 文件加壳会出错 (抛出: NotCompressibleException)

编译时提示找不到 libz 库，需要在 UPXDIR/src/MakeFile 中添加:

INCLUDES += -I$(UPX_ZLIBDIR)

LIBS += $(addprefix -L,$(dir $(wildcard $(UPX_ZLIBDIR)/libz$(libext))))

编译命令:

./configure

make clean

make

cp libz.a /usr/lib/libz.a

cp libz.a /usr/lib32/libz.a

cp libz.a /usr/lib64/libz.a

cp libz.so /usr/lib/libz.so

cp libz.so /usr/lib32/libz.so

cp libz.so /usr/lib64/libz.so

ucl-1.03.tar.gz

编译命令:

./configure --host=i686 --target=arm-eabi --enable-static

make clean

make

upx-master.zip

upx-3.93-src.tar

upx-3.91.zip

upx-3.92.zip

upx-3.93.zip

编译命令:

make clean

make all

CXX=g++ UPX_UCLDIR=/usr/local/android/upxmake/ucl-1.03 UPX_LZMADIR=/usr/local/android/upxmake/lzma443 UPX_LZMA_VERSION=0x443 make all

编译 upx 源码报如下错误的解决方法:

ERROR: binary file detected ./src/c_file.o

进入如下目录，注释掉如下信息:

/upx-3.93-src/src/stub/scripts/

vim check_whitespace.sh

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFia7PMTXtBVYDib71yml2m4r45dIFh8RSoiaybFPueyXIibHaibkUr5L5cdg/640?wx_fmt=png)

cp upx.out /root/gyp/UPX3.92/upx/upx-master/

cp upx.out /root/gyp/UPX3.92/upx/upx-3.91/

cp upx.out /root/gyp/UPX3.92/upx/upx-3.92/

cp upx.out /root/gyp/UPX3.92/upx/upx-3.93/

cp upx.out /root/gyp/UPX3.92/upx/upx-3.93-src/

./upx.out -h

./upx.out -f -o libjin_upx.so libjni.so

./upx.out -o libiohook_upx.so libiohook.so

./upx.out -f -o libiohook_upx.so libiohook.so

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF231qYvA52WtL4WdW75uwuGJK7R260uCs6OFu20cSwiar2XJ8jlv3DVMB1Nf6L9EHCtXfCibqulQxsA/640?wx_fmt=png)  

readelf -S libiohook_armeabi.so      加固前

readelf -S libiohook.so            加固后

备注: 使用 upx 加壳的 so 的 section table 被抹除了

readelf -d libiohook_armeabi.so      加固前 (可以看到 INIT 段)

readelf -d libiohook.so            加固后 (可以看到 INIT 段)

三、UPX 加壳 Android so 相关问题总结

在 native 代码中定义全局变量用于增加生成的二进制的体积

C:int const dummy_to_make_this_compressible[100000] = {1,2,3};

C++:extern "C" int const dummy_to_make_this_compressible[100000] = {1,2,3};

注意: 如果编译出来的库本身足够大，则此步骤可省略

在 native 代码中使用宏定义混淆函数名，用于增加静态反汇编分析难度

#define startSimpleWifi sSW

#define sendData sD

(1). 编译 UPX 出现 “cannot find -lz” 错误

分析: 原因是链接器 LD 没有找到编译出来的 zlib 库 libz.so 或 libz.a

解决方法: 将 libz.so 或 libz.a 拷贝到系统默认的动态链接库路径下，比如:/usr/lib,/usr/lib64 等

(2). 编译 UPX 出现 “CantPackException: DT_TEXTREL found; re-compile with -fPIC” 错误

分析: 这是早期 NDK 版本的 BUG

解决方案: 使用 NDK9 或以上的版本

(3). 编译 UPX 出现 “NotCompressibleException” 错误

分析: UPX 对被加壳的二进制文件有最小限制，太小的文件将无法被加壳

解决方案: 在 native 代码中定义足够大的数据变量，使得编译出来的二进制文件容易达到 UPX 的要求，参考《加固步骤》之《修改 native 代码》

(4). 编译 UPX 出现 “UnknownExecutableFormatException” 错误

分析: 被加壳的二进制文件必须存在 init 段，否则 UPX 将无法脱壳还原原始代码

解决方案：在 native 代码中定义_init() 方法，需要注意 C 和 C++ 的区别，参考《加固步骤》之《修改 native 代码》

备注: 查看二进制文件是否存在 init 段

(5). 使用 UPX 加壳的 so，在 eclipse 中启动 Android 程序时出现”Fatal signal…” 错误

分析: 此错误是因为 UPX 解析某些特殊字符处理不当导致的，该 BUG 已经有人提交 UPX 官方解决，但是当前官方正式发布的正式版本（V3.91）并没有 fix 该问题，而是在未正式发布

的 V3.92 才解决了该问题，因此本文档使用源代码版本为 V3.92 而非 V3.91

解决方案: 使用 V3.92 及以上版本的源码

(6). 为何删除 UPX 源码中的软件信息，以及如何定位查找这些信息

分析: UPX 对文件进行加壳时会把这些信息写入壳内，通过静态反汇编可查看到这些壳信息，进而寻找对应的脱壳机进行脱壳，使得攻击难度降低

解决方案: 在 UPX 源码中删除这些信息，并重新编译，步骤如下:

1). 使用原始版本对文件进行加壳

2). 使用 IDA 反汇编加壳文件，在反汇编文件的上下文中查找 UPX 壳特征字符串

3). 在 UPX 源码中查找这些特征字符串（建议使用 Search and Replace），并一一删除

packer.cpp

static const char *getIdentstr(unsigned *size, int small)

4). 重新编译 UPX

UPX 是如何区分文件格式的方法: 它是先确定大致可执行文件类型, 然后挨个格式试验 canPack, 一旦发现格式不对, 不符合此种格式的标准就抛异常，最后一个 canPack 也不符合就告诉大家这个文件” 未知文件格式”

p_vmlinx.cpp

templatebool PackVmlinuxBase::canPack()

packer.cpp

static const char *getIdentstr(unsigned *size, int small)

static char identbig[] =

        "\n\0"

        "$Info:"

        "This file is packed with the UPX executable packer http://upx.sf.net $"

        "\n\0"

        "$Id: UPX"

        UPX_VERSION_STRING4

        "Copyright (C) 1996-" UPX_VERSION_YEAR "the UPX Team. All Rights Reserved. $"

        "\n";

p_lx_elf.cpp

bool PackLinuxElf32::canPack()

if (/*jni_onload_sym ||*/ elf_find_dynamic(Elf32_Dyn::DT_INIT))

①　"INIT" 段是 ELF 文件结构中: Dynamic 表中的一个表项结构，它包含一个地址，该地址指向启动代码，并非真的段，也并非必须是一个区段，这个表项结构不是必需的，所以会在没有 "_init" 函数声明的情况下, 编译器不会添加它. 随意声明一个即可

②　并不是非加 "INIT 函数" 不可，其原理是在 Dynamic 表中增加了一条 INIT 表项，因为 UPX 只是简单的查找 Dynamic 中是否存在 INIT 表项结构，如果找不到就会报错, 它自己不会主动去做添加操作，可以对任意没有 INIT 的 SO 进行添加 INIT 表项的简单处理. 但是需要注意的一点是:INIT 的地址处理，因为根据试验, UPX 在执行完自身解密代码后, 会执行原 INIT 内的代码. 如果随意给一个地址必定出错. 所以在没有代码的情况下尝试构造一个空函数是一个好主意（修改 UPX 中 load 的代码. 使其忽略原 init 段）

③　经过验证: 如果. so 文件有_init 段, 区段 dynamic 中就会有一个标志等于 0xC, 其地址指向初始化区段文件偏移地址, 另外_init 并非区段, 只是一个导出函数, NDK 会生成对应的区段并融合在某个大区段中, 所以从区段表看不到它

四、UPX 源码分析（upx 加壳的原理和流程分析）

在这个项目中感兴趣的 UPX 源码都在文件夹 / src 中，进入该文件夹后可以发现其源码由文件夹 / src/stub，/src/filter，/lzma-sdk 和一系列 *.h, *.cpp 文件构成。其中 / src/stub 包含了针对不同平台，架构和格式的文件头定义和 loader 源码，/src/filter 是一系列被 filter 机制和 UPX 使用的头文件。其余的代码文件主要可以分为负责 UPX 程序总体的 main.cpp，work.cp 和 packmast.cpp，负责加脱壳类的定义与实现的 p_*.h 和 p_*.cpp，以及其他起到显示，运算等辅助作用的源码文件。源码的分析将会从 main.cpp 入手，经过 work.cpp，最终跳转到对应架构和平台的 packer() 类中

main.cpp

do_files(i,argc,argv);

void do_files(int i, int argc, char *argv[])

work.cpp

void do_files(int i, int argc, char *argv[])

do_one_file(iname,oname);

void do_one_file(const char *iname, char *oname)

PackMaster pm(&fi, opt);

if (opt->cmd == CMD_COMPRESS)

   pm.pack(&fo);

else if (opt->cmd == CMD_DECOMPRESS)

   pm.unpack(&fo);

else if (opt->cmd == CMD_TEST)

   pm.test();

else if (opt->cmd == CMD_LIST)

   pm.list();

else if (opt->cmd == CMD_FILEINFO)

   pm.fileInfo();

else

   throwInternalError("invalid command");

packmast.cpp

void PackMaster::pack(OutputFile *fo)

{

    p = getPacker(fi);

    fi = NULL;

    p->doPack(fo);

}

packmast.cpp

Packer *PackMaster::getPacker(InputFile *f)

{

    Packer *pp = visitAllPackers(try_pack, f, opt, f);

    if (!pp)

        throwUnknownExecutableFormat();

    pp->assertPacker();

    return pp;

}

static Packer* try_pack(Packer *p, void *user)

{

    if (p == NULL)

        return NULL;

    InputFile *f = (InputFile *) user;

    p->assertPacker();

    try {

        p->initPackHeader();

        f->seek(0,SEEK_SET);

        if (p->canPack())

        {

            if (opt->cmd == CMD_COMPRESS)

                p->updatePackHeader();

            f->seek(0,SEEK_SET);

            return p;

        }

    } catch (const IOException&) {

    } catch (...) {

        delete p;

        throw;

    }

    delete p;

    return NULL;

}

packer.cpp

void Packer::doPack(OutputFile *fo)

{

    uip->uiPackStart(fo);

    pack(fo);

    uip->uiPackEnd(fo);

}

根据分析可以得知 Packer 能否适配成功最终取决于每一个具体 Packer 类的成员函数 canPack(). 可以以常用的 Linux for AMD 64 为例，其实现位于 p_lx_elf.cpp 的 PackLinuxElf64amd::canPack() 中，而 Linux for x86 和 Linux for ARM 的实现均位于 PackLinuxElf32::canPack() 中，从 visitAllPackers() 的代码中也可以看到 UPX 当前并不支持 64 位 ARM 平台

Packer 的适配和初始化（UPX 对 Packer 的适配检查，通过适配的 Packer 将会被返回到 doPack() 中，通过调用其函数 pack() 进行加壳）

p_lx_elf.cpp

bool PackLinuxElf64amd::canPack()

第一部分代码，该部分代码主要是对 ELF 文件头 Ehdr 和程序运行所需的基本单位 Segment 的信息 Phdr 进行校验。代码读取了文件中长度为 Ehdr+14*Phdr 大小的内容，首先通过 checkEhdr() 将 Ehdr 中的字段与预设值进行比较，确定 Phdr 数量大于 1 且偏移值正确，随后对 Ehdr 的大小和偏移进行判定，判定 Phdr 数量是否大于 14，最后确定第一个具有 PT_LOAD 属性的 segment 是否覆盖了整个文件的头部

第二部分代码，从两段长注释中我们可以看出 UPX 仅支持对位置无关（PIE）的可执行文件和代码位置无关 (PIC) 的共享库文件进行加壳处理，然而可执行文件和共享库都（可能）具有 ET_DYN 属性，理论上没有办法将他们区分开。作者采用了一个巧妙的办法：当文件入口点为__libc_start_main，__uClibc_main 或__uClibc_start_main 之一时，说明文件依赖于 libc.so.6，该文件为满足 PIE 的可执行文件。因此该部分通过判定文件是否具有 ET_DYN 属性，若是则在其重定位表中搜寻以上三个符号，满足则跳转至 proceed 标号处

第三部分代码，该部分针对第二部分的 “漏网之鱼”，此时将待处理的文件视为共享库文件。共享库文件需要满足 PIC——文件中不包含代码重定位信息节 DT_TEXTREL。此外，文件最靠前的可执行节地址（通常为. init 节代码）必须在重定位信息之后，因为此时链接器 ld-linux 必须在. init 节之前进行重定位，UPX 加壳后会将入口点设置在. init 节上，必须避免破坏 ld-linux 所需的信息。若判定通过，变量 xct_off 将记录下. init 段地址（必然不等于 0）并作为后续 pack 函数中对待操作文件是否为共享库的判定条件

第四部分代码，注释中已经说明其调用的是 PackUnix::canPack()，函数实现位于 p_unix.cpp 中。该函数判断待操作文件是否具有可执行权限，大小是否大于 4096，并读取最末尾的一部分数据判定是否加壳

p_unix.cpp

bool PackUnix::canPack()

p_lx_elf.cpp

bool PackLinuxElf32::canPack()

Linux for x86 和 Linux for ARM 版本的 PackLinuxElf32::canPack() 与前例流程几乎一致。不同的是另一个版本的 canPack() 在第一部分的末尾额外增加了对 PT_NOTE 段的长度和偏移检测，并对 OS ABI 类型做了额外的检测

1．对加壳函数的拆解分析

UPX 对所有运行在其支持的架构上的 Linux ELF 文件都使用同一个 pack()，该函数的实现位于 p_unix.cpp 中。pack() 将很多具体操作下放到了各个子类分别实现的 pack1()、pack2()、pack3()、pack4() 函数中，因此其本体源码并不是很长。通过 pack() 中的注释我们可以发现其加壳流程大致分为初始化文件头，压缩文件本体，添加 loader 和修补 ELF 格式四部分

p_unix.cpp

void PackUnix::pack(OutputFile *fo)

void PackUnix::pack1(OutputFile * /*fo*/, Filter & /*ft*/)

int PackUnix::pack2(OutputFile *fo, Filter &ft)

void PackUnix::pack3(OutputFile *fo, Filter &/*ft*/)

void PackUnix::pack4(OutputFile *fo, Filter &)

2．对 pack1() 的分析

位于 pack() 开头的这部分代码完成的主要工作为初始化了一些和加壳相关的变量，设置了区块大小并在 I/O 流中分配内存用于加壳，随后调用了 pack1()。对于 AMD 64 来说其实现位于 p_lx_elf.cpp 中的 PackLinuxElf64::pack1() 中

p_lx_elf.cpp

void PackLinuxElf64amd::pack1(OutputFile *fo, Filter &ft)

{

    super::pack1(fo, ft);

    if (0!=xct_off)  // shared library

        return;

    generateElfHdr(fo, stub_amd64_linux_elf_fold, getbrk(phdri, e_phnum) );

}

这个函数调用了父类的同名函数 PackLinuxElf64::pack1() 进行处理，随后当文件不为共享库时调用 PackLinuxElf64::generateElfHdr() 生成一个 ELF 头，所有的代码都位于文件 p_lx_elf.cpp 中

p_lx_elf.cpp

void PackLinuxElf64::pack1(OutputFile *fo, Filter & /*ft*/)

首先分析 PackLinuxElf64::pack1(), 函数的前半部分读取了 ELF 头部 Ehdr 和程序运行时所需的信息 Phdr，将标志为 PT_NOTE 的段保存下来（虽然好像并没有用到）, 计算了 PT_LOAD 段的 page_size 和 page_mask。当文件为共享库时，根据前面 canPack() 处的说明，为了保证信息不被修改，xct_off 前面的所有数据被原封不动写到输出文件中，此外写入了一个描述 loader 的结构体 l_info

调用了 PackLinuxElf64::generateElfHdr() 生成了一个包含有 Ehdr 和两个 Phdr 在内的文件头，其中两个 segment 均为 PT_LOAD 类型，第一个具有 RX 属性，第二个则具有 RW 属性。同样的，在文件头的最后也追加了一个空 l_info 结构体

p_lx_elf.cpp

void PackLinuxElf32x86::pack1(OutputFile *fo, Filter &ft)

{

    super::pack1(fo, ft);

    if (0!=xct_off)  // shared library

        return;

    generateElfHdr(fo, stub_i386_linux_elf_fold, getbrk(phdri, e_phnum) );

}

p_lx_exc.cpp

void PackLinuxI386::pack1(OutputFile *fo, Filter &)

{

    // create a pseudo-unique program id for our paranoid stub

    progid = getRandomId();

    generateElfHdr(fo, stub_i386_linux_elf_execve_fold, 0);

}

p_lx_elf.cpp

void PackLinuxElf32::generateElfHdr(OutputFile *fo,void const *proto,unsigned const brka)

p_lx_elf.cpp

void PackLinuxElf64::generateElfHdr(OutputFile *fo,void const *proto,unsigned const brka)

对于 x86 和 ARM 来说，其可执行文件所需的 PackLinuxElf32::generateElfHdr() 和父类的 PackLinuxElf32::pack1() 与本例大同小异

3．对 pack2() 的分析

pack2() 的核心是 compressWithFilters()，调用了 pack2() 进行文件（实际上是 PT_LOAD 段）压缩，并在末尾补上一个 b_info 结构体 (UPX 设计的初衷是压缩可执行文件的大小)

p_unix.cpp

int PackUnix::pack2(OutputFile *fo, Filter &ft)

{

   while (remaining> 0)

    {

      unsigned const end_u_adler = upx_adler32(ibuf, ph.u_len, ph.u_adler);

        compressWithFilters(&ft,OVERHEAD,NULL_cconf, filter_strategy,!!n_block++);  // check compression ratio only on first block

   }

}

p_lx_elf.cpp

int PackLinuxElf32::pack2(OutputFile *fo, Filter &ft)

int PackLinuxElf64::pack2(OutputFile *fo, Filter &ft){

packExtent(x, total_in, total_out,((0==nx && (Elf64_Phdr::PF_X & get_te64(&phdri[k].p_flags)))? &ft : 0 ), fo, hdr_u_len);

}

当传递进来的参数 hdr_u_len 不为零时说明文件头（Ehdr+Phdrs）未被压缩，读取到 hdr_ibuf 中等待压缩，进入 for 循环，循环读取带压缩的数据进行压缩和输出到文件操作, 将结果写回文件。若 hdr_u_len 不为零，调用 upx_compress 压缩 hdr_ibuf，结果写回，然后将 hdr_u_len 置零防止重复压缩

p_unix.cpp

void PackUnix::packExtent(const Extent &x,unsigned &total_in,unsigned &total_out,Filter *ft,OutputFile *fo,unsigned hdr_u_len){

if (hdr_u_len) {

   int l = fi->readx(hdr_ibuf, hdr_u_len);

}

for (off_t rest = x.size; 0 != rest;) {

if (ft) {

      compressWithFilters(ft, OVERHEAD, NULL_cconf, filter_strategy,0, 0, 0, hdr_ibuf, hdr_u_len);

}else {

      (void) compress(ibuf, ph.u_len, obuf);    // ignore return value

}

if (hdr_u_len) {

int r = upx_compress(hdr_ibuf, hdr_u_len, hdr_obuf, &hdr_c_len, 0,ph.method, 10, NULL, NULL);

hdr_u_len = 0;  // compress hdr one time only

}

fo->write(&tmp, sizeof(tmp));

if (ph.c_len < ph.u_len) {

   fo->write(obuf, ph.c_len);

   // Checks ph.u_adler after decompression, after unfiltering

   verifyOverlappingDecompression(ft);

}

else {

   fo->write(ibuf, ph.u_len);

}

}

}

先将目光放在 pack2() 上，其实现位于 p_lx_elf.cpp 中的 PackLinuxElf64::pack2()，计算完变量之后筛选出 PT_LOAD 段，调用 packExtent() 进行数据打包和输出到文件，根据注释，PowerPC 有时候会给. data 段打上可执行标志，而打上该标志的段会被认为是代码段，在 packExtent() 中会调用 compressWithFilters() 进行压缩。然而对于过小的. data 段 compressWithFilters() 无法压缩。因此在 for 循环之前初始化了一个 nx 标志变量记录 PT_LOAD 下标。当且仅当带有可执行标志的第一个 PT_LOAD 段适用于 compressWithFilters()

压缩结束后计算已压缩数据和未压缩数据的和是否等于原文件大小。在此之前补齐文件位数为 4 的倍数，并把长度记录在变量 sz_pack2a 中，这个变量将会在 pack3() 被用到

unsigned sz_pack2;  // after pack2(), before loader

unsigned sz_pack2a;  // after pack2() of all PT_LOAD

sz_pack2a = fpad4(fo);  // MATCH01

4．对 pack3() 的分析

pack() 中对 pack3() 的注释写着 append loader，即添加 loader，而实际上 pack3() 不仅为输出结果添加了一个 loader，也将 pack2() 未处理的其他数据压缩后输出到结果中，并做了一系列调整

p_unix.cpp

void PackUnix::pack3(OutputFile *fo, Filter &/*ft*/)

{

    upx_byte *p = getLoader();

    lsize = getLoaderSize();

    updateLoader(fo);

    patchLoaderChecksum();

    fo->write(p, lsize);

}

p_lx_elf.cpp

PackLinuxElf::PackLinuxElf(InputFile *f)

    : super(f), e_phnum(0), dynstr(NULL),

    sz_phdrs(0), sz_elf_hdrs(0), sz_pack2(0), sz_pack2a(0),

    lg2_page(12), page_size(1u<<lg2_page), is_big(0),

    xct_off(0), xct_va(0), jni_onload_va(0),

    e_machine(0), ei_class(0), ei_data(0), ei_osabi(0), osabi_note(NULL),

    o_elf_shnum(0)

{

}

p_lx_elf.cpp

void PackLinuxElf::pack3(OutputFile *fo, Filter &ft)

void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)

void PackLinuxElf64::pack3(OutputFile *fo, Filter &ft){

super::pack3(fo, ft);  // loader follows compressed PT_LOADs

for (int j = e_phnum; --j>=0; ++phdr) {

   if (phdr->PT_INTERP==type) {             

      set_te16(&ehdri.e_phnum, --e_phnum);

   }

   if (phdr->PT_LOAD==type) {

      if (xct_off < ioff) {  // Slide up non-first PT_LOAD.

fi->seek(ioff, SEEK_SET); fi->readx(ibuf, len);

fo->seek(off, SEEK_SET); fo->write(ibuf, len);

set_te64(&phdr->p_offset, rel + ioff);

}else {  // Change length of first PT_LOAD.

va_init += get_te64(&phdr->p_vaddr);

set_te64(&phdr->p_filesz, sz_pack2 + lsize);

set_te64(&phdr->p_memsz,  sz_pack2 + lsize);

}

continue;  // all done with this PT_LOAD

}

// Compute new offset of &DT_INIT.d_val.

     if (phdr->PT_DYNAMIC==type) {

Elf64_Dyn *dyn = (Elf64_Dyn *)(void *)ibuf;

for (int j2 = len; j2> 0; ++dyn, j2 -= sizeof(*dyn)) {

if (dyn->DT_INIT==get_te64(&dyn->d_tag)) { 

}

}        

}

}

}

函数的第一部分调用了父类的 pack3()，即 PackLinuxElf::pack3() 为文件添加 loader，首先把对这个函数的关注暂时先放在脑后。接下来是对 pack2() 遗漏的文件的剩余部分进行压缩输出，随后写入一个 b_info 结构体。此时该结构体复用为 UPX 标志，在 sz_cpr 字段填入! UPX，其余字段清零

紧接着函数修改了输出文件中第一个 phdr 中 segment 的长度，添加了一个 lsize。不难猜出这个 lsize 为 loader 长度

对于共享库，函数遍历其每个 Phdr，当 segment 具有 PT_INTERP 属性时挪到最后，具有 PT_LOAD 属性时调整各项值为 loader 空出位置，具有 PT_DYNAMIC 重定位属性时修改 DT_INIT 项的值，使 DT_INIT 正确指向原先的. init 段地址，并清空 Ehdr 中关于 section 的数据，将原. init 段地址保存在 shoff 中

分析完子类的 pack3() 后将目光转向位于同一个源码文件下的 PackLinuxElf::pack3() 这个父类 pack3() 的主要工作是为输出文件补充和修正一些字段

这部分代码向输出文件中写入两个数值，第一个为输出文件中第一个 b_info 的偏移，第二个为截至目前为止的输出文件长度，该数值对于可执行文件来说即为 loader 偏移

p_lx_elf.cpp

void PackLinuxElf::pack3(OutputFile *fo, Filter &ft){

fo->write(&zero, t);

    len += t;

set_te32(&disp, 2*sizeof(disp) + len - (sz_elf_hdrs + sizeof(p_info) + sizeof(l_info)));

fo->write(&disp, sizeof(disp));  // .e_entry - &first_b_info

len += sizeof(disp);

set_te32(&disp, len);  // distance back to beginning (detect dynamic reloc)

fo->write(&disp, sizeof(disp));

len += sizeof(disp);

// 对于共享库文件，有三个额外的数值会被写入

if (xct_off) {  // is_shlib

   upx_uint64_t const firstpc_va = (jni_onload_va ? jni_onload_va : elf_unsigned_dynamic(Elf32_Dyn::DT_INIT) );

   set_te32(&disp, firstpc_va - load_va);

   fo->write(&disp, sizeof(disp));

   len += sizeof(disp);

   set_te32(&disp, hatch_off);

   fo->write(&disp, sizeof(disp));

   len += sizeof(disp);

   set_te32(&disp, xct_off);

   fo->write(&disp, sizeof(disp));

   len += sizeof(disp);

}

// 调用父类的 pack3() 添加 decompressor 解压缩器，即 UPX 的 loader，随后更新 l_info 结构体中的 size 字段, 父类 pack3()（如:void PackUnix::pack3(OutputFile *fo, Filter &/*ft*/)）

super::pack3(fo, ft);  // append the decompressor

}

unsigned xct_off;  // shared library: file offset of SHT_EXECINSTR

对于共享库文件，有三个额外的数值会被写入，分别是入口函数地址距第一个 PT_LOAD 段的偏移，意义未明的 hatch_off 和. init 段地址

p_unix.cpp（如下为父类 pack3()）

void PackUnix::pack3(OutputFile *fo, Filter &/*ft*/)

{

// 调用了位于 packer.cpp 的 Packer::getLoader()，通过 linker 获取了 loader 首字节

upx_byte *p = getLoader();

// 调用了位于同一个文件下的 Packer::getLoaderSize() 获取了 loader 长度

lsize = getLoaderSize();

// 调用位于 p_lx_elf.cpp 的 PackLinuxElf64::updateLoader 更新入口点

updateLoader(fo);

// 调用位于 p_unix.cpp 的 PackUnix::patchLoaderChecksum() 更新了 l_info 信息

patchLoaderChecksum();

// 最后将 loader 写入文件

    fo->write(p, lsize);

}

对于 pack3() 来说，x86 与 AMD64 除了 loader 外并无区别，ARM 的 PackLinuxElf32::ARM_updateLoader() 在入口点的设置上额外加上了_start 符号的偏移

p_lx_elf.cpp

void PackLinuxElf32::ARM_updateLoader(OutputFile * /*fo*/)

{

    set_te32(&elfout.ehdr.e_entry, sz_pack2 +

        linker->getSymbolOffset("_start") +

        get_te32(&elfout.phdr[0].p_vaddr));

}

p_lx_elf.cpp

void PackLinuxElf32::updateLoader(OutputFile * /*fo*/)

{

    set_te32(&elfout.ehdr.e_entry, sz_pack2 +

        get_te32(&elfout.phdr[0].p_vaddr));

}

p_lx_elf.cpp

void PackLinuxElf64::updateLoader(OutputFile * /*fo*/)

{

    set_te64(&elfout.ehdr.e_entry, sz_pack2 +

        get_te64(&elfout.phdr[0].p_vaddr));

}

p_lx_exc.cpp

void PackLinuxI386::updateLoader(OutputFile *fo)

{

    elfout.ehdr.e_entry = fo->getBytesWritten() + elfout.phdr[0].p_vaddr;

}

5．对 pack4() 的分析

pack() 的最后调用了 pack4() 对输出文件做最后的修补工作，调用了 checckFinalCompressionRadio() 检查压缩率

p_unix.cpp

void PackUnix::pack(OutputFile *fo)

{  

   pack1(fo, ft);  // generate Elf header, etc.

   fo->write(&hbuf, sizeof(hbuf));

      // append the compressed body

       if (pack2(fo, ft)) {

           // write block end marker (uncompressed size 0)

           b_info hdr; memset(&hdr, 0, sizeof(hdr));

           set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);

           fo->write(&hdr, sizeof(hdr));

       }

         pack3(fo, ft);  // append loader

       pack4(fo, ft);  // append PackHeader and overlay_offset; update Elf header

       // finally check the compression ratio

       if (!checkFinalCompressionRatio(fo))

           throwNotCompressible();

}

p_unix.cpp

void PackUnix::pack4(OutputFile *fo, Filter &)

{

// 调用了 writePackHeader()，然后写入了一个 overlay_offset。从子类的 pack4() 第一行代码得知 overlay_offset 为新的 Ehdr+Phdrs+l_info 的长度

    writePackHeader(fo);

    unsigned tmp;

    set_te32(&tmp, overlay_offset);

    fo->write(&tmp, sizeof(tmp));

}

p_lx_exc.cpp

void PackLinuxI386::pack4(OutputFile *fo, Filter &ft)

p_mach.cpp

void PackDylibAMD64::pack4(OutputFile *fo, Filter &ft)  // append PackHeader

p_lx_elf.cpp

void PackLinuxElf32::pack4(OutputFile *fo, Filter &ft)

void PackLinuxElf64::pack4(OutputFile *fo, Filter &ft){

overlay_offset = sz_elf_hdrs + sizeof(linfo);

// 当使用了 UPX 参数 --preserve-build-id 后保存在 pack1() 中赋值的数据

if (opt->o_unix.preserve_build_id) {

   fo->write(&shdrout, ssize);

   fo->write(o_shstrtab,shdrout.shdr[2].sh_size);

   fo->write(buildid_data,shdrout.shdr[1].sh_size);

}

// 重写了第一个 PT_LOAD 段的文件大小和内存映射大小，为了避免受到 SE Linux 的影响将两者设置为等同，随后调用了父类的 pack4() 增补数据 PackHeader 和 overlay_offset

set_te64(&elfout.phdr[0].p_filesz, sz_pack2 + lsize);

elfout.phdr[0].p_memsz = elfout.phdr[0].p_filesz;

super::pack4(fo, ft); // write PackHeader and overlay_offset

// 重写了 ELF 文件头，这部分代码用到的数据都已经在 pack2() 和 pack3() 中被修改完成了。注意到为了避免 SELinux 不允许内存页同时具有可写和可执行的限制，作者注释掉了一行修改段属性的代码

// rewrite Elf header

if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {

upx_uint64_t const base= get_te64(&elfout.phdr[0].p_vaddr);

set_te16(&elfout.ehdr.e_type, Elf64_Ehdr::ET_DYN);

set_te16(&elfout.ehdr.e_phnum, 1);

set_te64(&elfout.ehdr.e_entry,get_te64(&elfout.ehdr.e_entry) -  base);

set_te64(&elfout.phdr[0].p_vaddr, get_te64(&elfout.phdr[0].p_vaddr) - base);

set_te64(&elfout.phdr[0].p_paddr, get_te64(&elfout.phdr[0].p_paddr) - base);

// Strict SELinux (or PaX, grSecurity) disallows PF_W with PF_X

//elfout.phdr[0].p_flags |= Elf64_Phdr::PF_W;

}

if (0!=xct_off) {  // shared library

    fo->rewrite(&ehdri, sizeof(ehdri));

        fo->rewrite(phdri, e_phnum * sizeof(*phdri));

}else {

    if (Elf64_Phdr::PT_NOTE==get_te64(&elfout.phdr[2].p_type)) {

        upx_uint64_t const reloc = get_te64(&elfout.phdr[0].p_vaddr);

        set_te64(&elfout.phdr[2].p_vaddr,reloc + get_te64(&elfout.phdr[2].p_vaddr));

        set_te64(&elfout.phdr[2].p_paddr,reloc + get_te64(&elfout.phdr[2].p_paddr));

        fo->rewrite(&elfout, sz_elf_hdrs);

        // FIXME   fo->rewrite(&elfnote, sizeof(elfnote));

    }else {

        fo->rewrite(&elfout, sz_elf_hdrs);

}

    fo->rewrite(&linfo, sizeof(linfo));

}

}

p_unix.cpp

void PackUnix::pack4(OutputFile *fo, Filter &)

{

writePackHeader(fo);

}

p_unix.cpp

void PackUnix::writePackHeader(OutputFile *fo)

{

    unsigned char buf[32];

    memset(buf, 0, sizeof(buf));

// 函数初始化了一个长度为 buf[32] 的数组，调用在 try_pack() 中初始化的 PackHeader 的成员函数 getPackHeaderSize()，通过对版本和架构的判断给出这个 PackHeader 的长度，对于 Linux 来说该长度为 32

    const int hsize = ph.getPackHeaderSize();

    assert((unsigned)hsize <= sizeof(buf));

    // note: magic constants are always le32

    set_le32(buf+0, UPX_MAGIC_LE32);

    set_le32(buf+4, UPX_MAGIC2_LE32);

checkPatch(NULL, 0, 0, 0);  // reset

    patchPackHeader(buf, hsize);

    checkPatch(NULL, 0, 0, 0);  // reset

    fo->write(buf, hsize);

}

packmast.cpp

static Packer* try_pack(Packer *p, void *user){

p->assertPacker();

    try {

        p->initPackHeader();

        f->seek(0,SEEK_SET);

        if (p->canPack())

        {

            if (opt->cmd == CMD_COMPRESS)

                p->updatePackHeader();

            f->seek(0,SEEK_SET);

            return p;

        }

    }

}

packhead.cpp

int PackHeader::getPackHeaderSize() const {}

调用了位于 packer.cpp 的 Packer::patchPackHeader()，而该函数进行检查后最终调用了位于 packhead.cpp 的 PackHeader::putPackHeader() 对该数组进行数据填充

packer.cpp

int Packer::patchPackHeader(void *b, int blen){

checkPatch(b, blen, boff, size);

ph.putPackHeader(p);

}

packhead.cpp

void PackHeader::putPackHeader(upx_bytep p)

根据代码很容易整理出一个 Linux 通用的结构体

struct packHeader{

    uint32_t magic;

    uint8_t  version;

    uint8_t  format;

    uint8_t  method;

    uint8_t  level;

    uint32_t u_adler;

    uint32_t c_adler;

    uint32_t u_len;

    uint32_t c_len;

    uint32_t u_file_size;

    uint8_t  filter;

    uint8_t  filter_cto;

    uint8_t  n_mru;

    uint16_t checksum;

};

对于 ARM，PackLinuxElf32::pack4() 在重写结构时若文件中有 jni_onload，同样需要进行重写

p_lx_elf.cpp

void PackLinuxElf32::pack4(OutputFile *fo, Filter &ft)

6．Loader 的获取

loader 作为加壳后文件运行时的自解密代码，将追查 loader 的来源和构造流程

p_unix.cpp

void PackUnix::pack3(OutputFile *fo, Filter &/*ft*/)

{

// 调用了位于 packer.cpp 的 Packer::getLoader()，通过 linker 获取了 loader 首字节

upx_byte *p = getLoader();

// 调用了位于同一个文件下的 Packer::getLoaderSize() 获取了 loader 长度

lsize = getLoaderSize();

// 调用位于 p_lx_elf.cpp 的 PackLinuxElf64::updateLoader 更新入口点

updateLoader(fo);

// 调用位于 p_unix.cpp 的 PackUnix::patchLoaderChecksum() 更新了 l_info 信息

patchLoaderChecksum();

// 最后将 loader 写入文件

    fo->write(p, lsize);

}

packer.cpp

upx_byte *Packer::getLoader() const

{

   upx_byte *oloader = linker->getLoader(&size);

}

linker.cpp

upx_byte *ElfLinker::getLoader(int *llen) const {

    if (llen)

        *llen = outputlen;

    return output;

}

linker.cpp

int ElfLinker::addLoader(const char *sname) {

// 对 output 进行赋值的函数

// 关注点应该在于对 addLoader() 的调用和对 Section 这个结构体的赋值

}

在 pack2() 的 packExtent() 中，函数针对可执行的 PT_LOAD 段调用了 compressWithFilters() 进行压缩，在 compressWithFilters() 的末尾有这么一行函数调用 buildLoader(&best_ft); 函数名已经告诉了这个函数想干嘛，并且 pack() 函数只有在此处 compressWithFilters() 会被激活，显然这里就是唯一一个生成 loader 的地方。更深入地挖掘。对于 AMD 64，其实现为 p_lx_elf.cpp 中的 PackLinuxElf64amd::buildLoader()

p_unix.cpp

int PackLinuxElf64::pack2(OutputFile *fo, Filter &ft){

   packExtent(x, total_in, total_out,((0==nx && (Elf64_Phdr::PF_X & get_te64(&phdri[k].p_flags))) ? &ft : 0 ), fo, hdr_u_len);

}

p_unix.cpp

int PackUnix::pack2(OutputFile *fo, Filter &ft)

{

   while (remaining> 0)

    {

      unsigned const end_u_adler = upx_adler32(ibuf, ph.u_len, ph.u_adler);

        compressWithFilters(&ft,OVERHEAD,NULL_cconf, filter_strategy,!!n_block++);  // check compression ratio only on first block

   }

}

packer.cpp

void Packer::compressWithFilters(Filter *ft,

                                 const unsigned overlap_range,

                                 const upx_compress_config_t *cconf,

                                 int filter_strategy,

                                 int inhibit_compression_check)

{

    compressWithFilters(ft, overlap_range, cconf, filter_strategy,

                        0, 0, 0, NULL, 0, inhibit_compression_check);

}

packer.cpp

void Packer::compressWithFilters(Filter *ft,

                                 const unsigned overlap_range,

                                 const upx_compress_config_t *cconf,

                                 int filter_strategy,

                                 unsigned filter_off,

                                 unsigned ibuf_off,

                                 unsigned obuf_off,

                                 const upx_bytep hdr_ptr, unsigned hdr_len,

                                 int inhibit_compression_check)

{

    ibuf.checkState(); obuf.checkState();

    compressWithFilters(i_ptr, i_len,

                        o_ptr,

                        f_ptr, f_len,

                        hdr_ptr, hdr_len,

                        ft, overlap_range, cconf, filter_strategy,

                        inhibit_compression_check);

    ibuf.checkState(); obuf.checkState();  

}

packer.cpp

void Packer::compressWithFilters(upx_bytep i_ptr, unsigned i_len,

                                 upx_bytep o_ptr,

                                 upx_bytep f_ptr, unsigned f_len,

                                 const upx_bytep hdr_ptr, unsigned hdr_len,

                                 Filter *parm_ft,

                                 const unsigned overlap_range,

                                 const upx_compress_config_t *cconf,

                                 int filter_strategy,

                                 int inhibit_compression_check)

{

    buildLoader(&best_ft);

}

p_mach.cpp

templatevoid PackMachBase::buildLoader(const Filter *ft)

{

    buildMachLoader(stub_entry, sz_stub_entry, stub_fold, sz_stub_fold, ft);

}  

p_mach.cpp

templatevoid PackMachBase::buildMachLoader(

    upx_byte const *const proto,

    unsigned        const szproto,

    upx_byte const *const fold,

    unsigned        const szfold,

    Filter const *ft

)

{

    initLoader(proto, szproto);

    int r = upx_compress(uncLoader, h.sz_unc, sizeof(h) + cprLoader, &sz_cpr, NULL, ph.method, 10, NULL, NULL );

    linker->addSection("FOLDEXEC", cprLoader, sizeof(h) + h.sz_cpr, 0);

    addStubEntrySections(ft);

    defineSymbols(ft);

    relocateLoader();

}

p_lx_elf.cpp

void PackLinuxElf32x86::buildLoader(const Filter *ft)

void PackLinuxElf64amd::buildLoader(const Filter *ft)

{

    if (0!=xct_off) {  // shared library

        buildLinuxLoader(stub_amd64_linux_shlib_init,                         sizeof(stub_amd64_linux_shlib_init), NULL, 0, ft);

        return;

    }

    buildLinuxLoader(

        stub_amd64_linux_elf_entry, sizeof(stub_amd64_linux_elf_entry),

        stub_amd64_linux_elf_fold,  sizeof(stub_amd64_linux_elf_fold), ft);

}

p_lx_elf.cpp

void PackLinuxElf32::buildLinuxLoader(

    upx_byte const *const proto,

    unsigned        const szproto,

    upx_byte const *const fold,

    unsigned        const szfold,

    Filter const *ft

)

p_lx_elf.cpp

void PackLinuxElf64::buildLinuxLoader(

    upx_byte const *const proto,

    unsigned        const szproto,

    upx_byte const *const fold,

    unsigned        const szfold,

    Filter const *ft

){

// 函数开头调用了 initLoader()，对于共享库，传入的参数为 shlib_init，对于可执行文件，参数为 elf_entry，Packer::initLoader() 位于 packer.cpp 初始化了一个 linker，调用了位于 linker.cpp 中的 ELFLinker::init()

initLoader(proto, szproto);

int r = upx_compress(uncLoader, h.sz_unc, sizeof(h) + cprLoader, &h.sz_cpr, NULL, ph.method, 10, NULL, NULL );

// 由于共享库不会传入 fold 和 szfold 参数，这个 if 语句块只对可执行文件有效。这个语句块从 elf_fold 中提取了 ehdr+phdrs+l_info 之后的所有内容进行压缩，并在压缩数据块头部补上一个 b_info 结构体，最后放在名为 FOLDEXEC 的 Section 内

if (0 < szfold) {

   linker->addSection("FOLDEXEC", cprLoader, sizeof(h) + sz_cpr, 0);

   delete [] cprLoader;

}else {

   linker->addSection("FOLDEXEC", "", 0, 0);

}

// 调用了 addStubEntrySections() 把 sections 添加到 linker->output 中，等待 pack3() 写入文件

    addStubEntrySections(ft);

// 当文件为可执行文件时调用 defineSymbols() 修改 symbols，最后重定位 loader

if (0==xct_off)  

    defineSymbols(ft);  // main program only, not for shared lib

relocateLoader();   // 调用 relocateLoader() 重定位 loader

}

packer.cpp

void Packer::initLoader(const void *pdata, int plen, int small)

{

    delete linker;

    linker = newLinker();

    assert(bele == linker->bele);

    linker->init(pdata, plen);

    unsigned size;

    char const * const ident = getIdentstr(&size, small);

    linker->addSection("IDENTSTR", ident, size, 0);

}

p_lx_elf.cpp

void PackLinuxElf64amd::defineSymbols(Filter const *)

linker.cpp 中的 ELFLinker::init() 函数通过检测读入内容的标志位判断加壳还是脱壳，如果是加壳则初始化 output，最后将全部 sections,symbols 和 relocations（重定位）读入内存

linker.cpp

void ElfLinker::init(const void *pdata_v, int plen) {

const upx_byte *pdata = (const upx_byte *) pdata_v;

if (plen>= 16 && memcmp(pdata, "UPX#", 4) == 0) {

   inputlen = u_len;

    input = new upx_byte[inputlen + 1];

    unsigned new_len = u_len;

    int r = upx_decompress(pdata, c_len, input, &new_len, method, NULL);

}else {

    inputlen = plen;

    input = new upx_byte[inputlen + 1];

}

input[inputlen] = 0; // NUL terminate

output = new upx_byte[inputlen ? inputlen : 0x4000];  

outputlen = 0;

if ((int) strlen("Sections:\n"

                     "SYMBOL TABLE:\n"

                     "RELOCATION RECORDS FOR") <inputlen) {

int pos = find(input, inputlen, "Sections:\n", 10);

preprocessSections(psections, psymbols);

preprocessSymbols(psymbols, prelocs);

preprocessRelocations(prelocs, (char *) input + inputlen);

addLoader("*UND*");

}

}

7．loader 的拼接

addStubEntrySections 函数通过标志位和某些 sections 是否存在将 sections 拼接到 output 中，分析函数流程发现其添加顺序，除了 IDENTSTR 和位于 stub_amd64_linux_elf_fold 的内容，其余 sections 的顺序和在加壳后样本头部找到的 sections 块和顺序完全一致

p_lx_elf.cpp

void PackLinuxElf::addStubEntrySections(Filter const *)

{

   addLoader(

           (M_IS_NRV2E(ph.method) ? "NRV_HEAD,NRV2E,NRV_TAIL"

           : M_IS_NRV2D(ph.method) ? "NRV_HEAD,NRV2D,NRV_TAIL"

           : M_IS_NRV2B(ph.method) ? "NRV_HEAD,NRV2B,NRV_TAIL"

           : M_IS_LZMA(ph.method)  ? "LZMA_ELF00,+80C,LZMA_DEC20,LZMA_DEC30"

           : NULL), NULL);

   addLoader("ELFMAINY,IDENTSTR,+40,ELFMAINZ", NULL);

   addLoader("FOLDEXEC", NULL);

}

8．UPX 源码的核心头文件

1)/upx-3.93-src/src/stub/src/include/bsd.h

2)/upx-3.93-src/src/p_mach_enum.h

3)/upx-3.93-src/src/p_elf_enum.h

4)/upx-3.93-src/src/p_vmlinx.h

5)/upx-3.93-src/src/p_lx_elf.h

6)/upx-3.93-src/src/p_vmlinz.h

7)/upx-3.93-src/src/p_lx_sh.h

8)/upx-3.93-src/src/p_lx_exc.h

9)/upx-3.93-src/src/version.h

10)/upx-3.93-src/src/options.h

11)/upx-3.93-src/src/packmast.h

12)/upx-3.93-src/src/p_unix.h

13)/upx-3.93-src/src/p_mach.h

14)/upx-3.93-src/src/packer.h

15)/upx-3.93-src/src/linker.h

16)/upx-3.93-src/src/except.h

17)/upx-3.93-src/src/pefile.h

18)/upx-3.93-src/src/p_sys.h

19)/upx-3.93-src/src/p_exe.h

20)/upx-3.93-src/src/p_elf.h

21)/upx-3.93-src/src/p_com.h

22)/upx-3.93-src/src/mem.h

23)/upx-3.93-src/src/ui.h

9．参考文献

UPX 源码分析——加壳篇

https://my.oschina.net/ichunqiu/blog/844660

UPX 源码分析——加壳篇

http://bbs.ichunqiu.com/thread-19345-1-1.html

在 Android so 文件的. init、.init_array 上和 JNI_OnLoad 处下断点

http://blog.csdn.net/qq1084283172/article/details/54233552

ubuntu14.04 x86 编译 upx 3.92 及 so 加固

http://www.cnblogs.com/Reverser/p/5778042.html

Android SO（动态链接库）UPX 加固指南

http://blog.csdn.net/s1986q/article/details/54895022

杯具的 Android 版 UPX 移植笔记

https://www.douban.com/note/52154228/

Android NDK UPX 加固

http://blog.csdn.net/s1986q/article/details/55001594

UPX 为 APK 加壳中. init 段相关问题

http://blog.csdn.net/dalerkd/article/details/50603474

Android arm upx 交叉编译过程

http://blog.csdn.net/s1986q/article/details/54894947

Android so UPX 加壳

http://www.th7.cn/Program/Android/201606/885235.shtml

ubuntu14.04 x86 编译 upx 3.92 及 so 加固

http://www.mamicode.com/info-detail-1486853.html

Android SO（动态链接库）UPX 加固指南

http://blog.csdn.net/s1986q/article/details/54895022

Android SO 加壳 (加密) 与脱壳思路

http://blog.csdn.net/beyond702/article/details/53786662

UPX 为 APK 加壳中. init 段相关问题

https://my.oschina.net/rkd/blog/661043

UPX 为 APK 加壳中. init 段相关问题

https://my.oschina.net/rkd/blog/613958

10．技术文档

1)UPX 源码分析——加壳篇. pdf

2)Android SO（ 动态链接库） UPX 加固指南. pdf

3)Android so 加载深入分析. pdf

4)Android Linker 与 SO 加壳技术. pdf

5)linkers and loaders - 中文版. pdf

6)Android Oat Foramte 分析笔记. pdf

7)ELF 文件格式解析. pdf

8)ELF 文件的代码注入研究及其应用. pdf

9)ELF Linker 学习篇（一）关于 ELF 文件装载进内存. pdf

10)ELF Linker 学习篇（二）关于分配 soinfo 结构. pdf

11)ELF Linker 学习篇（三）关于链接过程. pdf

12)ELF Linker 学习篇（四）——初始化. pdf

13) 在 Android so 文件的. init、 .init_array 上和 JNI_OnLoad 处下断点. pdf

14)Android SO 文件保护加固——加密篇（一）.pdf

15)Android SO 文件保护加固——加密篇（二）.pdf

16)Android SO 文件保护加固——混淆篇（一）.pdf

17) 常见 App 加固厂商脱壳方法研究. pdf

18)Anti-Debugging Skills In APK.pdf

19) 调试器工作原理（1）：基础篇. pdf

20) 调试器工作原理（2）：实现断点. pdf

21) 调试器工作原理（3）：调试信息. pdf

22)Android 虚拟机调试器原理与实现. pdf

23)Android 程序的反编译对抗研究. pdf

24)Android 逃逸技术汇编. pdf

25)linker 阅读笔记一. pdf

五、Android N 的限制（Android 7.0 以上版本 so 的兼容性问题）

1.classloader-namespace 问题

W/System.err: java.lang.UnsatisfiedLinkError: dlopen failed: library

"/data/user/0/com.xxx.yyy/files/storage/com.aaa.bbb/version.1/lib/libxxx.s   o" is not accessible for the namespace "classloader-namespace"

①　Java 的代码在执行 System.load(...) 时，系统会检查代码所属的 ClassLoader 是否有该 so 路径的加载权限。ClassLoader 能加载 so 的路径，在 ClassLoader 构造的时候就已经指定了

②　如果你直接 new 出 DexClassLoader 去执行 System.load(...)，加载你指定路径里面的 so 不存在任何问题

③　但是如果你自己实现一个 ClassLoader，该 ClassLoader 的 findClass 再转给其他 ClassLoader 就会出现这个 classloader-namespace 的问题

2.Elf Section Header 完整性问题

1)E/linker: "/data/app/opt.game.talent-1/lib/arm/libiohook.so" .dynamic

section header was not found

E/IOHook: java.lang.UnsatisfiedLinkError: dlopen failed:

"/data/app/opt.game.talent-1/lib/arm/libiohook.so" .dynamic section header was not found

2)E/linker: "/data/app/opt.game.talent_gl-1/lib/arm/libiohook.so" has no section headers

E/IOHook: java.lang.UnsatisfiedLinkError: dlopen failed:

"/data/app/opt.game.talent_gl-1/lib/arm/libiohook.so" has no section headers

3)E/linker: "/data/app/opt.game.talent_gl-1/lib/arm/libiohook.so" has invalid shdr offset/size: 132216/1040

E/IOHook: java.lang.UnsatisfiedLinkError: dlopen failed:

"/data/app/opt.game.talent_gl-1/lib/arm/libiohook.so" has invalid shdr offset/size: 132216/1040

备注: 具有无效的 shdr 偏移 / 大小

①　Android N 之前 so 的加载只需要 ELF 头的 program header，对 section header 则完全无视。但新的 linker 现在开始改变规则了

②　普通的开发者对于自己编译出的 so 完全不用担心兼容性问题。但对于使用第三方 SDK 就要小心了

③　Android NDK 编译出来的 so，ELF section header 和 program header 都是完整的。但一些聪明的家伙发现修改 section header 或者抹去 section header 不会影响 so 的加载，还能起到保护 so 的目的 (其实很有限)

④　修改 section header 的好处是增加 so 逆向的难度，一个具体的例子：把 so 拖进 IDA 的时候直接报错退出

3. 解决方法

1) 修改如下路径的 upx 源码

/upx-3.93-src/src/p_lx_elf.cpp

原程序:

void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft) {

ehdri.e_shnum = 0;

ehdri.e_shoff = old_dtinit;  // easy to find for unpacking

ehdri.e_shoff = 0;

ehdri.e_shentsize = 0;

ehdri.e_shstrndx = 0;

}

修改后的程序:

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFrJcymJV9JhBgbu5y1alTO1YEGRjxBTdB7M0VR8fNS1Zib661BnW3D9w/640?wx_fmt=png)

原程序:

void PackLinuxElf64::pack3(OutputFile *fo, Filter &ft) {

ehdri.e_shnum = 0;

ehdri.e_shoff = old_dtinit;  // easy to find for unpacking

//ehdri.e_shentsize = 0;

//ehdri.e_shstrndx = 0;

}

修改后的程序:

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFZ98PYdicZIKlj53X4tu1nbqS2mCxaFHhMHs9ibqtD7A4spDibQK4aDLicA/640?wx_fmt=png)

编译 upx 源码，采用 upx.out 加壳 Android so 后运行 apk 报如下错误:

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFspO3z3kPg8SWrJ4nialibibLRGkKZcicD85rhOJqTO5AgfThQpXiaXEicn0g/640?wx_fmt=png)

2)upx 源码分析

/upx-3.93-src/src/p_lx_elf.cpp

void PackLinuxElf32::pack1(OutputFile *fo, Filter & /*ft*/)

{

    // if the preserve build-id option was specified

    if (opt->o_unix.preserve_build_id) {

        Elf32_Shdr *shdr = NULL;

        Elf32_Shdr const *tmp = shdri;

        if (! shdri) {

            shdr = New(Elf32_Shdr, e_shnum);

            fi->seek(0,SEEK_SET);

            fi->seek(ehdri.e_shoff,SEEK_SET);

            fi->readx((void*)shdr,ehdri.e_shentsize*ehdri.e_shnum);

            // set this so we can use elf_find_section_name

            shdri = (Elf32_Shdr *)shdr;

        }

        //set the shstrtab

        sec_strndx = &shdri[ehdri.e_shstrndx];

        char *strtab = New(char, sec_strndx->sh_size);

        fi->seek(0,SEEK_SET);

        fi->seek(sec_strndx->sh_offset,SEEK_SET);

        fi->readx(strtab,sec_strndx->sh_size);

        shstrtab = (const char*)strtab;

Elf32_Shdr const *buildid = elf_find_section_name(".note.gnu.build-id");

        if (buildid) {

            unsigned char *data = New(unsigned char, buildid->sh_size);

            memset(data,0,buildid->sh_size);

            fi->seek(0,SEEK_SET);

            fi->seek(buildid->sh_offset,SEEK_SET);

            fi->readx(data,buildid->sh_size);

            shdrout.shdr[2].sh_size = 29; //size of our static shstrtab

        }

        // repoint shdr in case it is used by code some where else

        if (shdr) {

            shdri = tmp;

            delete [] shdr;

            shdr = NULL;

            sec_strndx = NULL;

        }

    }

}

/upx-3.93-src/src/p_lx_elf.cpp

void PackLinuxElf64::pack1(OutputFile *fo, Filter & /*ft*/)

{

    // only execute if option present

    if (opt->o_unix.preserve_build_id) {

        // set this so we can use elf_find_section_name

        e_shnum = ehdri.e_shnum;

        // there is a class member similar to this, but I did not

        // want to assume it would be available

        Elf64_Shdr const *tmp = shdri;

        Elf64_Shdr *shdr = NULL;

        if (! shdri) {

            shdr = New(Elf64_Shdr, e_shnum);

            fi->seek(0,SEEK_SET);

            fi->seek(ehdri.e_shoff,SEEK_SET);

            fi->readx((void*)shdr,ehdri.e_shentsize*ehdri.e_shnum);

            // set this so we can use elf_find_section_name

            shdri = (Elf64_Shdr *)shdr;

        }

Elf64_Shdr const *buildid = elf_find_section_name(".note.gnu.build-id");

        if (buildid) {

            unsigned char *data = New(unsigned char, buildid->sh_size);

            memset(data,0,buildid->sh_size);

        }

        if (shdr) {

            shdri = tmp;

            delete [] shdr;

            shdr = NULL;

        }

    }

}

/upx-3.93-src/src/p_lx_elf.cpp

Elf32_Shdr const *PackLinuxElf32::elf_find_section_name(char const *const name) const

{

    Elf32_Shdr const *shdr = shdri;

    int j = e_shnum;

    for (; 0 <=--j; ++shdr) {

        if (0==strcmp(name, &shstrtab[get_te32(&shdr->sh_name)])) {

            return shdr;

        }

    }

    return 0;

}

/upx-3.93-src/src/p_lx_elf.cpp

Elf64_Shdr const *PackLinuxElf64::elf_find_section_name(char const *const name) const

{

    Elf64_Shdr const *shdr = shdri;

    int j = e_shnum;

    for (; 0 <=--j; ++shdr) {

        unsigned ndx = get_te64(&shdr->sh_name);

        if (0==strcmp(name, &shstrtab[ndx])) {

            return shdr;

        }

    }

    return 0;

}

/upx-3.93-src/src/p_lx_elf.cpp

Elf32_Shdr const *PackLinuxElf32::elf_find_section_type(unsigned const type) const

{

    Elf32_Shdr const *shdr = shdri;

    int j = e_shnum;

    for (; 0 <=--j; ++shdr) {

        if (type==get_te32(&shdr->sh_type)) {

            return shdr;

        }

    }

    return 0;

}

/upx-3.93-src/src/p_lx_elf.cpp

Elf64_Shdr const *PackLinuxElf64::elf_find_section_type(unsigned const type) const

{

    Elf64_Shdr const *shdr = shdri;

    int j = e_shnum;

    for (; 0 <=--j; ++shdr) {

        if (type==get_te32(&shdr->sh_type)) {

            return shdr;

        }

    }

    return 0;

}

六、UPX 脱壳全过程分析

1．先初始化

1) 保存现场

2) 寄存器入栈

3)ESI 指向 UPX1 区段

4) 指向要还原的首地址 UPX0 区段

5) 首地址入栈

6) 初始化 EBP

7)EBP 用来判断第二次循环还原方式

8) 初始化完毕

2．进行代码还原

1)UPX 壳进行代码还原，还原的方式分为两种

①　一种是 UPX 壳无法压缩的代码，UPX 老老实实的从 UPX1 区段将代码还原到 UPX0 区段

②　另一种就是 UPX0 中的重复指令，UPX 壳根据 UPX1 中的 KEY 值找到 UPX0 中重复指令的位置，再进行的代码还原

2) 具体过程如下:

①　依次取 UPX1 区段的数据进行还原

②　指向下一个要还原的数据

③　还原数据

3．进行 CALL 修复

1) 在还原代码时，CALL 后面的四个字节标志了 CALL 地址 KEY，通过上面的 CALL 算法将 KEY 还原成正确地址

4．进行函数表还原

1) 获取函数表还原基地址

2) 获取函数表还原偏移

3) 函数表还原完了进入下一个模块的跳转

4) 获取函数存放位置偏移

5) 获取函数所在 DLL 名称

6) 载入 DLL 到内存

7) 还原 DLL 后进入下一个 DLL 的还原跳转

8) 获取函数所在地址

9) 进行函数表地址还原

10) 循环还原函数表

5．节表初始化

1) 指向 VirtualProtect 函数地址

2) 指向文件头位置

3) 文件头大小

4)PAGE_EXECUTE_READWRITE

5) 使用 VirtualProtect 把文件头设置为 PAGE_EXECUTE_READWRITE，获得文件头的写权限

6) 完成节表的初始化

7) 用 VirtualProtect 恢复文件头属性

6．解码完毕飞向程序入口

7．IDA Pro 逆向工具常用快捷键

1) 使用 IDA Pro 定位关键代码的方法

①　搜索特征字符串，具体操作如下所示:

a. 快捷键 Ctrl+S，打开搜索类型选择对话框 --> 双击 Strings，跳到字符串段 --> 菜单项 “Search-->Text”

b. 快捷键 Alt+T，打开文本搜索对话框，在 String 文本框中输入要搜索的字符串点击 OK 即可

②　Tab 查看函数

③　Ctrl+1、spance

④　Alt+Q

⑤　Alt+S

⑥　G 转到一个 Jump Address

⑦　Create function-->P

⑧　Data-->D

⑨　Alt+G、寄存器 arm 与 thumb 转换

⑩　X--> 追踪某函数

11　F5--> 刷新

12　C--> 转成代码 -->N--> 重命名函数, 多看汇编, 少看伪代码

13　H-->16 进制转换

14　A--> 生成一个字符串

15　U--> 转成原数据, 重新定义数组长度

8．参考文献

1)UPX 脱壳全过程分析

http://bbs.awuming.com/simple/?t82674.html

2) 在 Android so 文件的. init、.init_array 上和 JNI_OnLoad 处下断点

http://blog.csdn.net/qq1084283172/article/details/54233552

七、附图

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFKmDOEn3hYKh16G5rUUEZQBD0F7vP8YicWGICIDKgLs3ib4LqkcQKPTUg/640?wx_fmt=png)

图一: Linux ELF 通用的 UPX 加壳文件格式，分为可执行文件和共享库

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNF2wBibINibwxsmyHCVRuB74BCrqqmA63gcSHmv7AiaFzdg6lsNE9BQRq0w/640?wx_fmt=png)

图二: Linux ELF 通用的 UPX 加壳文件格式，分为可执行文件和共享库

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFCxaGjVBECWZhGCxhgBnu1DzLRmrIsicwJDWWkOVqcr9mvcuDGRfVNyA/640?wx_fmt=png)

图三: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFwtVncQLAo7tx2zBcZMoqxjDKg5xrDpS8KydwcPOUPWYGHnuPL9OpKQ/640?wx_fmt=png)

图四: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFBNcSq9CsYzZ5FlJ9yuXQPSGVWrI4V6IsvszhibW7j5U8uX4FKXiaR2og/640?wx_fmt=png)

图五: ELF 共享库 (shared library) 被 UPX 加壳后的文件格式

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFicd4J6fGDrVRmAJKWkIBr83UVkCYNcDHB2mNgpVPz6tC5ib5r0xh6UtQ/640?wx_fmt=png)

图六: UPX 解析

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFIWD802kaRY4rn8VTdTefZrO1w7BicAxy1DwdClaVWb7Dnb72sthSpIg/640?wx_fmt=png)

图七: Android OAT 文件结构

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFhJrH4XBdu36HL3V6QW1MjmA3icuVCKM6jtbIj2G0RKQ3boakibIfibiaHg/640?wx_fmt=png)

图八: Android Oat Format

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFBUrO50Gcs59NBRz37xJCMznlUmASE67Amia5QvMaicodianpfJNG7xeicg/640?wx_fmt=png)

图九: Android ELF 文件格式

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNF0IzFHibIBF30OMsPsZZIzK7TiaiahfqHOHlxg19hzTQN90CBwXeicmHAIQ/640?wx_fmt=png)

图十: Smali 代码注入总体流程图

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFpbJ5HNYjjrbSVHLricelfMylbVG67iay4IyvT26QLVEtBND62mSf7R4Q/640?wx_fmt=png)

图十一: Android 系统启动架构图

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFjibibkcfajLxZtdOrEfFATMicuXIEiaZA0O4CINgjZSZDeiapxAenSpIcicw/640?wx_fmt=png)

图十二: Android 的壳模型（一）

![](https://mmbiz.qpic.cn/mmbiz_png/LtmuVIq6tF0IMKFcH1XWxvRsu5wVDNNFkzEbC7pjt8GbznibWux2EdZrwG7VUVhl353ObZkMPT9uHat0VmOkqBA/640?wx_fmt=png)