<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/1Fqb0j_gsm-eHF1uOwVgBw)

本文主要记述了 CGI 的含义，以及常见网络设备中使用的 CGI 框架与流程，最后通过 DLINK 和 Netgear 两款路由器的 CGI 漏洞介绍当前常见的 CGI 漏洞挖掘和分析流程。

### CGI 是什么

到目前为止，实现动态 Web 页面有 4 种技术可供选择：CGI，ASP，PHP 和 JSP。本节记述关于路由器 CGI 相关知识。

早期的 Web 服务器，只能响应浏览器发来的 HTTP 静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着 Web 技术的发展，逐渐出现了动态技术，但是 Web 服务器并不能够直接运行动态脚本，为了解决 Web 服务器与外部应用程序（CGI 程序）之间数据互通，于是出现了 CGI（Common Gateway Interface）通用网关接口。简单理解，可以认为 CGI 是 Web 服务器和运行其上的应用程序进行 “交流” 的一种约定。  
CGI 不是一门编程语言。它是网页的表单和你写的程序之间通信的一种协议。可以用任何语言写一个 CGI 脚本，这些语言只要能接收输入输出信息，读取环境变量。所以，几乎所有的编程语言都能写一个 CGI 脚本，例如：python ，C，甚至是 shell 脚本。

典型的 CGI 脚本做了如下的事情：

*   读取用户提交表单的信息
    
*   处理这些信息
    
*   输出，返回 html 响应
    

### 设备 CGI 分析

目前 IOT 设备主要有三个 WebServer：httpd，thttpd 和 Boa。httpd 是最简单的一个 Web Server，它的功能最弱，不支持认证，不支持 CGI。Thttpd 和 Boa 都支持认证、CGI 等，功能都比较全。

### Boa

Boa 是一个单任务的 http 服务器，源代码开放、性能高。Boa 是一个单任务 HTTP 服务器。这意味着与传统的 Web 服务器不同，它不会为每个传入的连接 fork，也不会 fork 自身的许多副本来处理多个连接。它在内部多路复用所有正在进行的 HTTP 连接，并且只为 CGI 程序（必须是单独的进程）、自动目录生成和自动文件压缩进行 fork。

#### 源码分析

在 Boa 官网下载源码。  
Boa 首先会调用 process_option_Iine() 将一些头部信息填写到 request 结构中完成这些环境变量的设置，随后 process_header_end() 会对用户进行验证。如果验证通过则判断 request 结构中的 is_cgi，非 0 则是 CGI 程序，调用 init_cgi() 函数进行处理，为 0 则是静态页面，调用 init_get() 函数进行处理。

**init_cgi**  
boa 程序在解析请求头的收尾函数 process_header_end 中，translate_uri 函数会解析请求的虚拟路径.

```
* Name: init_cgi * * Description: Called for GET/POST requests that refer to ScriptAlias * directories or application/x-httpd-cgi files.  Ties stdout to socket, * stdin to data if POST, and execs CGI. * stderr remains tied to our log file; is this good? * * Returns: * 0 - error or NPH, either way the socket is closed * 1 - success
```

init_cgi 首先通过调用 create_common_env()，complete_env() 完成对 CGI 环境变量的设置

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7sOVaUeQTgAETcKExv2wA3oHghyfkRMu2hFhVYuoG2oUWBE4I5PWnPw/640?wx_fmt=png)PS3GPD

translate_uri 函数中的 init_script_alias 函数，负责解析 ScriptAlias 请求，设置请求 cgi 类型，查看文件是否存在以及具有相关权限。  
然后 CGI 会 execve 执行相应的程序。

```
if (req->cgi_type) {            char *aargv[CGI_ARGC_MAX + 1];            create_argv(req, aargv);            execve(req->pathname, aargv, req->cgi_env);        } else {            if (req->pathname[strlen(req->pathname) - 1] == '/')                execl(dirmaker, dirmaker, req->pathname, req->request_uri,                      (void *) NULL);
```

#### 固件分析

这里分析 vivetok 摄像头固件，该摄像头的 web 是基于 Boa 进行二次开发的。

##### uhttpd

uHTTPd 作为 OpenWrt 中默认的 HTTP 服务器，主要是用来配合 LuCI Web 接口方便 OpenWrt 设备的管理，luci 就是一个网页界面，包含 openwrt 配置页面。以 cgi 的方式被 web 服务器调用并渲染页面，语言采用 lua，支持 CGI、Lua 和 UBUS 完成对请求的处理。在 IoT 设备上使用 OpenWrt 比较常见的情况是，结合 uhttpd 使用 LuCI 框架编写 lua 处理脚本。

#### 源码分析

下载 uhttpd 源代码  
首先在 uh_handle_request 中解析接收到的请求头

```
void uh_handle_request(struct client *cl){    struct http_request *req = &cl->request;    struct dispatch_handler *d;    char *url = blobmsg_data(blob_data(cl->hdr.head));    char *error_handler, *escaped_url;    blob_buf_init(&cl->hdr_response, 0);    url = uh_handle_alias(url);    uh_handler_run(cl, &url, false);    if (!url)        return;    req->redirect_status = 200;    d = dispatch_find(url, NULL);    if (d)        return uh_invoke_handler(cl, d, url, NULL);    if (__handle_file_request(cl, url))        return;    if (uh_handler_run(cl, &url, true)) {        if (!url)            return;        uh_handler_run(cl, &url, false);        if (__handle_file_request(cl, url))            return;    }    req->redirect_status = 404;    if (conf.error_handler) {        error_handler = alloca(strlen(conf.error_handler) + 1);        strcpy(error_handler, conf.error_handler);        if (__handle_file_request(cl, error_handler))            return;    }    escaped_url = uh_htmlescape(url);    uh_client_error(cl, 404, "Not Found", "The requested URL %s was not found on this server.",                    escaped_url ? escaped_url : "");    if (escaped_url)        free(escaped_url);}
```

使用 dispatch_find 函数根据请求的 url 找到合适的 dispatch_handler,cgi_prefix 在 / etc/config/uhttpd 配置文件中的默认值为 / cgi-bin，并且程序在 main 函数中默认添加了 cgi_dispatch, 当请求的 url 通过 check_cgi_path 函数校验，则会调用 cgi_handle_request 函数回调 cgi_main 函数 execl 执行对应的 CGI 程序

```
static void cgi_handle_request(struct client *cl, char *url, struct path_info *pi){    unsigned int mode = S_IFREG | S_IXOTH;    char *escaped_url;    if (!pi->ip && !((pi->stat.st_mode & mode) == mode)) {        escaped_url = uh_htmlescape(url);        uh_client_error(cl, 403, "Forbidden",                "You don't have permission to access %s on this server.",                escaped_url ? escaped_url : "the url");        if (escaped_url)            free(escaped_url);        return;    }    if (!uh_create_process(cl, pi, url, cgi_main)) {        uh_client_error(cl, 500, "Internal Server Error",                "Failed to create CGI process: %s", strerror(errno));        return;    }    return;}struct dispatch_handler cgi_dispatch = {    .script = true,    .check_path = check_cgi_path,    .handle_request = cgi_handle_request,};
```

执行 CGI 程序：

```
static void cgi_main(struct client *cl, struct path_info *pi, char *url){    const struct interpreter *ip = pi->ip;    struct env_var *var;    clearenv();    setenv("PATH", conf.cgi_path, 1);    for (var = uh_get_process_vars(cl, pi); var->name; var++) {        if (!var->value)            continue;        setenv(var->name, var->value, 1);    }    if (!chdir(pi->root)) {        if (ip)            execl(ip->path, ip->path, pi->phys, NULL);        else            execl(pi->phys, pi->phys, NULL);    }    printf("Status: 500 Internal Server Error\r\n\r\n"           "Unable to launch the requested CGI program:\n"           "  %s: %s\n", ip ? ip->path : pi->phys, strerror(errno));}
```

### CGI 漏洞

#### D-LINK SERVICE.CGI 远程命令执行漏洞

2018 年 1 月 17 日，CNVD 公开了 D-LinkDIR 615/645/815 service.cgi 远程命令执行漏洞（CNVD-2018-01084）。

D-Link DIR 615/645/815 路由器 1.03 及之前的固件版本存在远程命令执行漏洞。该漏洞是由于 service.cgi 中拼接了 HTTP POST 请求中的数据，造成后台命令拼接，导致可执行任意命令。

下载固件

先解压，再使用 binwalk 分析固件

```
$ unzip DIR-645_FIRMWARE_1.03.ZIP  Archive:  DIR-645_FIRMWARE_1.03.ZIP  inflating: dir645_FW_103.bin       $ binwalk -Me dir645_FW_103.bin Scan Time:     2021-08-12 23:03:41MD5 Checksum:  12a10a6a2fe96e0b7a50c2babd714e3dSignatures:    410DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------0             0x0             DLOB firmware header, boot partition: "dev=/dev/mtdblock/2"112           0x70            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 4237576 bytes1441904       0x160070        PackImg section delimiter tag, little endian size: 3169792 bytes; big endian size: 6172672 bytes1441936       0x160090        Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 6170670 bytes, 2216 inodes, blocksize: 262144 bytes, created: 2012-10-09 10:24:09Scan Time:     2021-08-12 23:03:43MD5 Checksum:  0eab4114d12c97a4a1ff29d0d307d6daSignatures:    410DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------1571792       0x17FBD0        MySQL ISAM index file Version 81621686       0x18BEB6        PGP RSA encrypted session key - keyid: 801000 4C RSA Encrypt-Only 1024b3149062       0x300D06        PGP RSA encrypted session key - keyid: 801000 3A RSA Encrypt-Only 1024b3149250       0x300DC2        PGP RSA encrypted session key - keyid: 801000 3A RSA Encrypt-Only 1024b3338272       0x32F020        Linux kernel version 2.6.333398624       0x33DBE0        CRC32 polynomial table, little endian3803284       0x3A0894        Neighborly text, "NeighborSolicitstunnel6 init(): can't add protocol"3803304       0x3A08A8        Neighborly text, "NeighborAdvertisementst add protocol"3808047       0x3A1B2F        Neighborly text, "neighbor %.2x%.2x.%.2x:%.2x:%.2x:%.2x:%.2x:%.2x lost on port %d(%s)(%s)"
```

#### 逆向 cgibin

使用 IDA 逆向 cgibin 文件

```
$ file cgibin                               cgibin: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped
```

查看 servicecgi_main 函数，我们可以看到 servicecgi_main 调用了 lxmldbc_system 函数，

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7Snos1NyKrLEibO3l6knfEXMPzaA4WZfpMDIgUBUVgTibH7hicFNMN502Q/640?wx_fmt=png)CxPDse

此函数调用了 system 函数。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7SicibjuVkqMRz589aHAQj3d2kXCg6rMvQ8fsSIM7GQ6JgEIIibCLyG2pQ/640?wx_fmt=png)K9aOqQ

接下来该漏洞的成因。  
在 servicecgi_main 中先判断请求的方法，只处理 get 和 post

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7XrhfcjRxuz7J7a58Cm6KYcVatRpntgJ5xGKqCX3cs2e4zaTvwEeaWg/640?wx_fmt=png)VA6EIs

在 servicecgi_main 中可以处理 EVENT,SERVICE,ACTION 三个类型的 form 表单参数域。servicecgi_main 会把这三个表单域参数存储在特定区域，然后进行 event,service,action 的处理。

在处理 event 请求时没有对 EVENT 值做必要的处理，然后进入 loc_40D038 模块，在模块中调用了 lxmldbc_system 函数，进而调用了 system 函数。

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7Uca8WpoozpJJq1LzfyOscibcTKicBLg0ZxObHSSwoWFCJsnmia0ibupYvg/640?wx_fmt=png)qnexhC

而 lxmldbc_system 会调用 system 执行 command，而且是没有任何过滤的，那就存在命令注入的风险了。

#### Netgear CVE-2016-6277

NETGEAR R6250 在 1.0.4.6.Beta 之前，R6400 在 1.0.1.18.Beta 之前，R6700 在 1.0.1.14.Beta，R6900，R7000 在 1.0.7.6.Beta 之前，R7100LG 在 1.0.0.28.Beta 之前，R7300DST 在 1.0.0.46.Beta 之前，1.0.1.8.Beta 之前的 R7900、1.0.3.26.Beta，D6220，D6400，D7000 之前的 R8000，以及可能的其他路由器，允许远程攻击者通过 shell 在 cgi-bin/ 的路径中执行任意命令。

下载 Netgear R7000 固件

使用 binwalk 解析固件，使用 IDA 分析 httpd 文件  
通过漏洞提示信息在 IDA 中查找到对应字符串

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj70jNDxyQg7GWrEE6ofDd05jBd2XiaibmvYuvHz1ERwnYz7W7lpqZnr9Eg/640?wx_fmt=png)dk6EPz![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7QjJASD8xa58AlgdeKFv8TNdtm1OAc2ibLIu2NRwFKBWWoibAhb4Nbs9w/640?wx_fmt=png)20aCDa

查看 v51 的来源

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj714Cwupib6D4SjEUx4MvAZ0VxS535XDvzTzgIXKpXh8iblIiaZtDUtmiciag/640?wx_fmt=png)b6b5pZ

可以看到 v51 是 v19 拷贝来的

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7EgOwVOxdzl7tO6nE9Py3bOWdh2iaha7AGybR2JXZqu100GFCJ5QdG6g/640?wx_fmt=png)xdVxVe

接着溯源可以看到 v19 来自 v12，v12 来自 v6,v6 是一个 URL，这也就和上文对应了起来

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBQiaTMHaibdcn3kKdEsdU8Kj7y92xIoZFd1COsHnrB3LLOzKNebyCpULbD7icDh2GtD74HYichDmMiaicBw/640?wx_fmt=png)jF6gE0

所以这里是一个因为对命令没有过滤的命令注入漏洞。

### 参考链接：

常见嵌入式 Web 服务器 CGI 处理功能简要分析：https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/

D-LINK SERVICE.CGI 远程命令执行漏洞：  
https://www.freebuf.com/articles/terminal/164680.html

end

  

招新小广告

ChaMd5 Venom 招收大佬入圈

新成立组 IOT + 工控 + 样本分析 长期招新  

欢迎联系 admin@chamd5.org

  
  

![](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBR8nk7RR7HefBINILy4PClwoEMzGCJovye9KIsEjCKwxlqcSFsGJSv3OtYIjmKpXzVyfzlqSicWwxQ/640?wx_fmt=jpeg)