<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/i2kQ8uBkPI4qglGQvangmQ)

公众号

![](https://mmbiz.qpic.cn/mmbiz_png/HpA1SPmFiaXnH0icIic57eR9QytbPrsHiapgSzTxN8oh4ibvYCVK7ETUkaZIRlbfNom9X0QGt93I0RFaaAKA0Sibab3Q/640?wx_fmt=png)

1、背景

![](https://mmbiz.qpic.cn/mmbiz_png/mtXBpHBrIJmMvSfMA2IDGnclSl50gYw6Njhvznic1ZW25vGceuDAakscJgPLT6WQmfvzSibQZ3ib5gnGYQYTlclFg/640?wx_fmt=png)

在 CTF 比赛中, CTF 逆向题目除了需要分析程序工作原理, 还要根据分析结果进一步求出 FLAG。逆向在解题赛制中单独占一类题型, 同时也是 PWN 题的前置技能。在攻防赛制中常与 PWN 题结合。CTF 逆向主要涉及到逆向分析和破解技巧，这也要求有较强的反汇编、反编译、加解密的功底。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**CTF 中的逆向题目一般常见考点**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

1、常见算法与数据结构。

2、各种排序算法, 树, 图等数据结构。

3、识别加密算法与哈希算法代码特征, 识别算法中魔改的部分。

4、代码混淆, 代码虚拟化, 修改代码流程, 反调试等。

5、软件加密壳是软件保护技术的集中应用。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**CTF 逆向题目两大主题：暴力破解、算法分析破解**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

1、**暴力破解：**通过修改汇编代码而跳过程序内部校验部分，从而改变程序的正常逻辑，最后满足题目要求来获取 flag。这就考验在逆向分析样本时候，对样本验证代码定位能力。

2、**算法破解：**这主要需要分析样本中的加密部分的汇编代码，将其加密算法进行还原，并根据分析结果写出对于的解密程序，最后算出 flag。这就考验了对样本分析过程中的耐心和扎实的逆向能力和一定的代码开发能力。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**逆向解题常见技巧**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

1、逆向分析与功能猜测结合, 通过逆向分析进行缩小猜测范围, 猜测为逆向指出方向, 逆向再验证猜测的思路。

2、结合样本中汇编代码上下文与整体程序功能, 关注程序中给出的文字提示信息。

3、实际比赛的逆向题目多数是为出题而出题, 有目的性强, 功能结 构单一, 无关代码少等特点。

4、遇到程序代码量极大时, 可以先判断是否引用了较多的开源的代码, 而程序的主逻辑相对简单。

![](https://mmbiz.qpic.cn/mmbiz_png/HpA1SPmFiaXnH0icIic57eR9QytbPrsHiapgSzTxN8oh4ibvYCVK7ETUkaZIRlbfNom9X0QGt93I0RFaaAKA0Sibab3Q/640?wx_fmt=png)

**2、逆向基础**

![](https://mmbiz.qpic.cn/mmbiz_png/mtXBpHBrIJmMvSfMA2IDGnclSl50gYw6Njhvznic1ZW25vGceuDAakscJgPLT6WQmfvzSibQZ3ib5gnGYQYTlclFg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

CTF 逆向常用工具

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

Ollydbg、IDA、PCHunter、Exeinfo PE(PeTool)、CFF Explore、exeScope、ApiMonitorTrial、winhex。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**CTF 逆向需涉及知识点**

**![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)**

**汇编知识：**window 下的 X86 和 X64; android 下的 ARM 和 ARM64。

**文件结构：**windox 下的 PE 文件; android 下的 dex 文件和 ELF 文件。

**反调试技术:** window 和 android 下的调试和反调试对抗技术。

**加壳和脱壳：**PE 的加壳和脱壳、 ELF 和 dex 的加壳和脱壳。

**开发能力：**C、C++、python 等语言的开发能力。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**CTF 样本逆向解题流程**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1、突破保护：**

获得样本程序时先用 ExeInfoPePE 工具进行查看程序属于哪平台下的，例如 windows X86/X64、android、linux 等，是否采用代码保护措施，例如：代码混淆、保护壳、各种反调试等，如果有那么在进行分析样本之前，需要先过掉样本混淆、脱壳、反反调试等技术来去除或绕过这些保护措施。

**2、定位关键代码：**

我们需要将目标软件进行反汇编，然后结合 IDA 和 OD 快速定位到关键代码（例如验证函数、关键字符串信息、程序导入表）。

**3、动静结合：**

我们找到程序的关键代码之后，就要对其进行详细的逆向分析。如果程序在 IDA 中 F5 可以生成伪代码，那么我们就先根据伪代码进行静态分析，然后模糊不清的地方可以结合 ollydbg 工具进行动态调试，观察来验证自己的猜想。

**4、破解验证算法：**

通过详细逆向分析完，程序的关键代码 (例如: 验证算法) 之后，接着就要根据分析出的结果，进行暴力破解或者进行算法解密代码的编写以此来获取或生成 flag。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

CTF 中常见的验证算法

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1、 直接比较验证：**

密钥一般没有经过加密，直接跟内置程序中的 key 进行比较 (也就是硬编码方式比较)，此类题型比较简单。

**2、加密比较验证：**

密钥一般会进行如异或、base64、MD5、RC4 等形式的加密，此类题型需要识别出其加密方式，然后再根据其算法特点还原出相应的 key 值，现实 CTF 比赛中可能出现密钥用不同加密算法分段加密或嵌套验证等多种加密组合起来的方式，也需要去深入识别分辨。

**3、 逆向自定义实现的算法：**

这类题目就需要去逆向题目作者自己编写实现的算法了，这样的算法难度相对比较难，在逆向过程中需要识别出其是算法问题题目，然后分析出其每个函数代表什么操作来进一步解题，需要逆向算法的题目一般都比较难，需要理清算法实现思路，跟踪自己输入的数据使用算法进行了哪些处理，最后变成了什么和什么比较，需要有一定的耐心和细心，建议多加练习。

**4、其他类型的加密题目：**

实在解不出来的，也可以尝试是否可以绕过或暴力破解穷举等方式。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**定位关键代码的方法**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1、顺序跟踪法：**

如果拿到的样本程序相对较小，代码量不多且主函数入口好找，即可使用顺序跟踪法，从程序主函数入口顺序跟踪，一步步分析完整的程序执行过程，基本就能知道程序的验证部分了，至于各个类型程序主函数的查找方法大家可以自行百度，这里还需要分清楚程序入口点和 main 函数的区别，大家一般需要找 main 函数，但也不全是找 main 函数，如果遇到了 MFC 的程序大家还需要根据具体情况具体分析，如果有条件大家也可以编码实现相应程序，然后反汇编来进行练习查找程序的主函数，这个需要平时多练习、多积累、多总结。

**2、 字符串查找：**

如果给定的样本程序没有做混淆处理，而且还有比较明显的字符串信息提示，那么就可以根据程序运行的提示，使用字符串查找功能查找程序所提示字符串的方式来反向查找其被引用的地址。例如 IDA 中 shift+F12 的字符串窗口，OD 中查找 -> 所有参考文本字串，字符串搜索的优先级很高，很多情况下对我们解题很有奇效，所以拿到程序后可以优先字符串查找尝试。

**3、系统函数断点：**

如果程序非常大而且也没有啥字符串提示信息可以利用，那么我们就可以猜测根据样本程序所使用的函数来定位关键验证代码，这需要掌握 C 语言或 C++ 语言还有 windows 核心编程的知识，熟悉一些通用函数具有的功能，例如：程序出现了一个弹窗，那么程序就有可能调用了 MessageBox 这个函数，如果程序出现了输出，那么程序就有可能调用了 printf 这个函数等等，所以可以通过程序所表现出的状态来下相应的函数断点，然后栈回溯反向查找其引用位置，进而找到关键代码。

![](https://mmbiz.qpic.cn/mmbiz_png/HpA1SPmFiaXnH0icIic57eR9QytbPrsHiapgSzTxN8oh4ibvYCVK7ETUkaZIRlbfNom9X0QGt93I0RFaaAKA0Sibab3Q/640?wx_fmt=png)

**3、汇编基础**

![](https://mmbiz.qpic.cn/mmbiz_png/mtXBpHBrIJmMvSfMA2IDGnclSl50gYw6Njhvznic1ZW25vGceuDAakscJgPLT6WQmfvzSibQZ3ib5gnGYQYTlclFg/640?wx_fmt=png)

(以下知识点只起到抛砖引玉的作用)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**X86 汇编**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

32 位 CPU 有 16 个寄存器, 32 位寄存器存放的是 4 个字节的数据，它们名称分别为：

4 个数据寄存器 (EAX、EBX、ECX 和 EDX);

2 个变址和指针寄存器 (ESI 和 EDI);

2 个指针寄存器 (ESP 和 EBP);

6 个段寄存器 (ES、CS、SS、DS、FS 和 GS);

1 个指令指针寄存器 (EIP);

1 个标志寄存器 (EFlags)。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**X64 汇编**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

64 位 CPU 有 16 个通用寄存器，寄存器存放 8 个字节数据，它们名称分别为：

rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp

r8,r9,r10,r11,r12,r13,r14,r15

32 位使用栈帧来作为传递的参数的保存位置，而 64 位使用寄存器，分别用 rdi,rsi,rdx,rcx,r8,r9 作为第 1-6 个参数。rax 作为返回值。

64 位没有栈帧的指针，32 位用 ebp 作为栈帧指针，64 位取消了这个设定，rbp 作为通用寄存器使用。

rax 作为函数返回值使用。

rsp 栈指针寄存器，指向栈顶

rdi，rsi，rdx，rcx，r8，r9 用作函数参数，依次对应第 1 参数，第 2 参数。。。

rbx，rbp，r12，r13，r14，r15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改。

r10，r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**通用汇编知识**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgD7leFyANoJsiaFpXzwKoZiarTs2CT7ccibcYMiaHHXMTw0ltvasPRJPR7VA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgD8fqVTibOZwU7HIVeXMWw6yYIJhJEEIZS5E3psiaLhz3oVTSqaktJEP8Q/640?wx_fmt=png)

函数 (Call) 的 3 种调用约定：_cdecl,_stdcall、_fastcall

**_cdecl：**是 C 语言的默认的函数调用方法，所有参数从右到左依次入栈，这些参数由调用者去清除。堆栈恢复常用指令 add,esp,x  ，x 表示参数占用的字节数

**_stdcall：**是 C++ 标准的函数调用方式，所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是 this 指针。

这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 ret x，其中 x 表示参数占用的字节数。

**_fastcall：**是编译器指定的函数快速调用方式。由于大多数函数参数个数很少，使用堆栈传递比较费时。因此_fastcall 通常规定前两个参数由寄存器传递，其余参数还是通过堆栈传递。但是不同的编译器编译的程序规定的寄存器不同，返回方式一般是 ret x。

总结三个调用约定：

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDX8dkkbhZ4cDibOKrlULgHe53bTS0nSYcQS7sFDMV8BicX40PXiaQqrNwQ/640?wx_fmt=png)

**函数参数和局部变量区分**

函数的局部变量的存在形式：mov eax, dword ptr[ebp -4]

函数参数表示法：mov eax， [esp+arg_0]

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**Arm32 汇编 (Android)**

**![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)**

ARM 微处理器共有 **37 个 32 位寄存器，其中 31 个为通用寄存器，6 个为状态寄存器。**但是这些寄存器不能被同时访问，具体哪些寄存器是可以访问的，取决 ARM 处理器的工作状态及具体的运行模式。但在任何时候，通用寄存器 R14~R0、程序计数器 PC、一个状态寄存器都是可访问的。 

 未分组寄存器 **R0 ~ R7，**共 8 个；

 分组寄存器 **R8 ~ R12**，**R13 ~ R14** R8 ~ R12：其中 FIQ 模式下有单独的一组 R8 ~ R12，共 5 个；

另外 6 种模式共用一组 R8 ~ R12，共 5 个；总共 10 个；

**R13 ~ R14**：其中 USR 和 SYS 模式（表格的第一列）共用一组 R13 ~ R14 共 2 个，另外 5 种模式下各有独自的一组 R13 ~ R14 共 10 个；总 共 12 个；

程序计数器 PC 即 **R15**，共 1 个；

 分组寄存器 R13、R14　         

寄存器 R13 通常做堆栈指针 SP　　     

寄存器 R14 用作子程序链接寄存器（Link Register-LR），也称为 LR，指向函数的返回地址。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**Arm64 汇编 (Android)**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

汇编中共有 34 个寄存器。其中包括 31 个通用寄存器、SP 寄存器、PC 寄存器，CPSR 寄存器。

31 个通用寄存器中：

**X0-X30：**表示是 64 位的寄存器。

**W0-W30：**表示是 32 位的寄存器。

**X31 :** 也称为零寄存器（它一般用于变量的初始化），它也有两表现形式：**XZR：**表示是 64 位的零寄存器， 它在内存中是用 8 个字节存储。

**WZR：**表示是 32 位的零寄存器，它在内存中是用 4 个字节存储。

**SP :** 保存栈指针 (栈顶指针)，使用 SP 或 WSP 来进行对 SP 寄存器的访问, 也就是用于操作局部变量地址。

**PC：**程序计数器（PC 指针寄存器），它用于指向即将要执行的下一条指令。

**CPSR：**状态寄存器

**FP（X29）：**保存栈帧地址（栈底指针）

**LP（X30）：**通常称 X30 为程序的链接寄存器，保存子程序结束后需要执行的下一条指令。

**![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDJ0DCZ1EfN2agxGcTAea1dshRtwq83Akl9uV2mNCys9VwRmaW1jp2Vw/640?wx_fmt=png)**

掌握 ARM 汇编中基本结构前需要回顾和并熟记以下的条件指令

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDcHXYdIjEJgtJrD8aWSpuDicuSXP8rNia61fteqgmelwic12UbariaUFZsw/640?wx_fmt=png)

**怎样在 ARM 汇编中去识别和定位出函数**

1.1、    B 跳转指令

1.2、    BL 带返回的跳转指令

1.3、    BLX 带返回和状态切换的跳转指令

1.4、    BX 带状态切换的跳转指令

2. 直接向程序计数器 PC 写入跳转地址值。

通过向程序计数器 PC 写入跳转地址值, 可以实现在 4GB 的地址空间中的任意跳转, 在跳转之前结合使用 MOV  LR，PC

总结：识别函数的方法就是汇编指令中是否有包含：B、BL、BLX、BX、PC 的汇编指令。

ARM 函数调用约定采用的是：ATPCS

ATPCS 的英文全称是 ARM-THUMB procedure call standard（ARM-Thumb 过程调用标准）

总结：参数 1~ 参数 4 分别保存到 R0~R3 寄存器中 ，剩下的参数从右往左一次入栈，被调用者实现栈平衡，返回值存放在 R0 中。

**函数参数：**

当参数个数小于等于 4 个的时候，使用 r0 到 r3 这 4 个寄存器进行参数传递；如果参数个数大于 4 个，余下的参数就通过 sp 所指向的数据栈进行参数传递。

比如有 3 个参数的话，那么 r0 代表函数的第一个参数，r1 代表函数的第二个参数，r2 代表函数的第三个参数。

比如有 6 个参数的话，那么 r0-r3 表示前面 4 个参数，然后余下的两个参数通过在栈上开辟 8 字节的空间进行参数传递。

**r0–r3：**存储传递给函数的参数值，多余的参数通过压栈传递。

**r4 -r11：**存储函数的局部变量，Thumb 模式不会使用 r8 以后的寄存器

**r12：**是内部过程调用暂时寄存器（intra-procedure-call scratch register）。

**r13：**存储栈指针 (sp)。在计算机中，栈非常重要。这个寄存器保存着栈顶的指针。这里可以看到更多关于栈的信息。

**r14：**链接寄存器 (link register)。存储着当被调用函数返回时，将要执行的下一条指令的地址。

**r15：**用作程序计数器 (program counter)。存储着当前执行指令的地址。每条执行被执行后，该计数器会进行自增 (+1)。

函数的返回值放到 r0 中。

fp 叫做 frame pointer 寄存器，即栈帧指针寄存器；sp 叫做 stack pointer 寄存器，即栈指针寄存器。

在 ARM 指令系统中是地址递减栈，入栈操作的参数入栈顺序是从右到左依次入栈，而参数的出栈顺序则是从左到右的你操作。包括 push/pop 和 LDMFD/STMFD 等。

函数返回值

1. 结果为一个 32 位的整数时, 可以通过寄存器 R0 返回。

2. 结果为一个 64 位整数时, 可以通过 R0 和 R1 返回，依此类推。

3. 结果为一个浮点数时, 可以通过浮点运算部件的寄存器 f0,d0 或者 s0 来返回。

4. 结果为一个复合的浮点数时, 可以通过寄存器 f0-fN 或者 d0~dN 来返回。

5. 对于位数更多的结果, 需要通过调用内存来传递。

![](https://mmbiz.qpic.cn/mmbiz_png/HpA1SPmFiaXnH0icIic57eR9QytbPrsHiapgSzTxN8oh4ibvYCVK7ETUkaZIRlbfNom9X0QGt93I0RFaaAKA0Sibab3Q/640?wx_fmt=png)

4、反调试

![](https://mmbiz.qpic.cn/mmbiz_png/mtXBpHBrIJmMvSfMA2IDGnclSl50gYw6Njhvznic1ZW25vGceuDAakscJgPLT6WQmfvzSibQZ3ib5gnGYQYTlclFg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**Window 反调试技术**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

应用程序通过利用反调试技术可以进行识别判断自身是否被调试，当识别到被调试就会改变执行的流程或修改自身自销毁。从而增加逆向调试的时间和复杂度。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**反调试实现的技术**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1.IsDebuggerPresent 函数**

实现原理：只能用于自身进程的检测，通过查询进程环境块 (PEB) 中的 IsDebugged 标志，如果被调试状态那么返回非 0，调试没有被调试状态返回 0

**2.NeQueryInfomationProcess 函数**

原理：用于提取一个给定进程的信息，函数参数 1 表示进程句柄，参数 2 表示信息类型，第二个参数 ProcessDebugPort 的值如果设置为 0x7，就可以进行返回句柄标识的进程是否被调试，如果处于调试状态那么就会返回调试的端口，非调试状态则返回 0。

**3.CheckRemoteDebuggerPresent 函数**

实现原理：它可以用于自身进程和其他进程，通过查询进程环境块（PEB）中的 ISDebugged 标志，如果被调试状态，那么返回值返回非 0，没调试状态返回 0。

**4.FindWindowA、EnumWindows**

实现原理: 通过检测运行环境的调试器的窗口信息。

**5.OutputDebigString 函数**

实现原理：调试器调试应用程序的时候是通过触发异常方式进行执行调试功能的，通过利用 SetLastError 函数设置错误码方式，并用 OutputDebugString 函数进行打印出来，如果程序再被附加调试状态那么 GetLastError 获取到的错误码是前面用

SetLastError 的错误码一致，如果没有被调试，那么错误码可能是任意值。

**6. 注册表检测**

实现原理：通过查找调试器引用的注册表信息进行判断，如果当前环境下的注册表有存在调试器的信息，

下面是调试器在注册表中的一个常用位置。

SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug(32 位系统)

SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\AeDebug(64 位系统)

该注册表项指定当应用程序发生错误时，触发哪一个调试器。默认情况下，它被设置为 Dr.Watson。如果该这册表的键值被修改为 OllyDbg(其他的调试器 X64dbg、Windbg、ollyIce 也一样)，则应用程序就可能确定它正在被调试。

**7.BeginDebugged 标志检测**

实现原理：当应用程序运行时候，fs:[30h] 指向 PEB 基地址，如果指向的 BeginDebugged 标志位 0 的情况下，那么应用程序没有被调试，反之被调试。

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDZuhxz3zIhWl6u6Xibf7LicqwZ16fNxvBqa2iby7hKPfr20HMqaGobs3BQ/640?wx_fmt=png)

**8. 检测 ProcessHead 标志**

实现原理：在 PEB 结构中的 Reserved 数组中有一个未公开的位置 ProcessHeap，它位于 PEB 结构的 0x18 处，ProcessHeap 中包含 ForceFlags 标志，可以通过该标志进行判断是否处于调试状态。

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDiaM1qnSlf7g7861NRmXLcxVTv4EJa1cyZuRjm6omibp47ZymMHmfCnGA/640?wx_fmt=png)

**9. 检测 NTGlobalFlag 标志**

实现原理：通过调试器启动的进程和正常创建启动的进程是有差别的，所以他们创建内存推的方式也不一样。NTGlobaFlag 标志它是微软未公开的，在 PEB 偏移 0x68 位置，如果值为 0x70，那么表示程序是调试器启动的。

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDgfib3ibsOwRDjvcshHQX14CUYr9F3YkchP4pI6Rb5WB8Un74HAuhpEGw/640?wx_fmt=png)

**10. 检测父进程是否是 explorer.exe**

实现原理：正常启动的应用，他的父进程是 explorer.exe，如果进程被调试状态那么它的父进程就是调试器进程。所以只要父进程不是 explorer.exe 进程就可以认定为调试状态。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**反调试检测小结**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

以上的反调试技术是相对应用比较多的技术，对于反调试技术一般是通过多种方案结合的。反调试技术除了以上的方案，还有程序中执行代码段的校验，运行的调试器检测，调试器的特征码检测，断点检测等等。反调试是逆向的第一个门槛，只有跨过这个门槛，逆向才能真正开始。

下面针对调试反调试的技术总结方案可以借鉴学习。

参考链接：https://github.com/LordNoteworthy/al-khaser

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**java 层检测**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1.isDebuggerConnected 函数**

检测原理：当 app 被调试的时候，调用 android.os.Debug.isDebuggerConnected() 返回值为 true，否则返回值为 false。

**2.android：debuggable 标签**

检测原理：Android 中的 AndroidManifest.xml 文件中如果 debuggable 属性值设置为 true，那么久表示可以调试，属性值为 false 就表示不可调试。

**3. 包签名校验**

检测原理：通过检测 app 的包签名信息，如果包签名不一致那么就是重新打包的。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

native 层检测

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

**1. 检测自身进程的 TracerPid 值**

检测原理：可以通过 / proc/pid/status 或 / proc/pid/task/pid/status 获取到 TracerPid 值，默认下是 0，被附加调试会变成调试的 PID 值。

**2. 基于 IDA 调试器检测**

检测原理：android_server 端口号 (通过 / proc/net/tcp 检测 23946 端口)、android_server 文件信息、调试器进程名、

**3. 检测自身进程 maps**

检测原理：通过检测 / proc/pid/maps 检测自身进程是否有保护敏感模块信息来判断是否被调试。

**4. 检测父进程 zygote 进程**

检测原理：因为 zygote 是所有程序的父进程，所有应用 app 也是通过 fork 方式创建出来的，通过 / proc/pid/cmdline 获取，如果当前父进程不是 zygote 进程那么久表示被调试了。

**5. 检测自身状态**

检测原理: app 在被附加调试过程中会被挂起暂停，所以通过 / proc/pid/stat 或 / proc/pid/task/stat 获取，当第三个字段属性为 t 时候，那么表示 app 在被调试暂停挂起。

**6. 抢占 Ptrace**

检测原理：在 android 系统中一个 app 只能被 ptrace 一次。所以先自己 ptrace 自己。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**android 反调试小结**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

由于 android 系统是开源的，所以对于以上利用系统属性及函数用于反调试的，都可以通过修改系统源码然后重新编译方式进行过检测。对于这种修改系统方式其实可以通过自己 ptrace 自身方式，如果自身 ptrace 后，tracePid 值还是为 0，那么表示该系统是重新修改编译过的。

攻防是个不断持续的过程，同样反调试和过反调试也是如此。就在于点高点低了。以上罗列的只是简单的一些方案。

![](https://mmbiz.qpic.cn/mmbiz_png/HpA1SPmFiaXnH0icIic57eR9QytbPrsHiapgSzTxN8oh4ibvYCVK7ETUkaZIRlbfNom9X0QGt93I0RFaaAKA0Sibab3Q/640?wx_fmt=png)

5、加壳和脱壳

![](https://mmbiz.qpic.cn/mmbiz_png/mtXBpHBrIJmMvSfMA2IDGnclSl50gYw6Njhvznic1ZW25vGceuDAakscJgPLT6WQmfvzSibQZ3ib5gnGYQYTlclFg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**Window 加壳方案**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

专门负责保护软件被非法修改或编译的程序。它附加在原始程序上，通过 window 加载器载入内存后，先于原始程序执行，以得到控制权，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来代码。

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDnnJL3WgAtpQF5SwFAFiaz1jAlaOFn7P0xNVrGOPiaBCSf8OcJYEVhcTQ/640?wx_fmt=png)

它的作用：可以有效防止破解者对程序文件进行非法修改，也可以防止程序被静态反编译。不同外壳的侧重方面是不一样的，有的侧重压缩，有的侧重加密。例如压缩壳的特点就是减少软件的体积，加密保护就不是它的重点。

**常见壳的加载过程：**

1. 保存入口参数

2. 获取壳本身需要使用的 API 地址

3. 解密原程序各个区块的数据

4.IAT 的初始化

5. 重定位项的处理

6.Hook API

7. 跳转到程序原入口点 (OEP)

壳的种类：

压缩壳有：UPX、ASPack、PECompact 等等

UPX 是开源：https://upx.github.io/

ASPack 壳的官网：http://www.aspack.com

加密壳：AsProtect、Armadillo、ExeCryptor 等等

虚拟机壳：Themida、Winlicense、VMProtect 等等

以上这些壳都可以用 ExeInfo PE 或 PEID 工具通过壳特征方式识别出什么类型的壳。

下图中是 PEID 工具识别壳的特征码 Signs 文件里面的特征。

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDM8OXVxjNiaUqefaYFEyGSCt6degQQK1Hhicb08f1nCvDpHPkibNHCWYibw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

**window 脱壳方案**

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

手动脱壳的步骤：

1. 查找真正的程序入口点

2. 抓取内存映像文件

3. 重建 PE 文件

定位程序 OEP 的方法：

**1. 根据跨段指令进行寻找 OEP**

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDHtu75QdDSicOf6JARNWxaDIWLC36mD0pTfn5cVBq1QZqtw8VsQRHryw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDnUkibuyzZNvRhHQFc8E2oFoicvQwrk4ic1ibY0a6qfHsfytCPJic98Oy9ag/640?wx_fmt=png)

**2. 用内存访问断点寻找 OEP**

方法: 先打开内存模块（Alt+M），接着直接对代码段（例如. text 区段）进行下内存访问断点（F2），这个断点是一次性断点，当所在段读取或执行时就中断，中断发生后，断点将自动删除。

**3. 根据栈平衡原理寻找 OEP**

在编写加壳软件时，必须保证外壳初始化的各寄存器值和原程序的各寄存器值是相同的。通常用 pushad/popad,pushfd/popfd 指令来保存和恢复现场环境。

**4. 根据编译语言特点寻找 OEP**

各类语言编译的文件入口点都有自己的特点。使用同一种编译器编译的程序，其入口代码都很类似，都有一段启动代码，编译器在编译程序时会自动和程序连接。在完成必须的初始化工作后，调用 WinMain 函数。

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

Android 加壳方案

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

目前市面上加固产品种类: 360 加固、爱加密加固、梆梆加固、腾讯乐固、网易易盾、几维加固、顶象加固。

一般 App 源程序加密之后就存放在那几个目录下，一般是：dex 文件尾部，libs 目录，assets 目录。

加固后可以通过 app 包里面的 lib 文件夹下的特有文件进行识别加固厂商。

网易易盾：libnesec.so、libbugrpt.so

爱加密：libexec.so,libexecmain.so，ijiami.dat

梆梆：libsecexe.so,libsecmain.so , libDexHelper.so

阿里聚安全：aliprotect.dat，libsgmain.so，libsgsecuritybody.so

腾讯安全：libtosprotection.armeabi.so，libtosprotection.armeabi-v7a.so，libtosprotection.x86.so

娜迦：libchaosvmp.so, libddog.so，libfdog.so

360：libprotectClass.so,libjiagu.so， libjiagu_art.so，libjiagu_x86.so

通付盾：libegis.so，libNSaferOnly.so

网秦：libnqshield.so

百度：libbaiduprotect.so

腾讯：libshellx-2.10.6.0.so，libBugly.so，libtup.so, libexec.so，libshell.so

APKProtect:libAPKProtect.so

几维安全：libkwscmm.so, libkwscr.so, libkwslinker.so

加固的特点

![](https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7P9HCQibfV8LxrRBVe9XNgDoxtfhIfKOsykzZKpOUP69DUlDNIbKjcxDnGfZwWiaiaaQWic6kw6ozC3Q/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/KqibibCPyYz2RyRnJmvtiatoklsSdPooP9HKcGuIvCDicD4zTQVsM9okdj00nVRhldYOUtibHTjuicsHpzjuibDZXxUdg/640?wx_fmt=png)

Android 脱壳方案

![](https://mmbiz.qpic.cn/mmbiz_png/CzF9RdyYoeK5GGPggy2Kt8NCv3G6icK8xgWK8FAgLkZnw7G1INTbX25ibGRbvXWpL8D0picibia6aAXjX6IxU4MdasA/640?wx_fmt=png)

脱壳的主要流程: 就是在 App 程序运行起来后，将源 App 的数据内存释放出来后，并将释放出来的数据拷贝出来。

**1. 内存 dump 法**

通过利用 frida 框架结合脱壳脚本 dex-dump

https://github.com/hluwa/FRIDA-DEXDump

通过在 app 内存中暴力搜索 dex.035 或者 dex.036 。

通过读取 / proc/pid/maps 查找后，进行 dump 数据。

**2.hook 关键函数法**

主要利用 frida 框架进行脚本开发。

通过 hook 关键函数 InMemoryDexClassLoader、dvmDexFileOpenPartial、DexClassLoader,dexFileParse、memcmp 然后去 dump 解密后的 dex 数据

**3. 动态调试法**

通过动态调试 app 下 mmap 函数断点，然后去 dump 出源 dex 数据。

**4. 定制系统法**

通过修改重编译 android 系统并刷机。

Hook Dalvik_dalvik_system_DexFile_defineClassNative。

枚举所有 DexClassDef，对所有的 class，调用 dvmDefineClass 进行强制加载

**5.dex2oat 法**

ART 模式下，dex2oat 生成 oat 时，内存中的 DEX 是完整的。

![](https://mmbiz.qpic.cn/mmbiz_png/AP7uYGaic65eecXicbzickFEbg36XW3HLu8Eia6SlqAnewYKsTLBOCRc1UiaAQKCZg30AZu4tFv4sYOY08GnpjRiau8g/640?wx_fmt=png)

E N D

![](https://mmbiz.qpic.cn/mmbiz_png/IYjOKYiazV1iaUatQzJKmFn3FhlZt2aMNibdXAeLbiclsALJO7riaWgZYNXm1GlfZbsIp9Cvd3ic9JXW4X6MZmHIYibYA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/hx6xunia7aWIMKREH0pIyvVIPBdibPL29omVEDrhXBSYKiak3soxgEtMCj6iafzyaBUdjXkaibp6VQsP3HVhkFo3pvg/640?wx_fmt=png)

点个赞、在看你最好看

  

![](https://mmbiz.qpic.cn/mmbiz_png/mbCibWYiamJu7vu50tfnFEqB24ue6Uc68oY1VWuYibg8VWXMWs1cEFXnCOib3FyQqtAsZAYtfpicyMMdicazZAEKMKzQ/640?wx_fmt=png)