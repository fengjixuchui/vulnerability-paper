<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/w7oJqqSHzmiiV9e5eklvJw)

  

    当你发现一个以 NT AUTHORITY\SYSTEM 运行的系统服务存在删除任意文件的漏洞时，您会怎么利用该漏洞？可能只是叹了口气，觉得只能产生DoS的效果，好吧，就这么放弃了。 

    在本文中，我们将向您展示一些技巧，可以从任意文件删除、任意文件夹删除和其他看似造成不了什么影响的文件系统操作的漏洞来实现权限提升。

**任意文件删除漏洞存在的几个问题**  

  

当我们考虑如何在 Windows 上利用任意文件删除漏洞时，会遇到两个比较棘手的问题：

  

1.  大多数关键的 Windows 操作系统文件(dll, sys, exe等)都被 DACL 锁定，甚至可以防止 SYSTEM用户进行修改。大多数操作系统文件归 TrustedInstaller 所有，只有该帐户才有权修改它们 （Microsoft Is Not Stupid !）。（读者练习：找出系统目录中可以被 SYSTEM用户删除或覆盖的关键 Windows 操作系统文件）
    
2.   即使您找到 SYSTEM 删除的文件，它也必须是在其他程序使用该删除的文件时会返回"打开失败"的文件，否则可能会造成其他错误。
    

  

可能出现的第三个问题，由于某些程序在使用该文件，导致你无法正常去删除该文件。

  

经验表明，要找到满足上述所有条件的可以删除的文件非常困难。在 C:\Windows、C:\Program Files 或 C:\Program Data 中查看通常的位置时，我们不知道有什么符合要求的，之前有一些该方面的研究涉及利用防病毒软件和其他软件产品，当然也需要具体分析这些软件的行为，而且问题是如果找到这些文件那么也只是第三方的软件存在的问题，和微软没有一点关系了，这种方法不通用。

  

  

**新的解决方案：利用Windows Installer服务特性**

  

ZDI 在去年收到的一份关于User Profile服务中的任意文件删除漏洞中，作者提出了下面的解决方案并给出了利用代码。

  

要了解该方法的原理，我们需要稍微了解一下Windows Installer服务的操作，下面是其大概的操作流程：

  

Windows Installer服务负责执行应用程序的安装，应用程序作者提供一个.msi 文件，该文件是定义安装应用程序必须进行的更改的数据库：要创建的文件夹、要复制的文件、要修改的注册表项、要执行的自定义操作等。

  

为确保在服务无法正常完成安装程序时仍然保持系统的完整性，并使安装恢复到之前的状态，Windows Installer 服务会强制执行事务，每次对系统进行更改时，Windows Installer 都会记录所有的更改，并且每次使用正在安装的软件包中的较新版本覆盖系统上的现有文件时，都会保留旧版本的副本。如果安装需要回滚，Windows Installer 服务会将系统恢复到其原始状态。在最简单的情况下，这些记录的位置是名为 C:\Config.Msi 的文件夹。

  

根据ZDI的解释，最简单的情况在C:\Config.Msi文件夹下，如果是更复杂的情况可能还有其他的操作，这个需要逆向Windows Installer服务，有兴趣可以自己去看看。

  

在安装过程中，Windows Installer 服务会创建一个名为 C:\Config.Msi 的文件夹并将回滚信息放在该文件夹中。每当安装过程对系统进行更改时，Windows Installer 都会在 C:\Config.Msi 中的 .rbs（回滚脚本）类型的文件中记录更改。此外，每当安装使用较新版本覆盖某个文件的较旧版本时，Windows Installer 都会将原始文件的副本放在 C:\Config.Msi 中。这种类型的文件将被赋予 .rbf（回滚文件）扩展名。如果需要回滚不完整的安装，该服务将读取 .rbs 和 .rbf 文件并使用它们将系统恢复到安装前存在的状态。

  

我们必须保护该运行机制不被恶意篡改。如果恶意用户能够在读取 .rbs 或 .rbf 文件之前对其进行更改，则回滚期间可能会发生对系统状态的任意更改。因此，Windows Installer 在 C:\Config.Msi目录和目录的文件上设置了一个较强的DACL。

  

这个机制引发了我们的思考：如果攻击者有任意文件夹删除漏洞怎么办？攻击者可以在 Windows Installer 创建后立即使用该漏洞来完全删除 C:\Config.Msi。然后攻击者可以使用一个弱的DACL 重新创建 C:\Config.Msi（普通用户可以在 C:\ 的根目录下创建文件夹）。一旦 Windows Installer 在 C:\Config.Msi 中创建回滚文件，攻击者就能够将 C:\Config.Msi 替换为包含攻击者指定的 .rbs 和 .rbf 文件。在回滚时，Windows Installer将对系统进行攻击者想要的更改效果。

  

要注意的是利用这个特性在这里需要你有一个以SYSTEM用户身份删除空文件夹的漏洞（这种漏洞一般存在于windows服务中），当然如果你可以移动或重命名任意文件夹也是可以的。

  

  

**从任意文件夹删除/移动/重命名到SYSTEM代码执行**

  

ZDI发布的源代码看样子是一个漏洞利用的框架，适用于 SYSTEM 或Administrator用户权限删除、移动或重命名任意空文件夹的漏洞。运行漏洞利用程序后，它将提示您启动对 C:\Config.Msi 的删除。可以通过触发任意文件夹删除漏洞来执行此操作，或者，出于测试目的，可以简单地从提升的命令提示符运行 rmdir C:\Config.Msi。成功运行后，利用程序会将攻击者要执行dll的文件放到 C:\Program Files\Common Files\microsoft shared\ink\HID.DLL。然后，您可以通过启动屏幕键盘 osk.exe 并切换到安全桌面（例如按 Ctrl-Alt-Delete）来获得SYSTEM用户权限运行的CMD SHELL。  

  

漏洞利用程序包含一个 .msi 文件，这个 .msi 的主要特别之处在于它包含两个自定义操作：一个会产生短暂的延迟，另一个会引发安装错误。当Windows Installer 服务尝试安装此 .msi 时，安装将中途停止并回滚。在回滚开始时，漏洞利用将 C:\Config.Msi 的内容替换为恶意的 .rbs 和 .rbf。.rbf 包含恶意 HID.DLL文件，.rbs 中我们让Windows Installer 将HID.DLL "恢复" 到我们想要的位置（C:\Program Files\Common Files\microsoft shared\ink\）。

  

漏洞利用的完整过程如下：

  

1.  创建一个空的C:\Config.Msi 目录并设置一个oplock（该利用机制由James Forshaw提出）
    
2.  攻击者触发文件夹删除漏洞，以SYSTEM（或admin）用户删除C:\Config.Msi（或将C:\Config.Msi移至别处），由于oplock的存在，SYSTEM 用户进程被迫等待锁被释放
    
3.  触发攻击程序中针对oplock的回调函数，过程如下：
    
4.  攻击程序将C:\Config.Msi移至别处，这样做是为了继续让攻击程序持有该oplock，被攻击的SYSTEM用户服务进程被迫继续等待，而文件夹 C:\Config.Msi 却是用于其他目的。
    
5.  攻击程序创建一个新线程，该线程调用 Windows Installer 服务来安装 .msi，禁用UI（不会被正常用户发现安装的窗口）
    
6.  在攻击程序oplock回调函数中继续并开始探测 C:\Config.Msi 的创建。Windows Installer 将创建 C:\Config.Msi，暂时将其用于临时文件，将其删除，然后再次创建它以用于存储回滚脚本（暂时不知道为什么Windows Installer 会创建两次该目录，需要具体分析）。回调线程会一直监测 C:\Config.Msi 以等待这些操作，记录操作的次数
    
7.  攻击程序回调函数检测到 Windows Installer 第二次创建了 C:\Config.Msi，回调函数释放 oplock 并退出。在此后SYSTEM用户服务进程会继续并删除（移动或重命名）由 Windows Installer 创建的 C:\Config.Msi目录
    
8.  攻击程序的主线程恢复，反复尝试使用弱 DACL 创建 C:\Config.Msi。一旦SYSTEM用户服务进程删除（移动或重命名）C:\Config.Msi，攻击程序的创建操作就会成功
    
9.  攻击程序监视 C:\Config.Msi 文件夹中的内容并等待 Windows 安装程序在那里创建一个 .rbs 文件
    
10.  攻击程序反复尝试将 C:\Config.Msi 移至其他位置，一旦 Windows Installer 关闭其对 .rbs 的句柄，移动就会成功，并且攻击程序会继续执行
    
11.  攻击程序最后一次创建 C:\Config.Msi，并在目录中放置一个与原始 .rbs 同名的恶意 .rbs 文件，与.rbs 一起写入恶意 .rbf中
    
12.  在 .msi 中指定的延迟和安装错误操作发生之后，Windows Installer 执行回滚，执行恶意的 .rbs 和 .rbf，释放恶意DLL到想要的目录
    

  

需要注意的是在第 7 步，存在条件竞争。如果SYSTEM用户的服务进程没有立即唤醒并删除 C:\Config.Msi，机会窗口会丢失，因为 Windows Installer 将很快打开 C:\Config.Msi 的句柄并开始在那里写入 .rbs。此时，删除 C:\Config.Msi 将不再起作用，因为它已经不是空的文件夹。为避免这种情况，建议在至少有 4 个处理器核心的系统上运行攻击程序。一个纯净的系统，没有太多其他操作，可能是理想的。如果您确实遇到了问题，则有必要重试攻击程序，再次触发漏洞。

  

  

**从任意文件删除到SYSTEM用户提权**

上述利用技术我们假定的是我们具有删除任意空文件夹的漏洞。但是，通常我们发现的漏洞是任意文件删除而不是文件夹删除。为了在这种情况下实现 SYSTEM用户提权，漏洞利用使用了一个额外的技巧。

  

在 NTFS 中，与文件夹关联的元数据（索引数据）存储在该文件夹的备用数据流中。如果文件夹名为C:\MyFolder，则索引数据位于称为 C:\MyFolder::$INDEX_ALLOCATION 的流中。一些实现细节可以在参考链接中找到。我们需要知道的是：删除文件夹的::$INDEX_ALLOCATION 流实际上会从文件系统中删除该文件夹，并且流名称（例如 C:\MyFolder::$INDEX_ALLOCATION）可以是传递给需要文件名的API，包括 DeleteFileW。

  

如果您能够以 SYSTEM 或管理员身份运行的服务进程调用 DeleteFileW 时候传递任意字符串给其参数，那么您不仅可以实现文件删除，还可以实现文件夹删除。在我们的案例中，要传递的字符串是 C:\Config.Msi::$INDEX_ALLOCATION。

  

需要注意的是，利用成功取决于漏洞 SYSTEM 服务进程中存在的特定代码。如果该服务进程只是调用 DeleteFileA | DeleteFileW，删除操作没有什么大问题。但是，在使用其他方式删除文件的情况下，某些程序会执行其他相关操作，比如检查指定文件的属性。所以命令行执行del C:\Config.Msi::$INDEX_ALLOCATION 是不会成功的！

  

  

**从文件夹内容删除到SYSTEM用户提权**

  

我们假设易受攻击的 SYSTEM 服务进程不允许我们删除指定的任意文件夹或文件，但我们可以让它删除任意文件夹的内容，或者递归地删除攻击者创建的某个文件夹。这种情况是否也可以进行权限提升呢？答案是是可以的，漏洞提交人在后续的说明中也证实了这一点。在提交的报告中，他使用了 Silent Cleanup 计划任务中的一个漏洞，该任务以 SYSTEM 身份运行。此服务某一个操作中会遍历临时文件夹并删除它在其中创建的每个文件，恰巧普通用户也对该目录存在控制权限，利用方案如下：

  

1.  创建一个子文件夹 temp\folder1
    
2.  创建一个文件 temp\folder1\file1.txt
    
3.  在 temp\folder1\file1.txt 上设置 oplock
    
4.  等待易受攻击的进程遍历 temp\folder1 的内容并尝试删除遍历到的文件file1.txt，这时候将触发 oplock 回调
    
5.  当 oplock 触发时，在回调中执行以下操作
    

1.  将 file1.txt 移到别处，使 temp\folder1 为空目录，这时候该目录就可以删除了。 我们移动 file1.txt 而不是仅仅删除它，因为删除它需要我们首先释放 oplock。 这样，回调线程仍然持有该 oplock，SYSTEM服务进程还是继续等待，同时我们执行下一步操作
    
2.  重新创建 temp\folder1 ，这时候并不是创建目录而是创建一个目录链接(junction)，链接到 "\RPC Control\" （该技术在James Forshaw提出来的文件操作漏洞利用的文章中经常遇到，可以参考之前文章）
    
3.  创建一个符号链接"\RPC Control\file1.txt"，该链接指向 C:\Config.Msi::$INDEX_ALLOCATION
    
4.  攻击程序回调函数完成，oplock 释放，SYSTEM服务进程继续执行，这时候删除 file1.txt 的操作变成了删除 C:\Config.Msi 文件夹。  
    

  

你可能发现该技术 James Forshaw 的 symboliclink-testing-tools 涉及 \RPC Control 的符号链接利用的技巧。有一点要注意的是，一开始如果设置 temp\folder1 到 \RPC Control 的连接，然后使用任意文件删除漏洞来进行递归删除是不够的。 \RPC Control 不是可枚举的文件系统，因此 SYSTEM 服务进程将无法通过枚举找到 \RPC Control\file1.txt。我们必须首先创建 temp\folder1\file1.txt 文件，这个文件真实存在于文件系统中，让SYSTEM服务进程通过枚举找到它，之后的操作就和正常的符号链接漏洞利用技术没有什么区别了。

  

  

**总结**  

  

*   任意文件夹删除/移动/重命名（甚至是空文件夹删除）漏洞，如果服务运行权限为 SYSTEM 或 Admin 用户，可以实现 SYSTEM 权限提升
    
*   以 SYSTEM 或 Admin 身份进行的任意文件删除漏洞通常可以实现 SYSTEM 权限提升
    
*   以 SYSTEM 或 Admin 身份删除任意文件夹中的内容，可以实现 SYSTEM 权限提升
    
*   以 SYSTEM 或 Admin 身份递归删除固定的文件，同时攻击者对目标文件夹具有可写权限（例如临时文件夹），可以实现 SYSTEM 权限提升
    
*   以 SYSTEM 或 Admin 身份创建任意文件夹漏洞可以造成系统永久性拒绝服务
    
*   以 SYSTEM 或 Admin 身份删除或覆盖任意文件，即使无法控制内容，也可以造成系统永久性拒绝服务
    

  

截止到2022年3月补丁发布，C:\Config.Msi\ 目录的权限仍然没有发生变化，说明该方法仍然适用，不排除某天微软为了彻底封杀这种漏洞利用而修改了该目录默认的权限 ：  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

_**参考链接**_

*   https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks
    
*   http://inform.pucp.edu.pe/~inf232/Ntfs/ntfs_doc_v0.5/attributes/index_allocation.html
    
*   https://github.com/googleprojectzero/symboliclink-testing-tools/blob/main/CreateSymlink/CreateSymlink_readme.txt
    

  

**关于山石网科安全技术研究院**

  

  

  

    山石安研院是山石网科的信息安全智库部门，主要负责反APT研究、出战及承办全球攻防赛事、高端攻防技术培训、全球中英文安全预警分析发布、各类软硬件漏洞挖掘和利用研究、承接国家网络安全相关课题、不定期发布年度或半年度的各类技术报告及公司整体攻防能力展现。技术方向包括移动安全、虚拟化安全、工控安全、物联安全、区块链安全、协议安全、源码安全、反APT及反窃密。  
    为多省公安厅提供技术支撑工作，为上合峰会、财富论坛、金砖五国等多次重大活动提供网络安保支撑工作。在多次攻防赛事中连获佳绩，网安中国行第一名，连续两届红帽杯冠军、网鼎杯线上第一名，在补天杯、极棒杯、全国多地的护网演习等也都获得优秀的成绩，每年获得大量的CNVD、CNNVD、CICSVD、CVE证书、编号和致谢。如需帮助请咨询 hslab@hillstonenet.com

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)