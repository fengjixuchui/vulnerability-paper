<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/-3heClqYvoc_Zx9-1K7NJQ)

![](https://mmbiz.qpic.cn/mmbiz_gif/WTOrX1w0s56SCcicutqYiarKB82TYibkfpj8icy0Bm6eo7bwVWibicT0bdCOBB3ichDQCgsHGx6baib5wqsz6hEh24WQlA/640?wx_fmt=gif)  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56SCcicutqYiarKB82TYibkfpjSagSTADBichxZLfAwVG9sBfAbuy69DsxzuTVc7Yuxes0c5hnicTVTJLQ/640?wx_fmt=png)

本文约 6000 字，阅读约需 13 分钟。

  

pwn 作为 ctf 比赛中的一个分支，可以说是难以入门。pwn 确实难，但难点主要在于对它的学习——知识点不系统，或是太高深，对新手不友好。事实上，我们只要多做多练，相互对照理解就可以快速入门了。

此文希望能够为新手提供相对来说最详细、最基础、最简单的解题过程及利用过程，并附上部分详解的链接，可以边对照边学习边理解。

pwn 分为堆、栈两个部分，其中栈是基础，也是最简单的。故以栈为例进行入门讲解。

栈利用的知识点分支中，最常见的为 “格式化字符串漏洞” 以及“栈溢出漏洞”。

PS：想要入门，大佬写的文章是必须阅读一些的。本文中涉及到的文章会附上链接。大佬会写的很详细，但本文仅作为 pwn 入门，所以本人会将自己的理解讲出来，作为入门而言，够用。

**1**

  

**工具及其使用**

  

  

**工具介绍**

  

首先讲讲用到的环境。我们一般情况下都是使用 vmware 安装一个 ubuntu16.04 版的环境，在其中运行自己写的利用脚本（即 exp）。

  

pwn 通过分析一个程序来寻找漏洞点进行利用，该题的目的在于通过程序中可以利用的点来获取靶机（在 ctf 中会以 ip 以及端口的方式给出）上的权限（称之为 shell）。该过程中必不可少的一环就是静态分析。

  

而静态分析所需要利用的到的工具便是 ida：

  

吾爱破解 ida：

  

```
https://www.52pojie.cn/thread-675251-1-1.html
```

  

**使用过程介绍**

  

pwn 程序目前大部分为 linux 上的 ELF 格式的可执行程序，该程序同操作系统相匹配，分成了 32 位和 64 位两种。

  

所以在做题之前可以先进行一下测试，看一下是哪一种，步骤为下（以攻防世界的 CGfsb 为例）：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZQrBicGNvt61be6BxjLY6bAia9MOaicsZq7IWuAG9H3ZAtF4sSgqYHh6Fg/640?wx_fmt=png)

  

两个命令：一个 file [pwn_name] 查看文件信息，（file + 空格 + 文件名）可看出是 32 位程序。

  

第二个 checksec [pwn_name] 查看该文件开启的保护，亦可以查看文件是 32 位程序（Arch 后面的）。其中各保护代表的含义：

  

【1】RELRO：RELRO 会有 Partial RELRO 和 FULL RELRO，如果开启 FULL RELRO，意味着我们无法修改 got 表。

  

【2】Stack：如果栈中开启 Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary 的方法来绕过。

  

【3】NX：NX enabled 如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的 callesp 或者 jmp esp 的方法就不能使用，但是可以利用 rop 这种方法绕过。

  

【4】PIE：PIE enabled 如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开 PIE 的话那么 No PIE (0x400000)，括号内的数据就是程序的基地址。

  

【5】FORTIFY：FORTIFY_SOURCE 机制对格式化字符串有两个限制，一是包含 %n 的格式化字符串不能位于程序内存中的可写地址；二是当使用位置参数时，必须使用范围内的所有参数。所以如果要使用 %7$x，你必须同时使用 1，2，3，4，5 和 6。该 5 条总结来源于：

  

```
https://blog.csdn.net/niexinming/article/details/78814422
```

  

仅入门可先看本文即可。

  

之所以先看程序是几位的，是因为静态分析工具 ida（也可动态分析，入门仅需了解静态）也分为 32 位和 64 位两种。使用时需要一一对应。

  

虽然 64 位的 ida 也可打开 32 位的 ida，但无法进行反汇编查看伪代码（32 位 ida 打开 64 位的同理），ida 下载后自带两种打开方式：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZX4E8LjuEriaZ5z1hfAmWjk9lW7UFjXw98GjJdVzkvcfkKLo74c7cv6g/640?wx_fmt=png)

  

使用步骤（以该题为例）：

  

上面已知该程序为 32 位，所以打开 ida.exe 并用 ida 打开该程序：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZwCOKXibGoWqhYnj2bam7GFelsuWHHecZlTK4Ixh1mxRttswSDRjVCUw/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Z5klYBGosCX9H8UZftnCjxoYJ6Keiasibvj2AdeQgOJxh3frAdFEWvP2A/640?wx_fmt=png)

  

打开后界面如下：左边是函数区，右边是汇编代码区。单击右侧区域后，空格可切换函数汇编和程序汇编两种格式。

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZKyibTHkW9aTdcx6WjHI26qELTPzb0qAefmgJZqGZdWbjHY1ddzPR70g/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZDsZ8jnlHsQxXicib6hze6AcwtUR39CUPSA8Qm4hibpG66BmzR4pibNLBdg/640?wx_fmt=png)

  

按 Tab 键或 F5，可查看反汇编的伪代码，效果如下（部分程序被加工过，如函数不能反汇编，或反汇编出的内容比较杂乱，就需要自己处理了。入门的话暂时接触不到）：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZCRaeS8uUhX44hFBI0RPbQrK20osOVTQicgX5gGicgZCuZIFNxXCHzwXQ/640?wx_fmt=png)

  

好了，有了伪码，就可以分析漏洞，寻找可利用点了。

  

pwntools 工具，安装过程网上各种各样，初次安装又会遇到各种各样的问题，所以需要自己有耐心，一点点通过搜索解决。具体过程在后文中边使用边讲解。

  

**2**

  

**如何区分堆题和栈题**

  

  

pwn 分支的题目，分为堆题和栈题，作为新手入门而言，基本都是自栈开始。

  

所以，需要在开始前对所做题是堆题还是栈题进行简单判断，再快速判断该题自己是否可以做，要不然很可能浪费时间。

  

其中堆、栈（也有人称栈为堆栈，名称不同意义相同）区别有六点，分别是：1. 在申请方式上；2. 申请后系统的响应上；3. 申请大小的限制；4. 分配空间的效率上；5. 堆和栈中的存储内容；6. 存取效率的比较。

  

我们可以在申请方式上对堆、栈进行区分：

  

栈：它由编译器自动管理，无需我们手工控制。

  

堆（heap）: 申请和释放由程序员控制，并指明大小。在 C 中使用 malloc 函数。

  

如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZASXntXlyia3kUrt6hLwia542FV9sQRTRaeHDYbdvreC2vDz60USUDRFQ/640?wx_fmt=png)

  

一般情况下，出现这种 malloc 函数有一半可能是堆题，可以找找资料看该题是否自己还没掌握的堆题。如果同时出现 malloc 函数，且函数中开辟空间的大小还是个变量，那这道题八成是堆题了。

  

而如果没有 malloc 函数，那基本上就是栈题了。如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zxt0VwOMbUR473f7gciaCctRzdQicW5nbzc3nQBbApacWANNiaOjmBqcPw/640?wx_fmt=png)

  

**3**

  

****栈题主流 fms 和栈溢出漏洞****

  

  

fms 同样分为 32 位 fms 和 64 位 fms，做题方法略有不同，本人有一篇细讲 64 位的：

  

```
https://www.anquanke.com/post/id/194458
```

  

个人认为先有解题经验，再去看各种理论文章，可以一一对应，快速理解。

  

本人文章已详细讲解 64 位 fms，故这里仅以攻防世界的 CGfsb 为例，讲解一下入门新手应如何解题：

  

格式化字符串漏洞特点是 printf 函数没有使用格式化字符，仅使用一个指针，如下图红色方框所示（出现这种类型的 printf 且还可以通过别的方法控制该函数中的变量 如此出的 & s，那么绝对存在格式化字符串漏洞可利用）

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zc4kRRwRoiahJJDDd1ZEcPj8l57XMn663HnVTPD47XCb55SyqsDR1E9w/640?wx_fmt=png)

  

利用过程：

  

首先要固定格式（红色方框中的 r 可以自行命名，但命名过后，后面就需要使用相同的变量名。这也是为什么网络中各位大佬写的 exp 中有的是 r 有的是 sh 等等）。

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZKhyFWLf4KzWib1faSichBnAt1Me4FOyc0AAv02ia7kgNibvicHFranic72cg/640?wx_fmt=png)

  

接下来，需要达到漏洞点（不管哪种题，都是在找到漏洞点后，先写出绕过代码，绕过程序的不可利用部分，达到了利用点）。比如该题，我们可利用点为 printf(&s)。

  

其中 & s 为可控变量，所以我们只需达到可以对 s 输入内容的地方，就可以通过控制变量来利用 fms 漏洞了。该题中无用的地方是红色方框中的输入：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZoQgY9CJ710SnjsIrHwWeiaZK3g7JrhiaHABnGcq2Q2RCWV0t2JHgIWmw/640?wx_fmt=png)

  

所以绕过方法就是随便发送（即输入，read 是读入函数）一些内容即可（不同的绕过有不同的方式，比如加入需要输入特定字符才能绕过，那就需要就题而论了），如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZLwvhiaB5QTdBf5xgs2JQGVt9BbNzthQp13wtj3WfP6v888c04mXNuDQ/640?wx_fmt=png)

  

绕过以后，就进入了可利用点，即对变量 s 输入的地方，编写利用代码如下：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zz2HXaheL5DkCIX6Q7CVTYZENRpQn5zOXTia7GGwp3gIdZcgUVqSyTtg/640?wx_fmt=png)

  

其中，payload2 之所以如此构造，是因为 fms 漏洞中，%n 会将一个地址中的值进行修改，修改的数字取决于在 %n 前面一共打印了几个字符。

  

然后 p32() 是打包函数，将一个数值（一般是对一个内存地址进行打包），32 位中一个地址是 4 个字节（拓展：u32() 是解包， p64() 是 64 位程序中的打包函数，u64() 是解包）。

  

而该处 p32() 中的地址是变量 pwnme 的地址，也是我们想要修改的变量。要将其修改为 8，然后一个地址是四个字节，所以再加四个 a，共八个字节，即可通过 %n 将这个地址（即该 pwnme 变量）中的值修改为 8（在伪代码中双击变量名即可跳转到下图界面）：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZHlFvyibBMJlv5cxbxHkjJDykoWEeHxCwMnXVr9Z9BBnRbfQncF9FoxA/640?wx_fmt=png)

  

然后又因为格式化字符串存在一个偏移问题，所以需要先找出该字符串的偏移才可，这也是为什么是 %10$n 而不是 %n。此处的偏移是 10，$ 前的 10 就是偏移量。

  

什么是偏移量？偏移量就是，我们的 %n 等格式化字符都是修改对应位置的值，所以我们要找到偏移，使 %n 对应到我们的地址。如下图：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZGCoziawVKweibjTvDoKDJ6vvDudxdMayQMh1t3BlfWrdVuja3iabfmG7Q/640?wx_fmt=png)

  

其中以四个 a 为参照，a 的十六进制为 61，a 后面的格式化字符 %x 依次输入对应位置（1、2、3、4...）的内存中的值的十六进制。

  

依次计数可知，第十个 %x 中的值的十六进制对应 4 个 a，即我们格式化字符串开始的位置。

  

之所以以四个 a 为参照，是因为在 32 位程序中，是以四个字节为一组的。所以一个偏移也对应四个字节。计算可得偏移为 10。

  

在我 64 位 fms 格式化漏洞文章中有一个我自己写的函数，直接调用可以自动算出偏移。链接：

  

```
https://www.anquanke.com/post/id/194458
```

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZRZpOByECRiaKnOL1Z96wrCrJjwfywiacB9u1C5ghvGN78ItysuPnGBiaw/640?wx_fmt=png)

  

好了，exp 已写完，接下来开始进行测试。测试的话不一定要到写完之后才可以进行，可以边写边测试，每完成一小块 exp 即可进行一次测试，看一下是否符合自己的预期。

  

最后执行完成的 exp 获取权限。获取 flag（由于该题作为入门题，直接执行了 cat flag 命令，所以不需要权限）。执行 exp 的命令为 python exp.py（因为我们的 exp 是 python 脚本，exp.py 的名字即文件名可自行修改）。

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZrB1BSE42gLnMia0OHA79dibfEndwpPibmvIcgFHiadrrgNOPBfNW5VibhvA/640?wx_fmt=png)

  

至此，一个简单的格式化字符串漏洞就利用成功了。有了一次简单的利用，就可以参考比较详细的格式化字符串漏洞的讲解，边对照边学习，进而更快学习，更好入门。建议先将格式化字符串漏洞研究懂，然后就可以由点及面的更好的学习了。

  

于此附上几个格式化字符串漏洞的详细讲解，如下：

  

发表于 i 春秋的一个详解，主讲 32 位：

  

```
https://www.cnblogs.com/ichunqiu/p/9329387.html
```

  

wiki 上的一个对 fms 的详解即利用，有栈有堆，建议先学完栈后在学堆，同样是以 32 位为主：

  

```
https://wiki.x10sec.org/pwn/fmtstr/fmtstr_example/
```

本人写的 64 位利用详解：

```
https://www.anquanke.com/post/id/194458
```

**4**

  

****简单栈溢出入门****

  

  

进行必要的检测步骤，查看开启了哪些保护，以及用 ida 打开查看伪码：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zn1voyA8uXSVhNukX16wB3UTicPr4I54eEOoGDwWwOApEcLasv05y4oA/640?wx_fmt=png)

双击左侧 main 查看其伪码就一个函数，双击该进入查看其内容：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Z8MlQ3SnbpjfGcw1yppzvRRAXkMd5CR65TaE0Qdfibye39WWE5aSoXqw/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Z7WNNS4wNJm6iapBCOhCNRIQzmW9aJdvhIlNdmY1BRticJ0J3jta3bib5w/640?wx_fmt=png)

  

可以看到一个 read 函数，而输入的字节数位 0x100，但是其大小为 0x88 个字节数，明显可输入字符大于变量 buf 的长度，所以存在溢出（溢出就是你可输入字符的字符数比它给定的变量字符数的大小要大，大的越多越好）。

  

由上可知，溢出漏洞的特点就是：1. 有一个可输入函数；2. 该函数输入的变量的原定大小要小于你实际可输入的大小。满足这两个条件，那么是溢出漏洞的可能性，就八九不离十了。

  

入门级原理如下：

  

首先要知道，之所以可以溢出利用，是因为我们通过溢出可以控制程序在该函数运行完后，接下来要调用的函数，即 return 到哪里。我们双击 read 函数中的 buf 变量可看到 00000088buf，往下面一直拉可看到一个 00000000 s 和 00000004 r，如下图。

  

其中 buf 即我们输入内容的变量，s 是标记上一个函数（即使由哪个函数跳转而来的），r 是标记下一个函数，即该函数执行完后，要跳转到哪里去继续执行，而 buf 的大小为 0x88 我们可输入大小为 0x100，所以我们可以已知输入到 r 的位置，来控制程序运行完后要执行哪个函数。

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Z6uwMuvME1vIZIvloiabT5ByRHsl1NFGic1bEUFIiclkRgviaLUGKFe981w/640?wx_fmt=png)

  

利用过程如下：

  

首先，固定框架如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZkwQTEDvhlxzhEPlluJo8tBUdxI5VQhj6cvs5KYrnUTib0cqhB01F7eQ/640?wx_fmt=png)

  

绕过无用代码：通过 ida 可知，该程序直接就是输出一段用来提示的字符串 “Input:” 后就可以直接输入了，所以该处不需要绕过不可利用的代码，如下：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZIxMB0VxZS0G4CBAOH3cpqrcibpZFB7r6TTlvfbmZw9yiaRBbGbU0aUaA/640?wx_fmt=png)

  

接下来构建 payload，通过溢出漏洞来进行利用：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZydiclFcKqM6ZsZEAVdnwvWwqXBRhXkKTuz4njaS95yhtZfhT6MZMYbQ/640?wx_fmt=png)

  

其中'a'*0x88 就是为了将 buf 给填满，然后就可以对 s 和 r 进行修改了。在入门阶段 s 我们暂时用不到，且影响不是太大，所以可以随便填充。

  

此处以 4 个 b 进行填充（因为是 32 位程序所以地址是四个字节，我们要填充就要用四个字节的字符来填充，内容任意）。

  

后面的就是填充 r 即 return——我们要执行的函数，又因函数都是有参数的，所以后面还要加上相应的参数。

  

我们再次明确一下我们做 pwn 题时的目的，就是获取目标靶机的权限。而获取权限有两个函数，最常见也是最常用的就是 system，然后是偏僻少用的 execve 函数，作为入门，我们此处使用 system 函数。

  

这个函数，就是程序中原来用来执行输出字符串命令的函数。因为程序中有该函数，所以我们可以直接利用（至于没有的话，我们就需要先泄露 libc 然后寻找 system 在 libc 中的偏移，进而获取其地址。此处仅讲直接利用，作为入门理解原理，参照大神们的细讲相互对照学习够用了）。

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Z5JyorpwNHmuFJ4FVkIM5KLmwRPevGICd4lj43bOllBxicw565RJOTgw/640?wx_fmt=png)

  

在我们使用程序中原有的函数时，我们可以利用 plt 表（每个程序都需要用到的两个表，plt 表和 got 表。got 表是用来链接 libc 中的函数的，plt 表是用来链接程序中已有的函数的，作为入门可以暂时这么理解，待掌握后就需要自行搜索大神们的文章正确掌握了）。

  

利用如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZSdp8nqkxiavDf2mbib3rdOkQyvnx9QEwvZ2MZCPG2HicROeay2Sunsc4A/640?wx_fmt=png)

  

图中首先将该程序以 ELF 文件格式进行解析并将解析后的结果给变量 file，接下来在解析后的结果 file 中使用 plt 表，并查找其中的 system 函数的地址赋值给 sys_plt 变量，最后将该函数的地址用 p32() 打包为 payload 做准备。

  

好了，这样将 r 覆盖后，我们就可以控制在该函数运行完之后跳转到 system 函数了。接下来想要获取权限，我们就要执行 system('/bin/sh') ，即函数我们已经跳转到 system 了，还缺个参数：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZMiaUb0XwZj6e4CyjlxB9OH0x7J1zHicnzNOMlAFsSiaQCke2oSQLPIZHg/640?wx_fmt=png)

  

我们可以先通过 ida 的这个功能搜索程序中已有的字符串，看一下是否已有 '/bin/sh'。该字符串可作为参数利用。可以看到存在如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zu4Hjt99yMbbTjfZ21kOmrITKlUickbN3jZAibf3BwOpWxhADkjzmkibxQ/640?wx_fmt=png)

  

双击查看地址：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZSnl0Gk4nQOHL2pq4fF0f1MZBeEnerIvgibHEbJnGhqhMxdpU43e1Eicg/640?wx_fmt=png)

  

找到 “/bin/sh” 的地址为 0x0804a024，用 p32() 打包如下：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZYE1r2J2QYG4WsRDhq7A1sVdpGSokNrnX5ewwywrQPD5FM3L9Yvya4w/640?wx_fmt=png)

  

这样就可以了吗？我们来测试一下：  

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3Zar8iaWaibpjRzjHP1G1kFlxKf735R1LsfnpQHgkmtwsiazLENSaPl7K5w/640?wx_fmt=png)

  

可以发现命令 ls 并未执行，也并没有获取到系统权限，那是因为在 32 位程序栈中，参数距离调用函数中间还隔了四个字节（具体的暂时不做了解）。所以只需要随便再填充四个字符就可以获取权限了，如下：

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZaTtiaZYQ4vXiaUoh93MiakiaRicCnOrakoiaFzcXSM5T0rFjIxgw3ia0Mz8icg/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56dRm7QQPY9wCAZgLuiarF3ZJcIAicd3ibgp5CnuGT313e551x7a1Bmx8gkWjGjFAOmsl0vBfaOwhr6w/640?wx_fmt=png)

  

可以看到命令 ls 成功执行。  

  

此处给出几个溢出漏洞利用的详解，如下：

  

此题详解：

  

```
https://www.cnblogs.com/chrysanthemum/p/11768058.html
```

  

栈溢出详解：

  

```
https://www.secpulse.com/archives/70608.html
https://segmentfault.com/a/1190000020325723?utm_source=tag-newest
https://www.jianshu.com/p/6a1235d99176
```

  

**5**

  

**结语**

  

  

pwn 其实并不难，我们要注意以下几点：

  

第一：我们要明确我们的目的，是通过利用程序中的原有片段来获取目标靶机的权限；

  

第二：想要利用已有片段就需要知道该片段在内存中的地址；

  

第三：不管哪个漏洞，其实都存在其原理，只要我们理解了原理就可以进行利用；

  

第四：在刚入门时我们学习，是一个一个漏洞点分开利用单个学习，但在我们掌握后就是对多个漏洞点同时利用，相互作用进而获得靶机权限。

  

感谢阅读。继续加油！

  

- END -

  

  

往期推荐

  

[![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s56wxRGkeQkNp5Rj9W4r5aUiaqQklRR3o5IMNzBBkCX8QFYZHEX0Lzf3mgVWHfRiaph8jgS0icITvvbdg/640?wx_fmt=png)](http://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247491252&idx=1&sn=0587902bf1754ad8ef0a701a41682edc&chksm=9b393805ac4eb113a9bcee81bfd9eee4684b6b0e1b8f68d689ec54ea2748e336e7b3d3c31c7c&scene=21#wechat_redirect)

C/S 架构系统渗透测试

[![](https://mmbiz.qpic.cn/mmbiz_jpg/WTOrX1w0s54gcW8GhcSaWq28addf6eaQBlpibAZMiapSXQSJalSZjhkHibjju4ykZLLqndSPYLBNn71Wj8dwBMgCA/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247490975&idx=1&sn=a7e7e4e5403f8c1a0ade50098c4898c2&chksm=9b393b2eac4eb2384e63458090115242485376565ab451d6f8ad5ca1e2ab8b778bedf7d05e89&scene=21#wechat_redirect)

抓取 HASH 的 10001 种方法

[![](https://mmbiz.qpic.cn/mmbiz_jpg/WTOrX1w0s57DJicf5wIXN3qY9jkGbAVo4gpTCRWnUezjibaiaPvDpablgvsPLcdFkH4WGFPE9diceBtQwVQGoPo0VA/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247490788&idx=1&sn=36a28378addb09fa2d3594e9b09f8c1b&chksm=9b393a55ac4eb343c4830d25af6053150d2322258b66199bfa0014938d8c0dfb288e223bc259&scene=21#wechat_redirect)

从访客网络到潜入机房

  

长按下方图片即可**关注**

![](https://mmbiz.qpic.cn/mmbiz_png/WTOrX1w0s564Abiad4b2nUggeFBz8QyCibiaRBNn0A5YI88OyFjU8fn2Isf9bat4vQn18NwG6cXxVOSuKiapNm2nibQ/640?wx_fmt=png)