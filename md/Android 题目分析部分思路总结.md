<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458459226&idx=1&sn=9efd4775e08ed6ec218912b240bfab67&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpdBDCbbEPhR25YhiafaaShibQDCTUEtPNeWuk8Z6rwMjK2b0YzkRGiavJA/640?wx_fmt=jpeg)  

本文为看雪论坛优秀文章

看雪论坛作者 ID：以和爲貴

我总结了几种经典的类型，列个目录吧：

1.Strange apk：firda dump 正在运行的 dex 文件  

2.app3: 怎么打开. ab 文件，jeb 动态调试  

3.ph0en1x_100：jeb 动态调试  

4.easydex：so 层静态分析，idc 脚本

```
protected void onCreate(Bundle arg5) {
        super.onCreate(arg5);
        this.setContentView(0x7F09001D);
        View input_str = this.findViewById(0x7F070022);
 // 输入字符串
        this.findViewById(0x7F07008A);
        ((Button)input_str).setOnClickListener(new View$OnClickListener(this.findViewById(0x7F070037)) {
            public void onClick(View arg9) {
                String str1 = ""; 
// 两个字符串临时存储变量
                String str2 = "";
                int t = 0;
 // 临时变量
                String str = this.val$ed.getText().toString();
                int num_30 = 30;
                if(str.length() == num_30) { 
// 输入的字符串的长度为30
                    while(t < 12) {
                        str1 = str1 + str.charAt(t);
 // 将前12个输入的字符存储到str1里面
                        ++t;
                    }
 
                    str1 = f.sctf(str1); 
// 跟进去发现是将前12个字符进行base64加密
                    while(t < num_30) {
                        str2 = str2 + str.charAt(t); 
// 将后12个字符存储到str2字符串里面
                        ++t;
                    }
 
                    if(str1.equals("c2N0ZntXM2xjMG1l")) { 
// 根据字符串1和该字符串相匹配，直接就能解出来前12个字符sctf{W3lc0me
                        Intent v4_1 = new Intent();
                        v4_1.putExtra("data_return", str2);
//返回.t文件中分析str2字符串的加密操作
                        s.this.setResult(-1, v4_1);
                        s.this.finish();
                    }
                    else {
                        Toast.makeText(s.this.getApplicationContext(), "something wrong", 1).show();
                    }
                }
                else {
                    Toast.makeText(s.this.getApplicationContext(), "something wrong", 1).show();
                }
            }
        });
    }
}
```

首先看一下 java 层  

（JEB 谁用谁说好，我感觉这个比 as 好用，动态调试的时候不用操作太多，还可以修改参数类型和名称，比 jadx，jdgui 好用好分析，还可以保存上次没有分析完的程序）

  
先看 manifest 文件，找到程序的入口点：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp6lFCAa7WkGC09Us3cicXLn2UPsPVJEFIQZk0ajrVqVBjfrTeD6spaSg/640?wx_fmt=png)  
  

sctf.demo.myapplication.t 这个是程序的入口点。

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpUZEkrIRQHnxzETKhZoNAZhkVO66s9yS0oAiaicH2mCRicQRuNHQq1FF7Q/640?wx_fmt=png)  
  

但是找不到啊，这里我猜测应该就是在 app 运行过程中动态释放出来的。  

那就用 frida_dump 试试吧。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpMN4ic1oST4KxwUQxeMo5HFI1MibSXcvnUkelr5X85GQ0T7GWmiaLyor9Q/640?wx_fmt=png)  
  

在指定文件夹里找到 dump 下的 dex 文件进行分析就可以了。

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCphV3o7jopyEaqLIO3SBZZz8BxMNHac1yqEiaqTu7dYnrPR63rBCzhiaNw/640?wx_fmt=png)  

只有第一个 dex 文件能找到了. t 文件。

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpU9ehOW5ClZzcOBeKyhqfLu7HmPlCOrFbxlqFpzUYmT9wAl5JXk2PSg/640?wx_fmt=png)  

在这个. t 文件的 oncreate 又定位到了这里：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCprvedbQq96ibXiciaqzeGWcDGWOsyFE0FVhRvs4kaaekSuBhRbUuTEwzZw/640?wx_fmt=png)  

因为程序一开始分析的是没有 sctf.demo.myapplication.t 文件了 xml 文件里只有 sctf.demo.myapplication.t 和 sctf.demo.myapplication.s 文件，所以这个 MAIN 应该是 sctf.demo.myapplication.s 文件里面的，所以就要分析 sctf.demo.myapplication.s 文件了。

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpibXCdHSblqSicM4aiaiaSmPfQCKQiaiclxLPUWhGEN7PCwttDialQjrEl0n4g/640?wx_fmt=png)  
  

然后修复一下代码，修改一下变量的名称，加一些注释便于分析：

```
public class t extends AppCompatActivity {
    public t() {
        super();
    }
 
    protected void onActivityResult(int arg9, int arg10, Intent arg11) {
        View v0 = this.findViewById(0x7F07008B);
        View v1 = this.findViewById(0x7F070023);
        if(arg9 == 1 && arg10 == -1) {
            try {
                MessageDigest str = MessageDigest.getInstance("MD5");
                str.update("syclover".getBytes());
 // 将syclover字符串进行md5加密
                String temp_str = new BigInteger(1, str.digest()).toString(16); 
// 将加密后的字符转化为字符串8bfc8af07bca146c937f283b8ec768d4
            }
            catch(Exception v5) {
                v5.printStackTrace();
            }
 
            if(f.encode(arg11.getStringExtra("data_return"), temp_str).equals("~8t808_8A8n848r808i8d8-8w808r8l8d8}8")) {
                ((TextView)v0).setVisibility(0);
                ((Button)v1).setVisibility(4);
 // 去除所有的8之后剩下~t0_An4r0id-w0rld}
            }
            else {
                Toast.makeText(this.getApplicationContext(), "one more step", 1).show();
            }
        }
    }
```

通过这段代码的分析可以得到前半部分的 flag：sctf{W3lc0me。

总结一下就是通过 base64 解密得到的（详细分析过程在代码注释）。

返回. t 文件对 str2 字符串进程分析。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpTlyKiahBgcyaLPOJ78Bk7kd4KLSF79QgEibvakXBUCKMrtWlSysIwbPg/640?wx_fmt=png)  
  

修复一下代码：

```
public static String encode(String temp_str, String str) {  // 将data_return字符串和加密后的字符串8bfc8af07bca146c937f283b8ec768d4格一位放一个
       int len_temp_str = temp_str.length();
       int len_str = str.length();
       StringBuilder t_str = new StringBuilder();
       int t;
       for(t = 0; t < len_temp_str; ++t) {
           t_str.append(temp_str.charAt(t));
           t_str.append(str.charAt(t / len_str));  // 每次都是只能取到第一个字符8
       }
 
       return t_str.toString();  // 返回字符8
   }
```

这个是中间的 encode 的函数（代码修复之后的）分析：

```
private void a() {
        SQLiteDatabase.loadLibs(((Context)this));
 // 加载数据库
        this.b = new a(((Context)this), "Demo.db", null, 1);
        ContentValues v0 = new ContentValues();
  // 实例化v0这个对象，用于存储用户名和密码
        v0.put("name", "Stranger");
 // name = Stranger
        v0.put("password", Integer.valueOf(0x1E240));
 // password = 0x1E240 = 123456
        com.example.yaphetshan.tencentwelcome.a.a v1 = new com.example.yaphetshan.tencentwelcome.a.a();
 // 初始化v1对象
        String v2 = v1.a(v0.getAsString("name"), v0.getAsString("password"));
 // 将获取到的用户名和密码的值转化为字符型变量存储到v2中,调用的v1.a方法，然后跟进去分信息v1.a的方法，如果传入两个参数，就是分别取0-4个字符,就是返回Stra1234
        this.a = this.b.getWritableDatabase(v1.a(v2 + v1.b(v2, v0.getAsString("password"))).substring(0, 7));
  // 调用了数据库函数，将刚刚的变量作为参数传入,调用了v1.a的方法和v1.b的方法
        this.a.insert("TencentMicrMsg", null, v0);
    }
```

通过分析后半部分代码得到了：~t0_An4r0id-w0rld}  

总结一下就是 md5 解密，然后分析 encode 函数，得到 flag 的后半部分  
这道题的关键所在就是，找到程序的入口点，dump 出正在运行的 dex 文件，字符串加密简单分析即可得到。

```
String v2 = v1.a(v0.getAsString("name"), v0.getAsString("password"));
```

打开之后一看是. ab 文件（在对安卓手机进行取证时，经常需要备份手机的应用程序数据，备份后得到的数据文件为 ab 格式，ab 文件一般分两种，一种是没有加密，这种文件前面有 24 字节的文件头，文件头包含 none 标志，文件头之后就是数据；一种是加密的备份文件，它的文件头就比较复杂了，文件头包含 AES-256 标志。）  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp4ficd8iapKicGIwP1VVqiaw4ndlWbbtjPlDPSeJryJiblRe0iaqcuwLnFaCw/640?wx_fmt=png)  
一般的话. ab 文件是用这个文件进行操作的 ![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpMBIW9HVUxI3eq7eAdzPbTdzlQG7GUic3hHkaVFwKn47XibXSLzibrgFWA/640?wx_fmt=png)  
我总结出来一般的话使用这两条指令中的一条：  
java -jar abe-all.jar unpack app3.ab app3.jar  
java -jar abe-all.jar unpack app3.ab app3.tar  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpe20qOrbCicGjskuiaOiawdqsJkOkvDd8YePzyiaKqich7O6wvOFA8kPsToA/640?wx_fmt=png)  
将. ab 文件转化为. tar 文件 ![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCplaT5seeVibWZepLzZ5myEfr9yQztPdibpL2tQOPjVRoLbPc7oxia9rkibA/640?wx_fmt=png)  
解压缩之后发现了 apk 文件，就可以进行分析了：

  
先从程序的入口点开始分析：

```
this.a = this.b.getWritableDatabase(v1.a(v2 + v1.b(v2, v0.getAsString("password"))).substring(0, 7));
```

这个代码是调用了这个方法：

```
v1.b(v2, v0.getAsString("password"))
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCps5tkqhW7GZP4zqAibweiaDicxDTcvMhWeECbsDhgUDOgD8gib62h9Itjrw/640?wx_fmt=png)  
最后这个代码这里，由于这里是给数据库传参数的函数，所以就是要分析这个，一开始的那个 tar 文件里面解压之后发现了. db 文件，就是数据库文件，所以我猜测，这里传入的参数应该是登录数据库的密码，重点就是要分析这个函数了。

```
package com.example.yaphetshan.tencentwelcome.a;
 
public class a {
    private String a;
 
    public a() {
        super();
        this.a = "yaphetshan";
    }
 
    public String a(String arg4, String arg5) {
        return arg4.substring(0, 4) + arg5.substring(0, 4);  // 返回值截取0-4位字符
    }
 
    public String a(String arg3) {
        new b();
        return b.b(arg3 + this.a);  // 调用了b方法，跟进去分析一下
    }
 
    public String b(String arg2, String arg3) {
        new b();
        return b.a(arg2);
    }
}
```

先是外层调用了 v1.a 的这个方法：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp7O7wGW4scKONNydhjjvq8SCfsjKjiaE580bibp4ic1vX4Qtt8hH3yLfYA/640?wx_fmt=png)  

然后又内层调用了这个方法：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp7Yk7077micq1qsALEFCtR75z8ibqQiauyohv6EgXd7sSypxEC65jPicbUA/640?wx_fmt=png)

先分析这个函数的返回值：

```
protected void onCreate(Bundle arg2) {
      super.onCreate(arg2);
      this.setContentView(0x7F040019);
      this.input_flag = this.findViewById(0x7F0C004F);
  }
 
  public void onGoClick(View arg5) {
      if(this.getSecret(this.getFlag()).equals(this.getSecret(this.encrypt(this.input_flag.getText().toString())))) {
          Toast.makeText(((Context)this), "Success", 1).show();
      }
      else {
          Toast.makeText(((Context)this), "Failed", 1).show();
      }
  }
```

跟进去分析：

```
if(this.getSecret(this.getFlag()).equals(this.getSecret(this.encrypt(this.input_flag.getText().toString()))))
```

继续跟进去分析 b 方法：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpSTdMnYE0fVicGibXCMAFOZtGKKOz3Uf5AwJvNh8l2uSQeicnSQKGA49EQ/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpK7zfZkQnT2fbbT6uXEiblia5iaAoIibOgtQ8Bulr9OibFHpqbmJ7iaueIoKw/640?wx_fmt=png)  
其实也没有什么，就是 md5 加密和 SHA-1 加密。  

这里我就用动态调试的方法吧：  
先获得这个函数的返回值： ![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpKR9yXUfW29jLLSPFs4RAKVpibbkycqXa1E8YqU7HURfmef75k1iafqUQ/640?wx_fmt=png)  
跟进去下个断点：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpZia1pXialVKA4pxwmB3z8voSOL8ODnvWLHQQO5raxm5z8z9wFdaKw1mg/640?wx_fmt=png)  
  

附上进程：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpnvlYoTcA9OibIJrKN7aIEn9Nic8jdyMdaWSVbBZFqGiaU74qSf3A5iaHlg/640?wx_fmt=png)  

把 v0 的类型改为 string 类型是这样的：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpOSfyoLqjb94ic7aOicHwKj3MLLNGlys3fs8JaS6iap8A3N4icdxv82UE0Q/640?wx_fmt=png)  
  

v0 = 44e2e4457d4e252ca5b9fe9d20b3fea5  
接下来就要看看这个函数的返回值了  
v1.a(v2 + v1.b(v2, v0.getAsString("password")))  
继续下断点：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpZcoGhU0B2gLhIAJvjl7hG1WJCpvm7Ov2HfoZp7tnglVJ327oW4JAfw/640?wx_fmt=png)  
  

v0 = "yaphetshan"  
然后分析这个：  
(v1.a(v2 + v1.b(v2, v0.getAsString("password"))).substring(0, 7))  
下断点，再调：  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpZIp4lpWDoxyVfcJFVpLkTvkicWc1jF2fb8kYKx9mIhepIXOHJ7XERtw/640?wx_fmt=png)

  
v0 = "ae56f99638285eb0743d8bf76d2b0c80e5cbb096"  
然后取前七位：ae56f99（这就是登录数据库的密码了，其实直接从最后一步那里下断点就行了，我想一步步的看看加密算法的结果）  

用 ae56f99 登录数据库找到：VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=  
这一眼就是 base64 编码，直接解码就行了  
Tctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}

```
三





ph0en1x_100
```

既然 JEB 动态调试这么好用，那就再来一个题（这个题就非常简单了，直接一步到位）。

  
关键代码就是这里，修复一下代码在分析就是这样的：

```
protected void onCreate(Bundle arg2) {
      super.onCreate(arg2);
      this.setContentView(0x7F040019);
      this.input_flag = this.findViewById(0x7F0C004F);
  }
  public void onGoClick(View arg5) {
      if(this.getSecret(this.getFlag()).equals(this.getSecret(this.encrypt(this.input_flag.getText().toString())))) {
          Toast.makeText(((Context)this), "Success", 1).show();
      }
      else {
          Toast.makeText(((Context)this), "Failed", 1).show();
      }
  }
```

```
if(this.getSecret(this.getFlag()).equals(this.getSecret(this.encrypt(this.input_flag.getText().toString()))))
```

如果这个 if 分支返回为真，就能让程序正确运行。

然后 equals 的两个参数在传入之前都调用了 getSecret（）函数，所以这个函数就不再用分析了。

  
先看一下 getflag（）函数：  
再看一下 encrypt（）函数：  

终于可以用 ida 分析了：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpicMsmPZxCKwkGFVKGeI3Nsuss7DXXGUS3MTfiaTiaNOyOL1Zfc8IAd3Nw/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCphVm0Y31TpOAnor8bibaZXMyxQJzpichYtK7XNh1M0GV0lI1B4AXs1b0Q/640?wx_fmt=png)  

上 ida 导入. h 文件在改一下参数：  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpOAL0UPETh2FNSaOYWlPKP6DHaDiaDhRc4ARG018nUBgZvwzWsBVcIPg/640?wx_fmt=png)  

分析一下 encrypt 函数，发现逻辑很简单，就是将传进来的字符串的每个字符的 ASCII 码减一。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpmlicEqiaTBqXTiapoznEIuK18InG9rh1NOAK8ibbyC0Q1JDOLn3WBecudg/640?wx_fmt=png)  

对于 getFlag 函数直接用 JEB 动态调试该函数得到返回值即可：  
下好断点，附加进程：  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCphlS6xzHuoNC8erdOXFN9ZY41EywFyIKgNX1kUrlvxIje4naTicaiaZjA/640?wx_fmt=png)

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpiahTiawW3xAj5ppyLVZlqNxqLjY1TOl0EZtFiazcg0ApuTkXJ5nNEiayHA/640?wx_fmt=png)  

string@4175:"ekfz@q2^x/t^fn0mF^6/^rbqanqntfg^E`hq|"  
直接上脚本就行了：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpSE44FsQAo3b36QGKJJibc0QEBj0NoIqafib42SOx3cgibdcUicXqRFWxTQ/640?wx_fmt=png)

```
四





easydex
```

apk 没有加固：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpr6517lanqMxG0CkgmROCr8hribm6N8ewk8dYAnnSF0lfhr1a1nib8qxw/640?wx_fmt=png)  

首先看看 apk 的 java 层：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpL5dPA1lc9Io4qbuaVfzNibEM5GVjRl4h0iaPuibwfLAoTicZDZCMDeAA0A/640?wx_fmt=png)  
发现只有一些资源文件，并没有发现 dex 文件，所以 dex 文件应该也是动态加载出来的。

  
这里我尝试用 frida-dexdump 想 dump 下正在运行的 dex 文件，但是啥也没有：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpQdKAjttyHl0G2NGAykKvCuQeJEnLsCZkYW1YjKngTufwzLbP5RLAow/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpIwaSluJZ41wbXhlsh1Qo32pJZWty5tII0FH4HQ9HTZG8FLsD4iah3Wg/640?wx_fmt=png)  
所以就要分析 so 层了：  

我想着先从 jnionload 或者 java 开始的来着，但是都没有，然后我就想着从这个函数分析吧：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpUfe3icibUVeVnqFmquM2HcdicaEQKyjLX3SZich5p3RibfrZOHUsIFxuheA/640?wx_fmt=png)  
一看这么多逻辑，先动态看看程序是怎么走的吧：  
先在这里下个断点，可以找出程序在系统中（经过了异或运算）的释放的 dex 文件的位置。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCprlbHbLAbrPe6vjIYB8iaH1eic2LUClQflB8z0084qXYbSwyoujju0boA/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp1IkeFvml2y9JBmJ43PUGFOt1QMgLF0Xfg7fp1uBZXdm3CVXzxCW9ZA/640?wx_fmt=png)  

然后接着动态分析就能分析出程序的流程：  
这个是我修复之后的代码：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpkvt3THR5qYnyRWsvx0OrK1YuC73yAjX6AkaxEttBxthwLzo4XKuAQQ/640?wx_fmt=png)  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpczEG1ofRhdHPgMVg3YHkibn3oZh81TSUbNoLqxfkkKcpvjvOQJulibYg/640?wx_fmt=png)  
  

这个 31 分支这里就是解密 dex 文件的位置：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpC41OXKSQTRicXJMJqtQXBzqrVic1rMejBsqmEWGib0a7Bbh3kxedJ0A9A/640?wx_fmt=png)  
  

下面就是对解密出来的 dex 文件（从 byte_7004 开始，长度为 0x35A0C 是加密后的数据）进行的操作：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpp7raD1RgGEX4wnC6eXibFYeTDR8hP2cbwoAAcq5ZJo5iaGzcr7HParKg/640?wx_fmt=png)  
这里有两种方法：  
1. 在删除 dex 文件操作之前下个断点，然后将手机中的 dex 文件 pull 到电脑上  
2. 使用 idc 脚本直接解密出 dex 文件：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpic6aWG5oGKQnQK4p2VbgdE64uXTgia7hmlFfGALmUic8HhQgLgapghX1w/640?wx_fmt=png)  
  

然后就可以得到 dex 文件进行分析了。

但是再 dex 文件中并没有发现明显的逻辑：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpzRjP73ttm0wFnYCoyNR3ibuwTDqzXS2Mer400TX9u26F2O2m3eKnYHQ/640?wx_fmt=png)  
  

然后将字符串解密：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpav93FbdiaTpMrJjVLns7AQlucCT4gbyMmvIic6tpHf11Pq9COye7bBOA/640?wx_fmt=png)  

然后再源 apk 文件中发现了 two fish 算法（这道题的关键应该是 so 层的分析，这个 twofish 算法我还是第一次听说）

  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpibiavtm1iczRcMsqYkAfuNOlOib2E89bMQDzCkzKv2VtBIVFgDLbvEs4Jg/640?wx_fmt=png)  
  

然后找个在线解密网站就行了：  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCpLeLYEm4KlU4UevA4O6GdT4WHYNXPBR0lYAu9s1Ik86SvgkH9n5wDDQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HLno7pTT0kS9qAbPlUnVCp2T78AicocwyOvOaSj4icQV0RzW43WOXmricVMCXLABlkCicRNqSXVGiaKng/640?wx_fmt=jpeg)

  

**看雪 ID：以和爲貴**

https://bbs.pediy.com/user-home-939330.htm

* 本文由看雪论坛 以和爲貴 原创，转载请注明来自看雪社区

[![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HkyIqzria1IPg7Z7ryK4C0wzvlJBty7JQ6MEmuVTcUmraRVlxtY2xMQ73iaCW0leXsbiaGibT6yKqiahA/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458456402&idx=2&sn=f885c82e338747520d237876d3314593&chksm=b18e21d886f9a8ce962d50cb0d74cb669ac18917c11f1e3133ff93085dc7ded652f109421b37&scene=21#wechat_redirect)

**#** **往期推荐**

1. [堆、UAF 之 PWN 从实验到原理](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458457898&idx=1&sn=a3cb542d0aa67530d769da24a11cf1e7&chksm=b18e27a086f9aeb6a369c278c64790fe841d87f162a859a01cc2ce5989581be2fc53be4e3f79&scene=21#wechat_redirect)  

2.[Frida inlineHook 原理分析及简单设计一款 AArch64 inlineHook 工具](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458457019&idx=1&sn=1b8dcdc9fbce79e5b202463fec3c77cc&chksm=b18e233186f9aa27180271881bde18b3a60fd0d84b8c1508815d3e4b0fe21202d36d80dc34ef&scene=21#wechat_redirect)

3.[PWN 学习笔记【格式化字符串漏洞练习】](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458456999&idx=1&sn=888c98e867eee43d5b93ec491482560f&chksm=b18e232d86f9aa3bb4eb50b749bf52b881006641abaeb2ef0598e8658d9a35a7ecf85392ddce&scene=21#wechat_redirect)

4.[Il2Cpp 恢复符号过程分析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458455703&idx=1&sn=b62787e03e008c34b1525fc269e4ca93&chksm=b18e3e1d86f9b70be942ea83245c1d89af4b505be4ef692af56cee5068b5238ec32d75272eaa&scene=21#wechat_redirect)

5. [记一次安全产品的漏洞挖掘](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458455526&idx=1&sn=f42801fd98759f7224a3052d45b4cb25&chksm=b18e3d6c86f9b47a27170075f62d9833009f5714725c22fd190ecfd2231efed75f70c04055b2&scene=21#wechat_redirect)

6.[CVE-2016-3309 提权漏洞学习笔记](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458454449&idx=1&sn=0e7fcab06f6208c134b8388ea61af637&chksm=b18e393b86f9b02df2779e9bd4d55058cc7666c0c83945978924a0690e47ee0f449087a1ef70&scene=21#wechat_redirect)

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=jpeg)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球分享**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球点赞**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球在看**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicd7icG69uHMQX9DaOnSPpTgamYf9cLw1XbJLEGr5Eic62BdV6TRKCjWVSQ/640?wx_fmt=gif)

点击 “阅读原文”，了解更多！