<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247595004&idx=1&sn=d604ddfc8336b22f1c004457294ef94d&scene=21#wechat_redirect)

扫码领资料

获网安教程

免费 & 进群

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSFJNibV2baHRo8G34MZhFD1sjTz4LHLiaKG9208VTU6pdTIEpC9jlW6UVfhIb9rHorCvvMsdiaya4T6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

最近帮朋友抓取某币圈大佬操盘的数据，但是关键数据被加密了。通过砸壳逆向分析后，用 frida 来 hook 解密函数进行抓取。逆向难度相对简单，适合入门学习。

![](https://mmbiz.qpic.cn/mmbiz_jpg/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwMSicVRricicnJ7lAWPHdmqhg1YrOxaB3cPqeK2iczsCTaialMM8uia6FdnmQ/640?wx_fmt=jpeg)

文章目录

*   难度
    
*   工具环境
    
*   抓包分析
    
*   IDA 分析 maco 文件
    
*   frida-trace hook CCCrypt
    
*   踩坑 - 文件生成位置
    
*   总结
    

难度
--

★☆☆☆☆

工具环境
----

*   越狱 IOS 14.4
    
*   frida-ios-dump
    
*   frida-trace
    
*   IDA 7.7
    
*   HTTP Catcher
    

抓包分析
----

找到某币圈大佬的操盘记录，来到持仓页面进行抓包。

![](https://mmbiz.qpic.cn/mmbiz_jpg/CBJYPapLzSGkZTNIKkoYiaSasXLcY1Edw8ibzwFyzd8cHGWWqbrRlCxuqsmWWiaZiaBkfGfiaw8qRKswBTCjhSgUiacA/640?wx_fmt=jpeg)

ios 的 app 抓包最简单的办法就是用 HTTP Cathcer，为了方便直接转发到 mac 上。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1Edwy0iaZ9w3aumSoPvxD425IIWZypfZc7AckmqicPjWpgMxeGf7AksbHPtw/640?wx_fmt=png)

可以看到请求参数是没有加密的，但是返回的关键数据都被加密了，但是无法判断加密算法的类型。

IDA 分析 maco 文件
--------------

这里使用 frida-ios-dump 进行砸壳，砸壳的过程就不说了。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwulrcTrBZGhymJrh4ibK97lHe5wVAX3WDTNwhLvCian6aweevUJSjJDGw/640?wx_fmt=png)

找到 maco 可执行文件，这类文件很明显的特征是没有后缀名。拖入 IDA 中分析关键加解密函数。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwH7xuhvPTgCzImOALfPvBjM65Fia0NJt2RfwWnT6T3ibYTQvcYZPzxkjw/640?wx_fmt=png)

搜索 decrypt 关键字，很容易就定位到解密函数位置，从函数名就能看出是使用的 AES 加密，所以问题就简单多了。

不管代码如何封装，最终肯定是调用 IOS 官方的加解密函数，所以直接 hook CCCrypt 即可，该函数的主要参数如下。

```
CCCryptorStatus CCCrypt(
  CCOperation op,/* 加密：kCCEncrypt = 0，解密：kCCDecrypt = 1 */
  CCAlgorithm alg,/* 加密算法，如kCCAlgorithmAES128等 */
  CCOptions options,/* 加密选项，如kCCOptionPKCS7Padding等 */
  const void key,/* 加密密钥 */
  size_t keyLength,/* 加密密钥长度 */
  const void iv,/* 可选的初始化向量 */
  const void dataIn,/* 可选的输入数据 */
  size_t dataInLength,/* 输入数据长度 */
  void dataOut,/* 输出数据 */
  size_t dataOutAvailable,/* 输出数据可用长度 */
  size_t dataOutMoved/* 实际输出数据长度 */
  )  

```

frida-trace hook CCCrypt
------------------------

```
frida-ps -U

```

查看当前应用的包名。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwmTGJIjfq8CX1OKUWA7N5577bN7tcLknHjo4kN0ZNtFbqvpCwzUaaibQ/640?wx_fmt=png)

下面就是直接上 frida 进行 hook 关键解密函数。

```
frida-trace -FU -i CCCrypt

```

因为当前已经在前台运行了程序，所以就不用指定包名，直接 hook 即可。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1Edwwfm6yu53z1WFTbp7R2kMmKEAFjibzzoyXUATibxGUgGayYC1eZ5pThRg/640?wx_fmt=png)

执行 frida-trace 之后会自动生成一个模板，需要手动修改。

```
{

  onEnter: function (log, args, state) {

      log("进入加密函数了。。。。")
      log('CCCrypt('+
          'op='+args[0] +
          ', alg=' + args[1] +
          ', options=' + args[2] +
          ', key=' + args[3] +
          ', keyLength=' + args[4] +
          ', iv=' + args[5] +
          ', dataIn=' + args[6] +
          ', dataInLength=' + args[7] +
          ', dataOut=' + args[8] +
          ', dataOutAvailable=' + args[9] +
          ', dataOutMoved=' + args[10] +
          ')'
      );
      //保存参数
      this.operation   = args[0]
      this.CCAlgorithm = args[1]
      this.CCOptions   = args[2]
      this.keyBytes   = args[3]
      this.keyLength   = args[4]
      this.ivBuffer   = args[5]
      this.inBuffer   = args[6]
      this.inLength   = args[7]
      this.outBuffer   = args[8]
      this.outLength   = args[9]
      this.outCountPtr = args[10]
      //this.operation == 0 代表是加密
      if (this.operation == 0) {
          log("进入加密函数了......")
          //打印加密前的原文
          console.log("In buffer:")
          console.log(hexdump(ptr(this.inBuffer), {
                  length: this.inLength.toInt32(),
                  header: true,
                  ansi: true
              })
          )
          //打印密钥
          console.log("Key: ")
          console.log(hexdump(ptr(this.keyBytes), {
              length: this.keyLength.toInt32(),
              header: true,
              ansi: true
              })
          )
          //打印 IV
          console.log("IV: ")
          console.log(hexdump(ptr(this.ivBuffer), {
              length: this.keyLength.toInt32(),
              header: true,
              ansi: true
              })
              )
      }
},
  onLeave: function (log, retval, state) {
      if (this.operation == 1) {
          // Show the buffers here if this a decryption operation
          log("进入解密函数了......")
          console.log(hexdump(ptr(this.outBuffer), {
              length: Memory.readUInt(this.outCountPtr),
              header: true,
              ansi: true
              })
          )
          console.log("Key: ")
          console.log(hexdump(ptr(this.keyBytes), {
              length: this.keyLength.toInt32(),
              header: true,
              ansi: true
              })
          )
          console.log("IV: ")
          console.log(hexdump(ptr(this.ivBuffer), {
              length: this.keyLength.toInt32(),
              header: true,
              ansi: true
              })
          )
      }
  }
}

```

这段代码可以当做模板直接复用。

执行 frida-trace 后，来到被需要抓取的页面，就会触发解密函数。此时通过 hexdump 解密出来的数据就是我们需要抓取的了。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwrByGoibOsibW9MzO3zeha5iaC108gbvAMWjTibxcPMsicCW5ggeDA10Deeg/640?wx_fmt=png)

但是 hexdump 只是方便我们查看，如何才能直接 dump 字符串的内容呢？这里就需要用到 Memory.readCString() 来读取字符数据。

同时根据需要，最终的目的是为了抓取数据。那么我们可以把解密后的数据写入到文件中进行保存。修改代码如下：

```
onLeave: function (log, retval, state) {
if (this.operation == 1) {
log("进入解密函数了......")
const jsonData = Memory.readCString(ptr(this.outBuffer));
const fileName = Math.random().toString(36).substring(7) + ".json";
const filePath = '/tmp/coin2/' + fileName
log(filePath)
log(jsonData)
var file = new File(filePath, "w");
file.write(jsonData);
file.flush();
file.close();
}
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1EdwxMkFYpljzeW9AaZ5MdCjXN5RfvX2s7oZnWI5x8jXicvbe6MicvfynPFQ/640?wx_fmt=png)

踩坑 - 文件生成位置
-----------

由于要保存解密后的数据，所以需要写文件。因为是在 mac 上执行的命令，所以一开始我误以为生成文件的位置也是在本机上。于是开始 debug，发现写入文件的代码既不报错也找不到生成后的文件。在这里浪费了很多时间【我裂开】。

虽然修改代码和执行 frida 的命令是在 mac 上，但是脚本最终是在 ios 设备上执行的，所以 frida 代码中生成的文件也是在 ios 上。

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGkZTNIKkoYiaSasXLcY1Edw1dmqQMhkTKuibIzJSkQpQ4L6aZEUVpH813nhQbY4NicU8AM3GdBaibzzg/640?wx_fmt=png)

目标是抓取一个用户的操盘数据，所以也不用写脚本，直接手动刷一遍即可 dump 所有交易记录了。

总结
--

本次 IOS 的逆向过程非常简单，主要是目标 app 没有做越狱检测，也没有使用魔改的加密算法，适合新手入门学习。

```
来源：https://zgao.top/ios逆向一-破解某币app加密数据

```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！  

@

**学习更多渗透技能！体验靶场实战练习**

```
（hack视频资料及工具）


```

（部分展示）

往期推荐

【精选】SRC 快速入门 + 上分小秘籍 + 实战指南

爬取免费代理，拥有自己的代理池

漏洞挖掘｜密码找回中的套路

渗透测试岗位面试题 (重点：渗透思路)

漏洞挖掘 | 通用型漏洞挖掘思路技巧

干货｜列了几种均能过安全狗的方法！

一名大学生的黑客成长史到入狱的自述

攻防演练｜红队手段之将蓝队逼到关站！

巧用 FOFA 挖到你的第一个漏洞

**看到这里了，点个 “赞”、“再看” 吧**