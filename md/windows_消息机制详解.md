<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ilVnpOAtvQNcsXsFXbCmWw)

**首发于奇安信攻防社区：https://forum.butian.net/share/1609**

前言
--

windows 是一个消息驱动的系统，windows 的消息提供了应用程序之间、应用程序与 windows 系统之间进行通信的手段。要想深入理解 windows，消息机制的知识是必不可少的。

基础
--

进程接收来自于鼠标、键盘等其他消息都是通过消息队列进行传输的

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyx9iabSicnFReia6KMGK0L6MPxarSicbwdNtB5srwmEI7OKWuOFaK44R9jA/640?wx_fmt=png)

常规模式下，有一个专用的进程来接收这些消息，然后再插入某个进程的消息队列，但是这样的话会涉及到频繁的进程间的通信，效率很差

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyjlSAG0gpCpvuAu9ZPpMMGrQ0tWkdicaRHtlEVco2ScJFeFhVBIJ2qkw/640?wx_fmt=png)

windows 为了解决这一问题，因为高 2G 的内核空间每个进程都是共用的，所以微软想到把消息的接收放到了 0 环，使用 GUI 线程

<1> 当线程刚创建的时候，都是普通线程，指向的是 SSDT 表

Thread.ServiceTable-> KeServiceDescriptorTable

<2> 当线程第一次调用`Win32k.sys`时，会调用一个函数：`PsConvertToGuiThread`，我们知道在 3 环进 0 环的过程中会取得一个调用号，当调用号在 100 以下的时候，在`ntosknl.exe`里面，当调用号大于 100 则是图形处理函数，调用`Win32k.sys`

如果是一个 GUI 线程，`win32Thread`指向的就是`THREADINFO`结构，如果是普通线程，这里就是一个空指针

主要做几件事：

a. 扩充内核栈，必须换成 64KB 的大内核栈，因为普通内核栈只有 12KB 大小。

b. 创建一个包含消息队列的结构体，并挂到`KTHREAD`上。对应的就是`MessageQueue`属性

c.Thread.ServiceTable-> KeServiceDescriptorTableShadow，把`Thread.ServiceTable`指向 SSDTShadow 表，这个表既包含了 SSDT 表里面的函数，又包含了`win32k.sys`里面的图形函数

d. 把需要的内存数据映射到本进程空间

总结：

<1> 消息队列存储在 0 环, 通过`KTHREAD.Win32Thread`可以找到

<2> 并不是所有线程都要消息队列，只有 GUI 线程才有消息队列

<3> 一个 GUI 线程对应 1 个消息队列

窗口与线程
-----

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyXfeBMAnLwRfVgibt7PicadibqngKzEb0M8UREeOvCktuKfAhxawVSWZSg/640?wx_fmt=png)

我们知道创建 windows 窗口使用的是`CreateWindow`，而这个函数底层调用的是`CreateWindowExA`和`CreateWindowExW`，我们逆向分析一下`CreateWindowExW`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyo10FibBdUZm6dyD1hIN7v7Tib64oDEuREib1L3tUz2eo9HqjLqkRrBgJw/640?wx_fmt=png)

首先调用`CreateWindowEx`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVty01g4elHWGS9pwC3L1GOj5OvMicbQmYCWeq7PrdQMCtRrXzcKepRT4ew/640?wx_fmt=png)

然后调用`VerNtUserCreateWindowEx`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtye7dHqjx0KnKZxq8vJ0lgJLqbh3fzIXJ4nEEnxSYztzgIKcJvbrYS9A/640?wx_fmt=png)

再调用`NtUserCreateWindowEx`

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyYm8tuJOdHcF0fvhYPfBtmxZlFBU9dPSPcQhGYicoVRZaKf0bE7ggO3w/640?wx_fmt=png)

通过`NtUserCreateWindowEx`进入 0 环

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyPcl2tyQgBbhU2croacYw7e2VvdZ4GNtB5mDVIS9iaZnymxpaTVcMaxg/640?wx_fmt=png)

windows 窗口都在 0 环有一个结构体，就是`WINDOW_OBJECT`，`pti`即窗口对象指向的线程。一个线程可以对应多个窗口，但是在同一个程序里面多个窗口只能对应一个线程

总结

1、窗口是在 0 环创建的

2、窗口句柄是全局的

3、一个线程可以用多个窗口，但每个窗口只能属于一个线程

一个 GUI 线程只有一个消息队列，一个线程可以有很多个窗口，一个线程中所有的窗口共享同一个消息队列

消息的接收
-----

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVty2guUAzOFgbiapLicRn1I8kVxHpibkWrmicvBd6DLP7zUoKbrjZMDNAQKxA/640?wx_fmt=png)

首先在 3 环创建窗口和窗口类的对象，对应 0 环的`_WINDOW_OBJECT`结构

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyKvWsY64le5QTQoa1LzElX3uPpqH4bCXadibAg7hOXIquPHofZtNM3Ow/640?wx_fmt=png)

消息队列的结构

```
<1> SentMessagesListHead //接到SendMessage发来的消息<2> PostedMessagesListHead //接到PostMessage发来的消息<3> HardwareMessagesListHead //接到鼠标、键盘的消息
```

如果要取所有队列的消息，则第二个参数设置为 NULL，后两个参数全部设置为 0

GetMessage 的主要功能：循环判断是否有该窗口的消息，如果有，将消息存储到 MSG 指定的结构，并将消息从列表中删除。

```
GetMessage(  LPMSG lpMsg,  //返回从队列中摘下来的消息  HWND hWnd,  //过滤条件一：发个这个窗口的消息  UNIT wMsgFilterMin, //过滤条件  UNIT wMsgFilterMax //过滤条件);
```

使用`GetMessage()`获取信息，另外一个程序利用`SendMessage`发送给窗口，这里`GetMessage`会接收到消息并直接处理

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyGDlIggGzqBsP3wYliaZOSgpZyIcJUNOhFEYwmsmUy9ohEBqCOBmvDIA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyY4UfFicxfwwa25OwVj5MQRXwPo1trTWHVx3xabeTwdVE3SialsgeufeA/640?wx_fmt=png)

### NtUserGetMessage

`User32!GetMessage` 调用 `w32k!NtUserGetMessage`

```
do{ //先判断SentMessagesListHead是否有消息 如果有处理掉 do {  ....  KeUserModeCallback(USER32_CALLBACK_WINDOWPROC,                               Arguments,                               ArgumentLength,                               &ResultPointer,                               &ResultLength);  .... }while(SentMessagesListHead != NULL) //以此判断其他的6个队列，里面如果有消息 返回  没有继续}while(其他队列!=NULL)
```

### SendMessage/PostMessage

`SendMessage`为同步，`PostMessage`为异步，`GetMessage`只处理第一个链表即`SentMessagesListHead`里面的消息

当一个程序利用`SendMessage`向另外一个程序发送消息时，另外一个程序会用`GetMessage`接收，这个过程`GetMessage`会在 0 环的`SentMessagesListHead`链表里面搜索是否存在`SendMessage`，如果存在`SendMessage`，`GetMessage`就会在两个程序的共享内存里面向发送消息的程序发送一个结果，在这个过程中，发送消息的程序是一直处于等待状态的，只有接收到返回的消息才会结束，这称为同步

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyhiawFOuoJhMSMnn7917UuHSR8UAP5cuB9BmIIjoA6BQhKKpJ9AT10eQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtySWR0RfDia0R7g2n26vUQZKFW01AvUM9P6boia0qNT1vGXoljiaWQame6g/640?wx_fmt=png)

如果利用`PostMessage`发送消息，处于第二个链表里面，`GetMessage`不会处理，而程序发完消息之后也会立即结束，不会有等待的过程，这成为异步，如果要处理，使用`DispatchMessage()`处理

```
MSG msg;while(GetMessage(&msg, NULL, 0, 0)){    TranslateMessage(&msg);    DispatchMessage(&msg);}
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyePEM1YLd2BQiabP0Zr2f2LY0FY9UBj5VYMMRUCicCrQNiclicSpSAIkS2Q/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyhyvkFEAuTM5lib5H4Ujsn1pByK1OsK9zSwtTq1C5MsovqUocE4EEiaIg/640?wx_fmt=png)

消息的分发
-----

这里如果只有`GetMessage`的话，关闭窗口是关闭不了的

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyBBgsJMQIiaiaYZTlnA6cqba1BDkF03HZ9PnJxh5HuibOLouUObo2FokaQ/640?wx_fmt=png)

### DispatchMessage

`User32!DispatchMessage` 调用 `w32k!NtUserDispatchMessage`

<1> 根据窗口句柄找到窗口对象

<2> 根据窗口对象得到窗口过程函数，由 0 环发起调用

如果使用`DispatchMessage`分发消息，根据窗口句柄调用相关的窗口过程，即可关闭

因为很多个消息共用一个消息队列，所以通过`GetMessage`取出消息之后，需要用`DispatchMessage`进行消息的分发

`DispatchMessage`通过`GetMessage`取出的句柄，进入 0 环找到`Window_Object`对象，再找到对应的窗口过程调用

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtywiahm6qbwoUFEOk2hEAbib5iarlDhdgiaWYhWtBBvicMf0buRp8YiakibByvQ/640?wx_fmt=png)

`TranslateMessage`是用来处理键盘输出的函数，定义一个函数

```
case WM_CHAR:  {   sprintf(szBuffer, "Down : %c", wParam);   MessageBox(hwnd, szBuffer, "", 0);   return 0;  }
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyBiaJS1GTTM6ibVbXcFIxNtc3RIlUjO0BTTJ64YnhnC203oOHnHV0IWtQ/640?wx_fmt=png)

这里如果不使用`TranslateMessage`，则没有`WM_CHAR`这个消息，需要自己定义`WM_KEYDOWN`

```
case WM_KEYDOWN:  {   sprintf(szBuffer, "Down : %d", wParam);   MessageBox(hwnd, szBuffer, "", 0);   return 0;  }
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyYtibOicXSeicSibLnd7icdsooWuicZaqoLO2SobPGMpuIeibcbfLgetRS9nJg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyNsyRiacCJpKryIqJ5RsE8PBpzGuyK5Z3zucfNVc6Z3cH995H2JY5u9w/640?wx_fmt=png)

消息有很多，但是不是每个消息都需要我们自己去处理，所以与我们无关的消息就使用 windows 提供的`DefWindowProc`让微软替我们处理即可

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyamvt0UTAsB4GyF5x331P46eIOOdk3JCxdLhQoApCKTuiaZjWHtW5UJw/640?wx_fmt=png)

内核回调机制
------

窗口过程函数除了`GetMessage`和`DispatchMessage` 能够调用，一些在 0 环的函数也能够直接进行调用。例如`CreateWindow`不向消息队列里面发送消息，而是直接调用 3 环提供的函数

这些消息类型可以被直接调用

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyD27cib6bv1PbTwMdYYUT9LctdWtukLmsPia2k2taVX645BXOicJ0zamkg/640?wx_fmt=png)

这里对`WM_CREATE`进行修改，当创建成功的时候弹窗

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyJOJLFQfQZIu4KmnuibegFVicowRRKjFNmtLsqoIM3TV691ZHQUU9k8ZQ/640?wx_fmt=png)

这里并没有执行到`GetMessage`和`TranslateMessage`就弹窗，说明被`CreateWindow`调用 0 环函数，0 环函数通过回调机制 (`KeUserModeCallBack`)，再调用窗口过程函数

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyPUjRISOk5elxC7rKicwcczrBEHPrCU7aQeINdDugYvnmHwyPUbz7uRA/640?wx_fmt=png)

所以调用窗口过程只能是以下三种情况

```
<1> GetMessage()在处理SentMessagesListHead中消息时<2> DispatchMessage()在处理其他队列中的消息时<3> 内核代码
```

1、从 0 环调用 3 环函数的几种方式：

APC、异常、内核回调

2、凡是有窗口的程序就有可能 0 环直接调用 3 环的程序。回调机制中 0 环调用 3 环的的代码是函数：`KeUserModeCallback`

3、回到 3 环的落脚点：

APC：`ntdll!KiUserApcDispatcher`

异常：`ntdll!KiUserExceptionDispatcher`

### KeUserModeCallback

`KeUserModeCallback`在 0 环对应`NtUserDispatchMessage`，调用`IntDispatchMessage`。通过`UserGetWindowObject`获得一个`Window_Object`类型，通过对象得到当前窗口的对应的窗口函数，然后调用`co_IntCallWindowProc`。

调用`KeUserModeCallback`，第一个值为索引，第二个值为窗口回调过程中所有有用的信息。第一个索引值， `KeUserModeCallback`函数的第一个参数就是索引，其实它是一个宏，有很多个对应的值

内核回调在 3 环的落脚点，有很多个地方，我们拿着索引去 3 环里面找回调函数地址表，如果索引为 0，则取表里面的第一个函数，如果索引为 1，则取表里面的第二个函数

> PEB+0x2C  回调函数地址表，由`user32.dll`提供

这里打开一个 exe，通过`fs:[0]`找到 TEB

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyDIlHWuNT0EufydRUBtbXuTicRyicawVdMGF6dT0vzQNwcTo3EZGv764w/640?wx_fmt=png)

TEB 的 0x30 偏移为 PEB

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyiaNz0ZHbkRLeHsQicUg58CD1aCyCgbZ3QmcViaGnW3ppFiayo3oibT3f1Tg/640?wx_fmt=png)

PEB 的 0x2C 偏移即为回调地址函数表

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtyg8icXMuzEOHmE3EzRjmVicx7PcRmq05aPWB4CmdySoAY5WZpPAyCkG9Q/640?wx_fmt=png)

这里通过`KeUserModeCallback`的第一个值，即索引找到函数之后，这个函数再去调用窗口过程函数，窗口过程函数已经通过`Arguments`放在了堆栈里面

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v5OTDggaicEG5WudVDicZKVtynH3USmo98Qd9DkBzewhWetlXTZd4SNe1TAGokBWOSVF5fnXBBdib2Gg/640?wx_fmt=png)

**原创稿件征集**

征集原创技术文章中，欢迎投递

投稿邮箱：edu@antvsion.com

文章类型：黑客极客技术、信息安全热点安全研究分析等安全相关

通过审核并发布能收获 200-800 元不等的稿酬。

[更多详情，点我查看！](http://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652885477&idx=1&sn=39e97a60d7b68d19569284654e74ffa1&chksm=bd59ad288a2e243e4d89b7c456fbd44a93d241c881075b342af22431d93dca56e52076ed75ce&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6iavic0tIJIoZCwKvUYnFFiaibgSm6mrFp1ZjAg4ITRicicuLN88YodIuqtF4DcUs9sruBa0bFLtX59lQQ/640?wx_fmt=gif)

靶场实操，戳 “阅读原文 “