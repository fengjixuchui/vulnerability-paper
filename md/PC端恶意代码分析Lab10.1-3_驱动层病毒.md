<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/eKRyuaqncarTJLpub0Icww)

![图片](https://mmbiz.qpic.cn/mmbiz_svg/OM4v0FU2h0uJnlvZ6YPYSHN8HfkeeT4tQMrfVgZnB9zo3QnXiaH5YES3NyVARCATlTibcOcibLqqx1xtAHv7ic74Q3Yf2FR9FfFz/640?wx_fmt=svg&wxfrom=5&wx_lazy=1&wx_co=1)

前言  

![图片](https://mmbiz.qpic.cn/mmbiz_gif/GIRBFLSfaJJNDc9AlVIgic0ibX3blcxgrarWwFJQfjVYB2eMk2KooO88LL4F6XalpKJXQKUW8uiacwXKEp9W0iaayQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

恶意代码分析是安全从业人员非常重要的一个技能。

参考书籍:<<恶意代码分析实战>>

               <<windows核心编程>>

![图片](https://mmbiz.qpic.cn/mmbiz_svg/OM4v0FU2h0uJnlvZ6YPYSHmz1WUXYmYpicev2747TZ0GawK9v7lspPIwXSc1yzEabdPxyASpvuXCMO0ibNibeRC8YKw6fic7DuAP/640?wx_fmt=svg&wxfrom=5&wx_lazy=1&wx_co=1)

**相关知识**

![图片](https://mmbiz.qpic.cn/mmbiz_gif/GIRBFLSfaJK9g8jdvxTibzxpIIyFibJL9EyS96zSclUT1vicj352kiazTXkIlvNZ70ROxcU7aqNFyYzzia23ibb0pJmQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

Windows会为每个驱动创建一个驱动对象，并以参数形式将其传给DriveEntry函数，DriverEntry函数回调函数填充这个驱动对象，然后DriverEntry会创建一个可以被用户态应用程序访问的设备对象，应用程序与驱动的交互请求都将通过这个设备对象进行。

请求内核态恶意组件的最常见函数是DeviceIoControl,它是从用户模块到内核设备的一种通用请求方法。使用该函数时，用户态应用程序传递一个任意长度的缓冲区数据作为收入，并且接收一个任意长度的缓冲区数据作为输出。

一些内核态恶意代码并没有明显的用户态组件，也没有创建内核对象，它们仅仅运行在驱动程序中

  

![图片](https://mmbiz.qpic.cn/mmbiz_svg/OM4v0FU2h0uJnlvZ6YPYSHN8HfkeeT4tQMrfVgZnB9zo3QnXiaH5YES3NyVARCATlTibcOcibLqqx1xtAHv7ic74Q3Yf2FR9FfFz/640?wx_fmt=svg&wxfrom=5&wx_lazy=1&wx_co=1)

**调试内核环境**

![图片](https://mmbiz.qpic.cn/mmbiz_gif/GIRBFLSfaJJNDc9AlVIgic0ibX3blcxgrarWwFJQfjVYB2eMk2KooO88LL4F6XalpKJXQKUW8uiacwXKEp9W0iaayQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

内核调试是双击联调。

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJK9g8jdvxTibzxpIIyFibJL9Emdqjang8qjjVSAxlAPDfJhVFzPea0yXy4GdkaHrXgOBk7TZRiae0QUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

然后vm新增一个串行端口，配置如下。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后windbg设置一个快捷方式，修改属性如下  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

之后再重启虚拟机，用windbg等待连接

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Lab10-1  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里可以看到有一个exe和一个驱动文件。

先静态分析一下exe,放入PEid中，发现没有加壳  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

放入IDA中查看。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里遇到了一个新的函数，

ControlService

给指定的发送一个控制码，这里的第二个参数是1，会卸载驱动  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里用驱动程序作为服务程序。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

创建并启动。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里再打开驱动。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

可以看到先是进入了驱动的加载部分，然后打开了一个函数。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

可以看到这里的函数都是内核级的，都带着RTL。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

可以看到是进行了注册表的写入，用这个方法写入容易绕过一些用户态的监测。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

而这里的注册表通过查询，可以得知是禁用防护墙的行为。

  

这里动态分析一下，先运行。

用procmon监控，regshot对比注册表变化。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里看到驱动加载的注册表操作在procmon中监测不到。只能用regshot进行结果对比，说明了这样的操作方式隐蔽性高。

接着用windbg开始调试。先是在虚拟机的windbg下一个在controlservice的断点,然后查找服务Lab10-01,然后查找其数据结构，对DriverUnload下断点，然后虚拟机继续运行到断点，然后单步调试，可以查看到注册的键值

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Lab10-2  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里先放入PEid中查看，无壳  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

放入IDA中查看。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里可以看到是从资源里面抽取一个驱动文件，然后写入到system32下，用Resource Hacker提取。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

然后创建服务，启动服务。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

但是这里只能查到服务，找不到驱动文件。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里再把驱动放入IDA中分析，可以看到这里是SSDT hook.

SSDT 的全称是 System Services Descriptor Table，系统服务描述符表。这里是把Ring3的win api和ring0的内核api关联起来。而SSDT hook就是把这个表中的地址改为自己的函数，达到一个重写的目的。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

NtQueryDirectoryFile 系统用来查询文件信息。

RtlCompareMemory

对比两个内存块。

KeServiceDescriptorTable

访问SSDT表的一个关键。

这里可以看到通过循环对SSDT表进行了一个查询，用来查找NtQueryDirectory的位置，然后替换成10486.  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里再通过RtlCompareMemory对文件开头Mlwx进行一个判断，如果是就隐藏。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里怎么能恢复隐藏文件呢。禁用驱动服务就行了。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Lab10-3

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里还是先用PEid打开，无壳。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

用IDA分析当前的exe.  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

可以看到是用system32下的驱动作为Process Helper的文件。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

之后创建了一个管道。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里可以看到lpOutBuffer和lpInBuffer都是0，是为了后面的进程隐藏。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

之后用COM组件每隔30s访问一个网站。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

接着用IDA打开sys文件。  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

IoGetCurrentProcess

返回一个指向当前进程的指针(EPROCESS(进程对象)）

IofCompleteRequest

示调用者已经完成了给定I/O请求的所有处理，并将给定的IRP返回给I/O管理器

IoCreateDevice

驱动中调用此函数来创建设备对象

PEB:存放进程信息。

可以看到这里先是创建了一个容易被用户态访问的设备句柄。

这里是对当前进程的操作，获取当前的进程  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

用windbg打开，查询一下EPROCESS的数据结构，对比一下偏移量，可以看到是访问了_LIST_ENTRY.

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这里上网查了一下，可以得知+8C，是指向下一个的指针。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

之后这里进行了一个双向链表解除链接的一个操作，原本指向下一个的指向前一项，原本指向前一个的指向下一项，这样就做到了隐藏进程。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

这里书上提到了一个知识点：进程只是线程的容器，只要线程合理地占用操作系统，它就会被调度，进程也会继续存在并正常运行。