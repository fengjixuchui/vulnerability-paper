> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/1065)

> 奇安信攻防社区 - CTF-pwn 技术总结（1）

**初级 Rop**
----------

返回导向编程（Return-Oriented Programming，缩写：ROP）是计算机安全中的一种漏洞利用技术，该技术允许攻击者在程序启用了安全保护技术（如堆栈不可执行—NX 保护）的情况下控制程序执行流，执行恶意代码。

### 使用方法：

利用栈溢出控制程序中函数的返回地址，再借助 ROPgadget 寻找程序 / libc 中带有 ret 的指令，利用这些指令构造一个指令序列，从而控制程序的执行。

### 例题演示：

来自某学校新生赛题： checkin，

ida 打开发现需要输入三个变量满足一个简单的等式，没什么限制随意构造即可

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-91db606fbc1d598e47423062acbc6c646e9b29e8.png)

进入 vul 函数，发现存在栈溢出，偏移为 10h，等下就要在这里构造 ROP 链

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ab2dc9fad2c689a896634db8297f5459163c488e.png)

还找到了后门函数，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0c415edbc6399cacbaa34878d323b575163e8484.png)

利用 ROPgadget 工具寻找可用的指令：

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d44ecbd32cbc69add901034a68ab4c2b7bd670f3.png)

也可以用它查找字符串：

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e7c650f09b649cb5287e194a69abcf1e2f9a198a.png)

#### 思路：

这样构造下面这样的 ROP 链就可以 getshell 了

```
pop rdi; ret; binsh_addr; system_addr
```

#### Exp：

```
from pwn import *
```

**通用 ROP**
----------

**通用 ROP** 也被称为 **ret2csu** ，因为利用的是 64 位 ELF 程序中带有的 **cus_init 函数**，让程序返回到这个函数上，我们就能控制很多寄存器的值，

csu_init 函数代码：

```
context.log_level = 'debug'
```

我们可以发现：

如果我们返回到 **loc_400616:** 中的 **pop rbx** 处，我们就能控制 **rbx、rbp、r12、r13、r14、r15** 这 6 个寄存器的值，然后再让程序返回到 **loc_400600:** 处，这样 **rdx 、rsi 以及 edi** 就能通过之前赋值的 **r13、r14、r15** 被我们控制，最后程序还能调用 *_r12+rbx_ 8 地址指向的函数 **，但是注意到之后有个** 验证 rbx 和 rbp **的代码，所以实际上 rbx 和 rbp 的值已经确定了，我们将其设置成 rbx=0 ，rbp=1，这样我们不仅可以通过验证，不会跳转到** short loc_400600 **处，而是接下去直到** loc_400616: **处的** retn**，而且还能直接调用** r12 处的函数 **（因为 rbx=0）。

### 例题演示：

来自 攻防世界 - pwn_100

#### 准备工作

**用 die 看看程序的基本信息**

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b9871624e7c1abf4c877021804ebaa94f161998c.png)

ELF64 位的程序

**用 checksec 看看开了啥保护**

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0753cd97a2f63ac370993ac16d679725c9e14496.png)

只开了 NX 保护

#### 静态分析

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a605cd37a17c46e6bbba91800807fdc8f4ac23ba.png)

进入函数 sub_40068E，注意到 V1 只开辟了 64h 的空间

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-80e4e0bfd5596a041e9432520ba7b7266fa904e9.png)

进入函数 sub_40063D，分析可知，该函数的功能类似 read（0，input，200），就是输入 200 个 byte 的数据保存到栈中，存在明显的栈溢出漏洞

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-25311e4fae1a4ada995d5f893fe09959b236495a.png)

#### 开始 ROP

发现程序中没有现成的 system 和 “/bin/sh” 使用，所以我们考虑使用通用 ROP 解题

找到两个通用 ROP 的关键地址

```
p = process( " . /checkin")
```

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0e74e02ee540e8a05ae76af1fffd5465bdf3af8b.png)

控制程序返回到这两个地址，我们可以控制 rbx,rbp,r12,r13,r14,r15,rdx,rsi,edi 寄存器的数据, 即 64 位程序函数的传参都没问题了，并且还可以调用我们构造的 [r12+rbx*8] 地址处所指向的的函数。

### 思路：

#### 1. 利用 puts 函数泄露 libc 中函数的地址

具体实现：

利用栈溢出覆盖栈中原本的返回地址为 _cus_addr_end_，将我们需要的寄存器参数（_puts_got_addr_）写入，再将返回地址覆盖为 _cus_addr_front_，这样就可以执行 puts 函数泄露 puts 函数的地址，注意执行完 _cus_addr_front_ 后还会接下去执行 _cus_addr_end_ 处的 pop，所以需要填充 8 _7 = 56 byte 的数据，最后再将返回地址覆盖为_ main_addr*，因为我们之后还得再利用栈溢出漏洞，还得注意将 payload 填充至 200 byte（输入函数有要求）

**注意这里输入数据用的是 send() 而不是 sendline，因为输入函数是 read() 而不是 gets()**

接下来接收打印在屏幕上的 puts 地址，再与 libc 中 puts 偏移地址相减获得 libc 基址——_libc_base_，之后就可以轻松获取 execve 函数的地址。

#### 2. 利用 read 函数将字符串写入 bss 段

具体实现：

类似第一步的操作，将 r12 寄存器的值设置为 read 函数 got 表地址——_read_got_addr_、将其参数设置为 bss 段偏移为 16 的地址——_bss_base_16_，执行 read()

你可能会好奇为什么不直接用 bss 段的起始地址而是用 bss 段偏移为 16 的地址？

**注意这里有一个坑，调试了好几遍才发现**

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-144442b4e5cc4b735bc92944b82ff9d63d350ea5.png)

**main 函数的开始从 _cs:stdin_ 和 _cs:stdout_ 里取值赋给寄存器，作为 setbuf 函数的参数，并且 bss 段首存在 stdin，stdout 结构体指针，如果在 bss 段首写入数据将这两个结构体指针覆盖了，程序运行到 call_setbuf 函数会报错，然后终止，所以要避开这两个结构体指针，从 _bss_base_16_ 写入 execve 地址——_sys_addr_**

最后利用 send()将 “/bin/sh” 写入 _bss_base_16_ + 8 处。

#### 3. 再次利用通用 ROP 执行 execve

具体实现：

类似第一步的操作，将 r12 寄存器的值设置为 _bss_base_16_、将其参数设置 _bss_base_16_ + 8, 执行 execv(“/bin/sh”)。

#### Exp：

```
e = ELF( ".checkin")
```

栈迁移
---

当溢出字节不够构造 ROP 链时，让栈迁移到攻击者能写入的一个地址, 只要这个地址下的内容攻击者提前布局好，就一样能进行 ROP。

我们需要了解栈迁移用到的最关键的两个汇编指令 **leave** 指令和 **ret** 指令。其作用就是用来还原栈空间的。

```
puts_got = e.got["puts"]
```

### **例题演示：**

来自 ctfshow 摆烂杯 - CET6

这道题题目给了 libc，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-2ecdf2bde319cdc570d442028642ad41550a3ec0.png)

只开了 NX 的 64 位程序，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6fa788826d761ea69f546ae36464ee03d272b08a.png)

第一关利用 4 字节的栈溢出覆盖 seconds 为 0，

这里明显存在 16 字节的栈溢出，但是实在太短了，根本没办法做什么事，果断使用栈迁移，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f1643231c7fd05298932f2468101c63e28131fce.png)

#### 思路：

将 **rbp** 覆盖成 **fake_stack 地址 (0x404F00)**，让程序再回到 **read 函数 (0x4011ae)**, 然后再巧妙把 **rbp** 覆盖成 **fake_stack+0x40 处地址 (0x404F40)**——这样就能在 **fake_stack 地址 (0x404F00)** 处写入数据，并让程序再回到 read 函数，这一次 **rsp** 因为 **leave；retn**，变为 **fake_stack+0x10(0x404f10)** , 这样就能通过构造 ROP 链，控制 read 函数的返回地址，让其打印出 got 表里 puts 函数的地址，从而就获取到了 libc 基址，再次让程序返回 read 函数，最后构造 getshell 的 ROP 链即可。

#### Exp：

```
pop_rdi = 0x400953
```

**PIE 绕过**
----------

### PIE（ ASLR ）保护机制

PIE 和 ASLR 的是操作系统的功能选项，两者一般一起配合使用，其随机化了 ELF 装载内存的基址（代码段、plt、got、data 等共同的基址）。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行 **Return-to-libc** 攻击。

但是 PIE 影响的是程序加载的基址，并不会影响指令间的相对地址，因此如果我们能够泄露程序的某个地址，就可以通过修改偏移获得程序其它函数的地址。

### PIE 怎么绕过

虽然程序每次运行的基址会变, 但程序中的各段的相对偏移是不会变的, 只要泄露出来一个地址, 比如函数栈帧中的返回地址

, 通过 ida 静态的看他的程序地址, 就能算出基址, 从而实现绕过

### 例题演示：

来自某高校新生赛题—checkin_revenge

输入三个数字满足等式，还是没啥限制，随意构造即可

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-2864ffaded44061e01f4064b41385b5986cdb7c0.png)

这里存在明显的栈溢出

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-8c292519f4fb9f9ca01cc66d18dcacb5310eea76.png)

但是这一题是开了 PIE 和 RELRO 的 64 位程序，所以我们不能再覆盖 got 表，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f4313f125a08458b5f4113aab68a157aa9edd873.png)

虽然 PIE 烦人，但是还是有弱点的：

**PIE 保护的一个弱点就是 pie 不会随机化地址的低 12 位，通俗点说就是我们十六进制地址的后三位，这样我们才有 “文章” 可做**

现在先整理一下思路：

*   我们的目的是得到 libc 中 system 和 / bin.sh 的地址
*   开启了地址随机化，每次运行的基址都不一样，所以得先得到每次程序运行的 libc 的基址，这里我们利用 **libc_start_main**，我们想办法得到程序中 libc_start_main 的地址，减去 libc 中的偏移，得到 libc 基址，进而获得 system 等的地址
*   为了得到 libc 基址，我们已经让程序正常运行了一次，那我们接下来就是要让程序再出现一次栈溢出漏洞, 在这时截获它，让它运行 system(’/bin/sh’), getshell

所以程序的运行地址我们要先泄露出来，有了它我们就能利用 **plt 表** 泄露出 **got 表** 内容。

具体做法是利用 **put()** 函数是打印一个字符串，直到遇到 ‘**\x00**‘才会停止打印，而我们输入的函数是 **read()** ，它不会帮我们添加 ‘**\x00**‘, 所以我们能用这个点来泄露出 **vlu()** 的返回地址，即 main 函数里的地址，也就能得到程序的运行基址，注意到 **vul()** 的返回地址为 **A89** ，而我们只能覆盖一个字节，开了 PIE 后只有最后三位是相同的，所以不能覆盖两个字节，所以我们只能回到 **A7F** 处，同样能达到我们再次栈溢出的目的

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-c1476212b795f17d6e61ef464cb08908554f7865.png)

然后有了程序基址，我们正常利用 puts 的 **plt 表**来调用 puts 泄露 **got 表**内容，因为 got 表写的是 libc 函数地址，所以就等于我们得到了 libc 基址，然后就是 64 位正常做。

#### EXP：

```
a = str(32)
```

数组越界
----

所谓的数组越界，简单地讲就是指数组下标变量的取值超过了初始定义时的大小，导致对数组元素的访问出现在数组的范围之外，这类错误也是 C 语言程序中最常见的错误之一。

在 C 语言中，数组必须是静态的。换而言之，数组的大小必须在程序运行前就确定下来。由于 C 语言并不具有类似 Java 等语言中现有的静态分析工具的功能，可以对程序中数组下标取值范围进行严格检查，一旦发现数组上溢或下溢，都会因抛出异常而终止程序。也就是说，C 语言并不检验数组边界，数组的两端都有可能越界，从而使其他变量的数据甚至程序代码被破坏。

### 利用数组越界漏洞我们能干什么？

答案是：修改任意地址里的数据

比如我们可以用数组越界漏洞，将 got 表里 printf 函数的地址修改成 system（‘/bin/sh’”）的地址，那么程序在之后调用 printf 函数时，实际上调用的是函数 system（‘/bin/sh’”），这样我们就获得了目标主机的控制权限。

### RELRO 保护

在 Linux 中有两种 RELRO 模式：`Partial RELRO` 和 `Full RELRO`。Linux 中`Partical RELRO`默认开启。如果开启 `FUll RELRO`，意味着我们无法修改 got 表，这样也就没法通过修改 GOT 表来进行 **Return-to-libc** 攻击

### 例题演示：

来自某学校新生杯赛题 - arry

首先，利用工具查看保护，发现没有 `FUll RELRO`，意味着我们可以修改 GOT 表，而且开了 PIE 保护，说明我们很可能泄露一些地址出来，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d37ef2fb60459080786034b11c0dcb55dcb17c5b.png)

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-5a3ecb5860549997d951f542809169f883b02fc9.png)

用 ida 打开，发现程序可以通过数组越界查看任意地址里的值并更改它，并且程序已经存在 system（“/bin/sh”）了。

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e3d2bf964824403043abb4049653cb8601cca23a.png)

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-96097aa4970be9590ea8a56d49d423e48a1ffd7b.png)

因为程序开了 **aslr 保护**（最后三位不变），所以我们要先泄露程序代码段的基址，然后再将 printf 的 got 表覆盖成后门函数的地址，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-73fb393412bab9e1ac969493bacecaf0a37c0c95.png)

在 ida 里可以发现数组 arry 的地址在 bss 段里，并且离 got 表很近，故我们可以通过计算 got 表项地址与 arry 的地址之间的偏移来获取 got 表项里的内容。

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-25ad9e2dbf4f400054f9d3a8680a12d6a8c71384.png)

在 gdb 中调试也可以发现 bss 段中 arry 离 got 段很近，直接将 arry 与 got 项之间地址相减得到两者之间的**偏移**，利用这个 **偏移** 获得 **stack_chk_fail** 函数的地址，然后用 0xFFFFFFFFF000 与得到的地址相与得到 **代码段基址** ，然后用 **代码段基址** 加上 **arry 和 system 的 got 表地址的偏移** 计算得到后门函数地址，再利用一次数组越界将 **printf 的 got 表项** 覆盖成后门函数地址

**坑点：** 第一次利用数组越界来获得代码段基址，我是选择泄露 system 函数的 got 表值，不知道为什么 change 时我填入的是获取到的它的原始值，但是调试的时候发现程序中的 system got 表值被更改了，应该是这里有什么保护机制吧，所以之后选择泄露 **stack_chk_fail** got 表项来获得代码段基址。

#### **Exp** ：

```
b = str(0)
```

伪随机数
----

在 C 语言中, rand() 函数可以用来产生随机数，但是这不是真真意义上的随机数，是一个伪随机数，是根据一个数，我们可以称它为种子，为基准以某个递推公式推算出来的一系数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统，为了改变这个种子的值，C 提供了 srand() 函数，它的原形是 void srand( int a)。

### 例题演示：

某高校新生赛题—guess

64 位保护全开

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-06933e4387ce17f26a581b26ab62070db97a8180.png)

主函数是输入一个文件名，然后程序会打开并读取它的前 4 个字节，将每个字节作为随机数种子，生成随机数。

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d027eb78e005bae764e0653d006b6e713646833e.png)

题目的难点在我们不知道靶机上有啥文件，但是这同样也存在一个漏洞。

#### 非预期解：

随意输入一个文件名，因为不存在这个文件，所以打开文件失败，随机数种子是初始值 0，这样每次生成的随机数都是同样的，是一个固定值，利用 **在相同 libc 库下由相同的随机数种子生成的随机数相同** 这个点，我们可以很轻松’’猜’’出四次 ‘随机数’。

EXP：

```
c = str(0)
```

#### 正常解：

目前我们可以确定在目标靶机上的文件就是这个 **guess 程序本身** ，而 guess 程序是一个 **ELF 文件** ，它的前四个字节是一个固定值：**0x7F454C46** ，接下来利用 **在相同 libc 库下由相同的随机数种子生成的随机数相同** 这个点模拟播种，生成随机数就好了。

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-549a406d46e2448758018c46ec74968f6681c310.png)

EXP：

```
sys_addr = 0x4007c6b
```

sandbox
-------

sandbox（沙箱），是一种安全机制，为执行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。  
在 ctf 比赛中，pwn 题中的沙盒一般都会限制 execve 的系统调用，这样一来 one_gadget 和 system 调用都不好使，只能采取 **open/read/write** 的组合方式来读取 flag，即 **ORW 类题**。

### 例题演示：

来自某高校新生杯赛题—shellcode

ida 打开发现这道题是让我们输入一段 shellcode，然后程序会运行它，但是这里存在 **sandbox()** 函数，他会进行过滤，这道题的提示里面说 **execve()** 被 ban 了，让我们尝试直接读取 flag

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-02c71516163d762bfc77db1b0ec93af00effb5b0.png)

很明显这是一类题型——**ORW** 类题

**ORW** 类题目是指程序开了沙箱保护，禁用了一些函数的调用（如 execve 等），使得我们并不能正常 get shell ，只能通过 ROP 的方式先调用 open 打开 flag 文件，然后利用 read 把 flag 的值读取到内存里面， 最后通过 write 来读取并打印 flag 内容。

所以我们需要一个依次调用 **open()**、**read()**、**write()** 的 shellcode，先用 **open()** 打开文件 flag.txt 然后通过 **read()** 读取文件内容到 栈上 最后利用 **write()** 将其输出到屏幕上。

#### Exp：

```
binsh_addr = 0x601060
```

**关键点：** 利用 pwntools 自带的功能生成我们想要的 shellcode，先选择架构

```
off = 0x10 + 8
```

然后再生成 shellcode,

```
p.sendlineafter( "Give ne your a:", a)
```

这个命令能帮我们生成一个调用函数 fuction(arg1,arg2,arg3…) 的汇编代码，

```
p.sendlineafter( "Give me your b:", b)
```

最后再用 **asm()** 包裹 shellcode 的汇编代码，生成字节码，一个 shellcode 就完成啦！

### 例题演示 2：

来自 ctfshow 摆烂杯—CET4

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a1830afdd9532da9287147ad1e4a172e1f4e98e0.png)

只开了 NX 保护，

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6b85b590f3e8c71c3b9e45a0b5ec6f0462869259.png)

这道题已知 libc 版本，

#### 方法一：

因为已知 libc，所以可以先泄露 got 表函数地址，然后 return_to_libc，利用 libc 函数构造 ROP 链，执行 **ORW** 获取 flag。

##### 思路：

先向 bss 段写入 flag 字符串，然后利用 open 函数（参数是 flag 字符串、0、0）打开 flag，然后再利用 read 函数（参数是文件指针 = 0x3，bss 段地址，100）读取 open 函数打开的 flag 文件中的数据，这里有一个隐藏知识，**open 函数打开的第一个文件的 fd 指针一般都为 0x3**，最后用 write 函数（参数是 1，bss 段地址，100）将 read 读取到的数据显示到屏幕上。

##### Exp:

```
p.sendlineafter( "cive me your c:", c)
```

#### 方法二：

编写 shellcode 执行来 **ORW** 获取 flag，但是没有可写入并且可执行的程序段，这里要用到一个函数—mprotect

![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a5ed61313f866781bdd7f6739fcbeddbdc1929c6.png)

##### mprotect：

在 Linux 中，mprotect() 函数可以用来修改一段指定内存区域的保护属性。

函数原型如下：

```
#gdb.attach(p, "bp 0x4007FC")
```

mprotect() 函数把自 start 开始的、长度为 len 的内存区的保护属性修改为 prot 指定的值。

prot 可以取以下几个值，并且可以用 “|” 将几个属性合起来使用：

1）PROT_READ：表示内存段内的内容可读；

2）PROT_WRITE：表示内存段内的内容可写；

3）PROT_EXEC：表示内存段中的内容可执行；

4）PROT_NONE：表示内存段中的内容根本没法访问。

##### 思路：

通过 mprotect 函数修改 bss 段为可执行，然后先 bss 段中写入 shellcode，最后让程序返回到 shellcode 地址。

##### Exp：

```
payload = "a"* off + p64(pop_rdi)+ p64(binsh_addr) +p64(sys_addr)
```