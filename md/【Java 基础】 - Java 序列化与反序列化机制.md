> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/HoTm35DeFC8CdCx3x-GOmA)

基本概念类对象序列化需要满足的条件基本的序列化 / 反序列化流程 java 反序列化的漏洞点 java 中的各种流操作参考链接

基本概念
----

java 的序列化机制就是为了**持久化存储**某个对象或者在**网络上传输**某个对象；

**一旦 jvm 关闭，那么 java 中的对象也就销毁了**，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里

序列化：把对象转换为字节序列

反序列化：把字节序列转换为对象

类对象序列化需要满足的条件
-------------

1、该类必须实现 **java.io.Serializable** 接口。

2、该类的**所有属性必须是可序列化的**。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。

基本的序列化 / 反序列化流程
---------------

**要序列化一个对象**，首先要**创建 OutputStream 对象（如 FileOutputStream）**，再将其**封装在一个 ObjectOutputStream 对象内**，接着只需**调用 writeObject() 方法**即可将对象序列化

```
1. 创建OutputStream对象
2. 将其封装在一个ObjectOutputStream对象内
3. 调用writeObject()方法

```

**要反序列化得到一个对象**，首先**创建一个 InputStream 对象（如 FileInputStream）**，再将其**封装在 ObjectInputStream 内**，然后**调用 readObject()** 即可。

```
1. 创建一个InputStream对象
2. 将其封装在ObjectInputStream内
3. 调用readObject()

```

```
package com.feng;

import java.io.*;

public class Test {
   public static void main(String[] args) {
       User user = new User("feng", 22, 185);
       try {
           // 创建一个FileOutputStream
           FileOutputStream fos = new FileOutputStream("./user.ser");
           // 将这个FileOutputStream封装到ObjectOutputStream中
           ObjectOutputStream os = new ObjectOutputStream(fos);
           // 调用writeObject方法，序列化对象到文件user.ser中
           os.writeObject(user);

           System.out.println("读取数据：");
           // 创建一个FileInutputStream
           FileInputStream fis = new FileInputStream("./user.ser");
           // 将FileInputStream封装到ObjectInputStream中
           ObjectInputStream oi = new ObjectInputStream(fis);
           // 调用readObject从user.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型
           User user1 = (User)oi.readObject();

           user1.info();
      } catch (FileNotFoundException e) {
           e.printStackTrace();
      } catch (IOException e) {
           e.printStackTrace();
      } catch (ClassNotFoundException e) {
           e.printStackTrace();
      }
  }
}

class User implements Serializable{
   private String name;
   private int age;
   private float height;

   public User(String name, int age, float height) {
       this.name = name;
       this.age = age;
       this.height = height;
  }

   public void info(){
       System.out.println("Name: "+name+", Age: "+age+", Height: "+height);
  }

   // private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException{
   //     System.out.println("[*]执行了自定义的readObject函数");
   // }
}

```

运行结果：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESJqmj35pN8dALdAoGcdYfjPAdWFmXnnqBqwUAEhpE7Z0JYbjK08JtQA/640?wx_fmt=png)

在 src 同级目录生成序列化后的文件：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESic0zy0DxJfZmQ43uk2MplsCvzkaWrEEyWmk1XRdxlee4nvPM3oqusKg/640?wx_fmt=png)

使用 linux 下的小工具`xxd`查看内容：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESJPhpZTtJxb7q21S6LFmCs0NTeu9xzabAAFAAdfy5ryhJa6WMOZ5Jww/640?wx_fmt=png)

注意**前 4 个字节**：

`AC ED`：STREAM_MAGIC，声明使用了序列化协议，**从这里可以判断保存的内容是否为序列化数据。** （这是**在黑盒挖掘反序列化漏洞很重要的一个点**）

`00 05`：STREAM_VERSION，序列化协议版本。

java 反序列化的漏洞点
-------------

php 反序列化一个对象时会自动触发`__weakup`、`__destruct`这些函数，如果这些函数当中有一些危险的操作，那么就可能导致漏洞的发生。

java 反序列化时会自动触发`readObject()`函数。

但在上面的例子中，`User user1 = (User)oi.readObject();`，readObject() 方法是 ObjectInputStream 类的一个方法。

**其实，java 是支持自定义 readObject 与 writeObject 方法的**，只要**某个类**中**按照特定的要求实现了 readObject 方法**（比如上面例子中 User 类实现了 readObject 方法），那么**在反序列化的时候就会自动调用它**，**如果这个自定义的 readObject 方法里进行了一些危险操作**，那么就会导致反序列化漏洞的发生了。

代码演示：

使用上面的代码，去掉注释。

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESpL7RJEWjMXEwWdIRyv9OGst6M9dCV1oqp443Au23SEfM3zSkmicwCCA/640?wx_fmt=png)

反序列化好后，**先自动执行自定义的 readObject 方法**，再执行调用的 info 方法。

在自定义的 readObject 方法中执行系统命令：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XVgibfKdr5KZkrFRdPKNib4ESsDo00570DvOCp68sClB28RNIGaso2GWHRIPIuW5icbvV3grNJLAgKoA/640?wx_fmt=png)

**真实应用中危险操作比较隐蔽**

java 中的各种流操作
------------

学习资料：https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html

**节点流**：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如 FileInputStream 和 FileOutputStream，他们直接从文件中读取或往文件中写入字节流。

**处理流**：“连接” 在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如 BufferedInputStream 和 BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率，以及 DataInputStream 和 DataOutputStream，使用已经存在的节点流来构造，提供了读写 Java 中的基本数据类型的功能。他们都属于过滤流。

Java 所有的**流类位于 java.io 包中**，都分别继承字以下四种抽象流类型。

<table width="964"><thead><tr><th><br></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table>

1.  继承自 InputStream/OutputStream 的流都是用于向程序中输入 / 输出数据，且数据的单位都是字节 (byte=8bit)
    
2.  继承自 Reader/Writer 的流都是用于向程序中输入 / 输出数据，且数据的单位都是字符 (2byte=16bit)
    

参考链接
----

https://github.com/Maskhe/javasec