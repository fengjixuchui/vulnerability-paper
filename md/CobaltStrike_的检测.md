<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yfbEYpL-ir6TJE0Ck010vA)

CobaltStrike 是一款渗透测试神器，支持 http/https、tcp、smb 等多种通信方式。

在 hvv 防守方、应急响应等场景中，都有检测 CobaltStrike 的需求。

现有检测方案
------

### 使用特征码扫描

*   https://github.com/Apr4h/CobaltStrikeScan
    
*   https://github.com/CCob/BeaconEye
    
*   https://github.com/jas502n/cs_yara
    

通常使用 yara 规则去匹配内存或者文件, 但缺点如不支持 3.x、只支持 http/https 的 beacon 等

### 内核检测方案

*   [2021] 检测 Cobalt Strike 只使用 40 行代码
    

其技术原理是

    1. 在内核通过 PsSetLoadImageNotifyRoutine 设置镜像加载通知回调，之后任何 exe,dll 的加载都会被检测。

    2. 而 CobaltStrike 使用 sRDI 方案，shellcode 会调用 LoadLibrary 来加载需要 dll，此时获取堆栈回溯

    3. 检测调用者的内存属性为是否为 private，是否可写

但缺点是

    1. 内核模块启动要先与 CobaltStrike，如果已经运行则无法检测

    2.  在客户业务环境中内核模块要保证稳定性兼容性，还要解决数字签名等问题

CobaltStrike 特征分析
-----------------

鉴于以上两种方案各有缺点，CobaltStrike 的特征到底是什么?

我认为有两个通用的特征

    1. 对于 http/https 通信而言 CobaltStrike 均使用 WinINet.dll 来进行通信

    2. 无论选择 exe/dll/raw 等格式，CobaltStrike 内存均会 sRDI

通过 ETW 记录 WinINet 日志
--------------------

ETW 可以记录 WinINet 的进程 id、线程 id、url、请求头、返回状态码、返回头等信息

在应急中，可以通过进程 id、线程 id、url 进一步排查，进而阻断其网络和进程。

### 手动操作步骤

    1. 打开事件查看器

    2. 打开菜单 查看 -> 显示分析和调试日志

    3. 进入 应用程序和服务日志 ->Microsoft->Windows->WinINet(Microsoft-Windows-WinINet)

    4. 右键启动 `Microsoft-Windows-WinINet/UsageLog` 日志

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaqRBCvfxUibMc0OCibvOuTJok176e0fPiaXhDryrQzy6bVyMQqR82uPemOI8MNrBRic7CPwFTGdrzTJg/640?wx_fmt=png)

                                        wininetlog

### 工具

用 C# 写了个简单的工具 WinINetLogger

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaqRBCvfxUibMc0OCibvOuTJokquWtgnoibElevfsnjOhUiaXwcEQyGxpNp9q70m9UEz55SFXXL9VIXWw/640?wx_fmt=png)

                                    wininetlogger

通过应用层的堆栈回溯判断 sRDI 和 CobaltStrike
--------------------------------

sRDI 本身具有很强的隐蔽性，在内存中可以任意编码、加密。

但正如前文提到的`内核检测方案`中，其调用系统 api 时，调用者的内存属性有问题。

正常调用系统 api 时，调用者内存属性一般为 IMAGE 类型，并且不可写。

但也有例外如 C# 和 V8 等包含 jit 即时编译的代码。

此时就需要结合 CobaltStrike 自身的特征

*   http/https 时，堆栈回溯只有两种情况
    

    1. 睡眠时：sRDI -> kernel32.dll!Sleep

    2. 通信时：sRDI -> WinINet.dll!xxxx

*   bindSMB 时，堆栈回溯只有两种情况
    

    1. 监听管道时：sRDI -> kernel32!ConnectNamedPipe

    2. 读取数据时：sRDI -> kernel32!ReadFile

*   bindTCP 时，堆栈回溯只有两种情况
    

    1. 监听端口时：sRDI -> ws2_32.dll!accept

    2. 接收数据时：sRDI -> ws2_32.dll!recv

分析调用堆栈时，如果这些 api 的调用者内存有问题，那么就可以确定是 CobaltStrike

### 通过 ProcessHacker 插件检测 CobaltStrike

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaqRBCvfxUibMc0OCibvOuTJoTLEACFRSf8t5l3mFFh2EpWE4aO2xjDGYoDyoiaibpggmhKb9BAfScuMw/640?wx_fmt=png)

参考链接
----

*   https://github.com/Apr4h/CobaltStrikeScan
    
*   https://github.com/CCob/BeaconEye
    
*   https://github.com/jas502n/cs_yara
    
*   https://medium.com/threat-hunters-forge/threat-hunting-with-etw-events-and-helk-part-1-installing-silketw-6eb74815e4a0
    
*   https://key08.com/index.php/2021/07/25/1260.html
    

工具和代码
-----

*   https://github.com/howmp/WinINetLogger
    
*   https://github.com/howmp/CobaltStrikeDetect
    
*   https://guage.cool/cobaltstrike-detect/processhacker.zip
    
*   https://guage.cool/cobaltstrike-detect/WinINetLogger.zip