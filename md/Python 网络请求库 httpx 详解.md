<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/blueberry-mint/p/15250125.html)

**_1_**|**_0_** **简介**
======================

httpx 是 Python 新一代的网络请求库，它包含以下特点

*   基于 Python3 的功能齐全的 http 请求模块
*   既能发送同步请求，也能发送异步请求
*   支持 HTTP/1.1 和 HTTP/2
*   能够直接向 WSGI 应用程序或者 ASGI 应用程序发送请求

**_2_**|**_0_** **安装**
======================

httpx 需要 Python3.6+（使用异步请求需要 Python3.8+）

```
pip3 install httpx
或
python3 -m pip install httpx
```

如果需要使用 HTTP/2，则需要安装 http2 的相关依赖

```
pip3 install httpx[http2]
或
python3 -m pip install httpx[http2]
```

**_3_**|**_0_** **使用**
======================

**_3_**|**_1_** **简单使用**
------------------------

httpx 与`requests`库的基本使用方法几乎是一模一样的

```
import httpx

r = httpx.get('https://httpbin.org/get')
print(r)  # <Response [200 OK]>
```

类似的，我们也可以使用`POST`, `PUT`, `DELETE`, `HEAD`和`OPTIONS`等请求方法，如下

```
r = httpx.post('https://httpbin.org/post', data={'key': 'value'})
r = httpx.put('https://httpbin.org/put', data={'key': 'value'})
r = httpx.delete('https://httpbin.org/delete')
r = httpx.head('https://httpbin.org/get')
r = httpx.options('https://httpbin.org/get')
```

带有请求头和请求参数的请求

```
import httpx

headers = {'user-agent': 'my-app/1.0.0'}
params = {'key1': 'value1', 'key2': 'value2'}
url = 'https://httpbin.org/get'
r = httpx.get(url, headers=headers, params=params)
print(r)
print(r.status_code)  # 状态码
print(r.encoding)  # 文本编码
print(r.text)
print(r.json())
```

结果如下

```
<Response [200 OK]>
ascii
{
  "args": {
    "key1": "value1", 
    "key2": "value2"
  }, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Host": "httpbin.org", 
    "User-Agent": "my-app/1.0.0", 
    "X-Amzn-Trace-Id": "Root=1-6139b788-2fd67d5627a5f6de346e154a"
  }, 
  "origin": "113.110.227.200", 
  "url": "https://httpbin.org/get?key1=value1&key2=value2"
}

{'args': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'my-app/1.0.0', 'X-Amzn-Trace-Id': 'Root=1-6139b788-2fd67d5627a5f6de346e154a'}, 'origin': '113.110.227.200', 'url': 'https://httpbin.org/get?key1=value1&key2=value2'}
```

请求带有 cookies

```
import httpx

url = 'http://httpbin.org/cookies'
cookies = {'color': 'green'}
r = httpx.get(url, cookies=cookies)
print(r.json())  # {'cookies': {'color': 'green'\}\}
```

设置超时时间

```
import httpx

r = httpx.get('http://httpbin.org', timeout=0.001)
print(r)
```

超过设置时间则报`httpx.ConnectTimeout: timed out`

**_3_**|**_2_** **高级用法**
------------------------

我们使用上面的请求方式时，httpx 每次发送请求都需要建立一个新的连接，然而随着请求的数量增加，整个程序的请求效率就会变得很低。

httpx 提供了`Client`来解决以上问题，`Client`是基于 HTTP 连接池实现的，这意味着当你对一个网站发送多次请求的时候，`Client`会保持原有的 TCP 连接，从而提升程序的执行效率。

### **_1_**|**_0_** **使用 Client 发送请求**

创建一个 client 对象，使用该对象去做相应的请求

```
import httpx

with httpx.Client() as client:
    headers = {'X-Custom': 'value'}
    r = client.get('https://example.com', headers=headers)
    print(r.text)
```

### **_1_**|**_0_** **跨请求共享配置**

我们可以将`headers`、`cookies`、`params`等参数放在`http.Client()`中，在`Client`下的请求共享这些配置参数

```
import httpx

headers1 = {'x-auth': 'from-client'}
params1 = {'client_id': '1234'}
url = 'https://example.com'
with httpx.Client(headers=headers1, params=params1) as client:
    headers2 = {'x-custom': 'from-request'}
    params2 = {'request_id': '4321'}
    r1 = client.get(url)
    print(r1.request.headers)
    r2 = client.get(url, headers=headers2, params=params2)
    print(r2.request.headers)
```

结果如下

```
Headers({'host': 'example.com', 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'user-agent': 'python-httpx/0.19.0', 'x-auth': 'from-client'})
Headers({'host': 'example.com', 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'user-agent': 'python-httpx/0.19.0', 'x-auth': 'from-client', 'x-custom': 'from-request'})
```

可以看出，r1 的请求头包含`{'x-auth': 'from-client'}`, r2 虽然配置了 headers2，但由于里面的 headers1 和 headers2 的参数不同，`Client`会合并这两个 headers 的参数作为一个新的 headers（如果参数相同，则 headers2 的参数会覆盖 headers1 的参数）。

### **_1_**|**_0_****HTTP 代理**

httpx 可以通过设置`proxies`参数来使用 http 代理，我们也可以使用不同的代理来分别处理 http 和 https 协议的请求，假设有如下两个代理

```
import httpx

proxies = {
    'http://': 'http://localhost:8080',  # 代理1
    'https://': 'http://localhost:8081',  # 代理2
}
url = 'https://example.com'
with httpx.Client(proxies=proxies) as client:
    r1 = client.get(url)
    print(r1)
```

上面的代理只是示范，实际场景下请替换成有效的 ip 代理

还有一点需要注意的是，httpx 的代理参数`proxies`只能在`httpx.Client()`中添加，`client.get()`是没有这个参数的。

### **_1_**|**_0_** **超时处理**

默认情况下，httpx 到处都做了严格的超时处理，默认时间为 5 秒，超过 5 秒无响应则报`TimeoutException`

```
# 普通请求:
httpx.get('http://example.com/api/v1/example', timeout=10.0)

# client实例:
with httpx.Client() as client:
    client.get("http://example.com/api/v1/example", timeout=10.0)
```

或者关闭超时处理

```
# 普通请求:
httpx.get('http://example.com/api/v1/example', timeout=None)

# client实例:
with httpx.Client() as client:
    client.get("http://example.com/api/v1/example", timeout=None)
```

### **_1_**|**_0_****SSL 验证**

当请求 https 协议的链接时，发出的请求需要验证所请求主机的身份，因此需要 SSL 证书来取得服务器的信任后。

如果要使用自定义的 CA 证书，则可以使用`verify`参数

```
import httpx

r = httpx.get("https://example.org", verify="path/to/client.pem")
```

或者你可以完全禁用 SSL 验证（不推荐）。

```
import httpx

r = httpx.get("https://example.org", verify=False)
```

**_3_**|**_3_** **异步支持**
------------------------

默认情况下，httpx 使用标准的同步请求方式，如果需要的话，我们也可以使用它提供的异步 client 来发送相关请求。

使用异步 client 比使用多线程发送请求更加高效，更能体现明显的性能优势，并且它还支持 WebSocket 等长网络连接。

### **_1_**|**_0_** **异步请求**

使用 async/await 语句来进行异步操作，创建一个`httpx.AsyncClient()`对象

```
import asyncio
import httpx


async def main():
    async with httpx.AsyncClient() as client:  # 创建一个异步client
        r = await client.get('https://www.example.com/')
        print(r)


if __name__ == '__main__':
    asyncio.run(main())
```

### **_1_**|**_0_** **同步请求与异步请求的比较**

我们来尝试使用同步和异步的方法进行请求，对比两种不同的方法的效率情况。

**同步请求**

```
import time
import httpx


def main():
    with httpx.Client() as client:
        for i in range(300):
            res = client.get('https://www.example.com')
            print(f'第{i + 1}次请求，status_code = {res.status_code}')


if __name__ == '__main__':
    start = time.time()
    main()
    end = time.time()
    print(f'同步发送300次请求，耗时：{end - start}')
```

同步发送 300 次请求，耗时：49.65340781211853

**异步请求**

```
import asyncio
import time
import httpx


async def req(client, i):
    res = await client.get('https://www.example.com')
    print(f'第{i + 1}次请求，status_code = {res.status_code}')
    return res


async def main():
    async with httpx.AsyncClient() as client:
        task_list = []  # 任务列表
        for i in range(300):
            res = req(client, i)
            task = asyncio.create_task(res)  # 创建任务
            task_list.append(task)
        await asyncio.gather(*task_list)  # 收集任务


if __name__ == '__main__':
    start = time.time()
    asyncio.run(main())
    end = time.time()
    print(f'异步发送300次请求，耗时：{end - start}')
```

异步发送 300 次请求，耗时：2.5227813720703125 （由于是异步执行的，所以打印的 i 值是无序的）

从两个例子可以看出，异步请求明显比同步请求的效率高很多。

以上就是 httpx 库的基本使用方法，想了解更多可以去 [httpx 官方文档](https://www.python-httpx.org/)中查看。

__EOF__

![](https://images.cnblogs.com/cnblogs_com/blueberry-mint/1783357/o_200612065730jenos.jpg)本文作者：**[蓝莓薄荷](https://www.cnblogs.com/blueberry-mint/p/15250125.html)**  
本文链接：[https://www.cnblogs.com/blueberry-mint/p/15250125.html](https://www.cnblogs.com/blueberry-mint/p/15250125.html)  
关于博主：评论和私信会在第一时间回复。或者[直接私信](https://msg.cnblogs.com/msg/send/blueberry-mint)我。  
版权声明：本博客所有文章除特别声明外，均采用 [BY-NC-SA](https://creativecommons.org/licenses/by-nc-nd/4.0/ "BY-NC-SA") 许可协议。转载请注明出处！  
声援博主：如果您觉得文章对您有帮助，可以点击文章右下角**【[推荐](javascript:void(0);)】**一下。您的鼓励是博主的最大动力！