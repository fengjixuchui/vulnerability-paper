<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/CWynBwrLN3vvwz_b7CdWzg)

‍  

    本文主要是针对 ReBeacon 项目的兼容合并之前二开时留下的记录。主要是将原生 Beacon 替换为 WBGlil 大佬的 ReBeacon。本人是比较菜的菜鸡，过程有一些错误时间问题就不改了。大佬们多多包容。

一、Stageless 构造分析

         ![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xLJukmKItxMoStvMksEVACRf7Us6xXFKk3IjU1ibpyhsyzfYorrbS8Gg/640?wx_fmt=png)

图:Stage 与 Stageless 关系

可能有些漏打 r 所以 Stageless 是普遍理解的 Stage 而 Stager 是 Stage，看图

当一般木马样本执行 Stager（Shellcode），该 Stager 大小一般在 1k 左右，功能是自动通过 Hash 查找 API 地址，并且下载最终 Stageless，该 Stageless 是包含 beacon 核心的一段 shellcode 通过 call 调用直接去执行这一组 shellcode，并且通过反射 DLL 注入技术将 DLL 注入到内存空间中，并且执行 DllMain 进入后门主体。

首先分析功能，Cobalt Strike 会通过协议来调用对应协议的处理函数:

“exportBeaconStage< 协议 >”   HTTP 和 HTTPS 是使用同一个函数

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xZWh2PXFd0c13m82Pm2FNb36XhqkXdrkaREJWryGuGyIWskicxj8hTicg/640?wx_fmt=png)

图:stageless 管理函数

              通过分析发现一个 payload 对应不同的导出 BeaconStage 函数。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xwfRjXcbgdPoibVUG2kI8K29Ypv69EV5OOA3xYMvLDeiavFictibOiaWRwOw/640?wx_fmt=png)

图:exportBeaconStageHTTP 函数

该函数根据处理器架构去从两个文件中选取一个进行读取，并且构造参数。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xLokYA4mB6NQibx3L8tUkAYAOJPM57snIEy2DG92uibeoicS8HWAiayptuw/640?wx_fmt=png)

图:DLL 文件选取

并且调用 exportBeaconStage 函数进行参数定义，该参数包含 profile 连接地址等信息。

如图所示，包含 URI 派生进程 水印等等信息，并且使用 beacon_obfuscate 进行异或加密。然后查找 AAAABBBBCCCC 进行替换为已经异或加密的参数信息

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xtiaR3e4BVL4vnScv01WAgOt5k2ebpRAT0rJZaUic4sO8Q9792YpJk2icw/640?wx_fmt=png)

图: 加密替换

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xbvh8DX68cxFUZ1YMfv1icvsAfXSzPQ6VnfHtSL8dJ6jfRibO7Ko4NlhA/640?wx_fmt=png)

图: 参数构造

              通过逆向分析，AAAABBBBCCCC 就是对应着 DLL 内部异或操作指令并且引用地址

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x7MUQmggaxHSW5utFtfZU48NQONUv4EVsUOia2HL1WRzOplEPIbBVicnQ/640?wx_fmt=png)

图: 异或操作

这个时候这个 DLL，直接通过 rundll32，可以进行上线了。但是 DLL 不能直接作为 Shellcode 进行加载，需要构造成反射 DLL 注入的 shellcode 才行。但是通过逆向发现 ReflectiveLoader 的指令为:int 3（中断 3，通过这个指令可以在调试模式产生断点效果） 和 nop（跳过 / 忽略） 并且没有多余的导出表函数，但是一般反射 dll 地址通过 ReflectiveLoader，但是该函数明显无效.

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xgW0eBYqZmseJou8HM3twcuHpAuI0pARdweVcSxMbacDBHcHt6GKYtw/640?wx_fmt=png)

图: ReflectiveLoader 函数

通过逆向 Cobalt Strike 分析发现 Cobalt Strike 通过查找 cc90909090 为定位点（跟 AAAABBBB 同理）进行替换，通过符号匹配定位 ReflectiveLoader 在文件偏移，以这个偏移进行查找。这个设计很巧妙，可以实现模块化替换代码数据，当然地址问题比较麻烦。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x4q7B1S1wWRQibW2NNT4f97p2MGmEjSIAhf8JriaqtqC36PDoELuAJstg/640?wx_fmt=png)

图: 查找 cc90 偏移

替换内容为 BeaconLoader，HV、MVF、VA 是根据 profile 中 allocator 参数控制，是申请内存方式，个人经验这里建议使用 VA，因为堆管理机制问题内存扫描概率很少会扫描到该地址。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x3fq6fumGMlX5ARk6f5z80GDWbvwfr0tss2qiaPA5NOOBGTTKhytO1iag/640?wx_fmt=png)

图:allocator 参数

这些. o 文件其实是 coff 文件对象文件，cobalt strike 会提取这些 coff 文件对应的代码段，一般不出意外是已经实现好地址寻址功能这里随机拿一个进行分析。

我们分析 VirtualAlloc 对应 BeaconLoader.VA.x64.o, 通过伪代码和对应指令调用堆栈寄存器 RSP+DllMain 偏移的函数，这里推断基本是 DLLMain 函数地址。并且发现该 coff 只有两个导出表。

功能方面，先查找对应的依赖库地址，并且定位 Kernel32EAT 和动态函数地址，最后申请内存，然后复制句柄和段和进程导入表等等，最后修改内存重定向表和打内存补丁，最后运行 DllMain。当然每一个函数地址内部样子这里不多分析，其实是 hash 定位得到对应 API 地址，然后执行对应流程如写入内存，申请内存空间等等。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x2lfBCKAmMAMTKibQUpxdUlDPqY3DAbNl9xiaVRYNX6M1GxHDibpPibibQvw/640?wx_fmt=png)

图:BeaconLoader.VA 核心流程

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x6CSpAEFKO8xtyBUer44rawprBaxvqhhTtlGOOA7BibWpMpSibyXnlMbw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xkicBET7tsPia4pCUHPBH3eXzUQGtZ84l1icXm2MH9uMRV246OyMyXIaicQ/640?wx_fmt=png)

图:BeaconLoader

       这样 ReflectiveLoader 被替换为对应内存申请方式的二进制代码。最后将处理好的 DLL 文件进行最后一步处理，加入寻找 ReflectiveLoader 函数的代码为头部，即可生成完成。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x5cocQrbaFMkFc5CdM3lq8okv90FBkxgVUIJVFmoGOShm6572zltuqQ/640?wx_fmt=png)

图:MZ 头

       当然这个 MZ 头不是 PE 文件的 MZ 头，而且汇编 pop 出栈指令

二、Stager 分析

Stager 其实就是普遍理解的 Shellcode，这组 shellcode 一般大小为 1k，一般功能是通过 hash 定位 API 地址，然后再调用 API 地址。

以下为定位 API 地址代码片段:

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xHjy16lpvuiaZXRGecYOLXrCkDGzPLqvic00AmnX42wloZnDQXsice0O7w/640?wx_fmt=png)

图:stager 头部

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xicmhibmiaQ8ef2ib5ibnmO4MwJ43AObTKSBF4COZib6BLmLJx8euFLoqb0SQ/640?wx_fmt=png)

图: 执行成功片段

       该定位片段执行完毕会通过图中 jmp eax 是进入跳转 api 内部，因为调研这个定位时就是通过 call 调用方式，如果再 call 调用会影响堆栈导致部分指针参数无法引用。

开始分析首先 Shellcode 通过 fs 寄存器的 0x30 偏移处获得 TEB 中的 PEB 指针，并且获取 Ldr 表

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xSetejmRicD48ETreJqhVdKW0qfHB14jhvxSyzAyebmJpBVjX1XsvLwg/640?wx_fmt=png)

图:TEB 结构体

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xELXPJURKH9KTYK1ep9HVx0ibtAyd4sGBrgJaZIicyNia8yxv4WSTPUQxQ/640?wx_fmt=png)

图:Ldr 与 PEB

       并且遍历里面链表，然后获取 InMemoryOrderModuleList 和 ShutdownInProgress 并且进行查询得到 kernel32.dll 的基地址然后获得导入表地址。

       流程：

TEB->PEB->Ldr->InMemoryOrderLoadList->currentProgram->ntdll->kernel32.BaseDll

       然后通过遍历并且通过 lodsb 指令计算对应函数名称 hash，然后得到 API 地址，最后恢复堆栈平衡，跳转到获取到的地址执行 API 功能。

l0x0726774C——LoadLibraryA

l0xA779563A——InternetOpenA

l0xC69F8957——InternetConnectA

l0x3B2E55EB—–HttpOpenRequestA

l0x7B18062D—–HttpSendRequestA

l0x315E2145—–GetDesktopWindow

l0x0BE057B7—–InternetErrorDlg

l0xE553A458—–VirtualAlloc

l0xE2899612—–InternetReadFile

这是这段 shellcode 调用的所有函数

1.LoadLibraryA 加载 wininet.dll

2.InternetOpenA->InternetConnectA->HttpOpenRequestA->HttpSendRequestA 创建连接发起请求

3.GetDesktopWindow->InternetErrorDlg 查找报错

4.VirtualAlloc 开辟内存

5.InternetReadFile 读入完整 shellcode

可以看到这段 shellcode 其实也只是一个远程下载的功能，当然整个 shellcode 一环扣一环感觉连接的很紧凑

三、Stageless 生成支持

原生 ReBeacon_Src 是带有 rawdata 数据的，替换为:AAABBBBCCCC 为开头即可需要长度 4096，我们称为标志数据，上面分析已经有对应的分析。注意入口函数异或算法的 key 也需一同修改。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x85kozaVjSR83SUDmUPVwPTlhbSdvyvbZKyUslXyYLZAd7gzXSUvZeg/640?wx_fmt=png)

图: 标志数据

入口算法，因为很多人需要绕过 Beacon_Eye，所以会对服务端 key 进行修改实现绕过 eye 目地。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xhMVysewsmQe6wuaSrVR1xnyj5ELrtKK2A8AfjpIRSeibnJCdcQ3cJzQ/640?wx_fmt=png)

图: 入口算法（0x61）

接着添加一个 ReflectiveLoader 导出函数，需要大量 int 3 和 nop 指令作为标志代码，因为服务端会对其进行替换覆盖为正确的加载代码。（长度一直延下去 一个中断 3 七个 nop）

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x28ADicnsIeL1BunZAo0dOY14XQCJdctdVIT2SCvaHfKACGrdF8r0ibng/640?wx_fmt=png)

图: 导出函数。

接着对项目进行编译，使用 CrackSleeve 进行加密为 beacon.x64.dll，替换二开环境的 sleeve 目录对应文件，接着生成 stageless 即可实现上线。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x9fhDv3PQ1sn39Tibjabdp5Jia5ibpcfLMtMtxnBMIFQT6yT1Mpia3Px1lA/640?wx_fmt=png)

图:Stageless 成功上线

四、对象文件加载修复

ReBeacon_Srcx 项目中对 BOF 功能仅停留在 x86(32 位) 上兼容，所以对于 32 位 BOF 可以做到完美加载，但是 x64 才是实战环境下的主要架构。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xWZRnOhMYkNlMkjabB7ERUBc8NXtS5IAMorQlcO85JwRMeHLb5VUynw/640?wx_fmt=png)

图: 问题代码点

通过代码分析，可以发现该流程为判断类型是否 6 和 20，并且修改对应段的偏移数据，还是比较复杂的算法。但是在 x64 下这段代码变得无效，所以需要添加见人 64 位的 bof 内存补丁功能。我们通过 IDA Pro

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xiaOOkQMUibib0BNzrHb4xDetLd6qHJ1vW7pF2sWVnxILG2pe5n3zZAh4w/640?wx_fmt=png)

图:x64 内存补丁伪代码

接下来通过宏定义，判断 WIN32 和 x64 架构，编译不同代码即可。类型小于 5 以下那么就跳出，如果是那么读取段数据对应的重定向值是否小于 0xffffffff 如果是那么修改 pcode+offset 对应的偏移值。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x7QoaRPK9LPNxMJF5eMjr8C46IzPClPt1SpXtLOqB4SwrqEoZiaINxTw/640?wx_fmt=png)

图: 内存补丁新代码

       接着使用自写 system 命令测试 bof 功能，成功加载。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xbPzGMOhw2YicW44MTT4UZpRFMvzicibIJtqfh5xdBVKrU1ulooJKT3jLw/640?wx_fmt=png)

图: 成功执行代码

                     （API 地址因为某些机制干扰 有 10% 功能性运行失败）

五、portscan 获取列表失败

在 cobalt strike 渗透过程，portscan 功能，对应的网段地址列表有时候无法获取。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xzx6f4U5DF03zkASSVErFB9OBhm2qYAJzBhBdq4gkC4c1IjTaWSCxQQ/640?wx_fmt=png)

图: 扫描窗口

这个对 cobaltstrike 的使用会造成不少没必要对麻烦，通过打开时命令会显确定问题在于 beacon 问题。

通过逆向发现，程序会最终发送一个 interfaces.x64.o 的 bof 对象文件到目标运行，获取对应的网段列表

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xXWJ8eAEpoZqSRiamZsM6W92mricorCfeX7Vop9Zw7VnO9Fbz3m1XUia4Q/640?wx_fmt=png)

图: 网段操作

       即然 bof 发送了，那么运行后应该会返回地址信息给 teamserver 那么只能重写这个对象文件了。 通过 IDA 分析该对象文件原理，发现通过 Iphlpap.dll 内部的 GetIfEntry 和 GetIpAddrTable 实现并且通过 beaconformatprintf 构造返回信息，而且发现其申请内存长度为 792，Windows SDK 编译可能根据编译器参数忽略一些参数等等会导致长度不一样所以需要进行修改改为动态获得参数。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xKPf5TyHRIL1iattfFxgOaJiaVwSjIdSGfse9CxKsZGzZARUXxibJ5ljAQ/640?wx_fmt=png)

图: 分析信息

根据该逻辑并且进一步完善，我们得到以下代码。直接忽略掉 LoadLibrary 的基本操作，直接进入重点代码。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xMiaJB6XvKialAleWZ5qtqmXfZz9iaxame4cxuibzrjM5cKCZbjqvthY4vw/640?wx_fmt=png)

图: 核心代码

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xu8LLTmEtom7nh0LboGgPfxh5jm0hAzDyEvibPmxGI8rBVfhtCI1TtwA/640?wx_fmt=png)

图: 修复成功

六、Hashdump 异常修复 （其它功能错误也是使用该方法修复）

Hashdump 导出时，报 error:2 错误，一般 cs 使用命名管道连接功能模块。如果错误代码为 2，那么代表没有找到路径可以推断功能没有被执行。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4x28wKzU9PD6L2fYtb2cBLks8cFJGEfpdoicyiaj4vozNM2DQGqoVoT1PQ/640?wx_fmt=png)

图: 异常代码 2

打开 spawn 函数，将 getDLLContent 返回值进行导出。通过 IDA 打开发现为一个 32 位程序（因为使用 32 位的寄存器与 32 位地址）。那么一个 64 位程序为什么使用 32 位动态连接库进行注入？？

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xonW2vIkoWcw9R6Wiab8icr8r7SXJnPrHHo14aaibRyIwvZ9lC0gmlVQWg/640?wx_fmt=png)

图: 汇编代码

那么既然确定错误点了，但是 spawn 其实没有问题，因为截屏缺没有问题，截屏也是使用 spawn 进行执行。那么分析一下这个 DLL 是怎么调取的。这个 GetDLLContent 其实就是资源读取通过 getDLLName 获取读取目标名。然后这个 Hashdump 是继承了 Job，所以上一级函数是直接调用 Hashdump 的 spawn 对象，然后 var2 就是架构名。看看调用语句。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xdNI5XM4CvHIFVku9eF74TzNK100PB1icIiaVL4voSicXYia7YGEdpHc88g/640?wx_fmt=png)

图:DLL 名字构造

发现使用 is64 函数，但是这个函数返回值却是 false 估计没被引用所以就算是 x64 因为 false 所以先取了 x86 返回值。那么我们直接参考截图功能使用 BeaconEntry 的 arch 函数即可获得架构类型，截图注释代码。

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xhI7elfTVNwmEUHks6IsGch4k4oNS5OuCLRmxZcD3E31TicIfTNmuDibg/640?wx_fmt=png)

图: 修复代码

然后成功执行 hashdump

![](https://mmbiz.qpic.cn/mmbiz_png/Rjauf06CllFkvAMNLGC17d35bOHH3x4xJVicjDEDhwictNYQKXSkdBrS7pq1vr4qConvTJuPpHbSd7FqMo5d9OmA/640?wx_fmt=png)

图:Hashdump