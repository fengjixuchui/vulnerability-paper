> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-274131.htm)

> 实战 dll 注入 (原理, 踩坑及排雷)

摘要
==

*   使用`vs2019`编写注入器程序, 在生成的注入器可用前, 踩了不少坑, 因此记录一下.
*   本文涉及三种恶意代码注入方法: 直接 dll 注入, 反射式 dll 注入, 镂空注入. 之所以选这三种注入方法, 是因最近在做一个检测进程内存空间以期发现代码注入的程序, 而实验发现这三种方法对目标进程的改变各有特点:
    *   直接 dll 注入: 还有 APC 注入, 本质都是在目标进程中执行`LoadLibrary`函数, 因而**在枚举目标进程的模块列表时可看到注入的 dll**.
    *   反射式 dll 注入: 这种方法也会在目标进程中开辟新的内存空间并写入代码. 但因为没有调用`LoadLibrary`, 所以**枚举目标进程的模块列表并不能看到注入的 dll. (意味着目标进程的 PEB 没有变化).**
    *   镂空注入: 直接改进程中某一模块的内存空间, 或者先注入一个合法模块, 再镂空该模块. **因为该方法没有注入恶意 dll, 所以直接枚举目标进程的模块列表也无法发现恶意代码, 需扫描进程的内存空间.**
*   标了`注:`的地方基本都是踩的坑.

直接注入
====

*   示例: LibSpy 项目的`OnMouseMove`和`InjectDll`
*   流程:
    *   `OpenProcess`打开目标进程 (一参为`PROCESS_CREATE_THREAD|PROCESS_QUERY_INFORMATION|PROCESS_VM_OPERATION|PROCESS_VM_WRITE| PROCESS_VM_READ`, 后面`CreateRemoteThread`才能执行)
        *   需要**给进程提权, 得到 SeDebug 权限**.
            1.  注: **准确地说不是提权, 而是将访问令牌中禁用的权限启用**. 成功调用下面几个函数的前提是进程具备该权限, 只是访问令牌中没有启用该权限. 而如果进程没有该权限, 则使用下面的函数后再调用`GetLastError`会返回`ERROR_NOT_ALL_ASSIGN`.
            2.  先用`LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&luid)`得到用户的 debug 权限.
            3.  然后用`OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,&hToken)`获取进程的令牌句柄.
            4.  最后用`AdjustTokenPrivileges`启用特权.
        *   若要打开关键进程 (`csrss.exe`等), 需在驱动中打开, 去掉关键进程的`EPROCESS`中的`PsIsProtectProcess`标志位, 并`关闭dll签名策略`. (参考开源项目`blackbone`)
    *   获取待注入的 dll 路径, 在目标进程内分配一块内存 (`VirtualAllocateEx`), 将路径拷贝到该内存中 (`WriteProcessMemory`)
    *   获取 kernel32 中的`LoadLibraryA`地址 (如果 dll 路径是宽字符串, 则用`LoadLibraryW`)
    *   调用`CreateRemoteThread`, 在目标进程中执行`LoadLibrary`, 进而执行`DllMain`函数中的目标代码
        *   注意, 因为`VirtualAllocEx`返回的是虚拟地址, 默认情况下`CreateRemoteThread`函数的`lpStartAddress`参数使用该地址是没问题的. 但是**若注入器是 32 位而被注入程序是 64 位**, 则可能导致`CreateRemoteThread`失败而返回 NULL. 参考: [createremotethread-returns-null-while-trying-to-use-it-to-inject-dll](https://stackoverflow.com/questions/60687458/createremotethread-returns-null-while-trying-to-use-it-to-inject-dll)

反射式注入 (reflective injection)
============================

*   概要
    *   没有使用`LoadLibrary`函数注入 dll.
    *   需由注入器自行解析 PE 文件:
        *   将 dll 头部 (包括`DOS头`, `PE头`, `区块表`) 逐字节写入新开辟的内存.
        *   按重定位表的信息手动重定位
        *   修复导入函数表: 使用`LdrLoadDll`得到 shellcode 需要的库的内存地址, 用`LdrGetProcedureAddress`得到要导入的函数的内存地址, 然后将这些地址填入导入表.
*   流程
    
    *   将自己实现的 LoadLibrary 功能函数保存为 shellcode.
        
        *   注: 在 shellcode 中使用的系统 api 都要事先通过`GetProcAddress`获取 (使用`GetModuleHandleA`获取模块句柄, 传入的模块名不用后缀), 并**作为参数传给 shellcode**.
        *   注: 需要审查注入器保存的 shellcode 是否是真实的函数体. 调试发现在 vs2019 中, 按默认选项编译**得到的函数地址处是一条跳转到实际函数体的 jmp 指令**. 因此`需要使用jmp指令的操作数计算实际函数地址`. 如下为获取一个 shellcode 函数的代码:
            
            ```
            // shellcode函数
            void shellcodeFunc(PMY_PARAMS pParams) {
                // pParams保存LdrLoadDll等系统api的内存地址
                // 用NtAllocateVirtualMemory在目标进程中开辟一块内存(需指定PAGE_EXECUTE_READWRITE权限)
                // 将dll的文件内容写入开辟的内存
                // 修复导入表; 重定位
                // 执行dll的入口函数DLLMain
            }
             
            DWORD size = 0, ssss=0;
             
            // 获取jmp指令后的双字操作数(即jmp的目的地址偏移)
            DWORD* jmpAddr = (DWORD*) ((BYTE*) shellcodeFunc + 1);
             
            // 加5得到jmp指令的下一条指令地址, 然后加上jmp的目的地址偏移, 得到函数体的实际起始地址
            WORD* Memx0 = (WORD*) ((BYTE*) shellcodeFunc + 5 + *jmpAddr);
            LONG_PTR* Memx = (LONG_PTR*) Memx0;
             
            // 用0xCCCCCCCCCCCCCCCC作为函数体结束识别标识.
            while (*Memx != 0xCCCCCCCCCCCCCCCC) {
                Memx++;
                size += 8;
            }
             
            // 将shellcode写入文件
            HANDLE hFile = CreateFile(LOADECODE, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, NULL, NULL);
            if (hFile) {
                WriteFile(hFile, Memx0, size, &ssss, NULL);
                CloseHandle(hFile);
            }
            ```
            
        *   注: 用 windbg 调试远程线程, 发现远程线程中`出现地址访问冲突`:
            *   原因 1: 出问题的地方试图读取`__security_cookie`
                *   解决: 编译时关闭`/GS`选项, 禁用栈保护.
            *   原因 2: 远程线程中试图调用一些不可用的函数, 包括`__CheckForDebuggerJustMyCode`, `_RTC_CheckStackVars`
                *   解决: 禁用`/JMC`选项, `/RTC`选项, 其他的如果是必要使用的动态库函数, 则需要用`LoadLibrary`和`GetProcAddress`获取, 且要确保目标进程已载入相应 dll.
        *   注: **shellcode 函数中不要用字符串常量, 因为在 vs2019 中调试发现这些字符串总是存在注入器进程的数据区而非栈上, 这样一来 shellcode 在运行时无法获取字符串 (毕竟注入并运行的 shellcode 在目标进程而非注入器进程)**. 在 shellcode 中最好还是通过传参的方式获取需要用到的字符串常量.
    *   在目标进程中开辟新内存, 依次写入:
        *   要注入的 dll 的文件内容.
        *   shellcode.
        *   传给 shellcode 的参数, 主要是 shellcode 需要的如下系统 api 的函数地址.
            *   `LdrLoadDll`: 获取注入的 dll 依赖的 dll 的内存地址.
            *   `LdrGetProcedureAddress`: 获取注入的 dll 需导入的函数的内存地址.
            *   `RtlInitAnsiString` `RtlAnsiStringToUnicodeString` `RtlFreeUnicodeString`: 用以配合上述两个函数, 得到导入函数的内存地址.
            *   `NtAllocateVirtualMemory`: 分配内存空间, 以写入要注入的 dll 的文件内容.
    *   创建远程线程, 执行 shellcode, 由 shellcode 载入 dll.
*   优点
    
    *   仅枚举进程模块列表并不能发现注入的 dll.
    
    ![](https://bbs.pediy.com/upload/attach/202208/873582_WA5PQQ93QAD3H2R.png)
    

镂空 (hollowing):
===============

*   概要:
    *   两种方式:
        *   镂空已有进程模块: 直接修改进程中已有模块的代码节, 注入恶意代码.
        *   先注入后镂空: 注入一个合法 dll(拥有合法签名), 然后修改 dll 入口点处代码为自己想执行的代码.
    *   下面只讲先注入 dll 后镂空的方法.
*   流程
    *   首先, 如普通的 dll 注入, `CreateRemoteThread`创建远程线程, 执行`LoadLibrary`注入一个 dll, 不同的是**注入到进程的是一个合法 dll(比如 system32 目录下的 dll)**.
    *   `EnumProcessModules`枚举进程模块, `GetModuleBaseNameA`得到每个模块的名称, 从而找到注入的 dll.
    *   注入器进程中分配 0x1000 的内存空间 (可用`malloc`或`HeapAlloc`), 然后将找到的 dll 的 PE 头部内容读进来.
    *   由 PE 头中的 optional 头得到目标 dll 的入口地址, 加上枚举模块时得到的 dll 的基址, 得到实际 dll 入口地址, 并用`WriteProcessMemory`向该地址写入 shellcode.
        *   注: 通过 windbg 调试发现, **注入入口地址不一定能成功执行 shellcode, 因为 DllMain 函数可能多次执行.** 如果只想执行一次 shellcode, `可把shellcode及其写在dll的末尾对齐空间.`
        *   如同反射式 dll 注入, 生成 shellcode 的方法也是在注入器中定义 shellcode 函数并获取其机器码.
    *   创建远程线程, 并以写入 shellcode 的地址为线程执行地址.
*   优点
    *   无需将恶意 dll 保存在磁盘中, 可躲避静态查杀.

[[2022 夏季班]《安卓高级研修班 (网课)》月薪两万班招生中～](https://www.kanxue.com/book-section_list-83.htm)

最后于 1 天前 被 wx_Niatruc 编辑 ，原因：

[#HOOK / 注入](forum-41-1-133.htm)