<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1631/)

[0x00 前言与背景](#toc_0x00)
-----------------------

学习beacon生成和调试分析和检测beacon的过程中的一些记录。

[0x01 二次开发CobaltStrike](#toc_0x01-cobaltstrike)
-----------------------------------------------

我这是在网上找到的一个由鸡哥反编译的一个CobaltStrike4.1版本，所以不在需要重新反编译了。如下是工作目录。`decomplie_src`是存储着CS反编译的代码，`lib目录`存储着cobaltstrike4.1.jar文件，作为库文件。`out`作为编译输出的目录，`src`存放着所需要的源码文件，也就是`decomplie_src`源码的子集。这里需要使用的工具是IDEA。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/7ec38214-4fe9-4bd6-9756-b31274b3c661.png)](https://storage.tttang.com/media/attachment/2022/06/27/7ec38214-4fe9-4bd6-9756-b31274b3c661.png)

首先新建一个项目，设置好项目名和路径之后，在Project下面新建两个目录，`decomplie_src`和`lib`目录。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/879304bd-749f-4fb9-9102-d921fd8d3d87.png)](https://storage.tttang.com/media/attachment/2022/06/27/879304bd-749f-4fb9-9102-d921fd8d3d87.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/ae38af40-3eaa-4f72-b0a8-7f5317bc590a.png)](https://storage.tttang.com/media/attachment/2022/06/27/ae38af40-3eaa-4f72-b0a8-7f5317bc590a.png)  
把反编译之后的decomplie_src目录里面的所有java文件复制到项目中的`decomplie_src`,并把cobaltstrike4.1.jar文件放到项目中的`lib`目录。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/db654056-8b66-4b05-bf8a-ac57caa7204a.png)](https://storage.tttang.com/media/attachment/2022/06/27/db654056-8b66-4b05-bf8a-ac57caa7204a.png)

对项目进行设置，添加模块依赖，在路径`File-->Project Structure-->Modules-->Dependencies`设置SDK。然后在Dependencies这个页面点一下"+"号，添加jar包，完成后点应用。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/feae85d3-7ff2-46a3-a483-52fba164cf6b.png)](https://storage.tttang.com/media/attachment/2022/06/27/feae85d3-7ff2-46a3-a483-52fba164cf6b.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/75088559-d521-4c9a-bd87-dc9d3fc7e641.png)](https://storage.tttang.com/media/attachment/2022/06/27/75088559-d521-4c9a-bd87-dc9d3fc7e641.png)

进入`Artifacts-->JAR-->From modules with dependencies`,设置一个MAIN CLASS为`aggressor.Aggressor`,这个值可以在`MANIFEST.MF`文件中查看。完成之后就是这样的结果。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/583b9b73-bc8f-4759-8088-7e3ea780b607.png)](https://storage.tttang.com/media/attachment/2022/06/27/583b9b73-bc8f-4759-8088-7e3ea780b607.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/ba705d56-f6d4-4ddf-afb5-be5848cd9c31.png)](https://storage.tttang.com/media/attachment/2022/06/27/ba705d56-f6d4-4ddf-afb5-be5848cd9c31.png)

然后就是将`decomplie_src`复制到`src`中，这里直接将网上编译的那个版本的src目录复制到本项目的`src`目录中，如果有其他需求可以自己从`decomplie_src`复制添加即可。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/a0633644-7662-4b9b-99c9-70deaaa484fb.png)](https://storage.tttang.com/media/attachment/2022/06/27/a0633644-7662-4b9b-99c9-70deaaa484fb.png)

`Build -->Build Artifacts -->Build`进行编译。在out目录就可以看到生成的.jar文件。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/6d451a26-9639-48ff-94bc-c90002bd64db.png)](https://storage.tttang.com/media/attachment/2022/06/27/6d451a26-9639-48ff-94bc-c90002bd64db.png)

在`Run --> Profile-->Edit...`编辑配置，选择“+”号，在JAR Application添加一个配置文件。在`Path to jar`选择编译生成的jar包路径。在`VM Optionals`填入`-XX:+AggressiveHeap -XX:+UseParallelGC`  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/bbb32806-610e-4d1a-a5d6-7e16f2f58566.png)](https://storage.tttang.com/media/attachment/2022/06/27/bbb32806-610e-4d1a-a5d6-7e16f2f58566.png)

以后每次要运行或者调试的时候，都可以`Run-->Profile-->Run(debug)`  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/06bd9380-19da-4aca-b6bc-3390c41ca56e.png)](https://storage.tttang.com/media/attachment/2022/06/27/06bd9380-19da-4aca-b6bc-3390c41ca56e.png)

最后就完成了。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/91837c06-ff61-4000-bb01-1ef6c30d5b19.png)](https://storage.tttang.com/media/attachment/2022/06/27/91837c06-ff61-4000-bb01-1ef6c30d5b19.png)

[0x02 beacon生成原理](#toc_0x02-beacon)
-----------------------------------

beacon生成主要有3个步骤，首先是将C2Patch的相关数据patch到beacon中，便于beacon使用，第二步，处理beacon的PE数据和添加引导shellcode，这段shellcode是引导执行ReflectiveLoader。第三步将beacon加密，并和一些数据patch到loader中。

在beacon生成这块，主要涉及到4个java文件。BeaconPayload.java主要是对beacon进行C2Profile相关的处理，主要涉及的函数为`exportBeaconStage`。MalleablePE.java，主要用于对beacon进行一些PE相关的处理，主要涉及的函数为`process`函数。而BeaconLoader.java主要是patch beacon的开头那段shellcode。主要涉及到`patchDOSHeader`函数。BaseArtifactUtils主要是将加密beacon数据和一些加密beacon的key之类的数据patch到loader模板上，

CobaltStrike服务端，通过()生成beacon，经过分析，将断点分别下在`WindowsExecutableStageDialog.dialogAction`和`WindowsExecutableStageDialog.dialogResult`这两个函数处。通过 dialogAction函数，选择需要保存的文件的内容或者格式。然后调用`SafeDialogs.saveFile`函数，弹出保存文件的选择框。

接着调用`dialogResult`函数，dialogResult函数是生成beacon的主要流程，参数的参数var1表示保存beacon的路径。

依次获取架构类型(x86或者x64)，然后监听器这里选的是reverse_http。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/b2408fd8-f7f0-43b9-a9ce-5d45c8f8d2a2.png)](https://storage.tttang.com/media/attachment/2022/06/27/b2408fd8-f7f0-43b9-a9ce-5d45c8f8d2a2.png)

然后调用`ScListener.export`函数,export函数的作用是通过不同的监听器，选择不同的Stage。本例中是调用eaconPayload.exportBeaconStageHTTP函数。exportBeaconStageHTTP的参数分别是(var1)端口，(var2)链接地址，var3，var4分别是false，var5是架构。通过不同的架构选择不同的BeaconStage数据。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/eb4fced7-f24c-4c00-b1af-59093161b52d.png)](https://storage.tttang.com/media/attachment/2022/06/27/eb4fced7-f24c-4c00-b1af-59093161b52d.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/15d96c2f-ae64-4ef1-a1ce-b5f1c5bb17c7.png)](https://storage.tttang.com/media/attachment/2022/06/27/15d96c2f-ae64-4ef1-a1ce-b5f1c5bb17c7.png)

在`exportBeaconStage`函数中，首先调用`SleevedResource.readResource`加载指定的beacon原始文件  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/51fb1080-8847-42a7-b21f-1b82c2cd5783.png)](https://storage.tttang.com/media/attachment/2022/06/27/51fb1080-8847-42a7-b21f-1b82c2cd5783.png)

然后读取C2Profile中的uri等C2Profile信息。我曾经根据这些默认的C2Profile的URI信息，捞到过一批有价值的CobaltStrike样本。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/d064796f-5a17-4d0c-984a-4eadc0da4758.png)](https://storage.tttang.com/media/attachment/2022/06/27/d064796f-5a17-4d0c-984a-4eadc0da4758.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/d714d5fb-945f-46e1-938e-6835ddb26824.png)](https://storage.tttang.com/media/attachment/2022/06/27/d714d5fb-945f-46e1-938e-6835ddb26824.png)

在解析完C2Profile数据之后，就会按照一定的顺序将这些C2Profile的参数拼装起来，并patch到beacon中，以供beacon使用。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/71c86be2-d8f7-4bbd-9a45-e51229c927f4.png)](https://storage.tttang.com/media/attachment/2022/06/27/71c86be2-d8f7-4bbd-9a45-e51229c927f4.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/8e9d9b83-0cc3-4cd3-ba5a-d54754c86f69.png)](https://storage.tttang.com/media/attachment/2022/06/27/8e9d9b83-0cc3-4cd3-ba5a-d54754c86f69.png)

在`beacon\BeaconConstants.java`这个文件中，可以看到C2Profile数据拼接序号的含义。在之前分析exportBeaconStageHTTP参数的时候，var1为端口。可以看到这里第二个处理的就是端口。而`beacon\BeaconConstants.java`文件的第二项的内容也是端口。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/1fda1fb4-6542-4f93-84b9-946b098d6daa.png)](https://storage.tttang.com/media/attachment/2022/06/27/1fda1fb4-6542-4f93-84b9-946b098d6daa.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/ee4236bd-cc55-4c77-b0e1-f7656026cb83.png)](https://storage.tttang.com/media/attachment/2022/06/27/ee4236bd-cc55-4c77-b0e1-f7656026cb83.png)

拼接C2Profile数据的是和，CobaltStrike使用`addShort`,`addInt`,`addData`,`addString`四个函数添加数据。其中前三个为基本函数，`addString`底层是通过`addData`实现的。以addData为例子，通过分析参数，可知依次添加了index，type，length，和value。且如果是short类型，type为1，如果是int类型，type为2，如果是Data或者string类型呢，type就为3了。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/cc8bb317-08e5-4b37-a4c3-b7bf787404dd.png)](https://storage.tttang.com/media/attachment/2022/06/27/cc8bb317-08e5-4b37-a4c3-b7bf787404dd.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/40e71229-666b-40ab-b53e-6dbe45d42ea2.png)](https://storage.tttang.com/media/attachment/2022/06/27/40e71229-666b-40ab-b53e-6dbe45d42ea2.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/cbaf710b-0288-4e31-a06c-451444f97f57.png)](https://storage.tttang.com/media/attachment/2022/06/27/cbaf710b-0288-4e31-a06c-451444f97f57.png)

然后将这些数据转化为byte类型，然后将其与46进行进行异或运算。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/86b317d6-eed8-45bd-b66f-32a572b6e545.png)](https://storage.tttang.com/media/attachment/2022/06/27/86b317d6-eed8-45bd-b66f-32a572b6e545.png)

将读取的原始beacon文件的byte转化为string类型，并定位其中的“AAAABBBBCCCCDDDDEEEEFFFF”字符串。然后用C2Profile数据替换掉。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/6e05faf1-c2bf-4506-ad45-10a9b98eb84c.png)](https://storage.tttang.com/media/attachment/2022/06/27/6e05faf1-c2bf-4506-ad45-10a9b98eb84c.png)

当C2Profile的数据patch到beacon之后呢，开始处理PE数据，CobaltStrike在处理PE数据的时候分为两部，首先会对PE数据进行预处理，也就是从C2Profile中读取关于PE处理的相关数据，例如image_size，compile_time等等，然后对这些PE的基础数据进行处理。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/176bcd30-cae2-4a4c-a3ac-7d2437ddb6ac.png)](https://storage.tttang.com/media/attachment/2022/06/27/176bcd30-cae2-4a4c-a3ac-7d2437ddb6ac.png)

在对PE数据进行预处理之后呢，根据所选择的架构不同，patch DOS头，也就是前面那段shellcode。首先调用findReflectiveLoader函数，通过导出表获取`ReflectiveLoader`导出函数地址。然后将该地址填充到shellcode中，其实分析过这种stage类型的beacon会发现，这种payload本质就是一个PE文件，只不过PE头被修改成一段可以执行的shellcode，这个shellcode的目的就是引导至ReflectiveLoader函数。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/f32cc7b3-625a-48aa-b7a8-9b5c65b55e65.png)](https://storage.tttang.com/media/attachment/2022/06/27/f32cc7b3-625a-48aa-b7a8-9b5c65b55e65.png)

构造合适的Loader,在`_patchArtifact`函数中，首先读取指定的Loader的模板，该模板位于resources/目录下面，然后生成一组随机的byte数组，并用这些数组对beacon进行异或加密，这也是为什么每个生成的beacon都是不一样的原因。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/8c77b7d2-3bd5-46ce-b47e-80fe7e1f97f4.png)](https://storage.tttang.com/media/attachment/2022/06/27/8c77b7d2-3bd5-46ce-b47e-80fe7e1f97f4.png)

然后依次保存1024个A所在地址偏移+16这个地址，beacon的长度，异或加密的随机数组，GetModuleHandleA，GetProcAddress函数地址(如果可以的话)，保存加密之后的beacon数据，将上述数据替换到那1024个A处。然后将byte[]写入指定文件即完成beacon的生成。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/126170b8-070f-4485-a280-bedbbb44036f.png)](https://storage.tttang.com/media/attachment/2022/06/27/126170b8-070f-4485-a280-bedbbb44036f.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/a8d748f5-c230-4083-9461-6505a2daa42a.png)](https://storage.tttang.com/media/attachment/2022/06/27/a8d748f5-c230-4083-9461-6505a2daa42a.png)

[0x03 beacon分析调试](#toc_0x03-beacon)
-----------------------------------

根据上面分析，cobalt strike 的stage模式从loader通过CreateThread执行beacon。经过一小段shellcode之后，执行`ReflectiveLoader`，在`ReflectiveLoader`处理完PE数据之后，其实是跳转到了DllEntryPoint函数。此处将重点分析beacon对于C2Profile的解析过程。

很显然，在beacon中，第一个函数的作用是定位当前EIP,第二个函数即就是`ReflectiveLoader`,经过对PE的一些处理之后，最后会执行`DllEntryPoint`.  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/05b99884-90d7-4776-847a-e70f880b92fb.png)](https://storage.tttang.com/media/attachment/2022/06/27/05b99884-90d7-4776-847a-e70f880b92fb.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/df4eadf5-e99e-4445-afe6-17668d54e38e.png)](https://storage.tttang.com/media/attachment/2022/06/27/df4eadf5-e99e-4445-afe6-17668d54e38e.png)

在dwReason为1的时候初始化C2Profile数据，在`Sub_339762_Parse_C2Profile`函数中，很显然，可以看到将C2Profile进行了解密。在内存中，大概还是以 index，type，length，value的顺序进行分布。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/fa8a426c-0aa4-4e07-ae97-d2ba0376243e.png)](https://storage.tttang.com/media/attachment/2022/06/27/fa8a426c-0aa4-4e07-ae97-d2ba0376243e.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/fbd3c33f-3321-4a62-ada8-4d18d597796d.png)](https://storage.tttang.com/media/attachment/2022/06/27/fbd3c33f-3321-4a62-ada8-4d18d597796d.png)

然后读取整个解密数据，解析出type和value，只将这两项目保存到刚刚malloc的内存中。并且将type和value从偏移为8的地址处开始保存。而这一部分数据的分布顺序就是一些检测工具，例如BeaconEye的检测原理。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/3e501b97-82cc-45b4-8e45-5f4462a9cad1.png)](https://storage.tttang.com/media/attachment/2022/06/27/3e501b97-82cc-45b4-8e45-5f4462a9cad1.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/f1d69d62-447f-4e73-a291-89d2ee78d5c8.png)](https://storage.tttang.com/media/attachment/2022/06/27/f1d69d62-447f-4e73-a291-89d2ee78d5c8.png)

其实，往下面翻一番是能找到所链接的server的。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/dc15fcce-7116-43cc-96d0-b8e0b29c9833.png)](https://storage.tttang.com/media/attachment/2022/06/27/dc15fcce-7116-43cc-96d0-b8e0b29c9833.png)

[0x04 BeaconEye原理分析](#toc_0x04-beaconeye)
-----------------------------------------

BeaconEye使用C#开发，通过使用yara规则，检测beacon解析之后的C2Profile数据分布实现的。因为libyaraNET库没有x86版本，所以BeaconEye务必编译成X64版本，才可以通过。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/94b28b2e-ca2d-464c-81bf-8e1a82283e33.png)](https://storage.tttang.com/media/attachment/2022/06/27/94b28b2e-ca2d-464c-81bf-8e1a82283e33.png)

以x86的yara规则举例子，yara第一段为全0，因为C2Profile数据是从+0x08处开始复制的，所以前八个字节没有数据为全0，剩下的数据就很简单了，根据解析C2Profile的变量类型来看，前六个数据类型分别是short，short，int，int，short，short对应的type分别是01，01,02,02,01,01。这样就是检测的原理。  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/c2f729c8-a600-4777-8cf6-93874e9c4448.png)](https://storage.tttang.com/media/attachment/2022/06/27/c2f729c8-a600-4777-8cf6-93874e9c4448.png)  
[![mark](https://storage.tttang.com/media/attachment/2022/06/27/edd5cebd-01aa-4459-b22f-036aed117bb5.png)](https://storage.tttang.com/media/attachment/2022/06/27/edd5cebd-01aa-4459-b22f-036aed117bb5.png)

[0x05 参考](#toc_0x05)
--------------------

*   [CobaltStrike二次开发环境初探](https://blog.51cto.com/u_15274949/2931535)
*   [CobaltStrike逆向学习系列(2)：Stageless Beacon 生成流程分析](https://xz.aliyun.com/t/10784)
*   [CobaltStrike逆向学习系列(3)：Beacon C2Profile 解析](https://xz.aliyun.com/t/10785)
*   [CobaltStrike逆向学习系列(5)：Bypass BeaconEye](https://xz.aliyun.com/t/10832)