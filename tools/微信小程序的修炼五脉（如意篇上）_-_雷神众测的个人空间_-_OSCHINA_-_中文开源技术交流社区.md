<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [my.oschina.net](https://my.oschina.net/u/4587690/blog/4451620)

> 声明 由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，雷神众测以及文章作者不为此承担任何责任。

_**声明**_

由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，雷神众测以及文章作者不为此承担任何责任。

雷神众测拥有对此文章的修改和解释权。如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经雷神众测允许，不得任意修改或者增减此文章内容，不得以任何方式将其用于商业目的。

_**No.1  
**_

_**前言**_

如意如意顺我⼼意，若不能顺我⼼意，我将竭尽全⼒，⽤⾃⼰的技术改变其意。

笔者是⼀位极其 “不听话” 的⼈，我不想要程序它觉得，我要我⾃⼰觉得；⾃⼰重新定义程序的逻辑以及游戏规则，掌控这其中的数据，让每⼀个环节都顺⾃⼰的⼼意，直到看到⾃⼰想要的结果为⽌。在这篇⽂章中，作者将会带领⼤家寻找微信⼩程序中特有且常⻅的任意⼿机号登录漏洞，并为读者们带来⼀种你从未听说以及利⽤过 并且只有在⼩程序中才会存在的类似于 CSRF 的漏洞。

此专题由于篇幅较⻓将会拆分为 “如意篇 （上）”、“如意篇（下）” 两篇⽂章，还请您⻅谅。

_**No.2  
**_

_**都是 sessionkey 惹的祸**_

不知读者们是否发现有些微信⼩程序有 “微信⼿机号快捷登录” 的功能，轻轻⼀点即会弹出所以保存在微信之中已经被信任的⼿机号，⽆需再接收验证码即可实现⼀键登录已经经过微信验证的⼿机号，⾮常之便捷。

![](https://oscimg.oschina.net/oscnet/5f0730c3a2693d2ff017dd8bf7b4b6d5ee3.png)

这个功能在微信⼩程序中名为 “获取⼿机号”，⽬前只向以中国⼤陆为主体的企业认证账户开放使⽤，并 在越来越多的企业级⼩程序中得到了完美的运⽤，其官⽅说明⽂档如下：

<table><tbody><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:0.col1:0.col1:9.classicTable1:0" powered-by="xiumi.us"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:9.classicTable1:0.td@@0"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:9.classicTable1:0.td@@1"><section powered-by="xiumi.us"><section><div colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:9.classicTable1:0.td@@1:0.classicTable1:0.td@@0"><section powered-by="xiumi.us"><p>获取微信⽤户绑定的⼿机号，需先调⽤ wx.login 接⼝。&nbsp;</p><p>因为需要⽤户主动触发才能发起获取⼿机号接⼝，所以该功能不由 API 来调⽤，需⽤ button 组件 的点击来触发。&nbsp;</p><p><strong>使⽤⽅法：</strong></p><p>需要将 button 组件 open-type 的值设置为 getPhoneNumber ，当⽤户点击并同意之 后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三 ⽅服务端结合 session_key 以及 app_id 进⾏解密获取⼿机号。</p></section></div></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:9.classicTable1:0.td@@2"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td></tr></tbody></table>

按照官⽅的开发⼿册，想使⽤ “获取⼿机号” 功能⾸先须在⼩程序内调⽤ “wx.login” 接⼝，示例代码如下：

wx.login({

   success (res) { 

    if (res.code) { 

      // 发起⽹络请求 

      wx.request({ 

 url:'https://demo.c-est.cool/Login',         console.log('成功将 code 传给⼩程序后端！')

  data: { 

    code: res.code }

     } else {

     console.log('登录失败！' + res.errMsg)

      }

   } 

})

当微信⼩程序运⾏⾄ “wx.login” 代码处时，会调⽤微信服务器的接⼝返回 “code” 参数：

<table><tbody><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:0.col1:0.col1:14.classicTable1:0" powered-by="xiumi.us"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:14.classicTable1:0.td@@0"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:14.classicTable1:0.td@@1"><section powered-by="xiumi.us"><section><div colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:14.classicTable1:0.td@@1:0.classicTable1:0.td@@0"><section powered-by="xiumi.us"><p>code：⽤户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调⽤ auth.code2Session，使⽤ code 换取 openid 和 session_key 等信息&nbsp;</p></section></div></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:14.classicTable1:0.td@@2"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td></tr></tbody></table>

可以将 “code” 参数理解为⼀次性校验⽤的 token，未使⽤的 code 有 5 分钟的有效期，⼀但使⽤⽆论调⽤成 功与否，此 code 便会失效。当⼩程序成功获取到 code 时，开发者便可使⽤预留代码将对应的 code 值传 回⼩程序后端服务器以便接下来调⽤ “auth.code2Session” 接⼝： 

<table><tbody><tr opera-tn-ra-comp="_$.pages:0.layers:0.comps:0.col1:0.col1:16.classicTable1:0" powered-by="xiumi.us"><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:16.classicTable1:0.td@@0"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:16.classicTable1:0.td@@1"><section powered-by="xiumi.us"><section><div colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:16.classicTable1:0.td@@1:0.classicTable1:0.td@@0"><section powered-by="xiumi.us"><p>登录凭证校验（本接⼝应在服务器端调⽤）。通过 wx.login 接⼝获得临时登录凭证 code 后传到 开发者服务器调⽤此接⼝完成登录流程。请求地址：GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET &amp;js_code=JSCODE&amp;grant_type=authorization_code</p></section></div></section></section></td><td colspan="1" rowspan="1" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.col1:0.col1:16.classicTable1:0.td@@2"><section powered-by="xiumi.us"><section><svg viewBox="0 0 1 1"><text x="-10" y="-10">_</text></svg></section></section></td></tr></tbody></table>

通过使⽤ “appId”、“appSecret” 和登录时获取到的“code”（js_code）内容来换取：“openid”（⽤户唯⼀ 标识）、“session_key”（会话密钥）等值。如下图所示，可以看到微信拥有⼀套⾮常成熟的⼩程序登录流程：  

![](https://oscimg.oschina.net/oscnet/87743648a179ef1ebcc2051530d774427c2.png)

在这此流程中 “session_key” 起到了⾄关重要的作⽤，只要能获取此 key 的内容，便可以控制回调凭证内容，使整套登录安全体系破产。咋们的微信爸爸（滴，5Q 币到账）肯定考虑到了这个问题，所以给出了如下提醒：

1. 开发者服务器可以根据⽤户标识来⽣成⾃定义登录态，⽤于后续业务逻辑中前后端交互时识别⽤户身份； 

2. 会话密钥 session_key 是对⽤户数据进⾏ 加密签名的密钥。为了应⽤⾃身的数据安全，开发者 服务器不应该把会话密钥下发到⼩程序，也不应该对外提供这个密钥。 

总结⼀下就是：从微信这边获取到的 “session_key” 打死也不能直接返回给⽤户，但你实在要返回⽤于校 验⽤户身份的话我也拦不住你，但求求你⾏⾏好使⽤⾃⼰⽣成的第三⽅ key 返回吧，将 “session_key” 和 ⾃⼰⽣成的 key 在数据库中做个关联就⾏。

然⽽，这毕竟只是个提醒，总会有开发者 “看不⻅”🙈或者不听取的，你懂的。接着我们回到“获取⼿机号” 功能，在顺利调⽤ “wx.login” 和“auth.code2Session”接⼝之后便可轻松得到 加密之后的⽤户⼿机号数据和加密使⽤的初始向量（iv)，将这些数据传递给微信⼩程序后端并使 ⽤ “session_key” 作为解密 key 可得到如下 json 数据：

（本段删除）最后我们来到⼩程序包的数据段，数据段的构造⾮常简单仅有 “内容块” 这么⼀个数据块，⾥⾯储存了每⼀个索引段中存在索引的⽂件的实际内容。

{ 

 "phoneNumber": "+33711123333",    "purePhoneNumber": "711123333",         "countryCode": "33", 

"watermark": 

{ 

     "appid":"APPID", 

     "timestamp": TIMESTAMP

   } 

}

♥phoneNumber：⽤户绑定的⼿机号（国外⼿机号会有区号）；

♥purePhoneNumber：没有区号的⼿机号；♥watermark：内含对应⼩程序的 appid 和数据加密时的时间戳。

可以看到这些参数都是可以轻易伪造的，并且⼩程序后端并不会对得到的⼿机号做⼆次校验例如短信验 证码校验（不然这个快捷登录功能便失去了意义），故只要 “session_key” 泄露我们便可以伪造登录凭证 实现任意⼿机号登录。

那便先来聊⼀聊⼩程序数据的加解密吧：微信使⽤的是 AES 加密，CBC 模式采⽤ PKCS7 填充，数据块⻓ 度为 128 位，输出使⽤ base64 编码。AES 是⽤于替代 DES 加密的对称加密算法，对称加密算法最⼤的特 性便是加、解密使⽤的同是⼀串密钥，只要获取到 key 便可加解⾃如（CBC 加密模式下还需要 iv 偏移量参数，⼀般固定不变或作为变量内容传输）

![](https://oscimg.oschina.net/oscnet/f4a572c7d96a79bb926aa9d3c60489dc26e.png)

上图为微信服务器加密⽤户开放数据的具体流程，使⽤的加密 key 与 “session_key” 为同⼀个，偏移量 iv 则直接与加密后的数据⼀起明⽂返回给了⼩程序后端。有细⼼的读者可能会看到此流程中有⼀个⽤于防 ⽌内容被篡改的签名过程，这个签名仅在 “获取⽤户信息” 功能中才会⽣成，在 “获取⼿机号” 功能中并⽆， 但这并不是微信的漏洞，因为签名是采⽤ sha1( rawData + sessionkey ) ⽅式⽣成的，若 session_key 泄露则⼀切验证签名的操作均是⽆济于事。

根据微信⼩程序对数据加密的⽅式，我们可以写出如下数据解密脚本：

<?php 

echo "请输⼊ SessionKey:"; 

$sessionKey = fgets(STDIN); 

echo "请输⼊本次加密 IV:"; 

$iv = fgets(STDIN); 

echo "请输⼊待解密内容:";

$encryptedData = fgets(STDIN);

function decryptData($encryptedData, $iv, $sessionKey) { $aesIV = base64_decode($iv); $aesCipher = base64_decode($encryptedData);  

$aesKey = base64_decode($sessionKey); $result = openssl_decrypt($aesCipher, "AES-128-CBC", $aesKey, 1, $aesIV); $dataObj = json_decode($result); 

return $result;

 } 

$result = decryptData($encryptedData, $iv, $sessionKey); 

echo sprintf("最终的解密结果为: %s\n", $result);

以及对应的数据加密脚本：

 <?php 

echo "请输⼊ SessionKey:"; 

$sessionKey = fgets(STDIN); 

echo "请输⼊本次解密 IV:";

 $iv = fgets(STDIN); 

echo "请输⼊待加密内容:"; 

$decryptedData = fgets(STDIN);

 function encryptData($decryptedData, $iv, $sessionKey) 

{ 

$aesIV = base64_decode($iv); $aesCipher = $decryptedData; $aesKey = base64_decode($sessionKey); 

$result = openssl_encrypt($aesCipher, "AES-128-CBC", $aesKey, 0, $aesIV); $dataObj = json_decode($result); 

return $result; 

} 

$result = encryptData($decryptedData, $iv, $sessionKey); 

echo sprintf("最终的加密结果为: %s\n", $result);

最终加、解密脚本运⾏效果如下

![](https://oscimg.oschina.net/oscnet/362e4d0f49c6e80581a21c99660eab14464.png)

巧妇难为⽆⽶之炊，有了解密之巧⼿，便得开始花式寻找 “session_key” 了。笔者为⼤家总结了如下三类 常⻅造成 “session_key” 泄漏的场景供⼤家参考：

**第⼀类：微信⼩程序 AppSecret 泄露** 

有⼀种看不⻅叫做开发觉得你看不⻅，你可以在⼩程序包内的配置⽂件中、Ta 的某个博客某篇⽂章中、 GitHub ⼩仓库中等等地⽅找到被泄露的 AppSecret

![](https://oscimg.oschina.net/oscnet/187d75675cfd939522a549181fe2f9cbd8e.png)

之后通过微信官⽅ API 的 jscode2session 功能便可直接获取⽬标⼩程序的 SessionKey （此接⼝调⽤没 有 IP ⽩名单限制）。有读者可能会问，请求参数 code 如何获取？其实⾮常简单，在⼩程序内找⼀个有登 录功能的地⽅（会触发 wx.login 的地⽅），然后开始抓包并⼈⼯触发登录功能，之后⼩程序便会把获 取到的 code 值传送回后端服务器，这时候只要拦截⼀下数据包即可获取 code 参数。

![](https://oscimg.oschina.net/oscnet/e5d0f216334d3c7c7dfd6d5011ff1fa6c41.png)

**第⼆类：在请求登录或获取 openid 时直接返回 SessionKey**

在许多⼩程序中当⽤户执⾏登录操作时，会将获取到的 code 值传送回服务器后端以便后端执⾏ jscode2session 操作来⽣成 SessionKey 。但许多程序开发者由于安全意识淡薄，当成功获取 SessionKey 值会将其内容直接返回给⽤户⽽不是与第三⽅ key 做关联处理返回第三⽅ key。例如下图为 ⾮常典型的案例，使⽤ code 换取 session_key：

![](https://oscimg.oschina.net/oscnet/b30d9bc1e77fdd134565df897f7d74d7727.png)

另外在⼀些⼩程序中需要获取⽤户在此⼩程序中的 openid 来识别⽤户的身份，但由于获取 openid 与获 取 session_key 使⽤的 api 为同⼀个均为 jscode2session ，所以在许多案例中在返回 openid 的同时也返 回了 session_key 的值。例如下图案例中，⼩程序只想要获取 openid 的值，但开发者没有对使⽤ API 获取 到的数据做过滤，连带着 session_key 的值⼀起返回了：

![](https://oscimg.oschina.net/oscnet/0a28269c5ca2c076be3d1bd1fd2c3f6406b.png)

这两个例⼦的程序后端部分代码可归纳如下，可以看⻅直接将通过 API 获取到的内容返回给了⽤户，并未 对获取到的数据做任何⼲预处理：

public void GetCode(string js_code)

 { 

string serviceAddress = "https://api.weixin.qq.com/sns/jscode2session?appid=XXX&secret=XXX"

+ "&js_code=" + js_code + "&grant_type=authorization_code"; HttpWebRequest 

request = (HttpWebRequest)WebRequest.Create(serviceAddress);

request.Method = "GET"; request.ContentType = "text/html"; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, System.Text.Encoding.UTF8); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); 

var obj = new

 { 

data = retString, 

msg = "success"

 };

Formatting microsoftDataFormatSetting = default(Formatting);

 string result =JsonConvert.SerializeObject(obj, microsoftDataFormatSetting); HttpContext.Current.Response.Write(result); 

}

第三类：在查询第三⽅ key 等功能中返回 SessionKey 当开发者⾮常规范的使⽤第三⽅ key 来关联 session_key，并且⼀切操作查询均只使⽤第三⽅ key，那么 是不是就没法获取到原本的 session_key 值了？其实也不尽然，例如如下图的⼩程序中整个登录流程⼗分 的规范，乍⼀看⼗分的安全，攻击者⽆法在登录流程中获取到 session_key 的值：

![](https://oscimg.oschina.net/oscnet/a65ea1132e0d86628bc84f72f516f238fd7.png)

但问题就出在这第三步操作中，⼩程序在执⾏完登录流程之后，使⽤对应⽤户的第三⽅ sessionID 查询⽤ 户信息。但在这个 api 中，开发者将数据库中对应 sessionID 的数据全部返回了，这其中包含有与其关联 的⼀个或多个 session_key 的值：

![](https://oscimg.oschina.net/oscnet/27f5532a1c0115c2ec6ebb35580a5bb83bd.png)

以上这三类就是常⻅的造成 session_key 泄露的场景，有了它你就可以在各种⼿机号之间来去⾃如了。

_**招聘启事**_

安恒雷神众测 SRC 运营（实习生）  
————————  
【职责描述】  
1.  负责 SRC 的微博、微信公众号等线上新媒体的运营工作，保持用户活跃度，提高站点访问量；  
2.  负责白帽子提交漏洞的漏洞审核、Rank 评级、漏洞修复处理等相关沟通工作，促进审核人员与白帽子之间友好协作沟通；  
3.  参与策划、组织和落实针对白帽子的线下活动，如沙龙、发布会、技术交流论坛等；  
4.  积极参与雷神众测的品牌推广工作，协助技术人员输出优质的技术文章；  
5.  积极参与公司媒体、行业内相关媒体及其他市场资源的工作沟通工作。

【任职要求】   
 1.  责任心强，性格活泼，具备良好的人际交往能力；  
 2.  对网络安全感兴趣，对行业有基本了解；  
 3.  良好的文案写作能力和活动组织协调能力。

简历投递至 strategy@dbappsecurity.com.cn

设计师（实习生）

————————

【职位描述】  
负责设计公司日常宣传图片、软文等与设计相关工作，负责产品品牌设计。

【职位要求】  
1、从事平面设计相关工作 1 年以上，熟悉印刷工艺；具有敏锐的观察力及审美能力，及优异的创意设计能力；有 VI 设计、广告设计、画册设计等专长；  
2、有良好的美术功底，审美能力和创意，色彩感强；精通 photoshop/illustrator/coreldrew / 等设计制作软件；  
3、有品牌传播、产品设计或新媒体视觉工作经历；

【关于岗位的其他信息】  
企业名称：杭州安恒信息技术股份有限公司  
办公地点：杭州市滨江区安恒大厦 19 楼  
学历要求：本科及以上  
工作年限：1 年及以上，条件优秀者可放宽

简历投递至 strategy@dbappsecurity.com.cn

安全招聘  
————————

公司：安恒信息  
岗位：Web 安全 安全研究员  
部门：战略支援部  
薪资：13-30K  
工作年限：1 年 +  
工作地点：杭州（总部）、广州、成都、上海、北京

工作环境：一座大厦，健身场所，医师，帅哥，美女，高级食堂…

【岗位职责】  
1. 定期面向部门、全公司技术分享;  
2. 前沿攻防技术研究、跟踪国内外安全领域的安全动态、漏洞披露并落地沉淀；  
3. 负责完成部门渗透测试、红蓝对抗业务;  
4. 负责自动化平台建设  
5. 负责针对常见 WAF 产品规则进行测试并落地 bypass 方案

【岗位要求】  
1. 至少 1 年安全领域工作经验；  
2. 熟悉 HTTP 协议相关技术  
3. 拥有大型产品、CMS、厂商漏洞挖掘案例；  
4. 熟练掌握 php、java、asp.net 代码审计基础（一种或多种）  
5. 精通 Web Fuzz 模糊测试漏洞挖掘技术  
6. 精通 OWASP TOP 10 安全漏洞原理并熟悉漏洞利用方法  
7. 有过独立分析漏洞的经验，熟悉各种 Web 调试技巧  
8. 熟悉常见编程语言中的至少一种（Asp.net、Python、php、java）

【加分项】  
1. 具备良好的英语文档阅读能力；  
2. 曾参加过技术沙龙担任嘉宾进行技术分享；  
3. 具有 CISSP、CISA、CSSLP、ISO27001、ITIL、PMP、COBIT、Security+、CISP、OSCP 等安全相关资质者；  
4. 具有大型 SRC 漏洞提交经验、获得年度表彰、大型 CTF 夺得名次者；  
5. 开发过安全相关的开源项目；  
6. 具备良好的人际沟通、协调能力、分析和解决问题的能力者优先；  
7. 个人技术博客；  
8. 在优质社区投稿过文章；

岗位：安全红队武器自动化工程师  
薪资：13-30K  
工作年限：2 年 +  
工作地点：杭州（总部）

【岗位职责】  
1. 负责红蓝对抗中的武器化落地与研究；  
2. 平台化建设；  
3. 安全研究落地。

【岗位要求】  
1. 熟练使用 Python、java、c/c++ 等至少一门语言作为主要开发语言；  
2. 熟练使用 Django、flask 等常用 web 开发框架、以及熟练使用 mysql、mongoDB、redis 等数据存储方案；  
3: 熟悉域安全以及内网横向渗透、常见 web 等漏洞原理；  
4. 对安全技术有浓厚的兴趣及热情，有主观研究和学习的动力；  
5. 具备正向价值观、良好的团队协作能力和较强的问题解决能力，善于沟通、乐于分享。

【加分项】  
1. 有高并发 tcp 服务、分布式等相关经验者优先；  
2. 在 github 上有开源安全产品优先；  
3: 有过安全开发经验、独自分析过相关开源安全工具、以及参与开发过相关后渗透框架等优先；  
4. 在 freebuf、安全客、先知等安全平台分享过相关技术文章优先；  
5. 具备良好的英语文档阅读能力。

简历投递至 strategy@dbappsecurity.com.cn

岗位：红队武器化 Golang 开发工程师  
薪资：13-30K  
工作年限：2 年 +  
工作地点：杭州（总部）

【岗位职责】  
1. 负责红蓝对抗中的武器化落地与研究；  
2. 平台化建设；  
3. 安全研究落地。

【岗位要求】  
1. 掌握 C/C++/Java/Go/Python/JavaScript 等至少一门语言作为主要开发语言；  
2. 熟练使用 Gin、Beego、Echo 等常用 web 开发框架、熟悉 MySQL、Redis、MongoDB 等主流数据库结构的设计, 有独立部署调优经验；  
3. 了解 docker，能进行简单的项目部署；  
3. 熟悉常见 web 漏洞原理，并能写出对应的利用工具；  
4. 熟悉 TCP/IP 协议的基本运作原理；  
5. 对安全技术与开发技术有浓厚的兴趣及热情，有主观研究和学习的动力，具备正向价值观、良好的团队协作能力和较强的问题解决能力，善于沟通、乐于分享。

【加分项】  
1. 有高并发 tcp 服务、分布式、消息队列等相关经验者优先；  
2. 在 github 上有开源安全产品优先；  
3: 有过安全开发经验、独自分析过相关开源安全工具、以及参与开发过相关后渗透框架等优先；  
4. 在 freebuf、安全客、先知等安全平台分享过相关技术文章优先；  
5. 具备良好的英语文档阅读能力。

简历投递至 strategy@dbappsecurity.com.cn

![](https://oscimg.oschina.net/oscnet/6979d03b195b4d6f105bde781ff882d8f86.jpg)

专注渗透测试技术

全球最新网络攻击技术

END

![](https://oscimg.oschina.net/oscnet/8f979665ecf1ad08a53b3e9d082c25cee69.jpg)

本文分享自微信公众号 - 雷神众测（thorsrc）。  
如有侵权，请联系 support@oschina.cn 删除。  
本文参与 “[OSC 源创计划](https://www.oschina.net/sharing-plan)”，欢迎正在阅读的你也加入，一起分享。