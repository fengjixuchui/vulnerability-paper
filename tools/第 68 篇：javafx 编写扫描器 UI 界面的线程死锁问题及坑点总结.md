<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/sJeYip6xszmUVx9L8qZAaQ)

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450ATcz6jUJnFNeOxRzVZ9Lbc0INLwTJTZT1GaNutZrfDn6csvjBoS2ox0efLUEexXqPEcVbYfbLo8w/640?wx_fmt=png)

 **Part1 前言** 
--------------

**大家好，我是 ABC_123**。之前编写工具的图形界面都是用 swing 框架来实现，但是 swing 框架已经 10 几年没有更新了，很多控件使用起来特别麻烦，然后界面美工需要花费很大精力。为了跟上知识更新的节奏，ABC_123 最近花时间学习了 javafx（有 swing 的基础，学习 javafx 上手是非常快的），于是花时间把之前的扫描工具的图形界面换成了 javafx，**但是在多线程操控图形界面控件的时候，遇到了一系列线程死锁问题**，为了解决这些问题，ABC_123 又踩了一大堆坑，今天当做笔记，自我复盘的同时，也把经验分享给大家。

 **Part2 技术研究过程** 
------------------

*   **扫描器设计思路**
    -----------
    

我想实现如下功能：burpsuite 抓到一个数据包之后，点击右键弹出菜单，将指定的扫描任务发送到服务端的 “扫描任务队列” 去进行扫描，与服务端通信是通过 socket 实现的。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969sQ7Neytm3sT3VStqA7PbXkTjZhLCZyxd6kibtvJGh7tvmKkibbb1Hzaw/640?wx_fmt=png)

“扫描任务队列” 会监听一个端口，收到 burpsuite 的任务请求之后，会新建一个 Tab 标签，然后每个任务分配 10 个线程扫描，也就是说，每一个 Tab 标签对应着一个扫描任务，每个扫描任务都是 10 个线程在运行。在编写这个扫描工具过程中，踩了一大堆坑，接下来把解决方法分享给大家。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969B5VUiaT6aQOyFEe8lSmBhibmujsQzxk8k6RmqibXSXtFVafcMI4166K1A/640?wx_fmt=png)

*   ### **坑 1：多线程中添加一个 Tab 标签直接报错**
    

刚开始用多线程操作 javafx 控件就遇到了一个报错，向图形界面添加一个图形控件时，报错提示 “Not on FX application thread; currentThread = Thread-3”，大致意思是 “当前线程不是 JavaFX 应用程序线程”。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969EKKFGotyXajTrJ7PHQpSezUibLzzib4zF8eKr8EYue9XI3j5FymdszibA/640?wx_fmt=png)

经过一系列搜索发现，操控 javafx 的图形控件需要用以下 Java 语句包裹起来就可以了 Platform.runLater(() -> { });。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969Qbj8CVt2Lp0eCdjiaOiccuYfft4Lq79VvzZmspLiaJz1LicQ1icUDTgzaEQ/640?wx_fmt=png)

*   ### **坑 2：Platform.runLater 与 ReentrantLock 可重入锁的选择问题**
    

进过前面探讨我们知道，Platform.runLater 保证 javafx 线程安全，ReentrantLock 锁可以保证全局变量的线程安全问题。这就引出一个问题，对于如下代码，当多线程操控 **qq.readResCount = qq.readResCount + 1;** 这个全局变量的值时，它本身已经被 **Platform.runLater(() -> {});** 包裹了，用不用加上再 ReentrantLock 锁保证线程安全呢？

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969N8xGDVkb0HAZULTkYwcvp2MbalKsjE0mygLTfIjv06YtFNOeBRia69g/640?wx_fmt=png)

在网上各种百度谷歌，然后询问身边的人，对这个问题说法不一，所以我干脆就自己编写一个测试代码，实战测试一下吧。

 **1  全局变量不加锁的错误写法**

首先回顾一下多线程资源竞争问题，如下代码运行之后出现错，因为多线程操控全局变量没有任何限制，很明显会出现竞争问题。正常输出是 7、8、9、10 随机出现，但是却出现了多个 10 及多个 11 的情况，输出结果明显不正确。接下来分情况测试一下，**探究一下 Platform.runLater 与 ReentrantLock 锁应该怎么配合使用**。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ39696icpIuiaWmYc6c3alaMtlTdVa2SuVerPGl85hT6X1rU7dUuy7zrb4BDA/640?wx_fmt=png)

 **2  Platform.runLater 不用，ReentrantLock 锁使用**

首先看这种情况，运行后马上各种报错，说明 **ReentrantLock 锁无法保证 javafx 控件的线程安全问题**。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ396941WK3dkZAdvkECzIK0mjuKeFeC3GiaEOUO3XKsib5BO3Xic7Zj3TUWgWg/640?wx_fmt=png)

 **3  Platform.runLater 使用，ReentrantLock 也使用**

接下来看这种情况，运行后非常稳定，没有问题，但是对于 Quanjv.count 全局变量的改变，ReentrantLock 锁是否可以去掉呢？

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969GRiciasfQKu74IQRZJZdTHObwDLdxfeC5YA486N7L3cAbHqwUMsU425Q/640?wx_fmt=png)

 **4  把 ReentrantLock 锁去掉**

接下来看这种情况，把 ReentrantLock 锁去掉，由 Platform.runLater 保护 Quanjv.count，发现程序运行之后，没有问题，说明 Platform.runLater 在保证 javafx 控件安全时，也能保证全局变量的线程安全。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969NuLH588ef8CGtRGDCYYxj0z2M7jIZfVnJQ2t4f9MkjKhPcpZqYwib2w/640?wx_fmt=png)

通过以上的测试，最终我们得出一个结论：

**1.** Platform.runLater(() -> {}); 不但可以保证 Javafx 控件线程安全，同时也可以保证全局变量数据的线程安全。

**2.** ReentrantLock 锁可以保证全局变量数据的线程安全，但是对于保证 javafx 控件线程安全毫无用处。

*   ### **坑 3：javafx 控件取值和修改值是否需要加锁**
    

在网上搜索了很多说法，答案不一，那我们还是编写测试代码，来测试一下吧。

 **1  javafx 控件取值过程测试**

为了保证测试效果，我们设置 100 个线程同时操作 textThread 方法，高并发可以提升线程安全问题报错的机率。经过测试我们发现，对于 TextArea 的多线程取值过程，不用加 Platform.runLater(() -> {});，也可以保证线程安全。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969bn6NfsE2nLDeVdWfs4jB1oOtHedjuhp1W5mIsnyh5wd6kj4GomibUMQ/640?wx_fmt=png)

 **2  javafx 控件修改值过程测试**

接下来再添加一行修改 javafx 控件文本框的代码：Quanjv.textarea.setText("test");，发现在 100 个线程操作下程序立马报错。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969j05UocXK09gFUPLEqvlI9zSLUKClW8FMSjGkOyczQWSGbaBzXibqkJQ/640?wx_fmt=png)

接下来对修改 javafx 值的代码用 Platform.runLater(() -> {}); 包裹起来，程序运行之后发现，100 个线程下没有任何错误。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969icghOUfUzvSOfYt9Bu5EwcwicLHqdXpb4HkH2e6KUPD1XoOrO0w124Qw/640?wx_fmt=png)

最终得出结论，**javafx 的控件的取值过程基本上不涉及线程安全问题，但是对于 javafx 组件的任何修改，必须考虑线程安全问题**。

*   ### **坑 4：Tabs 标签移除问题**
    

当发送一个扫描任务队列时，TabPane 会新建一个 Tab 标签，每个标签 10 个线程运行，双击 Tab 标签，就会停止该任务的多线程扫描，Tab 标签的标题会提示 “停止..” 字样，直到所有活动线程安全结束，该标签关闭。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969l99TaGvLKnolPh8ts2JOecLccbDxV70ofFibfLszicJ0ia6GrDicoVQZhw/640?wx_fmt=png)

代码是按照如下格式编写的，用 Platform.runLater(() -> {}); 代码包裹起来，按理上不存在线程安全问题。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969KIjfwoo5Ah16iaR8UPsOh3sfvXDgxicZ2eic2Kb7k1iaQvkbYaycD3C3Sg/640?wx_fmt=png)

但是实测结果，经常在如下代码中，出现报错问题，导致程序崩溃，所有扫描任务停止。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969uJQ1QdOPfSQb0S1ftvzY1S9gwqh4QGCn94rBhqZbDZziaRWyGoATnJQ/640?wx_fmt=png)

**这是一个隐藏非常深的线程安全 bug，在一天中会不定时的出现几次，而且没办法复现，让我大伤脑筋**。后来我终于想明白了，一个 TabPane 是由多个标签组成的，当你双击关闭其中一两个标签时，tabPane 的所有索引 id 都变了，而另一个线程对于 Tab 标签的 for 循环操作还在进行当中，而且还是按照原始的索引去遍历，而原始的索引都变了，造成了程序的崩溃。

*   ### **坑 5：jdk8 与 jdk11 等高版本不兼容**
    

举个例子，对于以下这个图形界面，是使用 scenebuilder20.x 版本拖拽出来的，看着没有问题。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969mQvS0gxDOiaKc7xaiaO4wiafN7GCJ9QN5ny97e1hiaoU0kYMUE42oXliazQ/640?wx_fmt=png)

但是如果用 sceneBuidler 8.x 版本打开，整个界面的很多控件的位置都乱了，重叠在一起。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969fQLkFnLHcoiatfZAcC3LibHbxfGapBI5tq6piaQ3JKqWAotxCQD5GQsWw/640?wx_fmt=png)

最终得出结论：**javafx 的图形界面在 jdk8 及其它高版本 jdk 是存在兼容性问题的**，Scenebuilder8.x 适用于 jdk8 版本的图形界面拖拽，Scenebuilder20.x 适用于 jdk11 到 jdk20 的版本的图形界面拖拽。

*   ### **坑 6：fmxl 行数过多会很卡**
    

用 Scenebuilder 拖拽的方法画图形界面，感觉特别方便，但是也有问题。比如说我写的如下工具，fxml 文件已经快 1500 行了，此时再用 scenebuilder 拖拽会特别卡。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969Efpph6BEJAN0rZq9SjK7MT693Wvbic9HdfUmevILicGB0X3poibibyanNw/640?wx_fmt=png)

最终没有办法，**我将其中一个 TabPane 界面的 Tab 标签删掉，用纯 java 代码编写，有时候用纯 java 代码写图形界面比拖拽是要方便的**。以下这个界面，按钮控件特别多，每个按钮的功能类似，于是我用一个 Map 集合放置每一个按钮标题和按钮事件中用到的关键值，然后用一个 for 循环，遍历 Map 集合添加 Button 按钮组件，很快搞定这个界面，比 Scenebuilder 拖拽图形界面还方便。

我们也可以发现，通过 java 纯代码编写的图形界面，比 Scenebuilder 拖拽的看起来要规整，**因为很多时候拖拽会在控件对齐方面会有误差**，这就是 java 代码编写图形界面的好处。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969D2A45rJgBzicuYSbxVEI3wC8eozpSjrRKb4d5c2mJ9BOEUOkTzkmIaQ/640?wx_fmt=png)

*   ### **坑 7：javafx 在 jdk11 至 jdk17 的编译问题**
    

按照正常的编写 javafx 程序的流程，idea 2022 版本编译出来的 jar 包，有时候会提示找不到主类，有时候会提示缺少 JavaFX 运行组件。对于 jdk8 下的 javafx 的编译，很简单，直接编译成一个 jar 包就可以在 jdk8 上双击运行，因为 jdk 是自带 javafx 库的，但是对于更高版本的 jdk，比如说 jdk11 或者 jdk17，默认是不带 javafx 库的，所以就引发出各种各样的问题。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969ibuZ3ZW8KTAMWibBvibfkLbGKF2vdFyGspVpmVltRBRE0EwoRXibylmXkQ/640?wx_fmt=png)

网上有很多解决这个问题的方法，但是说法不一，于是我经过各种测试，得出如下步骤，可以保证编译的 jar 包能够正常运行。

首先使用 idea 2022 新建项目，JDK 选择大于等于 jdk8 的版本即可，小于 jdk8 不支持 javafx。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969IxPUvJvqoRGicx69esZhorwtxEicat9CI7r1u4YbavetMLpoBmF511vw/640?wx_fmt=png)

可以看到 idea 2022 版本，已经自动在 pom.xml 文件中添加了 javafx 库了。所以我们无需添加额外的 javafx 的 jar 包，有的解决方案说是要从 javafx 官网下载 jar 包导入，实际上是没必要的。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ396937JYZTru34padxW4dCRXicMYUm41AicwYjKkJhZMeCG3KgYzYzMW4t8Q/640?wx_fmt=png)

接下来是最重要的一个步骤，我们需要新建一个主类，按照如下格式编写：

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969RE2DDVNpjtl1xDhqTjPXs1Lep9BJrmpiakDbFGUUmnH3YcicAhx7ukVA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969owyL4R32eJMlpuL7GJ14NJuXdn7IrRBxDcekibZFFQslOqC01kTNpXQ/640?wx_fmt=png)

接下来需要设置如何去编译 jar 包文件，主类需要选择我们新建的 JavaFXBootstrap 类，**记住一定要删掉 main\resources**。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969PtnVeIicQcxoKpRvW1Acdc5WPuLha4af079v6bs2Xvdp7uEM8KZt4IA/640?wx_fmt=png)

如下图所示，这是正确的 idea 配置。按照上述的操作编译出来的 jar 包，可以完美运行而不报错。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450AbQwfsn8aQToTzMhkJ3969ev3ZiaYC7txIDIDmYclP26dIlZpl2Qd7vA914Owlow3m4Q0OICKA0Uw/640?wx_fmt=png)

 **Part3 总结** 
--------------

**1.** 遇到线程安全问题，最好的方法就是写个 demo 程序在高并发下反复测试。

**2.** 其余的总结及结论都在文章里每一部分给出了，这里不再重复。

![](https://mmbiz.qpic.cn/mmbiz_png/OAz0RNU450A5qqg2iaK6KIYYR8y6pF5Rh3JHDibOKOop204nXz618iawdRb8dABicMPtHb2PkJE8x6koJO5HyuwZJQ/640?wx_fmt=png)

**公众号专注于网络安全技术分享，包括 APT 事件分析、红队攻防、蓝队分析、渗透测试、代码审计等，每周一篇，99% 原创，敬请关注。**

**Contact me: 0day123abc#gmail.com(replace # with @)**