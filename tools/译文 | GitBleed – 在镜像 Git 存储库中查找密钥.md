> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/m8ITw8HK1snTfAWRXZqV7Q)

![图片](https://mmbiz.qpic.cn/mmbiz_png/icqm3vRUymZn6f9UZkbSzllpAhtMSnQPLicWLUZVibJIfgZYW9Qz1aia3aJXJQYpFBbVrzia2Eia7aWerSicYjTo3qUlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

开卷有益 · 不求甚解

![图片](https://mmbiz.qpic.cn/mmbiz_png/icqm3vRUymZn6f9UZkbSzllpAhtMSnQPLibPj7xyP4TibzJib9MLnGJEicI99DGzzHictNnev4xwIBbTqN1ticJ6NQwDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  

概括
--

由于 Git 行为的差异，当通过“git clone”命令进行复制时，源代码存储库的部分部分是可见的。存储库的其他部分仅在使用“–mirror”选项时才可见。如果没有正确删除，这可能会导致机密通过 git 存储库暴露，并且当针对克隆的非镜像副本扫描存储库以获取机密时，会产生错误的安全感。

攻击者和漏洞赏金猎人可以利用 Git 行为中的这种差异在公共存储库中找到隐藏的秘密和其他敏感数据。

组织可以通过使用“–mirror”选项分析其存储库的更完整副本并使用BFG或git-filter-repo等工具（它们做得更彻底）删除敏感数据来缓解这种情况。

技术细节
----

Git 是一种流行的开源工具，用于源代码的版本控制。当用户复制本地或远程 git 存储库时，他们使用“git clone”命令。但是，此命令不会复制原始存储库中的所有数据，例如已删除的分支和提交。另一方面，有一个“–mirror”选项可以复制存储库的更多部分。这两种行为之间的差异可能导致机密和其他敏感数据在原始存储库中挥之不去。此外，现有的秘密检测工具通常在克隆的存储库上运行，并且不会检测存储库镜像部分中的秘密，除非通过“–mirror”命令进行克隆。

我们还在 GitHub 和 GitLab 中测试了分叉，在这两个系统中，分叉在后台使用常规的“git clone”，而不是“–mirror”版本。这意味着镜像部分中包含秘密的存储库不会将这些秘密传播到它们的分支。

我们提供了两个包含隐藏秘密的存储库示例，这些秘密仅在使用“–mirror”选项进行克隆时可见。这些可以在这里找到：

*   gb_testrepo_delete – 删除分支后保留机密
    
*   gb_testrepo_reset – 重置 git 历史记录后保留机密
    

如果您尝试在没有“–mirror”选项的情况下克隆存储库并检索密钥，它将不起作用：

![图片](https://mmbiz.qpic.cn/mmbiz_png/icqm3vRUymZmFyWqTz8IVcfgDGYSXpkPsnP1nTLdWHCukFOouyrmyqialrwoBSiaVWo3ticu7ntZHQKPOYOR18UU0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

和：

![图片](https://mmbiz.qpic.cn/mmbiz_png/icqm3vRUymZmFyWqTz8IVcfgDGYSXpkPsxm6Vx7M53ib5b82NCVgBqfpdic8Hs6p3Zjrhg0CZSjRYdB0J8CqXsVhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

如果您尝试使用“–mirror”选项进行相同操作，您现在可以检索密钥（还要注意检索到的对象数量较多）：

![图片](https://mmbiz.qpic.cn/mmbiz_png/icqm3vRUymZmFyWqTz8IVcfgDGYSXpkPsBiaISIyFicL7jtF73emliaickYKiaAe0Az5yDoeIypNfYufytxkiascH6MwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

和：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)img

如果您在克隆的存储库上运行gitleaks，则找不到任何秘密：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)img![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)img

但是，在镜像副本上运行gitleaks会发现隐藏在已删除区域中的秘密：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)img![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)img

工装
--

有很多现有的工具可以操纵 git 存储库，扫描它们的秘密并删除特定的提交。在我们的研究中，我们使用 git 检查存储库，使用git-filter-repo确定同一存储库的克隆副本和镜像副本之间的增量，以及使用 gitleaks扫描机密。

有关如何使用这些工具的示例，请参阅我们已发布到 GitHub的示例脚本。

缓解措施
----

组织可以通过使用“–mirror”选项分析大部分存储库来缓解这种情况，并使用BFG或git-filter-repo等工具删除敏感数据。还建议在 git 中进行垃圾收集和修剪。

组织不应分析常规克隆副本（没有“–mirror”选项），因为这可能会提供错误的安全感，并且不应依赖于删除机密的方法，例如通过“ git reset ”命令删除分支或倒回历史记录.

品牌推广
----

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)标识

最近似乎有一种趋势来命名漏洞。虽然我们认为这很愚蠢，但为什么不顺其自然呢？

因此，我们将其命名为“ **GitBleed** ”，因为它会导致存储库中的秘密泄露——带有镜像徽标，因为它涉及镜像存储库。

变更日志
----

2022-02-11：首次发布

译文申明
----

*   文章来源为`近期阅读文章`，质量尚可的，大部分较新，但也可能有老文章。
    
*   `开卷有益，不求甚解`，不需面面俱到，能学到一个小技巧就赚了。
    
*   `译文仅供参考`，具体内容表达以及含义, _`以原文为准`_ (译文来自自动翻译)
    
*   如英文不错的，`尽量阅读原文`。(点击原文跳转)
    
*   `每日早读`基本自动化发布(不定期删除)，这是`一项测试`
    

> > > ### `最新动态: Follow Me`
> > > 
> > > 微信/微博：**`red4blue`**
> > > 
> > > 公众号/知乎：**`blueteams`**
> > > 
> > > ![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)